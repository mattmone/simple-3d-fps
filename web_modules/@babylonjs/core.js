import { A as AbstractActionManager, a as AbstractScene, S as Scene, P as PointerEventTypes, b as PickingInfo, C as Camera, M as Mesh, c as AbstractMesh, K as KeyboardEventTypes, N as Node$2, H as HemisphericLight, I as ImageProcessingConfiguration, V as VertexData, d as StandardMaterial, T as TransformNode, e as MaterialHelper, _ as _CreationDataStorage, f as MaterialFlags, g as PushMaterial, h as MaterialDefines, L as Light, G as Geometry, i as MultiMaterial, j as ImageProcessingConfigurationDefines, k as ActionEvent } from '../common/standardMaterial-cad1cb30.js';
export { c as AbstractMesh, a as AbstractScene, k as ActionEvent, C as Camera, s as ColorCurves, G as Geometry, H as HemisphericLight, I as ImageProcessingConfiguration, j as ImageProcessingConfigurationDefines, K as KeyboardEventTypes, m as KeyboardInfo, n as KeyboardInfoPre, L as Light, h as MaterialDefines, f as MaterialFlags, e as MaterialHelper, M as Mesh, v as MeshLODLevel, i as MultiMaterial, N as Node, b as PickingInfo, P as PointerEventTypes, q as PointerInfo, o as PointerInfoBase, p as PointerInfoPre, g as PushMaterial, S as Scene, r as SceneLoaderFlags, d as StandardMaterial, t as StandardMaterialDefines, T as TransformNode, V as VertexData, _ as _CreationDataStorage, u as _InstancesBatch, l as _MeshCollisionData } from '../common/standardMaterial-cad1cb30.js';
import { j as Vector2, V as Vector3, l as Color3, i as Color4, n as _TypeStore, O as Observable, b as __extends, L as Logger, C as Constants, X as DeepCopier, E as EngineStore, h as Vector4, M as Matrix, Q as Quaternion, a1 as BezierCurve, m as Engine, W as SceneComponentConstants, P as PrecisionDate, T as Tools, a2 as IntersectionInfo, c as Tmp, a3 as ArrayTools, S as Space, A as Axis, a as __decorate, s as serialize, a4 as Scalar, w as StringDictionary, k as Epsilon, e as serializeAsVector3, a5 as serializeAsMeshReference, H as DomManagement, Y as Effect, Z as Texture, a6 as InternalTexture, U as UniformBuffer, F as Frustum, o as Viewport, a7 as Size, g as VertexBuffer, a8 as __awaiter, a9 as __generator, aa as Plane$1, ab as BoundingBox, y as SmartArrayNoDuplicate, ac as __assign, J as Material, ad as EngineCapabilities, ae as DataBuffer, af as RenderTargetCreationOptions, d as SerializationHelper, u as serializeAsColor3, v as expandToProperty, r as serializeAsTexture, ag as serializeAsImageProcessingConfiguration, p as SmartArray, a0 as EffectFallbacks, ah as BaseTexture, ai as CubeMapToSphericalPolynomialTools, aj as SphericalPolynomial, z as PerfCounter, _ as _DevTools, t as serializeAsColor4, ak as serializeAsCameraReference, al as ToGammaSpace, B as BoundingInfo, am as Path3D, an as WebRequest, I as SubMesh, ao as PositionNormalVertex, N as AsyncLoop, K as Buffer, ap as FactorGradient, aq as Color3Gradient, ar as ColorGradient, as as BoundingSphere, at as FilesInputStore } from '../common/texture-1533b140.js';
export { aN as AndOrNotEvaluator, aA as Angle, aB as Arc2, N as AsyncLoop, A as Axis, aG as BaseSubMesh, ah as BaseTexture, a1 as BezierCurve, ab as BoundingBox, B as BoundingInfo, as as BoundingSphere, K as Buffer, l as Color3, aq as Color3Gradient, i as Color4, ar as ColorGradient, C as Constants, ai as CubeMapToSphericalPolynomialTools, aD as Curve3, ae as DataBuffer, X as DeepCopier, av as DepthTextureCreationOptions, Y as Effect, ax as EffectCreationOptions, a0 as EffectFallbacks, m as Engine, ad as EngineCapabilities, E as EngineStore, k as Epsilon, aQ as EventState, ap as FactorGradient, at as FilesInputStore, F as Frustum, au as InstancingAttributeInfo, a6 as InternalTexture, a2 as IntersectionInfo, aW as LoadFileError, L as Logger, J as Material, M as Matrix, aS as MultiObserver, O as Observable, aR as Observer, az as Orientation, aC as Path2, am as Path3D, z as PerfCounter, aT as PerformanceMonitor, aa as Plane, aE as PositionNormalTextureVertex, ao as PositionNormalVertex, G as PostProcessManager, P as PrecisionDate, aV as PromisePolyfill, Q as Quaternion, aI as RenderingGroup, aJ as RenderingGroupInfo, R as RenderingManager, aX as RetryStrategy, aU as RollingAverage, a4 as Scalar, W as SceneComponentConstants, d as SerializationHelper, a7 as Size, p as SmartArray, y as SmartArrayNoDuplicate, S as Space, aF as SphericalHarmonics, aj as SphericalPolynomial, D as Stage, w as StringDictionary, I as SubMesh, x as Tags, Z as Texture, c as Tmp, al as ToGammaSpace, ay as ToLinearSpace, T as Tools, U as UniformBuffer, j as Vector2, V as Vector3, h as Vector4, g as VertexBuffer, o as Viewport, aH as WebGLDataBuffer, aw as WebGLPipelineContext, an as WebRequest, aK as _AlphaState, aL as _DepthCullingState, aM as _StencilState, n as _TypeStore, aY as className, v as expandToProperty, s as serialize, ak as serializeAsCameraReference, u as serializeAsColor3, t as serializeAsColor4, q as serializeAsColorCurves, $ as serializeAsFresnelParameters, ag as serializeAsImageProcessingConfiguration, aP as serializeAsMatrix, a5 as serializeAsMeshReference, f as serializeAsQuaternion, r as serializeAsTexture, aO as serializeAsVector2, e as serializeAsVector3 } from '../common/texture-1533b140.js';
import { A as Animation, S as Sound, C as CameraInputTypes, a as CameraInputsManager, F as FreeCameraInputsManager, b as FreeCamera, T as TargetCamera, P as PostProcess, c as ShaderMaterial, d as SceneLoader, D as DirectionalLight, e as SpotLight, f as CubeTexture, E as EnvironmentTextureTools, g as PBRMaterial, h as Skeleton, M as MorphTargetManager, i as AssetContainer, j as AnimationGroup, k as PBRBaseMaterial, R as RawTexture } from '../common/deferred-d38009ed.js';
export { l as Animatable, A as Animation, o as AnimationEvent, j as AnimationGroup, p as AnimationKeyInterpolation, q as AnimationRange, i as AssetContainer, B as Bone, C as CameraInputTypes, a as CameraInputsManager, f as CubeTexture, H as Deferred, D as DirectionalLight, z as DracoCompression, E as EnvironmentTextureTools, b as FreeCamera, F as FreeCameraInputsManager, r as FreeCameraKeyboardMoveInput, s as FreeCameraMouseInput, t as FreeCameraTouchInput, K as KeepAssets, G as MorphTarget, M as MorphTargetManager, k as PBRBaseMaterial, g as PBRMaterial, x as PBRMaterialDefines, v as PointLight, P as PostProcess, y as RawCubeTexture, R as RawTexture, n as RuntimeAnimation, d as SceneLoader, w as SceneLoaderProgressEvent, c as ShaderMaterial, u as ShadowLight, h as Skeleton, S as Sound, e as SpotLight, T as TargetCamera, m as TargetedAnimation, W as WeightedSound, I as WorkerPool, _ as _IAnimationState } from '../common/deferred-d38009ed.js';
import { D as DynamicTexture, U as UtilityLayerRenderer, B as BoxBuilder, P as PolygonMeshBuilder, a as PlaneBuilder } from '../common/polygonMesh-3d973801.js';
export { B as BoxBuilder, C as ClipboardEventTypes, b as ClipboardInfo, D as DynamicTexture, F as FadeInOutBehavior, L as Layer, c as LayerSceneComponent, a as PlaneBuilder, d as Polygon, P as PolygonMeshBuilder, U as UtilityLayerRenderer } from '../common/polygonMesh-3d973801.js';
import '../common/engine.renderTarget-560eb185.js';
import { R as RenderTargetTexture, P as ProceduralTexture } from '../common/proceduralTexture-e39d7431.js';
export { P as ProceduralTexture, a as ProceduralTextureSceneComponent, R as RenderTargetTexture } from '../common/proceduralTexture-e39d7431.js';

/**
 * The action to be carried out following a trigger
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions#available-actions
 */
var Action = /** @class */ (function () {
    /**
     * Creates a new Action
     * @param triggerOptions the trigger, with or without parameters, for the action
     * @param condition an optional determinant of action
     */
    function Action(
    /** the trigger, with or without parameters, for the action */
    triggerOptions, condition) {
        this.triggerOptions = triggerOptions;
        /**
        * An event triggered prior to action being executed.
        */
        this.onBeforeExecuteObservable = new Observable();
        if (triggerOptions.parameter) {
            this.trigger = triggerOptions.trigger;
            this._triggerParameter = triggerOptions.parameter;
        }
        else if (triggerOptions.trigger) {
            this.trigger = triggerOptions.trigger;
        }
        else {
            this.trigger = triggerOptions;
        }
        this._nextActiveAction = this;
        this._condition = condition;
    }
    /**
     * Internal only
     * @hidden
     */
    Action.prototype._prepare = function () {
    };
    /**
     * Gets the trigger parameters
     * @returns the trigger parameters
     */
    Action.prototype.getTriggerParameter = function () {
        return this._triggerParameter;
    };
    /**
     * Internal only - executes current action event
     * @hidden
     */
    Action.prototype._executeCurrent = function (evt) {
        if (this._nextActiveAction._condition) {
            var condition = this._nextActiveAction._condition;
            var currentRenderId = this._actionManager.getScene().getRenderId();
            // We cache the current evaluation for the current frame
            if (condition._evaluationId === currentRenderId) {
                if (!condition._currentResult) {
                    return;
                }
            }
            else {
                condition._evaluationId = currentRenderId;
                if (!condition.isValid()) {
                    condition._currentResult = false;
                    return;
                }
                condition._currentResult = true;
            }
        }
        this.onBeforeExecuteObservable.notifyObservers(this);
        this._nextActiveAction.execute(evt);
        this.skipToNextActiveAction();
    };
    /**
     * Execute placeholder for child classes
     * @param evt optional action event
     */
    Action.prototype.execute = function (evt) {
    };
    /**
     * Skips to next active action
     */
    Action.prototype.skipToNextActiveAction = function () {
        if (this._nextActiveAction._child) {
            if (!this._nextActiveAction._child._actionManager) {
                this._nextActiveAction._child._actionManager = this._actionManager;
            }
            this._nextActiveAction = this._nextActiveAction._child;
        }
        else {
            this._nextActiveAction = this;
        }
    };
    /**
     * Adds action to chain of actions, may be a DoNothingAction
     * @param action defines the next action to execute
     * @returns The action passed in
     * @see https://www.babylonjs-playground.com/#1T30HR#0
     */
    Action.prototype.then = function (action) {
        this._child = action;
        action._actionManager = this._actionManager;
        action._prepare();
        return action;
    };
    /**
     * Internal only
     * @hidden
     */
    Action.prototype._getProperty = function (propertyPath) {
        return this._actionManager._getProperty(propertyPath);
    };
    /**
     * Internal only
     * @hidden
     */
    Action.prototype._getEffectiveTarget = function (target, propertyPath) {
        return this._actionManager._getEffectiveTarget(target, propertyPath);
    };
    /**
     * Serialize placeholder for child classes
     * @param parent of child
     * @returns the serialized object
     */
    Action.prototype.serialize = function (parent) {
    };
    /**
     * Internal only called by serialize
     * @hidden
     */
    Action.prototype._serialize = function (serializedAction, parent) {
        var serializationObject = {
            type: 1,
            children: [],
            name: serializedAction.name,
            properties: serializedAction.properties || []
        };
        // Serialize child
        if (this._child) {
            this._child.serialize(serializationObject);
        }
        // Check if "this" has a condition
        if (this._condition) {
            var serializedCondition = this._condition.serialize();
            serializedCondition.children.push(serializationObject);
            if (parent) {
                parent.children.push(serializedCondition);
            }
            return serializedCondition;
        }
        if (parent) {
            parent.children.push(serializationObject);
        }
        return serializationObject;
    };
    /**
     * Internal only
     * @hidden
     */
    Action._SerializeValueAsString = function (value) {
        if (typeof value === "number") {
            return value.toString();
        }
        if (typeof value === "boolean") {
            return value ? "true" : "false";
        }
        if (value instanceof Vector2) {
            return value.x + ", " + value.y;
        }
        if (value instanceof Vector3) {
            return value.x + ", " + value.y + ", " + value.z;
        }
        if (value instanceof Color3) {
            return value.r + ", " + value.g + ", " + value.b;
        }
        if (value instanceof Color4) {
            return value.r + ", " + value.g + ", " + value.b + ", " + value.a;
        }
        return value; // string
    };
    /**
     * Internal only
     * @hidden
     */
    Action._GetTargetProperty = function (target) {
        return {
            name: "target",
            targetType: target._isMesh ? "MeshProperties"
                : target._isLight ? "LightProperties"
                    : target._isCamera ? "CameraProperties"
                        : "SceneProperties",
            value: target._isScene ? "Scene" : target.name
        };
    };
    return Action;
}());
_TypeStore.RegisteredTypes["BABYLON.Action"] = Action;

/**
 * A Condition applied to an Action
 */
var Condition = /** @class */ (function () {
    /**
     * Creates a new Condition
     * @param actionManager the manager of the action the condition is applied to
     */
    function Condition(actionManager) {
        this._actionManager = actionManager;
    }
    /**
     * Check if the current condition is valid
     * @returns a boolean
     */
    Condition.prototype.isValid = function () {
        return true;
    };
    /**
     * Internal only
     * @hidden
     */
    Condition.prototype._getProperty = function (propertyPath) {
        return this._actionManager._getProperty(propertyPath);
    };
    /**
     * Internal only
     * @hidden
     */
    Condition.prototype._getEffectiveTarget = function (target, propertyPath) {
        return this._actionManager._getEffectiveTarget(target, propertyPath);
    };
    /**
     * Serialize placeholder for child classes
     * @returns the serialized object
     */
    Condition.prototype.serialize = function () {
    };
    /**
     * Internal only
     * @hidden
     */
    Condition.prototype._serialize = function (serializedCondition) {
        return {
            type: 2,
            children: [],
            name: serializedCondition.name,
            properties: serializedCondition.properties
        };
    };
    return Condition;
}());
/**
 * Defines specific conditional operators as extensions of Condition
 */
var ValueCondition = /** @class */ (function (_super) {
    __extends(ValueCondition, _super);
    /**
     * Creates a new ValueCondition
     * @param actionManager manager for the action the condition applies to
     * @param target for the action
     * @param propertyPath path to specify the property of the target the conditional operator uses
     * @param value the value compared by the conditional operator against the current value of the property
     * @param operator the conditional operator, default ValueCondition.IsEqual
     */
    function ValueCondition(actionManager, target, 
    /** path to specify the property of the target the conditional operator uses  */
    propertyPath, 
    /** the value compared by the conditional operator against the current value of the property */
    value, 
    /** the conditional operator, default ValueCondition.IsEqual */
    operator) {
        if (operator === void 0) { operator = ValueCondition.IsEqual; }
        var _this = _super.call(this, actionManager) || this;
        _this.propertyPath = propertyPath;
        _this.value = value;
        _this.operator = operator;
        _this._target = target;
        _this._effectiveTarget = _this._getEffectiveTarget(target, _this.propertyPath);
        _this._property = _this._getProperty(_this.propertyPath);
        return _this;
    }
    Object.defineProperty(ValueCondition, "IsEqual", {
        /**
         * returns the number for IsEqual
         */
        get: function () {
            return ValueCondition._IsEqual;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueCondition, "IsDifferent", {
        /**
         * Returns the number for IsDifferent
         */
        get: function () {
            return ValueCondition._IsDifferent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueCondition, "IsGreater", {
        /**
         * Returns the number for IsGreater
         */
        get: function () {
            return ValueCondition._IsGreater;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueCondition, "IsLesser", {
        /**
         * Returns the number for IsLesser
         */
        get: function () {
            return ValueCondition._IsLesser;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Compares the given value with the property value for the specified conditional operator
     * @returns the result of the comparison
     */
    ValueCondition.prototype.isValid = function () {
        switch (this.operator) {
            case ValueCondition.IsGreater:
                return this._effectiveTarget[this._property] > this.value;
            case ValueCondition.IsLesser:
                return this._effectiveTarget[this._property] < this.value;
            case ValueCondition.IsEqual:
            case ValueCondition.IsDifferent:
                var check;
                if (this.value.equals) {
                    check = this.value.equals(this._effectiveTarget[this._property]);
                }
                else {
                    check = this.value === this._effectiveTarget[this._property];
                }
                return this.operator === ValueCondition.IsEqual ? check : !check;
        }
        return false;
    };
    /**
     * Serialize the ValueCondition into a JSON compatible object
     * @returns serialization object
     */
    ValueCondition.prototype.serialize = function () {
        return this._serialize({
            name: "ValueCondition",
            properties: [
                Action._GetTargetProperty(this._target),
                { name: "propertyPath", value: this.propertyPath },
                { name: "value", value: Action._SerializeValueAsString(this.value) },
                { name: "operator", value: ValueCondition.GetOperatorName(this.operator) }
            ]
        });
    };
    /**
     * Gets the name of the conditional operator for the ValueCondition
     * @param operator the conditional operator
     * @returns the name
     */
    ValueCondition.GetOperatorName = function (operator) {
        switch (operator) {
            case ValueCondition._IsEqual: return "IsEqual";
            case ValueCondition._IsDifferent: return "IsDifferent";
            case ValueCondition._IsGreater: return "IsGreater";
            case ValueCondition._IsLesser: return "IsLesser";
            default: return "";
        }
    };
    /**
     * Internal only
     * @hidden
     */
    ValueCondition._IsEqual = 0;
    /**
     * Internal only
     * @hidden
     */
    ValueCondition._IsDifferent = 1;
    /**
     * Internal only
     * @hidden
     */
    ValueCondition._IsGreater = 2;
    /**
     * Internal only
     * @hidden
     */
    ValueCondition._IsLesser = 3;
    return ValueCondition;
}(Condition));
/**
 * Defines a predicate condition as an extension of Condition
 */
var PredicateCondition = /** @class */ (function (_super) {
    __extends(PredicateCondition, _super);
    /**
     * Creates a new PredicateCondition
     * @param actionManager manager for the action the condition applies to
     * @param predicate defines the predicate function used to validate the condition
     */
    function PredicateCondition(actionManager, 
    /** defines the predicate function used to validate the condition */
    predicate) {
        var _this = _super.call(this, actionManager) || this;
        _this.predicate = predicate;
        return _this;
    }
    /**
     * @returns the validity of the predicate condition
     */
    PredicateCondition.prototype.isValid = function () {
        return this.predicate();
    };
    return PredicateCondition;
}(Condition));
/**
 * Defines a state condition as an extension of Condition
 */
var StateCondition = /** @class */ (function (_super) {
    __extends(StateCondition, _super);
    /**
     * Creates a new StateCondition
     * @param actionManager manager for the action the condition applies to
     * @param target of the condition
     * @param value to compare with target state
     */
    function StateCondition(actionManager, target, 
    /** Value to compare with target state  */
    value) {
        var _this = _super.call(this, actionManager) || this;
        _this.value = value;
        _this._target = target;
        return _this;
    }
    /**
     * Gets a boolean indicating if the current condition is met
     * @returns the validity of the state
     */
    StateCondition.prototype.isValid = function () {
        return this._target.state === this.value;
    };
    /**
     * Serialize the StateCondition into a JSON compatible object
     * @returns serialization object
     */
    StateCondition.prototype.serialize = function () {
        return this._serialize({
            name: "StateCondition",
            properties: [
                Action._GetTargetProperty(this._target),
                { name: "value", value: this.value }
            ]
        });
    };
    return StateCondition;
}(Condition));
_TypeStore.RegisteredTypes["BABYLON.ValueCondition"] = ValueCondition;
_TypeStore.RegisteredTypes["BABYLON.PredicateCondition"] = PredicateCondition;
_TypeStore.RegisteredTypes["BABYLON.StateCondition"] = StateCondition;

/**
 * This defines an action responsible to toggle a boolean once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var SwitchBooleanAction = /** @class */ (function (_super) {
    __extends(SwitchBooleanAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param target defines the object containing the boolean
     * @param propertyPath defines the path to the boolean property in the target object
     * @param condition defines the trigger related conditions
     */
    function SwitchBooleanAction(triggerOptions, target, propertyPath, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this.propertyPath = propertyPath;
        _this._target = _this._effectiveTarget = target;
        return _this;
    }
    /** @hidden */
    SwitchBooleanAction.prototype._prepare = function () {
        this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
        this._property = this._getProperty(this.propertyPath);
    };
    /**
     * Execute the action toggle the boolean value.
     */
    SwitchBooleanAction.prototype.execute = function () {
        this._effectiveTarget[this._property] = !this._effectiveTarget[this._property];
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    SwitchBooleanAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "SwitchBooleanAction",
            properties: [
                Action._GetTargetProperty(this._target),
                { name: "propertyPath", value: this.propertyPath }
            ]
        }, parent);
    };
    return SwitchBooleanAction;
}(Action));
/**
 * This defines an action responsible to set a the state field of the target
 *  to a desired value once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var SetStateAction = /** @class */ (function (_super) {
    __extends(SetStateAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param target defines the object containing the state property
     * @param value defines the value to store in the state field
     * @param condition defines the trigger related conditions
     */
    function SetStateAction(triggerOptions, target, value, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this.value = value;
        _this._target = target;
        return _this;
    }
    /**
     * Execute the action and store the value on the target state property.
     */
    SetStateAction.prototype.execute = function () {
        this._target.state = this.value;
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    SetStateAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "SetStateAction",
            properties: [
                Action._GetTargetProperty(this._target),
                { name: "value", value: this.value }
            ]
        }, parent);
    };
    return SetStateAction;
}(Action));
/**
 * This defines an action responsible to set a property of the target
 *  to a desired value once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var SetValueAction = /** @class */ (function (_super) {
    __extends(SetValueAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param target defines the object containing the property
     * @param propertyPath defines the path of the property to set in the target
     * @param value defines the value to set in the property
     * @param condition defines the trigger related conditions
     */
    function SetValueAction(triggerOptions, target, propertyPath, value, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this.propertyPath = propertyPath;
        _this.value = value;
        _this._target = _this._effectiveTarget = target;
        return _this;
    }
    /** @hidden */
    SetValueAction.prototype._prepare = function () {
        this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
        this._property = this._getProperty(this.propertyPath);
    };
    /**
     * Execute the action and set the targetted property to the desired value.
     */
    SetValueAction.prototype.execute = function () {
        this._effectiveTarget[this._property] = this.value;
        if (this._target.markAsDirty) {
            this._target.markAsDirty(this._property);
        }
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    SetValueAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "SetValueAction",
            properties: [
                Action._GetTargetProperty(this._target),
                { name: "propertyPath", value: this.propertyPath },
                { name: "value", value: Action._SerializeValueAsString(this.value) }
            ]
        }, parent);
    };
    return SetValueAction;
}(Action));
/**
 * This defines an action responsible to increment the target value
 *  to a desired value once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var IncrementValueAction = /** @class */ (function (_super) {
    __extends(IncrementValueAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param target defines the object containing the property
     * @param propertyPath defines the path of the property to increment in the target
     * @param value defines the value value we should increment the property by
     * @param condition defines the trigger related conditions
     */
    function IncrementValueAction(triggerOptions, target, propertyPath, value, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this.propertyPath = propertyPath;
        _this.value = value;
        _this._target = _this._effectiveTarget = target;
        return _this;
    }
    /** @hidden */
    IncrementValueAction.prototype._prepare = function () {
        this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
        this._property = this._getProperty(this.propertyPath);
        if (typeof this._effectiveTarget[this._property] !== "number") {
            Logger.Warn("Warning: IncrementValueAction can only be used with number values");
        }
    };
    /**
     * Execute the action and increment the target of the value amount.
     */
    IncrementValueAction.prototype.execute = function () {
        this._effectiveTarget[this._property] += this.value;
        if (this._target.markAsDirty) {
            this._target.markAsDirty(this._property);
        }
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    IncrementValueAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "IncrementValueAction",
            properties: [
                Action._GetTargetProperty(this._target),
                { name: "propertyPath", value: this.propertyPath },
                { name: "value", value: Action._SerializeValueAsString(this.value) }
            ]
        }, parent);
    };
    return IncrementValueAction;
}(Action));
/**
 * This defines an action responsible to start an animation once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var PlayAnimationAction = /** @class */ (function (_super) {
    __extends(PlayAnimationAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param target defines the target animation or animation name
     * @param from defines from where the animation should start (animation frame)
     * @param end defines where the animation should stop (animation frame)
     * @param loop defines if the animation should loop or stop after the first play
     * @param condition defines the trigger related conditions
     */
    function PlayAnimationAction(triggerOptions, target, from, to, loop, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this.from = from;
        _this.to = to;
        _this.loop = loop;
        _this._target = target;
        return _this;
    }
    /** @hidden */
    PlayAnimationAction.prototype._prepare = function () {
    };
    /**
     * Execute the action and play the animation.
     */
    PlayAnimationAction.prototype.execute = function () {
        var scene = this._actionManager.getScene();
        scene.beginAnimation(this._target, this.from, this.to, this.loop);
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    PlayAnimationAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "PlayAnimationAction",
            properties: [
                Action._GetTargetProperty(this._target),
                { name: "from", value: String(this.from) },
                { name: "to", value: String(this.to) },
                { name: "loop", value: Action._SerializeValueAsString(this.loop) || false }
            ]
        }, parent);
    };
    return PlayAnimationAction;
}(Action));
/**
 * This defines an action responsible to stop an animation once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var StopAnimationAction = /** @class */ (function (_super) {
    __extends(StopAnimationAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param target defines the target animation or animation name
     * @param condition defines the trigger related conditions
     */
    function StopAnimationAction(triggerOptions, target, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this._target = target;
        return _this;
    }
    /** @hidden */
    StopAnimationAction.prototype._prepare = function () {
    };
    /**
     * Execute the action and stop the animation.
     */
    StopAnimationAction.prototype.execute = function () {
        var scene = this._actionManager.getScene();
        scene.stopAnimation(this._target);
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    StopAnimationAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "StopAnimationAction",
            properties: [Action._GetTargetProperty(this._target)]
        }, parent);
    };
    return StopAnimationAction;
}(Action));
/**
 * This defines an action responsible that does nothing once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var DoNothingAction = /** @class */ (function (_super) {
    __extends(DoNothingAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param condition defines the trigger related conditions
     */
    function DoNothingAction(triggerOptions, condition) {
        if (triggerOptions === void 0) { triggerOptions = Constants.ACTION_NothingTrigger; }
        return _super.call(this, triggerOptions, condition) || this;
    }
    /**
     * Execute the action and do nothing.
     */
    DoNothingAction.prototype.execute = function () {
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    DoNothingAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "DoNothingAction",
            properties: []
        }, parent);
    };
    return DoNothingAction;
}(Action));
/**
 * This defines an action responsible to trigger several actions once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var CombineAction = /** @class */ (function (_super) {
    __extends(CombineAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param children defines the list of aggregated animations to run
     * @param condition defines the trigger related conditions
     */
    function CombineAction(triggerOptions, children, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this.children = children;
        return _this;
    }
    /** @hidden */
    CombineAction.prototype._prepare = function () {
        for (var index = 0; index < this.children.length; index++) {
            this.children[index]._actionManager = this._actionManager;
            this.children[index]._prepare();
        }
    };
    /**
     * Execute the action and executes all the aggregated actions.
     */
    CombineAction.prototype.execute = function (evt) {
        for (var index = 0; index < this.children.length; index++) {
            this.children[index].execute(evt);
        }
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    CombineAction.prototype.serialize = function (parent) {
        var serializationObject = _super.prototype._serialize.call(this, {
            name: "CombineAction",
            properties: [],
            combine: []
        }, parent);
        for (var i = 0; i < this.children.length; i++) {
            serializationObject.combine.push(this.children[i].serialize(null));
        }
        return serializationObject;
    };
    return CombineAction;
}(Action));
/**
 * This defines an action responsible to run code (external event) once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var ExecuteCodeAction = /** @class */ (function (_super) {
    __extends(ExecuteCodeAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param func defines the callback function to run
     * @param condition defines the trigger related conditions
     */
    function ExecuteCodeAction(triggerOptions, func, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this.func = func;
        return _this;
    }
    /**
     * Execute the action and run the attached code.
     */
    ExecuteCodeAction.prototype.execute = function (evt) {
        this.func(evt);
    };
    return ExecuteCodeAction;
}(Action));
/**
 * This defines an action responsible to set the parent property of the target once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var SetParentAction = /** @class */ (function (_super) {
    __extends(SetParentAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param target defines the target containing the parent property
     * @param parent defines from where the animation should start (animation frame)
     * @param condition defines the trigger related conditions
     */
    function SetParentAction(triggerOptions, target, parent, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this._target = target;
        _this._parent = parent;
        return _this;
    }
    /** @hidden */
    SetParentAction.prototype._prepare = function () {
    };
    /**
     * Execute the action and set the parent property.
     */
    SetParentAction.prototype.execute = function () {
        if (this._target.parent === this._parent) {
            return;
        }
        var invertParentWorldMatrix = this._parent.getWorldMatrix().clone();
        invertParentWorldMatrix.invert();
        this._target.position = Vector3.TransformCoordinates(this._target.position, invertParentWorldMatrix);
        this._target.parent = this._parent;
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    SetParentAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "SetParentAction",
            properties: [
                Action._GetTargetProperty(this._target),
                Action._GetTargetProperty(this._parent),
            ]
        }, parent);
    };
    return SetParentAction;
}(Action));
_TypeStore.RegisteredTypes["BABYLON.SetParentAction"] = SetParentAction;
_TypeStore.RegisteredTypes["BABYLON.ExecuteCodeAction"] = ExecuteCodeAction;
_TypeStore.RegisteredTypes["BABYLON.DoNothingAction"] = DoNothingAction;
_TypeStore.RegisteredTypes["BABYLON.StopAnimationAction"] = StopAnimationAction;
_TypeStore.RegisteredTypes["BABYLON.PlayAnimationAction"] = PlayAnimationAction;
_TypeStore.RegisteredTypes["BABYLON.IncrementValueAction"] = IncrementValueAction;
_TypeStore.RegisteredTypes["BABYLON.SetValueAction"] = SetValueAction;
_TypeStore.RegisteredTypes["BABYLON.SetStateAction"] = SetStateAction;
_TypeStore.RegisteredTypes["BABYLON.SetParentAction"] = SetParentAction;

/**
 * Action Manager manages all events to be triggered on a given mesh or the global scene.
 * A single scene can have many Action Managers to handle predefined actions on specific meshes.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var ActionManager = /** @class */ (function (_super) {
    __extends(ActionManager, _super);
    /**
     * Creates a new action manager
     * @param scene defines the hosting scene
     */
    function ActionManager(scene) {
        var _this = _super.call(this) || this;
        _this._scene = scene || EngineStore.LastCreatedScene;
        scene.actionManagers.push(_this);
        return _this;
    }
    // Methods
    /**
     * Releases all associated resources
     */
    ActionManager.prototype.dispose = function () {
        var index = this._scene.actionManagers.indexOf(this);
        for (var i = 0; i < this.actions.length; i++) {
            var action = this.actions[i];
            ActionManager.Triggers[action.trigger]--;
            if (ActionManager.Triggers[action.trigger] === 0) {
                delete ActionManager.Triggers[action.trigger];
            }
        }
        if (index > -1) {
            this._scene.actionManagers.splice(index, 1);
        }
    };
    /**
     * Gets hosting scene
     * @returns the hosting scene
     */
    ActionManager.prototype.getScene = function () {
        return this._scene;
    };
    /**
     * Does this action manager handles actions of any of the given triggers
     * @param triggers defines the triggers to be tested
     * @return a boolean indicating whether one (or more) of the triggers is handled
     */
    ActionManager.prototype.hasSpecificTriggers = function (triggers) {
        for (var index = 0; index < this.actions.length; index++) {
            var action = this.actions[index];
            if (triggers.indexOf(action.trigger) > -1) {
                return true;
            }
        }
        return false;
    };
    /**
     * Does this action manager handles actions of any of the given triggers. This function takes two arguments for
     * speed.
     * @param triggerA defines the trigger to be tested
     * @param triggerB defines the trigger to be tested
     * @return a boolean indicating whether one (or more) of the triggers is handled
     */
    ActionManager.prototype.hasSpecificTriggers2 = function (triggerA, triggerB) {
        for (var index = 0; index < this.actions.length; index++) {
            var action = this.actions[index];
            if (triggerA == action.trigger || triggerB == action.trigger) {
                return true;
            }
        }
        return false;
    };
    /**
     * Does this action manager handles actions of a given trigger
     * @param trigger defines the trigger to be tested
     * @param parameterPredicate defines an optional predicate to filter triggers by parameter
     * @return whether the trigger is handled
     */
    ActionManager.prototype.hasSpecificTrigger = function (trigger, parameterPredicate) {
        for (var index = 0; index < this.actions.length; index++) {
            var action = this.actions[index];
            if (action.trigger === trigger) {
                if (parameterPredicate) {
                    if (parameterPredicate(action.getTriggerParameter())) {
                        return true;
                    }
                }
                else {
                    return true;
                }
            }
        }
        return false;
    };
    Object.defineProperty(ActionManager.prototype, "hasPointerTriggers", {
        /**
         * Does this action manager has pointer triggers
         */
        get: function () {
            for (var index = 0; index < this.actions.length; index++) {
                var action = this.actions[index];
                if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPointerOutTrigger) {
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActionManager.prototype, "hasPickTriggers", {
        /**
         * Does this action manager has pick triggers
         */
        get: function () {
            for (var index = 0; index < this.actions.length; index++) {
                var action = this.actions[index];
                if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPickUpTrigger) {
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Registers an action to this action manager
     * @param action defines the action to be registered
     * @return the action amended (prepared) after registration
     */
    ActionManager.prototype.registerAction = function (action) {
        if (action.trigger === ActionManager.OnEveryFrameTrigger) {
            if (this.getScene().actionManager !== this) {
                Logger.Warn("OnEveryFrameTrigger can only be used with scene.actionManager");
                return null;
            }
        }
        this.actions.push(action);
        if (ActionManager.Triggers[action.trigger]) {
            ActionManager.Triggers[action.trigger]++;
        }
        else {
            ActionManager.Triggers[action.trigger] = 1;
        }
        action._actionManager = this;
        action._prepare();
        return action;
    };
    /**
     * Unregisters an action to this action manager
     * @param action defines the action to be unregistered
     * @return a boolean indicating whether the action has been unregistered
     */
    ActionManager.prototype.unregisterAction = function (action) {
        var index = this.actions.indexOf(action);
        if (index !== -1) {
            this.actions.splice(index, 1);
            ActionManager.Triggers[action.trigger] -= 1;
            if (ActionManager.Triggers[action.trigger] === 0) {
                delete ActionManager.Triggers[action.trigger];
            }
            delete action._actionManager;
            return true;
        }
        return false;
    };
    /**
     * Process a specific trigger
     * @param trigger defines the trigger to process
     * @param evt defines the event details to be processed
     */
    ActionManager.prototype.processTrigger = function (trigger, evt) {
        for (var index = 0; index < this.actions.length; index++) {
            var action = this.actions[index];
            if (action.trigger === trigger) {
                if (evt) {
                    if (trigger === ActionManager.OnKeyUpTrigger
                        || trigger === ActionManager.OnKeyDownTrigger) {
                        var parameter = action.getTriggerParameter();
                        if (parameter && parameter !== evt.sourceEvent.keyCode) {
                            if (!parameter.toLowerCase) {
                                continue;
                            }
                            var lowerCase = parameter.toLowerCase();
                            if (lowerCase !== evt.sourceEvent.key) {
                                var unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;
                                var actualkey = String.fromCharCode(unicode).toLowerCase();
                                if (actualkey !== lowerCase) {
                                    continue;
                                }
                            }
                        }
                    }
                }
                action._executeCurrent(evt);
            }
        }
    };
    /** @hidden */
    ActionManager.prototype._getEffectiveTarget = function (target, propertyPath) {
        var properties = propertyPath.split(".");
        for (var index = 0; index < properties.length - 1; index++) {
            target = target[properties[index]];
        }
        return target;
    };
    /** @hidden */
    ActionManager.prototype._getProperty = function (propertyPath) {
        var properties = propertyPath.split(".");
        return properties[properties.length - 1];
    };
    /**
     * Serialize this manager to a JSON object
     * @param name defines the property name to store this manager
     * @returns a JSON representation of this manager
     */
    ActionManager.prototype.serialize = function (name) {
        var root = {
            children: new Array(),
            name: name,
            type: 3,
            properties: new Array() // Empty for root but required
        };
        for (var i = 0; i < this.actions.length; i++) {
            var triggerObject = {
                type: 0,
                children: new Array(),
                name: ActionManager.GetTriggerName(this.actions[i].trigger),
                properties: new Array()
            };
            var triggerOptions = this.actions[i].triggerOptions;
            if (triggerOptions && typeof triggerOptions !== "number") {
                if (triggerOptions.parameter instanceof Node) {
                    triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));
                }
                else {
                    var parameter = {};
                    DeepCopier.DeepCopy(triggerOptions.parameter, parameter, ["mesh"]);
                    if (triggerOptions.parameter && triggerOptions.parameter.mesh) {
                        parameter._meshId = triggerOptions.parameter.mesh.id;
                    }
                    triggerObject.properties.push({ name: "parameter", targetType: null, value: parameter });
                }
            }
            // Serialize child action, recursively
            this.actions[i].serialize(triggerObject);
            // Add serialized trigger
            root.children.push(triggerObject);
        }
        return root;
    };
    /**
     * Creates a new ActionManager from a JSON data
     * @param parsedActions defines the JSON data to read from
     * @param object defines the hosting mesh
     * @param scene defines the hosting scene
     */
    ActionManager.Parse = function (parsedActions, object, scene) {
        var actionManager = new ActionManager(scene);
        if (object === null) {
            scene.actionManager = actionManager;
        }
        else {
            object.actionManager = actionManager;
        }
        // instanciate a new object
        var instanciate = function (name, params) {
            var internalClassType = _TypeStore.GetClass("BABYLON." + name);
            if (internalClassType) {
                var newInstance = Object.create(internalClassType.prototype);
                newInstance.constructor.apply(newInstance, params);
                return newInstance;
            }
        };
        var parseParameter = function (name, value, target, propertyPath) {
            if (propertyPath === null) {
                // String, boolean or float
                var floatValue = parseFloat(value);
                if (value === "true" || value === "false") {
                    return value === "true";
                }
                else {
                    return isNaN(floatValue) ? value : floatValue;
                }
            }
            var effectiveTarget = propertyPath.split(".");
            var values = value.split(",");
            // Get effective Target
            for (var i = 0; i < effectiveTarget.length; i++) {
                target = target[effectiveTarget[i]];
            }
            // Return appropriate value with its type
            if (typeof (target) === "boolean") {
                return values[0] === "true";
            }
            if (typeof (target) === "string") {
                return values[0];
            }
            // Parameters with multiple values such as Vector3 etc.
            var split = new Array();
            for (var i = 0; i < values.length; i++) {
                split.push(parseFloat(values[i]));
            }
            if (target instanceof Vector3) {
                return Vector3.FromArray(split);
            }
            if (target instanceof Vector4) {
                return Vector4.FromArray(split);
            }
            if (target instanceof Color3) {
                return Color3.FromArray(split);
            }
            if (target instanceof Color4) {
                return Color4.FromArray(split);
            }
            return parseFloat(values[0]);
        };
        // traverse graph per trigger
        var traverse = function (parsedAction, trigger, condition, action, combineArray) {
            if (combineArray === void 0) { combineArray = null; }
            if (parsedAction.detached) {
                return;
            }
            var parameters = new Array();
            var target = null;
            var propertyPath = null;
            var combine = parsedAction.combine && parsedAction.combine.length > 0;
            // Parameters
            if (parsedAction.type === 2) {
                parameters.push(actionManager);
            }
            else {
                parameters.push(trigger);
            }
            if (combine) {
                var actions = new Array();
                for (var j = 0; j < parsedAction.combine.length; j++) {
                    traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);
                }
                parameters.push(actions);
            }
            else {
                for (var i = 0; i < parsedAction.properties.length; i++) {
                    var value = parsedAction.properties[i].value;
                    var name = parsedAction.properties[i].name;
                    var targetType = parsedAction.properties[i].targetType;
                    if (name === "target") {
                        if (targetType !== null && targetType === "SceneProperties") {
                            value = target = scene;
                        }
                        else {
                            value = target = scene.getNodeByName(value);
                        }
                    }
                    else if (name === "parent") {
                        value = scene.getNodeByName(value);
                    }
                    else if (name === "sound") {
                        // Can not externalize to component, so only checks for the presence off the API.
                        if (scene.getSoundByName) {
                            value = scene.getSoundByName(value);
                        }
                    }
                    else if (name !== "propertyPath") {
                        if (parsedAction.type === 2 && name === "operator") {
                            value = ValueCondition[value];
                        }
                        else {
                            value = parseParameter(name, value, target, name === "value" ? propertyPath : null);
                        }
                    }
                    else {
                        propertyPath = value;
                    }
                    parameters.push(value);
                }
            }
            if (combineArray === null) {
                parameters.push(condition);
            }
            else {
                parameters.push(null);
            }
            // If interpolate value action
            if (parsedAction.name === "InterpolateValueAction") {
                var param = parameters[parameters.length - 2];
                parameters[parameters.length - 1] = param;
                parameters[parameters.length - 2] = condition;
            }
            // Action or condition(s) and not CombineAction
            var newAction = instanciate(parsedAction.name, parameters);
            if (newAction instanceof Condition && condition !== null) {
                var nothing = new DoNothingAction(trigger, condition);
                if (action) {
                    action.then(nothing);
                }
                else {
                    actionManager.registerAction(nothing);
                }
                action = nothing;
            }
            if (combineArray === null) {
                if (newAction instanceof Condition) {
                    condition = newAction;
                    newAction = action;
                }
                else {
                    condition = null;
                    if (action) {
                        action.then(newAction);
                    }
                    else {
                        actionManager.registerAction(newAction);
                    }
                }
            }
            else {
                combineArray.push(newAction);
            }
            for (var i = 0; i < parsedAction.children.length; i++) {
                traverse(parsedAction.children[i], trigger, condition, newAction, null);
            }
        };
        // triggers
        for (var i = 0; i < parsedActions.children.length; i++) {
            var triggerParams;
            var trigger = parsedActions.children[i];
            if (trigger.properties.length > 0) {
                var param = trigger.properties[0].value;
                var value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);
                if (value._meshId) {
                    value.mesh = scene.getMeshByID(value._meshId);
                }
                triggerParams = { trigger: ActionManager[trigger.name], parameter: value };
            }
            else {
                triggerParams = ActionManager[trigger.name];
            }
            for (var j = 0; j < trigger.children.length; j++) {
                if (!trigger.detached) {
                    traverse(trigger.children[j], triggerParams, null, null);
                }
            }
        }
    };
    /**
     * Get a trigger name by index
     * @param trigger defines the trigger index
     * @returns a trigger name
     */
    ActionManager.GetTriggerName = function (trigger) {
        switch (trigger) {
            case 0: return "NothingTrigger";
            case 1: return "OnPickTrigger";
            case 2: return "OnLeftPickTrigger";
            case 3: return "OnRightPickTrigger";
            case 4: return "OnCenterPickTrigger";
            case 5: return "OnPickDownTrigger";
            case 6: return "OnPickUpTrigger";
            case 7: return "OnLongPressTrigger";
            case 8: return "OnPointerOverTrigger";
            case 9: return "OnPointerOutTrigger";
            case 10: return "OnEveryFrameTrigger";
            case 11: return "OnIntersectionEnterTrigger";
            case 12: return "OnIntersectionExitTrigger";
            case 13: return "OnKeyDownTrigger";
            case 14: return "OnKeyUpTrigger";
            case 15: return "OnPickOutTrigger";
            default: return "";
        }
    };
    /**
     * Nothing
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.NothingTrigger = Constants.ACTION_NothingTrigger;
    /**
     * On pick
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnPickTrigger = Constants.ACTION_OnPickTrigger;
    /**
     * On left pick
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnLeftPickTrigger = Constants.ACTION_OnLeftPickTrigger;
    /**
     * On right pick
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnRightPickTrigger = Constants.ACTION_OnRightPickTrigger;
    /**
     * On center pick
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnCenterPickTrigger = Constants.ACTION_OnCenterPickTrigger;
    /**
     * On pick down
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnPickDownTrigger = Constants.ACTION_OnPickDownTrigger;
    /**
     * On double pick
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnDoublePickTrigger = Constants.ACTION_OnDoublePickTrigger;
    /**
     * On pick up
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnPickUpTrigger = Constants.ACTION_OnPickUpTrigger;
    /**
     * On pick out.
     * This trigger will only be raised if you also declared a OnPickDown
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnPickOutTrigger = Constants.ACTION_OnPickOutTrigger;
    /**
     * On long press
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnLongPressTrigger = Constants.ACTION_OnLongPressTrigger;
    /**
     * On pointer over
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnPointerOverTrigger = Constants.ACTION_OnPointerOverTrigger;
    /**
     * On pointer out
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnPointerOutTrigger = Constants.ACTION_OnPointerOutTrigger;
    /**
     * On every frame
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnEveryFrameTrigger = Constants.ACTION_OnEveryFrameTrigger;
    /**
     * On intersection enter
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnIntersectionEnterTrigger = Constants.ACTION_OnIntersectionEnterTrigger;
    /**
     * On intersection exit
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnIntersectionExitTrigger = Constants.ACTION_OnIntersectionExitTrigger;
    /**
     * On key down
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnKeyDownTrigger = Constants.ACTION_OnKeyDownTrigger;
    /**
     * On key up
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
     */
    ActionManager.OnKeyUpTrigger = 15;
    return ActionManager;
}(AbstractActionManager));

/**
 * This defines an action helpful to play a defined sound on a triggered action.
 */
var PlaySoundAction = /** @class */ (function (_super) {
    __extends(PlaySoundAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param sound defines the sound to play
     * @param condition defines the trigger related conditions
     */
    function PlaySoundAction(triggerOptions, sound, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this._sound = sound;
        return _this;
    }
    /** @hidden */
    PlaySoundAction.prototype._prepare = function () {
    };
    /**
     * Execute the action and play the sound.
     */
    PlaySoundAction.prototype.execute = function () {
        if (this._sound !== undefined) {
            this._sound.play();
        }
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    PlaySoundAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "PlaySoundAction",
            properties: [{ name: "sound", value: this._sound.name }]
        }, parent);
    };
    return PlaySoundAction;
}(Action));
/**
 * This defines an action helpful to stop a defined sound on a triggered action.
 */
var StopSoundAction = /** @class */ (function (_super) {
    __extends(StopSoundAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param sound defines the sound to stop
     * @param condition defines the trigger related conditions
     */
    function StopSoundAction(triggerOptions, sound, condition) {
        var _this = _super.call(this, triggerOptions, condition) || this;
        _this._sound = sound;
        return _this;
    }
    /** @hidden */
    StopSoundAction.prototype._prepare = function () {
    };
    /**
     * Execute the action and stop the sound.
     */
    StopSoundAction.prototype.execute = function () {
        if (this._sound !== undefined) {
            this._sound.stop();
        }
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    StopSoundAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "StopSoundAction",
            properties: [{ name: "sound", value: this._sound.name }]
        }, parent);
    };
    return StopSoundAction;
}(Action));
_TypeStore.RegisteredTypes["BABYLON.PlaySoundAction"] = StopSoundAction;
_TypeStore.RegisteredTypes["BABYLON.StopSoundAction"] = StopSoundAction;

/**
 * This defines an action responsible to change the value of a property
 * by interpolating between its current value and the newly set one once triggered.
 * @see http://doc.babylonjs.com/how_to/how_to_use_actions
 */
var InterpolateValueAction = /** @class */ (function (_super) {
    __extends(InterpolateValueAction, _super);
    /**
     * Instantiate the action
     * @param triggerOptions defines the trigger options
     * @param target defines the object containing the value to interpolate
     * @param propertyPath defines the path to the property in the target object
     * @param value defines the target value at the end of the interpolation
     * @param duration deines the time it will take for the property to interpolate to the value.
     * @param condition defines the trigger related conditions
     * @param stopOtherAnimations defines if the other scene animations should be stopped when the action has been triggered
     * @param onInterpolationDone defines a callback raised once the interpolation animation has been done
     */
    function InterpolateValueAction(triggerOptions, target, propertyPath, value, duration, condition, stopOtherAnimations, onInterpolationDone) {
        if (duration === void 0) { duration = 1000; }
        var _this = _super.call(this, triggerOptions, condition) || this;
        /**
         * Defines the time it will take for the property to interpolate to the value.
         */
        _this.duration = 1000;
        /**
         * Observable triggered once the interpolation animation has been done.
         */
        _this.onInterpolationDoneObservable = new Observable();
        _this.propertyPath = propertyPath;
        _this.value = value;
        _this.duration = duration;
        _this.stopOtherAnimations = stopOtherAnimations;
        _this.onInterpolationDone = onInterpolationDone;
        _this._target = _this._effectiveTarget = target;
        return _this;
    }
    /** @hidden */
    InterpolateValueAction.prototype._prepare = function () {
        this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
        this._property = this._getProperty(this.propertyPath);
    };
    /**
     * Execute the action starts the value interpolation.
     */
    InterpolateValueAction.prototype.execute = function () {
        var _this = this;
        var scene = this._actionManager.getScene();
        var keys = [
            {
                frame: 0,
                value: this._effectiveTarget[this._property]
            }, {
                frame: 100,
                value: this.value
            }
        ];
        var dataType;
        if (typeof this.value === "number") {
            dataType = Animation.ANIMATIONTYPE_FLOAT;
        }
        else if (this.value instanceof Color3) {
            dataType = Animation.ANIMATIONTYPE_COLOR3;
        }
        else if (this.value instanceof Vector3) {
            dataType = Animation.ANIMATIONTYPE_VECTOR3;
        }
        else if (this.value instanceof Matrix) {
            dataType = Animation.ANIMATIONTYPE_MATRIX;
        }
        else if (this.value instanceof Quaternion) {
            dataType = Animation.ANIMATIONTYPE_QUATERNION;
        }
        else {
            Logger.Warn("InterpolateValueAction: Unsupported type (" + typeof this.value + ")");
            return;
        }
        var animation = new Animation("InterpolateValueAction", this._property, 100 * (1000.0 / this.duration), dataType, Animation.ANIMATIONLOOPMODE_CONSTANT);
        animation.setKeys(keys);
        if (this.stopOtherAnimations) {
            scene.stopAnimation(this._effectiveTarget);
        }
        var wrapper = function () {
            _this.onInterpolationDoneObservable.notifyObservers(_this);
            if (_this.onInterpolationDone) {
                _this.onInterpolationDone();
            }
        };
        scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, wrapper);
    };
    /**
     * Serializes the actions and its related information.
     * @param parent defines the object to serialize in
     * @returns the serialized object
     */
    InterpolateValueAction.prototype.serialize = function (parent) {
        return _super.prototype._serialize.call(this, {
            name: "InterpolateValueAction",
            properties: [
                Action._GetTargetProperty(this._target),
                { name: "propertyPath", value: this.propertyPath },
                { name: "value", value: Action._SerializeValueAsString(this.value) },
                { name: "duration", value: Action._SerializeValueAsString(this.duration) },
                { name: "stopOtherAnimations", value: Action._SerializeValueAsString(this.stopOtherAnimations) || false }
            ]
        }, parent);
    };
    return InterpolateValueAction;
}(Action));
_TypeStore.RegisteredTypes["BABYLON.InterpolateValueAction"] = InterpolateValueAction;

/**
 * Class used to override all child animations of a given target
 */
var AnimationPropertiesOverride = /** @class */ (function () {
    function AnimationPropertiesOverride() {
        /**
         * Gets or sets a value indicating if animation blending must be used
         */
        this.enableBlending = false;
        /**
         * Gets or sets the blending speed to use when enableBlending is true
         */
        this.blendingSpeed = 0.01;
        /**
         * Gets or sets the default loop mode to use
         */
        this.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;
    }
    return AnimationPropertiesOverride;
}());

/**
 * Base class used for every default easing function.
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var EasingFunction = /** @class */ (function () {
    function EasingFunction() {
        this._easingMode = EasingFunction.EASINGMODE_EASEIN;
    }
    /**
     * Sets the easing mode of the current function.
     * @param easingMode Defines the willing mode (EASINGMODE_EASEIN, EASINGMODE_EASEOUT or EASINGMODE_EASEINOUT)
     */
    EasingFunction.prototype.setEasingMode = function (easingMode) {
        var n = Math.min(Math.max(easingMode, 0), 2);
        this._easingMode = n;
    };
    /**
     * Gets the current easing mode.
     * @returns the easing mode
     */
    EasingFunction.prototype.getEasingMode = function () {
        return this._easingMode;
    };
    /**
     * @hidden
     */
    EasingFunction.prototype.easeInCore = function (gradient) {
        throw new Error('You must implement this method');
    };
    /**
     * Given an input gradient between 0 and 1, this returns the corrseponding value
     * of the easing function.
     * @param gradient Defines the value between 0 and 1 we want the easing value for
     * @returns the corresponding value on the curve defined by the easing function
     */
    EasingFunction.prototype.ease = function (gradient) {
        switch (this._easingMode) {
            case EasingFunction.EASINGMODE_EASEIN:
                return this.easeInCore(gradient);
            case EasingFunction.EASINGMODE_EASEOUT:
                return (1 - this.easeInCore(1 - gradient));
        }
        if (gradient >= 0.5) {
            return (((1 - this.easeInCore((1 - gradient) * 2)) * 0.5) + 0.5);
        }
        return (this.easeInCore(gradient * 2) * 0.5);
    };
    /**
     * Interpolation follows the mathematical formula associated with the easing function.
     */
    EasingFunction.EASINGMODE_EASEIN = 0;
    /**
     * Interpolation follows 100% interpolation minus the output of the formula associated with the easing function.
     */
    EasingFunction.EASINGMODE_EASEOUT = 1;
    /**
     * Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half.
     */
    EasingFunction.EASINGMODE_EASEINOUT = 2;
    return EasingFunction;
}());
/**
 * Easing function with a circle shape (see link below).
 * @see https://easings.net/#easeInCirc
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var CircleEase = /** @class */ (function (_super) {
    __extends(CircleEase, _super);
    function CircleEase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @hidden */
    CircleEase.prototype.easeInCore = function (gradient) {
        gradient = Math.max(0, Math.min(1, gradient));
        return (1.0 - Math.sqrt(1.0 - (gradient * gradient)));
    };
    return CircleEase;
}(EasingFunction));
/**
 * Easing function with a ease back shape (see link below).
 * @see https://easings.net/#easeInBack
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var BackEase = /** @class */ (function (_super) {
    __extends(BackEase, _super);
    /**
     * Instantiates a back ease easing
     * @see https://easings.net/#easeInBack
     * @param amplitude Defines the amplitude of the function
     */
    function BackEase(
    /** Defines the amplitude of the function */
    amplitude) {
        if (amplitude === void 0) { amplitude = 1; }
        var _this = _super.call(this) || this;
        _this.amplitude = amplitude;
        return _this;
    }
    /** @hidden */
    BackEase.prototype.easeInCore = function (gradient) {
        var num = Math.max(0, this.amplitude);
        return (Math.pow(gradient, 3.0) - ((gradient * num) * Math.sin(3.1415926535897931 * gradient)));
    };
    return BackEase;
}(EasingFunction));
/**
 * Easing function with a bouncing shape (see link below).
 * @see https://easings.net/#easeInBounce
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var BounceEase = /** @class */ (function (_super) {
    __extends(BounceEase, _super);
    /**
     * Instantiates a bounce easing
     * @see https://easings.net/#easeInBounce
     * @param bounces Defines the number of bounces
     * @param bounciness Defines the amplitude of the bounce
     */
    function BounceEase(
    /** Defines the number of bounces */
    bounces, 
    /** Defines the amplitude of the bounce */
    bounciness) {
        if (bounces === void 0) { bounces = 3; }
        if (bounciness === void 0) { bounciness = 2; }
        var _this = _super.call(this) || this;
        _this.bounces = bounces;
        _this.bounciness = bounciness;
        return _this;
    }
    /** @hidden */
    BounceEase.prototype.easeInCore = function (gradient) {
        var y = Math.max(0.0, this.bounces);
        var bounciness = this.bounciness;
        if (bounciness <= 1.0) {
            bounciness = 1.001;
        }
        var num9 = Math.pow(bounciness, y);
        var num5 = 1.0 - bounciness;
        var num4 = ((1.0 - num9) / num5) + (num9 * 0.5);
        var num15 = gradient * num4;
        var num65 = Math.log((-num15 * (1.0 - bounciness)) + 1.0) / Math.log(bounciness);
        var num3 = Math.floor(num65);
        var num13 = num3 + 1.0;
        var num8 = (1.0 - Math.pow(bounciness, num3)) / (num5 * num4);
        var num12 = (1.0 - Math.pow(bounciness, num13)) / (num5 * num4);
        var num7 = (num8 + num12) * 0.5;
        var num6 = gradient - num7;
        var num2 = num7 - num8;
        return (((-Math.pow(1.0 / bounciness, y - num3) / (num2 * num2)) * (num6 - num2)) * (num6 + num2));
    };
    return BounceEase;
}(EasingFunction));
/**
 * Easing function with a power of 3 shape (see link below).
 * @see https://easings.net/#easeInCubic
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var CubicEase = /** @class */ (function (_super) {
    __extends(CubicEase, _super);
    function CubicEase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @hidden */
    CubicEase.prototype.easeInCore = function (gradient) {
        return (gradient * gradient * gradient);
    };
    return CubicEase;
}(EasingFunction));
/**
 * Easing function with an elastic shape (see link below).
 * @see https://easings.net/#easeInElastic
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var ElasticEase = /** @class */ (function (_super) {
    __extends(ElasticEase, _super);
    /**
     * Instantiates an elastic easing function
     * @see https://easings.net/#easeInElastic
     * @param oscillations Defines the number of oscillations
     * @param springiness Defines the amplitude of the oscillations
     */
    function ElasticEase(
    /** Defines the number of oscillations*/
    oscillations, 
    /** Defines the amplitude of the oscillations*/
    springiness) {
        if (oscillations === void 0) { oscillations = 3; }
        if (springiness === void 0) { springiness = 3; }
        var _this = _super.call(this) || this;
        _this.oscillations = oscillations;
        _this.springiness = springiness;
        return _this;
    }
    /** @hidden */
    ElasticEase.prototype.easeInCore = function (gradient) {
        var num2;
        var num3 = Math.max(0.0, this.oscillations);
        var num = Math.max(0.0, this.springiness);
        if (num == 0) {
            num2 = gradient;
        }
        else {
            num2 = (Math.exp(num * gradient) - 1.0) / (Math.exp(num) - 1.0);
        }
        return (num2 * Math.sin(((6.2831853071795862 * num3) + 1.5707963267948966) * gradient));
    };
    return ElasticEase;
}(EasingFunction));
/**
 * Easing function with an exponential shape (see link below).
 * @see https://easings.net/#easeInExpo
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var ExponentialEase = /** @class */ (function (_super) {
    __extends(ExponentialEase, _super);
    /**
     * Instantiates an exponential easing function
     * @see https://easings.net/#easeInExpo
     * @param exponent Defines the exponent of the function
     */
    function ExponentialEase(
    /** Defines the exponent of the function */
    exponent) {
        if (exponent === void 0) { exponent = 2; }
        var _this = _super.call(this) || this;
        _this.exponent = exponent;
        return _this;
    }
    /** @hidden */
    ExponentialEase.prototype.easeInCore = function (gradient) {
        if (this.exponent <= 0) {
            return gradient;
        }
        return ((Math.exp(this.exponent * gradient) - 1.0) / (Math.exp(this.exponent) - 1.0));
    };
    return ExponentialEase;
}(EasingFunction));
/**
 * Easing function with a power shape (see link below).
 * @see https://easings.net/#easeInQuad
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var PowerEase = /** @class */ (function (_super) {
    __extends(PowerEase, _super);
    /**
     * Instantiates an power base easing function
     * @see https://easings.net/#easeInQuad
     * @param power Defines the power of the function
     */
    function PowerEase(
    /** Defines the power of the function */
    power) {
        if (power === void 0) { power = 2; }
        var _this = _super.call(this) || this;
        _this.power = power;
        return _this;
    }
    /** @hidden */
    PowerEase.prototype.easeInCore = function (gradient) {
        var y = Math.max(0.0, this.power);
        return Math.pow(gradient, y);
    };
    return PowerEase;
}(EasingFunction));
/**
 * Easing function with a power of 2 shape (see link below).
 * @see https://easings.net/#easeInQuad
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var QuadraticEase = /** @class */ (function (_super) {
    __extends(QuadraticEase, _super);
    function QuadraticEase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @hidden */
    QuadraticEase.prototype.easeInCore = function (gradient) {
        return (gradient * gradient);
    };
    return QuadraticEase;
}(EasingFunction));
/**
 * Easing function with a power of 4 shape (see link below).
 * @see https://easings.net/#easeInQuart
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var QuarticEase = /** @class */ (function (_super) {
    __extends(QuarticEase, _super);
    function QuarticEase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @hidden */
    QuarticEase.prototype.easeInCore = function (gradient) {
        return (gradient * gradient * gradient * gradient);
    };
    return QuarticEase;
}(EasingFunction));
/**
 * Easing function with a power of 5 shape (see link below).
 * @see https://easings.net/#easeInQuint
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var QuinticEase = /** @class */ (function (_super) {
    __extends(QuinticEase, _super);
    function QuinticEase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @hidden */
    QuinticEase.prototype.easeInCore = function (gradient) {
        return (gradient * gradient * gradient * gradient * gradient);
    };
    return QuinticEase;
}(EasingFunction));
/**
 * Easing function with a sin shape (see link below).
 * @see https://easings.net/#easeInSine
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var SineEase = /** @class */ (function (_super) {
    __extends(SineEase, _super);
    function SineEase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @hidden */
    SineEase.prototype.easeInCore = function (gradient) {
        return (1.0 - Math.sin(1.5707963267948966 * (1.0 - gradient)));
    };
    return SineEase;
}(EasingFunction));
/**
 * Easing function with a bezier shape (see link below).
 * @see http://cubic-bezier.com/#.17,.67,.83,.67
 * @see http://doc.babylonjs.com/babylon101/animations#easing-functions
 */
var BezierCurveEase = /** @class */ (function (_super) {
    __extends(BezierCurveEase, _super);
    /**
     * Instantiates a bezier function
     * @see http://cubic-bezier.com/#.17,.67,.83,.67
     * @param x1 Defines the x component of the start tangent in the bezier curve
     * @param y1 Defines the y component of the start tangent in the bezier curve
     * @param x2 Defines the x component of the end tangent in the bezier curve
     * @param y2 Defines the y component of the end tangent in the bezier curve
     */
    function BezierCurveEase(
    /** Defines the x component of the start tangent in the bezier curve */
    x1, 
    /** Defines the y component of the start tangent in the bezier curve */
    y1, 
    /** Defines the x component of the end tangent in the bezier curve */
    x2, 
    /** Defines the y component of the end tangent in the bezier curve */
    y2) {
        if (x1 === void 0) { x1 = 0; }
        if (y1 === void 0) { y1 = 0; }
        if (x2 === void 0) { x2 = 1; }
        if (y2 === void 0) { y2 = 1; }
        var _this = _super.call(this) || this;
        _this.x1 = x1;
        _this.y1 = y1;
        _this.x2 = x2;
        _this.y2 = y2;
        return _this;
    }
    /** @hidden */
    BezierCurveEase.prototype.easeInCore = function (gradient) {
        return BezierCurve.Interpolate(gradient, this.x1, this.y1, this.x2, this.y2);
    };
    return BezierCurveEase;
}(EasingFunction));

/**
 * Class used to work with sound analyzer using fast fourier transform (FFT)
 * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
 */
var Analyser = /** @class */ (function () {
    /**
     * Creates a new analyser
     * @param scene defines hosting scene
     */
    function Analyser(scene) {
        /**
         * Gets or sets the smoothing
         * @ignorenaming
         */
        this.SMOOTHING = 0.75;
        /**
         * Gets or sets the FFT table size
         * @ignorenaming
         */
        this.FFT_SIZE = 512;
        /**
         * Gets or sets the bar graph amplitude
         * @ignorenaming
         */
        this.BARGRAPHAMPLITUDE = 256;
        /**
         * Gets or sets the position of the debug canvas
         * @ignorenaming
         */
        this.DEBUGCANVASPOS = { x: 20, y: 20 };
        /**
         * Gets or sets the debug canvas size
         * @ignorenaming
         */
        this.DEBUGCANVASSIZE = { width: 320, height: 200 };
        this._scene = scene;
        this._audioEngine = Engine.audioEngine;
        if (this._audioEngine.canUseWebAudio && this._audioEngine.audioContext) {
            this._webAudioAnalyser = this._audioEngine.audioContext.createAnalyser();
            this._webAudioAnalyser.minDecibels = -140;
            this._webAudioAnalyser.maxDecibels = 0;
            this._byteFreqs = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);
            this._byteTime = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);
            this._floatFreqs = new Float32Array(this._webAudioAnalyser.frequencyBinCount);
        }
    }
    /**
     * Get the number of data values you will have to play with for the visualization
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/frequencyBinCount
     * @returns a number
     */
    Analyser.prototype.getFrequencyBinCount = function () {
        if (this._audioEngine.canUseWebAudio) {
            return this._webAudioAnalyser.frequencyBinCount;
        }
        else {
            return 0;
        }
    };
    /**
     * Gets the current frequency data as a byte array
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
     * @returns a Uint8Array
     */
    Analyser.prototype.getByteFrequencyData = function () {
        if (this._audioEngine.canUseWebAudio) {
            this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;
            this._webAudioAnalyser.fftSize = this.FFT_SIZE;
            this._webAudioAnalyser.getByteFrequencyData(this._byteFreqs);
        }
        return this._byteFreqs;
    };
    /**
     * Gets the current waveform as a byte array
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteTimeDomainData
     * @returns a Uint8Array
     */
    Analyser.prototype.getByteTimeDomainData = function () {
        if (this._audioEngine.canUseWebAudio) {
            this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;
            this._webAudioAnalyser.fftSize = this.FFT_SIZE;
            this._webAudioAnalyser.getByteTimeDomainData(this._byteTime);
        }
        return this._byteTime;
    };
    /**
     * Gets the current frequency data as a float array
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
     * @returns a Float32Array
     */
    Analyser.prototype.getFloatFrequencyData = function () {
        if (this._audioEngine.canUseWebAudio) {
            this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;
            this._webAudioAnalyser.fftSize = this.FFT_SIZE;
            this._webAudioAnalyser.getFloatFrequencyData(this._floatFreqs);
        }
        return this._floatFreqs;
    };
    /**
     * Renders the debug canvas
     */
    Analyser.prototype.drawDebugCanvas = function () {
        var _this = this;
        if (this._audioEngine.canUseWebAudio) {
            if (!this._debugCanvas) {
                this._debugCanvas = document.createElement("canvas");
                this._debugCanvas.width = this.DEBUGCANVASSIZE.width;
                this._debugCanvas.height = this.DEBUGCANVASSIZE.height;
                this._debugCanvas.style.position = "absolute";
                this._debugCanvas.style.top = this.DEBUGCANVASPOS.y + "px";
                this._debugCanvas.style.left = this.DEBUGCANVASPOS.x + "px";
                this._debugCanvasContext = this._debugCanvas.getContext("2d");
                document.body.appendChild(this._debugCanvas);
                this._registerFunc = function () {
                    _this.drawDebugCanvas();
                };
                this._scene.registerBeforeRender(this._registerFunc);
            }
            if (this._registerFunc && this._debugCanvasContext) {
                var workingArray = this.getByteFrequencyData();
                this._debugCanvasContext.fillStyle = 'rgb(0, 0, 0)';
                this._debugCanvasContext.fillRect(0, 0, this.DEBUGCANVASSIZE.width, this.DEBUGCANVASSIZE.height);
                // Draw the frequency domain chart.
                for (var i = 0; i < this.getFrequencyBinCount(); i++) {
                    var value = workingArray[i];
                    var percent = value / this.BARGRAPHAMPLITUDE;
                    var height = this.DEBUGCANVASSIZE.height * percent;
                    var offset = this.DEBUGCANVASSIZE.height - height - 1;
                    var barWidth = this.DEBUGCANVASSIZE.width / this.getFrequencyBinCount();
                    var hue = i / this.getFrequencyBinCount() * 360;
                    this._debugCanvasContext.fillStyle = 'hsl(' + hue + ', 100%, 50%)';
                    this._debugCanvasContext.fillRect(i * barWidth, offset, barWidth, height);
                }
            }
        }
    };
    /**
     * Stops rendering the debug canvas and removes it
     */
    Analyser.prototype.stopDebugCanvas = function () {
        if (this._debugCanvas) {
            if (this._registerFunc) {
                this._scene.unregisterBeforeRender(this._registerFunc);
                this._registerFunc = null;
            }
            document.body.removeChild(this._debugCanvas);
            this._debugCanvas = null;
            this._debugCanvasContext = null;
        }
    };
    /**
     * Connects two audio nodes
     * @param inputAudioNode defines first node to connect
     * @param outputAudioNode defines second node to connect
     */
    Analyser.prototype.connectAudioNodes = function (inputAudioNode, outputAudioNode) {
        if (this._audioEngine.canUseWebAudio) {
            inputAudioNode.connect(this._webAudioAnalyser);
            this._webAudioAnalyser.connect(outputAudioNode);
        }
    };
    /**
     * Releases all associated resources
     */
    Analyser.prototype.dispose = function () {
        if (this._audioEngine.canUseWebAudio) {
            this._webAudioAnalyser.disconnect();
        }
    };
    return Analyser;
}());

// Sets the default audio engine to Babylon.js
Engine.AudioEngineFactory = function (hostElement) { return new AudioEngine(hostElement); };
/**
 * This represents the default audio engine used in babylon.
 * It is responsible to play, synchronize and analyse sounds throughout the  application.
 * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
 */
var AudioEngine = /** @class */ (function () {
    /**
     * Instantiates a new audio engine.
     *
     * There should be only one per page as some browsers restrict the number
     * of audio contexts you can create.
     * @param hostElement defines the host element where to display the mute icon if necessary
     */
    function AudioEngine(hostElement) {
        var _this = this;
        if (hostElement === void 0) { hostElement = null; }
        this._audioContext = null;
        this._audioContextInitialized = false;
        this._muteButton = null;
        /**
         * Gets whether the current host supports Web Audio and thus could create AudioContexts.
         */
        this.canUseWebAudio = false;
        /**
         * Defines if Babylon should emit a warning if WebAudio is not supported.
         * @ignoreNaming
         */
        this.WarnedWebAudioUnsupported = false;
        /**
         * Gets whether or not mp3 are supported by your browser.
         */
        this.isMP3supported = false;
        /**
         * Gets whether or not ogg are supported by your browser.
         */
        this.isOGGsupported = false;
        /**
         * Gets whether audio has been unlocked on the device.
         * Some Browsers have strong restrictions about Audio and won t autoplay unless
         * a user interaction has happened.
         */
        this.unlocked = true;
        /**
         * Defines if the audio engine relies on a custom unlocked button.
         * In this case, the embedded button will not be displayed.
         */
        this.useCustomUnlockedButton = false;
        /**
         * Event raised when audio has been unlocked on the browser.
         */
        this.onAudioUnlockedObservable = new Observable();
        /**
         * Event raised when audio has been locked on the browser.
         */
        this.onAudioLockedObservable = new Observable();
        this._tryToRun = false;
        this._onResize = function () {
            _this._moveButtonToTopLeft();
        };
        if (typeof window.AudioContext !== 'undefined' || typeof window.webkitAudioContext !== 'undefined') {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.canUseWebAudio = true;
        }
        var audioElem = document.createElement('audio');
        this._hostElement = hostElement;
        try {
            if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/, '')) {
                this.isMP3supported = true;
            }
        }
        catch (e) {
            // protect error during capability check.
        }
        try {
            if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '')) {
                this.isOGGsupported = true;
            }
        }
        catch (e) {
            // protect error during capability check.
        }
    }
    Object.defineProperty(AudioEngine.prototype, "audioContext", {
        /**
         * Gets the current AudioContext if available.
         */
        get: function () {
            if (!this._audioContextInitialized) {
                this._initializeAudioContext();
            }
            else {
                if (!this.unlocked && !this._muteButton) {
                    this._displayMuteButton();
                }
            }
            return this._audioContext;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Flags the audio engine in Locked state.
     * This happens due to new browser policies preventing audio to autoplay.
     */
    AudioEngine.prototype.lock = function () {
        this._triggerSuspendedState();
    };
    /**
     * Unlocks the audio engine once a user action has been done on the dom.
     * This is helpful to resume play once browser policies have been satisfied.
     */
    AudioEngine.prototype.unlock = function () {
        this._triggerRunningState();
    };
    AudioEngine.prototype._resumeAudioContext = function () {
        var result;
        if (this._audioContext.resume) {
            result = this._audioContext.resume();
        }
        return result || Promise.resolve();
    };
    AudioEngine.prototype._initializeAudioContext = function () {
        try {
            if (this.canUseWebAudio) {
                this._audioContext = new AudioContext();
                // create a global volume gain node
                this.masterGain = this._audioContext.createGain();
                this.masterGain.gain.value = 1;
                this.masterGain.connect(this._audioContext.destination);
                this._audioContextInitialized = true;
                if (this._audioContext.state === "running") {
                    // Do not wait for the promise to unlock.
                    this._triggerRunningState();
                }
            }
        }
        catch (e) {
            this.canUseWebAudio = false;
            Logger.Error("Web Audio: " + e.message);
        }
    };
    AudioEngine.prototype._triggerRunningState = function () {
        var _this = this;
        if (this._tryToRun) {
            return;
        }
        this._tryToRun = true;
        this._resumeAudioContext()
            .then(function () {
            _this._tryToRun = false;
            if (_this._muteButton) {
                _this._hideMuteButton();
            }
        }).catch(function () {
            _this._tryToRun = false;
            _this.unlocked = false;
        });
        // Notify users that the audio stack is unlocked/unmuted
        this.unlocked = true;
        this.onAudioUnlockedObservable.notifyObservers(this);
    };
    AudioEngine.prototype._triggerSuspendedState = function () {
        this.unlocked = false;
        this.onAudioLockedObservable.notifyObservers(this);
        this._displayMuteButton();
    };
    AudioEngine.prototype._displayMuteButton = function () {
        var _this = this;
        if (this.useCustomUnlockedButton || this._muteButton) {
            return;
        }
        this._muteButton = document.createElement("BUTTON");
        this._muteButton.className = "babylonUnmuteIcon";
        this._muteButton.id = "babylonUnmuteIconBtn";
        this._muteButton.title = "Unmute";
        var css = ".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E);  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }";
        var style = document.createElement('style');
        style.appendChild(document.createTextNode(css));
        document.getElementsByTagName('head')[0].appendChild(style);
        document.body.appendChild(this._muteButton);
        this._moveButtonToTopLeft();
        this._muteButton.addEventListener('touchend', function () {
            _this._triggerRunningState();
        }, true);
        this._muteButton.addEventListener('click', function () {
            _this._triggerRunningState();
        }, true);
        window.addEventListener("resize", this._onResize);
    };
    AudioEngine.prototype._moveButtonToTopLeft = function () {
        if (this._hostElement && this._muteButton) {
            this._muteButton.style.top = this._hostElement.offsetTop + 20 + "px";
            this._muteButton.style.left = this._hostElement.offsetLeft + 20 + "px";
        }
    };
    AudioEngine.prototype._hideMuteButton = function () {
        if (this._muteButton) {
            document.body.removeChild(this._muteButton);
            this._muteButton = null;
        }
    };
    /**
     * Destroy and release the resources associated with the audio ccontext.
     */
    AudioEngine.prototype.dispose = function () {
        if (this.canUseWebAudio && this._audioContextInitialized) {
            if (this._connectedAnalyser && this._audioContext) {
                this._connectedAnalyser.stopDebugCanvas();
                this._connectedAnalyser.dispose();
                this.masterGain.disconnect();
                this.masterGain.connect(this._audioContext.destination);
                this._connectedAnalyser = null;
            }
            this.masterGain.gain.value = 1;
        }
        this.WarnedWebAudioUnsupported = false;
        this._hideMuteButton();
        window.removeEventListener("resize", this._onResize);
        this.onAudioUnlockedObservable.clear();
        this.onAudioLockedObservable.clear();
    };
    /**
     * Gets the global volume sets on the master gain.
     * @returns the global volume if set or -1 otherwise
     */
    AudioEngine.prototype.getGlobalVolume = function () {
        if (this.canUseWebAudio && this._audioContextInitialized) {
            return this.masterGain.gain.value;
        }
        else {
            return -1;
        }
    };
    /**
     * Sets the global volume of your experience (sets on the master gain).
     * @param newVolume Defines the new global volume of the application
     */
    AudioEngine.prototype.setGlobalVolume = function (newVolume) {
        if (this.canUseWebAudio && this._audioContextInitialized) {
            this.masterGain.gain.value = newVolume;
        }
    };
    /**
     * Connect the audio engine to an audio analyser allowing some amazing
     * synchornization between the sounds/music and your visualization (VuMeter for instance).
     * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser
     * @param analyser The analyser to connect to the engine
     */
    AudioEngine.prototype.connectToAnalyser = function (analyser) {
        if (this._connectedAnalyser) {
            this._connectedAnalyser.stopDebugCanvas();
        }
        if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {
            this._connectedAnalyser = analyser;
            this.masterGain.disconnect();
            this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);
        }
    };
    return AudioEngine;
}());

/**
 * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.
 * It will be also used in a future release to apply effects on a specific track.
 * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music#using-sound-tracks
 */
var SoundTrack = /** @class */ (function () {
    /**
     * Creates a new sound track.
     * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music#using-sound-tracks
     * @param scene Define the scene the sound track belongs to
     * @param options
     */
    function SoundTrack(scene, options) {
        if (options === void 0) { options = {}; }
        /**
         * The unique identifier of the sound track in the scene.
         */
        this.id = -1;
        this._isMainTrack = false;
        this._isInitialized = false;
        this._scene = scene;
        this.soundCollection = new Array();
        this._options = options;
        if (!this._isMainTrack && this._scene.soundTracks) {
            this._scene.soundTracks.push(this);
            this.id = this._scene.soundTracks.length - 1;
        }
    }
    SoundTrack.prototype._initializeSoundTrackAudioGraph = function () {
        if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {
            this._outputAudioNode = Engine.audioEngine.audioContext.createGain();
            this._outputAudioNode.connect(Engine.audioEngine.masterGain);
            if (this._options) {
                if (this._options.volume) {
                    this._outputAudioNode.gain.value = this._options.volume;
                }
                if (this._options.mainTrack) {
                    this._isMainTrack = this._options.mainTrack;
                }
            }
            this._isInitialized = true;
        }
    };
    /**
     * Release the sound track and its associated resources
     */
    SoundTrack.prototype.dispose = function () {
        if (Engine.audioEngine && Engine.audioEngine.canUseWebAudio) {
            if (this._connectedAnalyser) {
                this._connectedAnalyser.stopDebugCanvas();
            }
            while (this.soundCollection.length) {
                this.soundCollection[0].dispose();
            }
            if (this._outputAudioNode) {
                this._outputAudioNode.disconnect();
            }
            this._outputAudioNode = null;
        }
    };
    /**
     * Adds a sound to this sound track
     * @param sound define the cound to add
     * @ignoreNaming
     */
    SoundTrack.prototype.AddSound = function (sound) {
        if (!this._isInitialized) {
            this._initializeSoundTrackAudioGraph();
        }
        if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {
            sound.connectToSoundTrackAudioNode(this._outputAudioNode);
        }
        if (sound.soundTrackId) {
            if (sound.soundTrackId === -1) {
                this._scene.mainSoundTrack.RemoveSound(sound);
            }
            else if (this._scene.soundTracks) {
                this._scene.soundTracks[sound.soundTrackId].RemoveSound(sound);
            }
        }
        this.soundCollection.push(sound);
        sound.soundTrackId = this.id;
    };
    /**
     * Removes a sound to this sound track
     * @param sound define the cound to remove
     * @ignoreNaming
     */
    SoundTrack.prototype.RemoveSound = function (sound) {
        var index = this.soundCollection.indexOf(sound);
        if (index !== -1) {
            this.soundCollection.splice(index, 1);
        }
    };
    /**
     * Set a global volume for the full sound track.
     * @param newVolume Define the new volume of the sound track
     */
    SoundTrack.prototype.setVolume = function (newVolume) {
        if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {
            this._outputAudioNode.gain.value = newVolume;
        }
    };
    /**
     * Switch the panning model to HRTF:
     * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.
     * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
     */
    SoundTrack.prototype.switchPanningModelToHRTF = function () {
        if (Engine.audioEngine.canUseWebAudio) {
            for (var i = 0; i < this.soundCollection.length; i++) {
                this.soundCollection[i].switchPanningModelToHRTF();
            }
        }
    };
    /**
     * Switch the panning model to Equal Power:
     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
     * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
     */
    SoundTrack.prototype.switchPanningModelToEqualPower = function () {
        if (Engine.audioEngine.canUseWebAudio) {
            for (var i = 0; i < this.soundCollection.length; i++) {
                this.soundCollection[i].switchPanningModelToEqualPower();
            }
        }
    };
    /**
     * Connect the sound track to an audio analyser allowing some amazing
     * synchornization between the sounds/music and your visualization (VuMeter for instance).
     * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser
     * @param analyser The analyser to connect to the engine
     */
    SoundTrack.prototype.connectToAnalyser = function (analyser) {
        if (this._connectedAnalyser) {
            this._connectedAnalyser.stopDebugCanvas();
        }
        this._connectedAnalyser = analyser;
        if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {
            this._outputAudioNode.disconnect();
            this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, Engine.audioEngine.masterGain);
        }
    };
    return SoundTrack;
}());

// Adds the parser to the scene parsers.
AbstractScene.AddParser(SceneComponentConstants.NAME_AUDIO, function (parsedData, scene, container, rootUrl) {
    // TODO: add sound
    var loadedSounds = [];
    var loadedSound;
    container.sounds = container.sounds || [];
    if (parsedData.sounds !== undefined && parsedData.sounds !== null) {
        for (var index = 0, cache = parsedData.sounds.length; index < cache; index++) {
            var parsedSound = parsedData.sounds[index];
            if (Engine.audioEngine.canUseWebAudio) {
                if (!parsedSound.url) {
                    parsedSound.url = parsedSound.name;
                }
                if (!loadedSounds[parsedSound.url]) {
                    loadedSound = Sound.Parse(parsedSound, scene, rootUrl);
                    loadedSounds[parsedSound.url] = loadedSound;
                    container.sounds.push(loadedSound);
                }
                else {
                    container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));
                }
            }
            else {
                container.sounds.push(new Sound(parsedSound.name, null, scene));
            }
        }
    }
    loadedSounds = [];
});
Object.defineProperty(Scene.prototype, "mainSoundTrack", {
    get: function () {
        var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
            compo = new AudioSceneComponent(this);
            this._addComponent(compo);
        }
        if (!this._mainSoundTrack) {
            this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });
        }
        return this._mainSoundTrack;
    },
    enumerable: true,
    configurable: true
});
Scene.prototype.getSoundByName = function (name) {
    var index;
    for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {
        if (this.mainSoundTrack.soundCollection[index].name === name) {
            return this.mainSoundTrack.soundCollection[index];
        }
    }
    if (this.soundTracks) {
        for (var sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {
            for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {
                if (this.soundTracks[sdIndex].soundCollection[index].name === name) {
                    return this.soundTracks[sdIndex].soundCollection[index];
                }
            }
        }
    }
    return null;
};
Object.defineProperty(Scene.prototype, "audioEnabled", {
    get: function () {
        var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
            compo = new AudioSceneComponent(this);
            this._addComponent(compo);
        }
        return compo.audioEnabled;
    },
    set: function (value) {
        var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
            compo = new AudioSceneComponent(this);
            this._addComponent(compo);
        }
        if (value) {
            compo.enableAudio();
        }
        else {
            compo.disableAudio();
        }
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(Scene.prototype, "headphone", {
    get: function () {
        var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
            compo = new AudioSceneComponent(this);
            this._addComponent(compo);
        }
        return compo.headphone;
    },
    set: function (value) {
        var compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
            compo = new AudioSceneComponent(this);
            this._addComponent(compo);
        }
        if (value) {
            compo.switchAudioModeForHeadphones();
        }
        else {
            compo.switchAudioModeForNormalSpeakers();
        }
    },
    enumerable: true,
    configurable: true
});
/**
 * Defines the sound scene component responsible to manage any sounds
 * in a given scene.
 */
var AudioSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function AudioSceneComponent(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_AUDIO;
        this._audioEnabled = true;
        this._headphone = false;
        this.scene = scene;
        scene.soundTracks = new Array();
        scene.sounds = new Array();
    }
    Object.defineProperty(AudioSceneComponent.prototype, "audioEnabled", {
        /**
         * Gets whether audio is enabled or not.
         * Please use related enable/disable method to switch state.
         */
        get: function () {
            return this._audioEnabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AudioSceneComponent.prototype, "headphone", {
        /**
         * Gets whether audio is outputing to headphone or not.
         * Please use the according Switch methods to change output.
         */
        get: function () {
            return this._headphone;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Registers the component in a given scene
     */
    AudioSceneComponent.prototype.register = function () {
        this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    AudioSceneComponent.prototype.rebuild = function () {
        // Nothing to do here. (Not rendering related)
    };
    /**
     * Serializes the component data to the specified json object
     * @param serializationObject The object to serialize to
     */
    AudioSceneComponent.prototype.serialize = function (serializationObject) {
        serializationObject.sounds = [];
        if (this.scene.soundTracks) {
            for (var index = 0; index < this.scene.soundTracks.length; index++) {
                var soundtrack = this.scene.soundTracks[index];
                for (var soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {
                    serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());
                }
            }
        }
    };
    /**
     * Adds all the element from the container to the scene
     * @param container the container holding the elements
     */
    AudioSceneComponent.prototype.addFromContainer = function (container) {
        var _this = this;
        if (!container.sounds) {
            return;
        }
        container.sounds.forEach(function (sound) {
            sound.play();
            sound.autoplay = true;
            _this.scene.mainSoundTrack.AddSound(sound);
        });
    };
    /**
     * Removes all the elements in the container from the scene
     * @param container contains the elements to remove
     * @param dispose if the removed element should be disposed (default: false)
     */
    AudioSceneComponent.prototype.removeFromContainer = function (container, dispose) {
        var _this = this;
        if (dispose === void 0) { dispose = false; }
        if (!container.sounds) {
            return;
        }
        container.sounds.forEach(function (sound) {
            sound.stop();
            sound.autoplay = false;
            _this.scene.mainSoundTrack.RemoveSound(sound);
            if (dispose) {
                sound.dispose();
            }
        });
    };
    /**
     * Disposes the component and the associated ressources.
     */
    AudioSceneComponent.prototype.dispose = function () {
        var scene = this.scene;
        if (scene._mainSoundTrack) {
            scene.mainSoundTrack.dispose();
        }
        if (scene.soundTracks) {
            for (var scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {
                scene.soundTracks[scIndex].dispose();
            }
        }
    };
    /**
     * Disables audio in the associated scene.
     */
    AudioSceneComponent.prototype.disableAudio = function () {
        var scene = this.scene;
        this._audioEnabled = false;
        var i;
        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
            scene.mainSoundTrack.soundCollection[i].pause();
        }
        if (scene.soundTracks) {
            for (i = 0; i < scene.soundTracks.length; i++) {
                for (var j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
                    scene.soundTracks[i].soundCollection[j].pause();
                }
            }
        }
    };
    /**
     * Enables audio in the associated scene.
     */
    AudioSceneComponent.prototype.enableAudio = function () {
        var scene = this.scene;
        this._audioEnabled = true;
        var i;
        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
            if (scene.mainSoundTrack.soundCollection[i].isPaused) {
                scene.mainSoundTrack.soundCollection[i].play();
            }
        }
        if (scene.soundTracks) {
            for (i = 0; i < scene.soundTracks.length; i++) {
                for (var j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
                    if (scene.soundTracks[i].soundCollection[j].isPaused) {
                        scene.soundTracks[i].soundCollection[j].play();
                    }
                }
            }
        }
    };
    /**
     * Switch audio to headphone output.
     */
    AudioSceneComponent.prototype.switchAudioModeForHeadphones = function () {
        var scene = this.scene;
        this._headphone = true;
        scene.mainSoundTrack.switchPanningModelToHRTF();
        if (scene.soundTracks) {
            for (var i = 0; i < scene.soundTracks.length; i++) {
                scene.soundTracks[i].switchPanningModelToHRTF();
            }
        }
    };
    /**
     * Switch audio to normal speakers.
     */
    AudioSceneComponent.prototype.switchAudioModeForNormalSpeakers = function () {
        var scene = this.scene;
        this._headphone = false;
        scene.mainSoundTrack.switchPanningModelToEqualPower();
        if (scene.soundTracks) {
            for (var i = 0; i < scene.soundTracks.length; i++) {
                scene.soundTracks[i].switchPanningModelToEqualPower();
            }
        }
    };
    AudioSceneComponent.prototype._afterRender = function () {
        var scene = this.scene;
        if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || (scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1)) {
            return;
        }
        var listeningCamera;
        var audioEngine = Engine.audioEngine;
        if (scene.activeCameras.length > 0) {
            listeningCamera = scene.activeCameras[0];
        }
        else {
            listeningCamera = scene.activeCamera;
        }
        if (listeningCamera && audioEngine.audioContext) {
            audioEngine.audioContext.listener.setPosition(listeningCamera.position.x, listeningCamera.position.y, listeningCamera.position.z);
            // for VR cameras
            if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {
                listeningCamera = listeningCamera.rigCameras[0];
            }
            var mat = Matrix.Invert(listeningCamera.getViewMatrix());
            var cameraDirection = Vector3.TransformNormal(new Vector3(0, 0, -1), mat);
            cameraDirection.normalize();
            // To avoid some errors on GearVR
            if (!isNaN(cameraDirection.x) && !isNaN(cameraDirection.y) && !isNaN(cameraDirection.z)) {
                audioEngine.audioContext.listener.setOrientation(cameraDirection.x, cameraDirection.y, cameraDirection.z, 0, 1, 0);
            }
            var i;
            for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
                var sound = scene.mainSoundTrack.soundCollection[i];
                if (sound.useCustomAttenuation) {
                    sound.updateDistanceFromListener();
                }
            }
            if (scene.soundTracks) {
                for (i = 0; i < scene.soundTracks.length; i++) {
                    for (var j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
                        sound = scene.soundTracks[i].soundCollection[j];
                        if (sound.useCustomAttenuation) {
                            sound.updateDistanceFromListener();
                        }
                    }
                }
            }
        }
    };
    return AudioSceneComponent;
}());
Sound._SceneComponentInitialization = function (scene) {
    var compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);
    if (!compo) {
        compo = new AudioSceneComponent(scene);
        scene._addComponent(compo);
    }
};

/**
 * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.
 * @see http://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior
 */
var AutoRotationBehavior = /** @class */ (function () {
    function AutoRotationBehavior() {
        this._zoomStopsAnimation = false;
        this._idleRotationSpeed = 0.05;
        this._idleRotationWaitTime = 2000;
        this._idleRotationSpinupTime = 2000;
        this._isPointerDown = false;
        this._lastFrameTime = null;
        this._lastInteractionTime = -Infinity;
        this._cameraRotationSpeed = 0;
        this._lastFrameRadius = 0;
    }
    Object.defineProperty(AutoRotationBehavior.prototype, "name", {
        /**
         * Gets the name of the behavior.
         */
        get: function () {
            return "AutoRotation";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoRotationBehavior.prototype, "zoomStopsAnimation", {
        /**
        * Gets the flag that indicates if user zooming should stop animation.
        */
        get: function () {
            return this._zoomStopsAnimation;
        },
        /**
        * Sets the flag that indicates if user zooming should stop animation.
        */
        set: function (flag) {
            this._zoomStopsAnimation = flag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoRotationBehavior.prototype, "idleRotationSpeed", {
        /**
        * Gets the default speed at which the camera rotates around the model.
        */
        get: function () {
            return this._idleRotationSpeed;
        },
        /**
        * Sets the default speed at which the camera rotates around the model.
        */
        set: function (speed) {
            this._idleRotationSpeed = speed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoRotationBehavior.prototype, "idleRotationWaitTime", {
        /**
        * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
        */
        get: function () {
            return this._idleRotationWaitTime;
        },
        /**
        * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
        */
        set: function (time) {
            this._idleRotationWaitTime = time;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoRotationBehavior.prototype, "idleRotationSpinupTime", {
        /**
        * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
        */
        get: function () {
            return this._idleRotationSpinupTime;
        },
        /**
        * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
        */
        set: function (time) {
            this._idleRotationSpinupTime = time;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoRotationBehavior.prototype, "rotationInProgress", {
        /**
         * Gets a value indicating if the camera is currently rotating because of this behavior
         */
        get: function () {
            return Math.abs(this._cameraRotationSpeed) > 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initializes the behavior.
     */
    AutoRotationBehavior.prototype.init = function () {
        // Do notihng
    };
    /**
     * Attaches the behavior to its arc rotate camera.
     * @param camera Defines the camera to attach the behavior to
     */
    AutoRotationBehavior.prototype.attach = function (camera) {
        var _this = this;
        this._attachedCamera = camera;
        var scene = this._attachedCamera.getScene();
        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function (pointerInfoPre) {
            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
                _this._isPointerDown = true;
                return;
            }
            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
                _this._isPointerDown = false;
            }
        });
        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {
            var now = PrecisionDate.Now;
            var dt = 0;
            if (_this._lastFrameTime != null) {
                dt = now - _this._lastFrameTime;
            }
            _this._lastFrameTime = now;
            // Stop the animation if there is user interaction and the animation should stop for this interaction
            _this._applyUserInteraction();
            var timeToRotation = now - _this._lastInteractionTime - _this._idleRotationWaitTime;
            var scale = Math.max(Math.min(timeToRotation / (_this._idleRotationSpinupTime), 1), 0);
            _this._cameraRotationSpeed = _this._idleRotationSpeed * scale;
            // Step camera rotation by rotation speed
            if (_this._attachedCamera) {
                _this._attachedCamera.alpha -= _this._cameraRotationSpeed * (dt / 1000);
            }
        });
    };
    /**
     * Detaches the behavior from its current arc rotate camera.
     */
    AutoRotationBehavior.prototype.detach = function () {
        if (!this._attachedCamera) {
            return;
        }
        var scene = this._attachedCamera.getScene();
        if (this._onPrePointerObservableObserver) {
            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
        }
        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
        this._attachedCamera = null;
    };
    /**
     * Returns true if user is scrolling.
     * @return true if user is scrolling.
     */
    AutoRotationBehavior.prototype._userIsZooming = function () {
        if (!this._attachedCamera) {
            return false;
        }
        return this._attachedCamera.inertialRadiusOffset !== 0;
    };
    AutoRotationBehavior.prototype._shouldAnimationStopForInteraction = function () {
        if (!this._attachedCamera) {
            return false;
        }
        var zoomHasHitLimit = false;
        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {
            zoomHasHitLimit = true;
        }
        // Update the record of previous radius - works as an approx. indicator of hitting radius limits
        this._lastFrameRadius = this._attachedCamera.radius;
        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();
    };
    /**
     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
     */
    AutoRotationBehavior.prototype._applyUserInteraction = function () {
        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {
            this._lastInteractionTime = PrecisionDate.Now;
        }
    };
    // Tools
    AutoRotationBehavior.prototype._userIsMoving = function () {
        if (!this._attachedCamera) {
            return false;
        }
        return this._attachedCamera.inertialAlphaOffset !== 0 ||
            this._attachedCamera.inertialBetaOffset !== 0 ||
            this._attachedCamera.inertialRadiusOffset !== 0 ||
            this._attachedCamera.inertialPanningX !== 0 ||
            this._attachedCamera.inertialPanningY !== 0 ||
            this._isPointerDown;
    };
    return AutoRotationBehavior;
}());

/**
 * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
 * @see http://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior
 */
var BouncingBehavior = /** @class */ (function () {
    function BouncingBehavior() {
        /**
         * The duration of the animation, in milliseconds
         */
        this.transitionDuration = 450;
        /**
         * Length of the distance animated by the transition when lower radius is reached
         */
        this.lowerRadiusTransitionRange = 2;
        /**
         * Length of the distance animated by the transition when upper radius is reached
         */
        this.upperRadiusTransitionRange = -2;
        this._autoTransitionRange = false;
        // Animations
        this._radiusIsAnimating = false;
        this._radiusBounceTransition = null;
        this._animatables = new Array();
    }
    Object.defineProperty(BouncingBehavior.prototype, "name", {
        /**
         * Gets the name of the behavior.
         */
        get: function () {
            return "Bouncing";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BouncingBehavior.prototype, "autoTransitionRange", {
        /**
         * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
         */
        get: function () {
            return this._autoTransitionRange;
        },
        /**
         * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
         * Transition ranges will be set to 5% of the bounding box diagonal in world space
         */
        set: function (value) {
            var _this = this;
            if (this._autoTransitionRange === value) {
                return;
            }
            this._autoTransitionRange = value;
            var camera = this._attachedCamera;
            if (!camera) {
                return;
            }
            if (value) {
                this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {
                    if (!mesh) {
                        return;
                    }
                    mesh.computeWorldMatrix(true);
                    var diagonal = mesh.getBoundingInfo().diagonalLength;
                    _this.lowerRadiusTransitionRange = diagonal * 0.05;
                    _this.upperRadiusTransitionRange = diagonal * 0.05;
                });
            }
            else if (this._onMeshTargetChangedObserver) {
                camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initializes the behavior.
     */
    BouncingBehavior.prototype.init = function () {
        // Do notihng
    };
    /**
     * Attaches the behavior to its arc rotate camera.
     * @param camera Defines the camera to attach the behavior to
     */
    BouncingBehavior.prototype.attach = function (camera) {
        var _this = this;
        this._attachedCamera = camera;
        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {
            if (!_this._attachedCamera) {
                return;
            }
            // Add the bounce animation to the lower radius limit
            if (_this._isRadiusAtLimit(_this._attachedCamera.lowerRadiusLimit)) {
                _this._applyBoundRadiusAnimation(_this.lowerRadiusTransitionRange);
            }
            // Add the bounce animation to the upper radius limit
            if (_this._isRadiusAtLimit(_this._attachedCamera.upperRadiusLimit)) {
                _this._applyBoundRadiusAnimation(_this.upperRadiusTransitionRange);
            }
        });
    };
    /**
     * Detaches the behavior from its current arc rotate camera.
     */
    BouncingBehavior.prototype.detach = function () {
        if (!this._attachedCamera) {
            return;
        }
        if (this._onAfterCheckInputsObserver) {
            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
        }
        if (this._onMeshTargetChangedObserver) {
            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
        }
        this._attachedCamera = null;
    };
    /**
     * Checks if the camera radius is at the specified limit. Takes into account animation locks.
     * @param radiusLimit The limit to check against.
     * @return Bool to indicate if at limit.
     */
    BouncingBehavior.prototype._isRadiusAtLimit = function (radiusLimit) {
        if (!this._attachedCamera) {
            return false;
        }
        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {
            return true;
        }
        return false;
    };
    /**
     * Applies an animation to the radius of the camera, extending by the radiusDelta.
     * @param radiusDelta The delta by which to animate to. Can be negative.
     */
    BouncingBehavior.prototype._applyBoundRadiusAnimation = function (radiusDelta) {
        var _this = this;
        if (!this._attachedCamera) {
            return;
        }
        if (!this._radiusBounceTransition) {
            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);
            this._radiusBounceTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);
        }
        // Prevent zoom until bounce has completed
        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;
        this._attachedCamera.wheelPrecision = Infinity;
        this._attachedCamera.inertialRadiusOffset = 0;
        // Animate to the radius limit
        this.stopAllAnimations();
        this._radiusIsAnimating = true;
        var animatable = Animation.TransitionTo("radius", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, function () { return _this._clearAnimationLocks(); });
        if (animatable) {
            this._animatables.push(animatable);
        }
    };
    /**
     * Removes all animation locks. Allows new animations to be added to any of the camera properties.
     */
    BouncingBehavior.prototype._clearAnimationLocks = function () {
        this._radiusIsAnimating = false;
        if (this._attachedCamera) {
            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;
        }
    };
    /**
     * Stops and removes all animations that have been applied to the camera
     */
    BouncingBehavior.prototype.stopAllAnimations = function () {
        if (this._attachedCamera) {
            this._attachedCamera.animations = [];
        }
        while (this._animatables.length) {
            this._animatables[0].onAnimationEnd = null;
            this._animatables[0].stop();
            this._animatables.shift();
        }
    };
    /**
     * The easing function used by animations
     */
    BouncingBehavior.EasingFunction = new BackEase(0.3);
    /**
     * The easing mode used by animations
     */
    BouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;
    return BouncingBehavior;
}());

/**
 * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.
 * @see http://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior
 */
var FramingBehavior = /** @class */ (function () {
    function FramingBehavior() {
        this._mode = FramingBehavior.FitFrustumSidesMode;
        this._radiusScale = 1.0;
        this._positionScale = 0.5;
        this._defaultElevation = 0.3;
        this._elevationReturnTime = 1500;
        this._elevationReturnWaitTime = 1000;
        this._zoomStopsAnimation = false;
        this._framingTime = 1500;
        /**
         * Define if the behavior should automatically change the configured
         * camera limits and sensibilities.
         */
        this.autoCorrectCameraLimitsAndSensibility = true;
        this._isPointerDown = false;
        this._lastInteractionTime = -Infinity;
        // Framing control
        this._animatables = new Array();
        this._betaIsAnimating = false;
    }
    Object.defineProperty(FramingBehavior.prototype, "name", {
        /**
         * Gets the name of the behavior.
         */
        get: function () {
            return "Framing";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FramingBehavior.prototype, "mode", {
        /**
         * Gets current mode used by the behavior.
         */
        get: function () {
            return this._mode;
        },
        /**
         * Sets the current mode used by the behavior
         */
        set: function (mode) {
            this._mode = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FramingBehavior.prototype, "radiusScale", {
        /**
         * Gets the scale applied to the radius
         */
        get: function () {
            return this._radiusScale;
        },
        /**
         * Sets the scale applied to the radius (1 by default)
         */
        set: function (radius) {
            this._radiusScale = radius;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FramingBehavior.prototype, "positionScale", {
        /**
         * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
         */
        get: function () {
            return this._positionScale;
        },
        /**
         * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
         */
        set: function (scale) {
            this._positionScale = scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FramingBehavior.prototype, "defaultElevation", {
        /**
        * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
        * behaviour is triggered, in radians.
        */
        get: function () {
            return this._defaultElevation;
        },
        /**
        * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
        * behaviour is triggered, in radians.
        */
        set: function (elevation) {
            this._defaultElevation = elevation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FramingBehavior.prototype, "elevationReturnTime", {
        /**
         * Gets the time (in milliseconds) taken to return to the default beta position.
         * Negative value indicates camera should not return to default.
         */
        get: function () {
            return this._elevationReturnTime;
        },
        /**
         * Sets the time (in milliseconds) taken to return to the default beta position.
         * Negative value indicates camera should not return to default.
         */
        set: function (speed) {
            this._elevationReturnTime = speed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FramingBehavior.prototype, "elevationReturnWaitTime", {
        /**
         * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
         */
        get: function () {
            return this._elevationReturnWaitTime;
        },
        /**
         * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
         */
        set: function (time) {
            this._elevationReturnWaitTime = time;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FramingBehavior.prototype, "zoomStopsAnimation", {
        /**
        * Gets the flag that indicates if user zooming should stop animation.
        */
        get: function () {
            return this._zoomStopsAnimation;
        },
        /**
        * Sets the flag that indicates if user zooming should stop animation.
        */
        set: function (flag) {
            this._zoomStopsAnimation = flag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FramingBehavior.prototype, "framingTime", {
        /**
         * Gets the transition time when framing the mesh, in milliseconds
        */
        get: function () {
            return this._framingTime;
        },
        /**
         * Sets the transition time when framing the mesh, in milliseconds
        */
        set: function (time) {
            this._framingTime = time;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initializes the behavior.
     */
    FramingBehavior.prototype.init = function () {
        // Do notihng
    };
    /**
     * Attaches the behavior to its arc rotate camera.
     * @param camera Defines the camera to attach the behavior to
     */
    FramingBehavior.prototype.attach = function (camera) {
        var _this = this;
        this._attachedCamera = camera;
        var scene = this._attachedCamera.getScene();
        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);
        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function (pointerInfoPre) {
            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
                _this._isPointerDown = true;
                return;
            }
            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
                _this._isPointerDown = false;
            }
        });
        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {
            if (mesh) {
                _this.zoomOnMesh(mesh);
            }
        });
        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {
            // Stop the animation if there is user interaction and the animation should stop for this interaction
            _this._applyUserInteraction();
            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it
            // back to the default position after a given timeout
            _this._maintainCameraAboveGround();
        });
    };
    /**
     * Detaches the behavior from its current arc rotate camera.
     */
    FramingBehavior.prototype.detach = function () {
        if (!this._attachedCamera) {
            return;
        }
        var scene = this._attachedCamera.getScene();
        if (this._onPrePointerObservableObserver) {
            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
        }
        if (this._onAfterCheckInputsObserver) {
            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
        }
        if (this._onMeshTargetChangedObserver) {
            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
        }
        this._attachedCamera = null;
    };
    /**
     * Targets the given mesh and updates zoom level accordingly.
     * @param mesh  The mesh to target.
     * @param radius Optional. If a cached radius position already exists, overrides default.
     * @param framingPositionY Position on mesh to center camera focus where 0 corresponds bottom of its bounding box and 1, the top
     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
     * @param onAnimationEnd Callback triggered at the end of the framing animation
     */
    FramingBehavior.prototype.zoomOnMesh = function (mesh, focusOnOriginXZ, onAnimationEnd) {
        if (focusOnOriginXZ === void 0) { focusOnOriginXZ = false; }
        if (onAnimationEnd === void 0) { onAnimationEnd = null; }
        mesh.computeWorldMatrix(true);
        var boundingBox = mesh.getBoundingInfo().boundingBox;
        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);
    };
    /**
     * Targets the given mesh with its children and updates zoom level accordingly.
     * @param mesh  The mesh to target.
     * @param radius Optional. If a cached radius position already exists, overrides default.
     * @param framingPositionY Position on mesh to center camera focus where 0 corresponds bottom of its bounding box and 1, the top
     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
     * @param onAnimationEnd Callback triggered at the end of the framing animation
     */
    FramingBehavior.prototype.zoomOnMeshHierarchy = function (mesh, focusOnOriginXZ, onAnimationEnd) {
        if (focusOnOriginXZ === void 0) { focusOnOriginXZ = false; }
        if (onAnimationEnd === void 0) { onAnimationEnd = null; }
        mesh.computeWorldMatrix(true);
        var boundingBox = mesh.getHierarchyBoundingVectors(true);
        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);
    };
    /**
     * Targets the given meshes with their children and updates zoom level accordingly.
     * @param meshes  The mesh to target.
     * @param radius Optional. If a cached radius position already exists, overrides default.
     * @param framingPositionY Position on mesh to center camera focus where 0 corresponds bottom of its bounding box and 1, the top
     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
     * @param onAnimationEnd Callback triggered at the end of the framing animation
     */
    FramingBehavior.prototype.zoomOnMeshesHierarchy = function (meshes, focusOnOriginXZ, onAnimationEnd) {
        if (focusOnOriginXZ === void 0) { focusOnOriginXZ = false; }
        if (onAnimationEnd === void 0) { onAnimationEnd = null; }
        var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (var i = 0; i < meshes.length; i++) {
            var boundingInfo = meshes[i].getHierarchyBoundingVectors(true);
            Tools.CheckExtends(boundingInfo.min, min, max);
            Tools.CheckExtends(boundingInfo.max, min, max);
        }
        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);
    };
    /**
     * Targets the bounding box info defined by its extends and updates zoom level accordingly.
     * @param minimumWorld Determines the smaller position of the bounding box extend
     * @param maximumWorld Determines the bigger position of the bounding box extend
     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
     * @param onAnimationEnd Callback triggered at the end of the framing animation
     */
    FramingBehavior.prototype.zoomOnBoundingInfo = function (minimumWorld, maximumWorld, focusOnOriginXZ, onAnimationEnd) {
        var _this = this;
        if (focusOnOriginXZ === void 0) { focusOnOriginXZ = false; }
        if (onAnimationEnd === void 0) { onAnimationEnd = null; }
        var zoomTarget;
        if (!this._attachedCamera) {
            return;
        }
        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY
        var bottom = minimumWorld.y;
        var top = maximumWorld.y;
        var zoomTargetY = bottom + (top - bottom) * this._positionScale;
        var radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);
        if (focusOnOriginXZ) {
            zoomTarget = new Vector3(0, zoomTargetY, 0);
        }
        else {
            var centerWorld = minimumWorld.add(radiusWorld);
            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);
        }
        if (!this._vectorTransition) {
            this._vectorTransition = Animation.CreateAnimation("target", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);
        }
        this._betaIsAnimating = true;
        var animatable = Animation.TransitionTo("target", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);
        if (animatable) {
            this._animatables.push(animatable);
        }
        // sets the radius and lower radius bounds
        // Small delta ensures camera is not always at lower zoom limit.
        var radius = 0;
        if (this._mode === FramingBehavior.FitFrustumSidesMode) {
            var position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
            if (this.autoCorrectCameraLimitsAndSensibility) {
                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;
            }
            radius = position;
        }
        else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {
            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {
                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;
            }
        }
        // Set sensibilities
        if (this.autoCorrectCameraLimitsAndSensibility) {
            var extend = maximumWorld.subtract(minimumWorld).length();
            this._attachedCamera.panningSensibility = 5000 / extend;
            this._attachedCamera.wheelPrecision = 100 / radius;
        }
        // transition to new radius
        if (!this._radiusTransition) {
            this._radiusTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);
        }
        animatable = Animation.TransitionTo("radius", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, function () {
            _this.stopAllAnimations();
            if (onAnimationEnd) {
                onAnimationEnd();
            }
            if (_this._attachedCamera && _this._attachedCamera.useInputToRestoreState) {
                _this._attachedCamera.storeState();
            }
        });
        if (animatable) {
            this._animatables.push(animatable);
        }
    };
    /**
     * Calculates the lowest radius for the camera based on the bounding box of the mesh.
     * @param mesh The mesh on which to base the calculation. mesh boundingInfo used to estimate necessary
     *			  frustum width.
     * @return The minimum distance from the primary mesh's center point at which the camera must be kept in order
     *		 to fully enclose the mesh in the viewing frustum.
     */
    FramingBehavior.prototype._calculateLowerRadiusFromModelBoundingSphere = function (minimumWorld, maximumWorld) {
        var size = maximumWorld.subtract(minimumWorld);
        var boxVectorGlobalDiagonal = size.length();
        var frustumSlope = this._getFrustumSlope();
        // Formula for setting distance
        // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)
        var radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;
        // Horizon distance
        var radius = radiusWithoutFraming * this._radiusScale;
        var distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));
        var distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));
        var distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);
        var camera = this._attachedCamera;
        if (!camera) {
            return 0;
        }
        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {
            // Don't exceed the requested limit
            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;
        }
        // Don't exceed the upper radius limit
        if (camera.upperRadiusLimit) {
            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;
        }
        return distance;
    };
    /**
     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera
     * is automatically returned to its default position (expected to be above ground plane).
     */
    FramingBehavior.prototype._maintainCameraAboveGround = function () {
        var _this = this;
        if (this._elevationReturnTime < 0) {
            return;
        }
        var timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;
        var defaultBeta = Math.PI * 0.5 - this._defaultElevation;
        var limitBeta = Math.PI * 0.5;
        // Bring the camera back up if below the ground plane
        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {
            this._betaIsAnimating = true;
            //Transition to new position
            this.stopAllAnimations();
            if (!this._betaTransition) {
                this._betaTransition = Animation.CreateAnimation("beta", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);
            }
            var animatabe = Animation.TransitionTo("beta", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, function () {
                _this._clearAnimationLocks();
                _this.stopAllAnimations();
            });
            if (animatabe) {
                this._animatables.push(animatabe);
            }
        }
    };
    /**
     * Returns the frustum slope based on the canvas ratio and camera FOV
     * @returns The frustum slope represented as a Vector2 with X and Y slopes
     */
    FramingBehavior.prototype._getFrustumSlope = function () {
        // Calculate the viewport ratio
        // Aspect Ratio is Height/Width.
        var camera = this._attachedCamera;
        if (!camera) {
            return Vector2.Zero();
        }
        var engine = camera.getScene().getEngine();
        var aspectRatio = engine.getAspectRatio(camera);
        // Camera FOV is the vertical field of view (top-bottom) in radians.
        // Slope of the frustum top/bottom planes in view space, relative to the forward vector.
        var frustumSlopeY = Math.tan(camera.fov / 2);
        // Slope of the frustum left/right planes in view space, relative to the forward vector.
        // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit
        // along the forward vector.
        var frustumSlopeX = frustumSlopeY * aspectRatio;
        return new Vector2(frustumSlopeX, frustumSlopeY);
    };
    /**
     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.
     */
    FramingBehavior.prototype._clearAnimationLocks = function () {
        this._betaIsAnimating = false;
    };
    /**
     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
     */
    FramingBehavior.prototype._applyUserInteraction = function () {
        if (this.isUserIsMoving) {
            this._lastInteractionTime = PrecisionDate.Now;
            this.stopAllAnimations();
            this._clearAnimationLocks();
        }
    };
    /**
     * Stops and removes all animations that have been applied to the camera
     */
    FramingBehavior.prototype.stopAllAnimations = function () {
        if (this._attachedCamera) {
            this._attachedCamera.animations = [];
        }
        while (this._animatables.length) {
            if (this._animatables[0]) {
                this._animatables[0].onAnimationEnd = null;
                this._animatables[0].stop();
            }
            this._animatables.shift();
        }
    };
    Object.defineProperty(FramingBehavior.prototype, "isUserIsMoving", {
        /**
         * Gets a value indicating if the user is moving the camera
         */
        get: function () {
            if (!this._attachedCamera) {
                return false;
            }
            return this._attachedCamera.inertialAlphaOffset !== 0 ||
                this._attachedCamera.inertialBetaOffset !== 0 ||
                this._attachedCamera.inertialRadiusOffset !== 0 ||
                this._attachedCamera.inertialPanningX !== 0 ||
                this._attachedCamera.inertialPanningY !== 0 ||
                this._isPointerDown;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * The easing function used by animations
     */
    FramingBehavior.EasingFunction = new ExponentialEase();
    /**
     * The easing mode used by animations
     */
    FramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;
    // Statics
    /**
     * The camera can move all the way towards the mesh.
     */
    FramingBehavior.IgnoreBoundsSizeMode = 0;
    /**
     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides
     */
    FramingBehavior.FitFrustumSidesMode = 1;
    return FramingBehavior;
}());

/**
 * @hidden
 */
var FaceDirectionInfo = /** @class */ (function () {
    function FaceDirectionInfo(direction, rotatedDirection, diff, ignore) {
        if (rotatedDirection === void 0) { rotatedDirection = new Vector3(); }
        if (diff === void 0) { diff = 0; }
        if (ignore === void 0) { ignore = false; }
        this.direction = direction;
        this.rotatedDirection = rotatedDirection;
        this.diff = diff;
        this.ignore = ignore;
    }
    return FaceDirectionInfo;
}());
/**
 * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera
 */
var AttachToBoxBehavior = /** @class */ (function () {
    /**
     * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera
     * @param ui The transform node that should be attched to the mesh
     */
    function AttachToBoxBehavior(ui) {
        this.ui = ui;
        /**
         *  The name of the behavior
         */
        this.name = "AttachToBoxBehavior";
        /**
         * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)
         */
        this.distanceAwayFromFace = 0.15;
        /**
         * The distance from the bottom of the face that the UI should be attached to (default: 0.15)
         */
        this.distanceAwayFromBottomOfFace = 0.15;
        this._faceVectors = [new FaceDirectionInfo(Vector3.Up()), new FaceDirectionInfo(Vector3.Down()), new FaceDirectionInfo(Vector3.Left()), new FaceDirectionInfo(Vector3.Right()), new FaceDirectionInfo(Vector3.Forward()), new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))];
        this._tmpMatrix = new Matrix();
        this._tmpVector = new Vector3();
        this._zeroVector = Vector3.Zero();
        this._lookAtTmpMatrix = new Matrix();
        /* Does nothing */
    }
    /**
     *  Initializes the behavior
     */
    AttachToBoxBehavior.prototype.init = function () {
        /* Does nothing */
    };
    AttachToBoxBehavior.prototype._closestFace = function (targetDirection) {
        var _this = this;
        // Go over each face and calculate the angle between the face's normal and targetDirection
        this._faceVectors.forEach(function (v) {
            if (!_this._target.rotationQuaternion) {
                _this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._target.rotation.y, _this._target.rotation.x, _this._target.rotation.z);
            }
            _this._target.rotationQuaternion.toRotationMatrix(_this._tmpMatrix);
            Vector3.TransformCoordinatesToRef(v.direction, _this._tmpMatrix, v.rotatedDirection);
            v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));
        });
        // Return the face information of the one with the normal closeset to target direction
        return this._faceVectors.reduce(function (min, p) {
            if (min.ignore) {
                return p;
            }
            else if (p.ignore) {
                return min;
            }
            else {
                return min.diff < p.diff ? min : p;
            }
        }, this._faceVectors[0]);
    };
    AttachToBoxBehavior.prototype._lookAtToRef = function (pos, up, ref) {
        if (up === void 0) { up = new Vector3(0, 1, 0); }
        Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);
        this._lookAtTmpMatrix.invert();
        Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);
    };
    /**
     * Attaches the AttachToBoxBehavior to the passed in mesh
     * @param target The mesh that the specified node will be attached to
     */
    AttachToBoxBehavior.prototype.attach = function (target) {
        var _this = this;
        this._target = target;
        this._scene = this._target.getScene();
        // Every frame, update the app bars position
        this._onRenderObserver = this._scene.onBeforeRenderObservable.add(function () {
            if (!_this._scene.activeCamera) {
                return;
            }
            // Find the face closest to the cameras position
            var cameraPos = _this._scene.activeCamera.position;
            if (_this._scene.activeCamera.devicePosition) {
                cameraPos = _this._scene.activeCamera.devicePosition;
            }
            var facing = _this._closestFace(cameraPos.subtract(target.position));
            if (_this._scene.activeCamera.leftCamera) {
                _this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);
            }
            else {
                _this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);
            }
            // Get camera up direction
            Vector3.TransformCoordinatesToRef(Vector3.Up(), _this._tmpMatrix, _this._tmpVector);
            // Ignore faces to not select a parrelel face for the up vector of the UI
            _this._faceVectors.forEach(function (v) {
                if (facing.direction.x && v.direction.x) {
                    v.ignore = true;
                }
                if (facing.direction.y && v.direction.y) {
                    v.ignore = true;
                }
                if (facing.direction.z && v.direction.z) {
                    v.ignore = true;
                }
            });
            var facingUp = _this._closestFace(_this._tmpVector);
            // Unignore faces
            _this._faceVectors.forEach(function (v) {
                v.ignore = false;
            });
            // Position the app bar on that face
            _this.ui.position.copyFrom(target.position);
            if (facing.direction.x) {
                facing.rotatedDirection.scaleToRef((target.scaling.x / 2) + _this.distanceAwayFromFace, _this._tmpVector);
                _this.ui.position.addInPlace(_this._tmpVector);
            }
            if (facing.direction.y) {
                facing.rotatedDirection.scaleToRef((target.scaling.y / 2) + _this.distanceAwayFromFace, _this._tmpVector);
                _this.ui.position.addInPlace(_this._tmpVector);
            }
            if (facing.direction.z) {
                facing.rotatedDirection.scaleToRef((target.scaling.z / 2) + _this.distanceAwayFromFace, _this._tmpVector);
                _this.ui.position.addInPlace(_this._tmpVector);
            }
            // Rotate to be oriented properly to the camera
            if (!_this.ui.rotationQuaternion) {
                _this.ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.ui.rotation.y, _this.ui.rotation.x, _this.ui.rotation.z);
            }
            facing.rotatedDirection.scaleToRef(-1, _this._tmpVector);
            _this._lookAtToRef(_this._tmpVector, facingUp.rotatedDirection, _this.ui.rotationQuaternion);
            // Place ui the correct distance from the bottom of the mesh
            if (facingUp.direction.x) {
                _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.x / 2, _this._tmpVector);
            }
            if (facingUp.direction.y) {
                _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.y / 2, _this._tmpVector);
            }
            if (facingUp.direction.z) {
                _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.z / 2, _this._tmpVector);
            }
            _this.ui.position.addInPlace(_this._tmpVector);
        });
    };
    /**
     *  Detaches the behavior from the mesh
     */
    AttachToBoxBehavior.prototype.detach = function () {
        this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);
    };
    return AttachToBoxBehavior;
}());

/**
 * Class representing a ray with position and direction
 */
var Ray = /** @class */ (function () {
    /**
     * Creates a new ray
     * @param origin origin point
     * @param direction direction
     * @param length length of the ray
     */
    function Ray(
    /** origin point */
    origin, 
    /** direction */
    direction, 
    /** length of the ray */
    length) {
        if (length === void 0) { length = Number.MAX_VALUE; }
        this.origin = origin;
        this.direction = direction;
        this.length = length;
    }
    // Methods
    /**
     * Checks if the ray intersects a box
     * @param minimum bound of the box
     * @param maximum bound of the box
     * @param intersectionTreshold extra extend to be added to the box in all direction
     * @returns if the box was hit
     */
    Ray.prototype.intersectsBoxMinMax = function (minimum, maximum, intersectionTreshold) {
        if (intersectionTreshold === void 0) { intersectionTreshold = 0; }
        var newMinimum = Ray.TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
        var newMaximum = Ray.TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
        var d = 0.0;
        var maxValue = Number.MAX_VALUE;
        var inv;
        var min;
        var max;
        var temp;
        if (Math.abs(this.direction.x) < 0.0000001) {
            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
                return false;
            }
        }
        else {
            inv = 1.0 / this.direction.x;
            min = (newMinimum.x - this.origin.x) * inv;
            max = (newMaximum.x - this.origin.x) * inv;
            if (max === -Infinity) {
                max = Infinity;
            }
            if (min > max) {
                temp = min;
                min = max;
                max = temp;
            }
            d = Math.max(min, d);
            maxValue = Math.min(max, maxValue);
            if (d > maxValue) {
                return false;
            }
        }
        if (Math.abs(this.direction.y) < 0.0000001) {
            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
                return false;
            }
        }
        else {
            inv = 1.0 / this.direction.y;
            min = (newMinimum.y - this.origin.y) * inv;
            max = (newMaximum.y - this.origin.y) * inv;
            if (max === -Infinity) {
                max = Infinity;
            }
            if (min > max) {
                temp = min;
                min = max;
                max = temp;
            }
            d = Math.max(min, d);
            maxValue = Math.min(max, maxValue);
            if (d > maxValue) {
                return false;
            }
        }
        if (Math.abs(this.direction.z) < 0.0000001) {
            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
                return false;
            }
        }
        else {
            inv = 1.0 / this.direction.z;
            min = (newMinimum.z - this.origin.z) * inv;
            max = (newMaximum.z - this.origin.z) * inv;
            if (max === -Infinity) {
                max = Infinity;
            }
            if (min > max) {
                temp = min;
                min = max;
                max = temp;
            }
            d = Math.max(min, d);
            maxValue = Math.min(max, maxValue);
            if (d > maxValue) {
                return false;
            }
        }
        return true;
    };
    /**
     * Checks if the ray intersects a box
     * @param box the bounding box to check
     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction
     * @returns if the box was hit
     */
    Ray.prototype.intersectsBox = function (box, intersectionTreshold) {
        if (intersectionTreshold === void 0) { intersectionTreshold = 0; }
        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
    };
    /**
     * If the ray hits a sphere
     * @param sphere the bounding sphere to check
     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction
     * @returns true if it hits the sphere
     */
    Ray.prototype.intersectsSphere = function (sphere, intersectionTreshold) {
        if (intersectionTreshold === void 0) { intersectionTreshold = 0; }
        var x = sphere.center.x - this.origin.x;
        var y = sphere.center.y - this.origin.y;
        var z = sphere.center.z - this.origin.z;
        var pyth = (x * x) + (y * y) + (z * z);
        var radius = sphere.radius + intersectionTreshold;
        var rr = radius * radius;
        if (pyth <= rr) {
            return true;
        }
        var dot = (x * this.direction.x) + (y * this.direction.y) + (z * this.direction.z);
        if (dot < 0.0) {
            return false;
        }
        var temp = pyth - (dot * dot);
        return temp <= rr;
    };
    /**
     * If the ray hits a triange
     * @param vertex0 triangle vertex
     * @param vertex1 triangle vertex
     * @param vertex2 triangle vertex
     * @returns intersection information if hit
     */
    Ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {
        var edge1 = Ray.TmpVector3[0];
        var edge2 = Ray.TmpVector3[1];
        var pvec = Ray.TmpVector3[2];
        var tvec = Ray.TmpVector3[3];
        var qvec = Ray.TmpVector3[4];
        vertex1.subtractToRef(vertex0, edge1);
        vertex2.subtractToRef(vertex0, edge2);
        Vector3.CrossToRef(this.direction, edge2, pvec);
        var det = Vector3.Dot(edge1, pvec);
        if (det === 0) {
            return null;
        }
        var invdet = 1 / det;
        this.origin.subtractToRef(vertex0, tvec);
        var bu = Vector3.Dot(tvec, pvec) * invdet;
        if (bu < 0 || bu > 1.0) {
            return null;
        }
        Vector3.CrossToRef(tvec, edge1, qvec);
        var bv = Vector3.Dot(this.direction, qvec) * invdet;
        if (bv < 0 || bu + bv > 1.0) {
            return null;
        }
        //check if the distance is longer than the predefined length.
        var distance = Vector3.Dot(edge2, qvec) * invdet;
        if (distance > this.length) {
            return null;
        }
        return new IntersectionInfo(bu, bv, distance);
    };
    /**
     * Checks if ray intersects a plane
     * @param plane the plane to check
     * @returns the distance away it was hit
     */
    Ray.prototype.intersectsPlane = function (plane) {
        var distance;
        var result1 = Vector3.Dot(plane.normal, this.direction);
        if (Math.abs(result1) < 9.99999997475243E-07) {
            return null;
        }
        else {
            var result2 = Vector3.Dot(plane.normal, this.origin);
            distance = (-plane.d - result2) / result1;
            if (distance < 0.0) {
                if (distance < -9.99999997475243E-07) {
                    return null;
                }
                else {
                    return 0;
                }
            }
            return distance;
        }
    };
    /**
     * Checks if ray intersects a mesh
     * @param mesh the mesh to check
     * @param fastCheck if only the bounding box should checked
     * @returns picking info of the intersecton
     */
    Ray.prototype.intersectsMesh = function (mesh, fastCheck) {
        var tm = Tmp.Matrix[0];
        mesh.getWorldMatrix().invertToRef(tm);
        if (this._tmpRay) {
            Ray.TransformToRef(this, tm, this._tmpRay);
        }
        else {
            this._tmpRay = Ray.Transform(this, tm);
        }
        return mesh.intersects(this._tmpRay, fastCheck);
    };
    /**
     * Checks if ray intersects a mesh
     * @param meshes the meshes to check
     * @param fastCheck if only the bounding box should checked
     * @param results array to store result in
     * @returns Array of picking infos
     */
    Ray.prototype.intersectsMeshes = function (meshes, fastCheck, results) {
        if (results) {
            results.length = 0;
        }
        else {
            results = [];
        }
        for (var i = 0; i < meshes.length; i++) {
            var pickInfo = this.intersectsMesh(meshes[i], fastCheck);
            if (pickInfo.hit) {
                results.push(pickInfo);
            }
        }
        results.sort(this._comparePickingInfo);
        return results;
    };
    Ray.prototype._comparePickingInfo = function (pickingInfoA, pickingInfoB) {
        if (pickingInfoA.distance < pickingInfoB.distance) {
            return -1;
        }
        else if (pickingInfoA.distance > pickingInfoB.distance) {
            return 1;
        }
        else {
            return 0;
        }
    };
    /**
     * Intersection test between the ray and a given segment whithin a given tolerance (threshold)
     * @param sega the first point of the segment to test the intersection against
     * @param segb the second point of the segment to test the intersection against
     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
     * @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
     */
    Ray.prototype.intersectionSegment = function (sega, segb, threshold) {
        var o = this.origin;
        var u = Tmp.Vector3[0];
        var rsegb = Tmp.Vector3[1];
        var v = Tmp.Vector3[2];
        var w = Tmp.Vector3[3];
        segb.subtractToRef(sega, u);
        this.direction.scaleToRef(Ray.rayl, v);
        o.addToRef(v, rsegb);
        sega.subtractToRef(o, w);
        var a = Vector3.Dot(u, u); // always >= 0
        var b = Vector3.Dot(u, v);
        var c = Vector3.Dot(v, v); // always >= 0
        var d = Vector3.Dot(u, w);
        var e = Vector3.Dot(v, w);
        var D = a * c - b * b; // always >= 0
        var sc, sN, sD = D; // sc = sN / sD, default sD = D >= 0
        var tc, tN, tD = D; // tc = tN / tD, default tD = D >= 0
        // compute the line parameters of the two closest points
        if (D < Ray.smallnum) { // the lines are almost parallel
            sN = 0.0; // force using point P0 on segment S1
            sD = 1.0; // to prevent possible division by 0.0 later
            tN = e;
            tD = c;
        }
        else { // get the closest points on the infinite lines
            sN = (b * e - c * d);
            tN = (a * e - b * d);
            if (sN < 0.0) { // sc < 0 => the s=0 edge is visible
                sN = 0.0;
                tN = e;
                tD = c;
            }
            else if (sN > sD) { // sc > 1 => the s=1 edge is visible
                sN = sD;
                tN = e + b;
                tD = c;
            }
        }
        if (tN < 0.0) { // tc < 0 => the t=0 edge is visible
            tN = 0.0;
            // recompute sc for this edge
            if (-d < 0.0) {
                sN = 0.0;
            }
            else if (-d > a) {
                sN = sD;
            }
            else {
                sN = -d;
                sD = a;
            }
        }
        else if (tN > tD) { // tc > 1 => the t=1 edge is visible
            tN = tD;
            // recompute sc for this edge
            if ((-d + b) < 0.0) {
                sN = 0;
            }
            else if ((-d + b) > a) {
                sN = sD;
            }
            else {
                sN = (-d + b);
                sD = a;
            }
        }
        // finally do the division to get sc and tc
        sc = (Math.abs(sN) < Ray.smallnum ? 0.0 : sN / sD);
        tc = (Math.abs(tN) < Ray.smallnum ? 0.0 : tN / tD);
        // get the difference of the two closest points
        var qtc = Tmp.Vector3[4];
        v.scaleToRef(tc, qtc);
        var qsc = Tmp.Vector3[5];
        u.scaleToRef(sc, qsc);
        qsc.addInPlace(w);
        var dP = Tmp.Vector3[6];
        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)
        var isIntersected = (tc > 0) && (tc <= this.length) && (dP.lengthSquared() < (threshold * threshold)); // return intersection result
        if (isIntersected) {
            return qsc.length();
        }
        return -1;
    };
    /**
     * Update the ray from viewport position
     * @param x position
     * @param y y position
     * @param viewportWidth viewport width
     * @param viewportHeight viewport height
     * @param world world matrix
     * @param view view matrix
     * @param projection projection matrix
     * @returns this ray updated
     */
    Ray.prototype.update = function (x, y, viewportWidth, viewportHeight, world, view, projection) {
        this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
        return this;
    };
    // Statics
    /**
     * Creates a ray with origin and direction of 0,0,0
     * @returns the new ray
     */
    Ray.Zero = function () {
        return new Ray(Vector3.Zero(), Vector3.Zero());
    };
    /**
     * Creates a new ray from screen space and viewport
     * @param x position
     * @param y y position
     * @param viewportWidth viewport width
     * @param viewportHeight viewport height
     * @param world world matrix
     * @param view view matrix
     * @param projection projection matrix
     * @returns new ray
     */
    Ray.CreateNew = function (x, y, viewportWidth, viewportHeight, world, view, projection) {
        var result = Ray.Zero();
        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
    };
    /**
    * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
    * transformed to the given world matrix.
    * @param origin The origin point
    * @param end The end point
    * @param world a matrix to transform the ray to. Default is the identity matrix.
    * @returns the new ray
    */
    Ray.CreateNewFromTo = function (origin, end, world) {
        if (world === void 0) { world = Matrix.IdentityReadOnly; }
        var direction = end.subtract(origin);
        var length = Math.sqrt((direction.x * direction.x) + (direction.y * direction.y) + (direction.z * direction.z));
        direction.normalize();
        return Ray.Transform(new Ray(origin, direction, length), world);
    };
    /**
     * Transforms a ray by a matrix
     * @param ray ray to transform
     * @param matrix matrix to apply
     * @returns the resulting new ray
     */
    Ray.Transform = function (ray, matrix) {
        var result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
        Ray.TransformToRef(ray, matrix, result);
        return result;
    };
    /**
     * Transforms a ray by a matrix
     * @param ray ray to transform
     * @param matrix matrix to apply
     * @param result ray to store result in
     */
    Ray.TransformToRef = function (ray, matrix, result) {
        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
        result.length = ray.length;
        var dir = result.direction;
        var len = dir.length();
        if (!(len === 0 || len === 1)) {
            var num = 1.0 / len;
            dir.x *= num;
            dir.y *= num;
            dir.z *= num;
            result.length *= len;
        }
    };
    /**
      * Unproject a ray from screen space to object space
      * @param sourceX defines the screen space x coordinate to use
      * @param sourceY defines the screen space y coordinate to use
      * @param viewportWidth defines the current width of the viewport
      * @param viewportHeight defines the current height of the viewport
      * @param world defines the world matrix to use (can be set to Identity to go to world space)
      * @param view defines the view matrix to use
      * @param projection defines the projection matrix to use
      */
    Ray.prototype.unprojectRayToRef = function (sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
        var matrix = Tmp.Matrix[0];
        world.multiplyToRef(view, matrix);
        matrix.multiplyToRef(projection, matrix);
        matrix.invert();
        var nearScreenSource = Tmp.Vector3[0];
        nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
        nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
        nearScreenSource.z = -1.0;
        var farScreenSource = Tmp.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0);
        var nearVec3 = Tmp.Vector3[2];
        var farVec3 = Tmp.Vector3[3];
        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);
        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);
        this.origin.copyFrom(nearVec3);
        farVec3.subtractToRef(nearVec3, this.direction);
        this.direction.normalize();
    };
    Ray.TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);
    Ray.smallnum = 0.00000001;
    Ray.rayl = 10e8;
    return Ray;
}());
Scene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace) {
    if (cameraViewSpace === void 0) { cameraViewSpace = false; }
    var result = Ray.Zero();
    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);
    return result;
};
Scene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace) {
    if (cameraViewSpace === void 0) { cameraViewSpace = false; }
    var engine = this.getEngine();
    if (!camera) {
        if (!this.activeCamera) {
            throw new Error("Active camera not set");
        }
        camera = this.activeCamera;
    }
    var cameraViewport = camera.viewport;
    var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
    // Moving coordinates to local viewport world
    x = x / engine.getHardwareScalingLevel() - viewport.x;
    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
    result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix());
    return this;
};
Scene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {
    var result = Ray.Zero();
    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);
    return result;
};
Scene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {
    if (!PickingInfo) {
        return this;
    }
    var engine = this.getEngine();
    if (!camera) {
        if (!this.activeCamera) {
            throw new Error("Active camera not set");
        }
        camera = this.activeCamera;
    }
    var cameraViewport = camera.viewport;
    var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
    var identity = Matrix.Identity();
    // Moving coordinates to local viewport world
    x = x / engine.getHardwareScalingLevel() - viewport.x;
    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
    result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());
    return this;
};
Scene.prototype._internalPick = function (rayFunction, predicate, fastCheck, trianglePredicate) {
    if (!PickingInfo) {
        return null;
    }
    var pickingInfo = null;
    for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
        var mesh = this.meshes[meshIndex];
        if (predicate) {
            if (!predicate(mesh)) {
                continue;
            }
        }
        else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
            continue;
        }
        var world = mesh.getWorldMatrix();
        var ray = rayFunction(world);
        var result = mesh.intersects(ray, fastCheck, trianglePredicate);
        if (!result || !result.hit) {
            continue;
        }
        if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
            continue;
        }
        pickingInfo = result;
        if (fastCheck) {
            break;
        }
    }
    return pickingInfo || new PickingInfo();
};
Scene.prototype._internalMultiPick = function (rayFunction, predicate, trianglePredicate) {
    if (!PickingInfo) {
        return null;
    }
    var pickingInfos = new Array();
    for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
        var mesh = this.meshes[meshIndex];
        if (predicate) {
            if (!predicate(mesh)) {
                continue;
            }
        }
        else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
            continue;
        }
        var world = mesh.getWorldMatrix();
        var ray = rayFunction(world);
        var result = mesh.intersects(ray, false, trianglePredicate);
        if (!result || !result.hit) {
            continue;
        }
        pickingInfos.push(result);
    }
    return pickingInfos;
};
Scene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate) {
    var _this = this;
    if (!PickingInfo) {
        return null;
    }
    var result = this._internalPick(function (world) {
        if (!_this._tempPickingRay) {
            _this._tempPickingRay = Ray.Zero();
        }
        _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null);
        return _this._tempPickingRay;
    }, predicate, fastCheck, trianglePredicate);
    if (result) {
        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
    }
    return result;
};
Scene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {
    var _this = this;
    var result = this._internalPick(function (world) {
        if (!_this._pickWithRayInverseMatrix) {
            _this._pickWithRayInverseMatrix = Matrix.Identity();
        }
        world.invertToRef(_this._pickWithRayInverseMatrix);
        if (!_this._cachedRayForTransform) {
            _this._cachedRayForTransform = Ray.Zero();
        }
        Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);
        return _this._cachedRayForTransform;
    }, predicate, fastCheck, trianglePredicate);
    if (result) {
        result.ray = ray;
    }
    return result;
};
Scene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {
    var _this = this;
    return this._internalMultiPick(function (world) { return _this.createPickingRay(x, y, world, camera || null); }, predicate, trianglePredicate);
};
Scene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {
    var _this = this;
    return this._internalMultiPick(function (world) {
        if (!_this._pickWithRayInverseMatrix) {
            _this._pickWithRayInverseMatrix = Matrix.Identity();
        }
        world.invertToRef(_this._pickWithRayInverseMatrix);
        if (!_this._cachedRayForTransform) {
            _this._cachedRayForTransform = Ray.Zero();
        }
        Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);
        return _this._cachedRayForTransform;
    }, predicate, trianglePredicate);
};
Camera.prototype.getForwardRay = function (length, transform, origin) {
    if (length === void 0) { length = 100; }
    if (!transform) {
        transform = this.getWorldMatrix();
    }
    if (!origin) {
        origin = this.position;
    }
    var forward = this._scene.useRightHandedSystem ? new Vector3(0, 0, -1) : new Vector3(0, 0, 1);
    var forwardWorld = Vector3.TransformNormal(forward, transform);
    var direction = Vector3.Normalize(forwardWorld);
    return new Ray(origin, direction, length);
};

/**
 * Class containing a set of static utilities functions for managing Pivots
 * @hidden
 */
var PivotTools = /** @class */ (function () {
    function PivotTools() {
    }
    /** @hidden */
    PivotTools._RemoveAndStorePivotPoint = function (mesh) {
        if (mesh && PivotTools._PivotCached === 0) {
            // Save old pivot and set pivot to 0,0,0
            mesh.getPivotPointToRef(PivotTools._OldPivotPoint);
            if (!PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {
                mesh.setPivotMatrix(Matrix.IdentityReadOnly);
                PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), PivotTools._PivotTranslation);
                PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
                PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
                PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);
                mesh.position.addInPlace(PivotTools._PivotTmpVector);
            }
        }
        PivotTools._PivotCached++;
    };
    /** @hidden */
    PivotTools._RestorePivotPoint = function (mesh) {
        if (mesh && !PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && PivotTools._PivotCached === 1) {
            mesh.setPivotPoint(PivotTools._OldPivotPoint);
            PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
            PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
            PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);
            mesh.position.subtractInPlace(PivotTools._PivotTmpVector);
        }
        this._PivotCached--;
    };
    // Stores the state of the pivot cache (_oldPivotPoint, _pivotTranslation)
    // store/remove pivot point should only be applied during their outermost calls
    PivotTools._PivotCached = 0;
    PivotTools._OldPivotPoint = new Vector3();
    PivotTools._PivotTranslation = new Vector3();
    PivotTools._PivotTmpVector = new Vector3();
    return PivotTools;
}());

/**
 * A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events
 */
var PointerDragBehavior = /** @class */ (function () {
    /**
     * Creates a pointer drag behavior that can be attached to a mesh
     * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)
     */
    function PointerDragBehavior(options) {
        this._useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;
        /**
         * The maximum tolerated angle between the drag plane and dragging pointer rays to trigger pointer events. Set to 0 to allow any angle (default: 0)
         */
        this.maxDragAngle = 0;
        /**
         * @hidden
         */
        this._useAlternatePickedPointAboveMaxDragAngle = false;
        /**
         * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
         */
        this.currentDraggingPointerID = -1;
        /**
         * If the behavior is currently in a dragging state
         */
        this.dragging = false;
        /**
         * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)
         */
        this.dragDeltaRatio = 0.2;
        /**
         * If the drag plane orientation should be updated during the dragging (Default: true)
         */
        this.updateDragPlane = true;
        // Debug mode will display drag planes to help visualize behavior
        this._debugMode = false;
        this._moving = false;
        /**
         *  Fires each time the attached mesh is dragged with the pointer
         *  * delta between last drag position and current drag position in world space
         *  * dragDistance along the drag axis
         *  * dragPlaneNormal normal of the current drag plane used during the drag
         *  * dragPlanePoint in world space where the drag intersects the drag plane
         */
        this.onDragObservable = new Observable();
        /**
         *  Fires each time a drag begins (eg. mouse down on mesh)
         */
        this.onDragStartObservable = new Observable();
        /**
         *  Fires each time a drag ends (eg. mouse release after drag)
         */
        this.onDragEndObservable = new Observable();
        /**
         *  If the attached mesh should be moved when dragged
         */
        this.moveAttached = true;
        /**
         *  If the drag behavior will react to drag events (Default: true)
         */
        this.enabled = true;
        /**
         * If camera controls should be detached during the drag
         */
        this.detachCameraControls = true;
        /**
         * If set, the drag plane/axis will be rotated based on the attached mesh's world rotation (Default: true)
         */
        this.useObjectOrienationForDragging = true;
        /**
         * Predicate to determine if it is valid to move the object to a new position when it is moved
         */
        this.validateDrag = function (targetPosition) { return true; };
        this._tmpVector = new Vector3(0, 0, 0);
        this._alternatePickedPoint = new Vector3(0, 0, 0);
        this._worldDragAxis = new Vector3(0, 0, 0);
        this._targetPosition = new Vector3(0, 0, 0);
        this._attachedElement = null;
        this._startDragRay = new Ray(new Vector3(), new Vector3());
        this._lastPointerRay = {};
        this._dragDelta = new Vector3();
        // Variables to avoid instantiation in the below method
        this._pointA = new Vector3(0, 0, 0);
        this._pointB = new Vector3(0, 0, 0);
        this._pointC = new Vector3(0, 0, 0);
        this._lineA = new Vector3(0, 0, 0);
        this._lineB = new Vector3(0, 0, 0);
        this._localAxis = new Vector3(0, 0, 0);
        this._lookAt = new Vector3(0, 0, 0);
        this._options = options ? options : {};
        var optionCount = 0;
        if (this._options.dragAxis) {
            optionCount++;
        }
        if (this._options.dragPlaneNormal) {
            optionCount++;
        }
        if (optionCount > 1) {
            throw "Multiple drag modes specified in dragBehavior options. Only one expected";
        }
    }
    Object.defineProperty(PointerDragBehavior.prototype, "name", {
        /**
         *  The name of the behavior
         */
        get: function () {
            return "PointerDrag";
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Initializes the behavior
     */
    PointerDragBehavior.prototype.init = function () { };
    /**
     * Attaches the drag behavior the passed in mesh
     * @param ownerNode The mesh that will be dragged around once attached
     */
    PointerDragBehavior.prototype.attach = function (ownerNode) {
        var _this = this;
        this._scene = ownerNode.getScene();
        this._attachedNode = ownerNode;
        // Initialize drag plane to not interfere with existing scene
        if (!PointerDragBehavior._planeScene) {
            if (this._debugMode) {
                PointerDragBehavior._planeScene = this._scene;
            }
            else {
                PointerDragBehavior._planeScene = new Scene(this._scene.getEngine(), { virtual: true });
                PointerDragBehavior._planeScene.detachControl();
                this._scene.onDisposeObservable.addOnce(function () {
                    PointerDragBehavior._planeScene.dispose();
                    PointerDragBehavior._planeScene = null;
                });
            }
        }
        this._dragPlane = Mesh.CreatePlane("pointerDragPlane", this._debugMode ? 1 : 10000, PointerDragBehavior._planeScene, false, Mesh.DOUBLESIDE);
        // State of the drag
        this.lastDragPosition = new Vector3(0, 0, 0);
        var pickPredicate = function (m) {
            return _this._attachedNode == m || m.isDescendantOf(_this._attachedNode);
        };
        this._pointerObserver = this._scene.onPointerObservable.add(function (pointerInfo, eventState) {
            if (!_this.enabled) {
                return;
            }
            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
                if (!_this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
                    _this._startDrag(pointerInfo.event.pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);
                }
            }
            else if (pointerInfo.type == PointerEventTypes.POINTERUP) {
                if (_this.currentDraggingPointerID == pointerInfo.event.pointerId) {
                    _this.releaseDrag();
                }
            }
            else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
                var pointerId = pointerInfo.event.pointerId;
                // If drag was started with anyMouseID specified, set pointerID to the next mouse that moved
                if (_this.currentDraggingPointerID === PointerDragBehavior._AnyMouseID && pointerId !== PointerDragBehavior._AnyMouseID && pointerInfo.event.pointerType == "mouse") {
                    if (_this._lastPointerRay[_this.currentDraggingPointerID]) {
                        _this._lastPointerRay[pointerId] = _this._lastPointerRay[_this.currentDraggingPointerID];
                        delete _this._lastPointerRay[_this.currentDraggingPointerID];
                    }
                    _this.currentDraggingPointerID = pointerId;
                }
                // Keep track of last pointer ray, this is used simulating the start of a drag in startDrag()
                if (!_this._lastPointerRay[pointerId]) {
                    _this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());
                }
                if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {
                    _this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);
                    _this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);
                    if (_this.currentDraggingPointerID == pointerId && _this.dragging) {
                        _this._moveDrag(pointerInfo.pickInfo.ray);
                    }
                }
            }
        });
        this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(function () {
            if (_this._moving && _this.moveAttached) {
                PivotTools._RemoveAndStorePivotPoint(_this._attachedNode);
                // Slowly move mesh to avoid jitter
                _this._targetPosition.subtractToRef((_this._attachedNode).absolutePosition, _this._tmpVector);
                _this._tmpVector.scaleInPlace(_this.dragDeltaRatio);
                (_this._attachedNode).getAbsolutePosition().addToRef(_this._tmpVector, _this._tmpVector);
                if (_this.validateDrag(_this._tmpVector)) {
                    (_this._attachedNode).setAbsolutePosition(_this._tmpVector);
                }
                PivotTools._RestorePivotPoint(_this._attachedNode);
            }
        });
    };
    /**
     * Force relase the drag action by code.
     */
    PointerDragBehavior.prototype.releaseDrag = function () {
        this.dragging = false;
        this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerID });
        this.currentDraggingPointerID = -1;
        this._moving = false;
        // Reattach camera controls
        if (this.detachCameraControls && this._attachedElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {
            this._scene.activeCamera.attachControl(this._attachedElement, true);
        }
    };
    /**
     * Simulates the start of a pointer drag event on the behavior
     * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)
     * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)
     * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)
     */
    PointerDragBehavior.prototype.startDrag = function (pointerId, fromRay, startPickedPoint) {
        if (pointerId === void 0) { pointerId = PointerDragBehavior._AnyMouseID; }
        this._startDrag(pointerId, fromRay, startPickedPoint);
        var lastRay = this._lastPointerRay[pointerId];
        if (pointerId === PointerDragBehavior._AnyMouseID) {
            lastRay = this._lastPointerRay[Object.keys(this._lastPointerRay)[0]];
        }
        if (lastRay) {
            // if there was a last pointer ray drag the object there
            this._moveDrag(lastRay);
        }
    };
    PointerDragBehavior.prototype._startDrag = function (pointerId, fromRay, startPickedPoint) {
        if (!this._scene.activeCamera || this.dragging || !this._attachedNode) {
            return;
        }
        PivotTools._RemoveAndStorePivotPoint(this._attachedNode);
        // Create start ray from the camera to the object
        if (fromRay) {
            this._startDragRay.direction.copyFrom(fromRay.direction);
            this._startDragRay.origin.copyFrom(fromRay.origin);
        }
        else {
            this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);
            this._attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);
            this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);
        }
        this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);
        var pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);
        if (pickedPoint) {
            this.dragging = true;
            this.currentDraggingPointerID = pointerId;
            this.lastDragPosition.copyFrom(pickedPoint);
            this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerID });
            this._targetPosition.copyFrom((this._attachedNode).absolutePosition);
            // Detatch camera controls
            if (this.detachCameraControls && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {
                if (this._scene.activeCamera.inputs.attachedElement) {
                    this._attachedElement = this._scene.activeCamera.inputs.attachedElement;
                    this._scene.activeCamera.detachControl(this._scene.activeCamera.inputs.attachedElement);
                }
                else {
                    this._attachedElement = null;
                }
            }
        }
        PivotTools._RestorePivotPoint(this._attachedNode);
    };
    PointerDragBehavior.prototype._moveDrag = function (ray) {
        this._moving = true;
        var pickedPoint = this._pickWithRayOnDragPlane(ray);
        if (pickedPoint) {
            if (this.updateDragPlane) {
                this._updateDragPlanePosition(ray, pickedPoint);
            }
            var dragLength = 0;
            // depending on the drag mode option drag accordingly
            if (this._options.dragAxis) {
                // Convert local drag axis to world
                Vector3.TransformCoordinatesToRef(this._options.dragAxis, this._attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis);
                // Project delta drag from the drag plane onto the drag axis
                pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);
                dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);
                this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);
            }
            else {
                dragLength = this._dragDelta.length();
                pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);
            }
            this._targetPosition.addInPlace(this._dragDelta);
            this.onDragObservable.notifyObservers({ dragDistance: dragLength, delta: this._dragDelta, dragPlanePoint: pickedPoint, dragPlaneNormal: this._dragPlane.forward, pointerId: this.currentDraggingPointerID });
            this.lastDragPosition.copyFrom(pickedPoint);
        }
    };
    PointerDragBehavior.prototype._pickWithRayOnDragPlane = function (ray) {
        var _this = this;
        if (!ray) {
            return null;
        }
        // Calculate angle between plane normal and ray
        var angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));
        // Correct if ray is casted from oposite side
        if (angle > Math.PI / 2) {
            angle = Math.PI - angle;
        }
        // If the angle is too perpendicular to the plane pick another point on the plane where it is looking
        if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {
            if (this._useAlternatePickedPointAboveMaxDragAngle) {
                // Invert ray direction along the towards object axis
                this._tmpVector.copyFrom(ray.direction);
                (this._attachedNode).absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);
                this._alternatePickedPoint.normalize();
                this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));
                this._tmpVector.addInPlace(this._alternatePickedPoint);
                // Project resulting vector onto the drag plane and add it to the attached nodes absolute position to get a picked point
                var dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);
                this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);
                this._alternatePickedPoint.addInPlace(this._tmpVector);
                this._alternatePickedPoint.addInPlace((this._attachedNode).absolutePosition);
                return this._alternatePickedPoint;
            }
            else {
                return null;
            }
        }
        var pickResult = PointerDragBehavior._planeScene.pickWithRay(ray, function (m) { return m == _this._dragPlane; });
        if (pickResult && pickResult.hit && pickResult.pickedMesh && pickResult.pickedPoint) {
            return pickResult.pickedPoint;
        }
        else {
            return null;
        }
    };
    // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera
    PointerDragBehavior.prototype._updateDragPlanePosition = function (ray, dragPlanePosition) {
        this._pointA.copyFrom(dragPlanePosition);
        if (this._options.dragAxis) {
            this.useObjectOrienationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this._attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis);
            // Calculate plane normal in direction of camera but perpendicular to drag axis
            this._pointA.addToRef(this._localAxis, this._pointB); // towards drag axis
            ray.origin.subtractToRef(this._pointA, this._pointC);
            this._pointA.addToRef(this._pointC.normalize(), this._pointC); // towards camera
            // Get perpendicular line from direction to camera and drag axis
            this._pointB.subtractToRef(this._pointA, this._lineA);
            this._pointC.subtractToRef(this._pointA, this._lineB);
            Vector3.CrossToRef(this._lineA, this._lineB, this._lookAt);
            // Get perpendicular line from previous result and drag axis to adjust lineB to be perpendiculat to camera
            Vector3.CrossToRef(this._lineA, this._lookAt, this._lookAt);
            this._lookAt.normalize();
            this._dragPlane.position.copyFrom(this._pointA);
            this._pointA.addToRef(this._lookAt, this._lookAt);
            this._dragPlane.lookAt(this._lookAt);
        }
        else if (this._options.dragPlaneNormal) {
            this.useObjectOrienationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this._attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal);
            this._dragPlane.position.copyFrom(this._pointA);
            this._pointA.addToRef(this._localAxis, this._lookAt);
            this._dragPlane.lookAt(this._lookAt);
        }
        else {
            this._dragPlane.position.copyFrom(this._pointA);
            this._dragPlane.lookAt(ray.origin);
        }
        // Update the position of the drag plane so it doesn't get out of sync with the node (eg. when moving back and forth quickly)
        this._dragPlane.position.copyFrom(this._attachedNode.absolutePosition);
        this._dragPlane.computeWorldMatrix(true);
    };
    /**
     *  Detaches the behavior from the mesh
     */
    PointerDragBehavior.prototype.detach = function () {
        if (this._pointerObserver) {
            this._scene.onPointerObservable.remove(this._pointerObserver);
        }
        if (this._beforeRenderObserver) {
            this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
        }
        this.releaseDrag();
    };
    PointerDragBehavior._AnyMouseID = -2;
    return PointerDragBehavior;
}());

/**
 * A behavior that when attached to a mesh will allow the mesh to be scaled
 */
var MultiPointerScaleBehavior = /** @class */ (function () {
    /**
     * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled
     */
    function MultiPointerScaleBehavior() {
        this._startDistance = 0;
        this._initialScale = new Vector3(0, 0, 0);
        this._targetScale = new Vector3(0, 0, 0);
        this._sceneRenderObserver = null;
        this._dragBehaviorA = new PointerDragBehavior({});
        this._dragBehaviorA.moveAttached = false;
        this._dragBehaviorB = new PointerDragBehavior({});
        this._dragBehaviorB.moveAttached = false;
    }
    Object.defineProperty(MultiPointerScaleBehavior.prototype, "name", {
        /**
         *  The name of the behavior
         */
        get: function () {
            return "MultiPointerScale";
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Initializes the behavior
     */
    MultiPointerScaleBehavior.prototype.init = function () { };
    MultiPointerScaleBehavior.prototype._getCurrentDistance = function () {
        return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();
    };
    /**
     * Attaches the scale behavior the passed in mesh
     * @param ownerNode The mesh that will be scaled around once attached
     */
    MultiPointerScaleBehavior.prototype.attach = function (ownerNode) {
        var _this = this;
        this._ownerNode = ownerNode;
        // Create 2 drag behaviors such that each will only be triggered by a separate pointer
        this._dragBehaviorA.onDragStartObservable.add(function (e) {
            if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {
                if (_this._dragBehaviorA.currentDraggingPointerID == _this._dragBehaviorB.currentDraggingPointerID) {
                    _this._dragBehaviorA.releaseDrag();
                }
                else {
                    _this._initialScale.copyFrom(ownerNode.scaling);
                    _this._startDistance = _this._getCurrentDistance();
                }
            }
        });
        this._dragBehaviorB.onDragStartObservable.add(function (e) {
            if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {
                if (_this._dragBehaviorA.currentDraggingPointerID == _this._dragBehaviorB.currentDraggingPointerID) {
                    _this._dragBehaviorB.releaseDrag();
                }
                else {
                    _this._initialScale.copyFrom(ownerNode.scaling);
                    _this._startDistance = _this._getCurrentDistance();
                }
            }
        });
        // Once both drag behaviors are active scale based on the distance between the two pointers
        [this._dragBehaviorA, this._dragBehaviorB].forEach(function (behavior) {
            behavior.onDragObservable.add(function () {
                if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {
                    var ratio = _this._getCurrentDistance() / _this._startDistance;
                    _this._initialScale.scaleToRef(ratio, _this._targetScale);
                }
            });
        });
        ownerNode.addBehavior(this._dragBehaviorA);
        ownerNode.addBehavior(this._dragBehaviorB);
        // On every frame move towards target scaling to avoid jitter caused by vr controllers
        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(function () {
            if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {
                var change = _this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);
                if (change.length() > 0.01) {
                    ownerNode.scaling.addInPlace(change);
                }
            }
        });
    };
    /**
     *  Detaches the behavior from the mesh
     */
    MultiPointerScaleBehavior.prototype.detach = function () {
        var _this = this;
        this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
        [this._dragBehaviorA, this._dragBehaviorB].forEach(function (behavior) {
            behavior.onDragStartObservable.clear();
            behavior.onDragObservable.clear();
            _this._ownerNode.removeBehavior(behavior);
        });
    };
    return MultiPointerScaleBehavior;
}());

/**
 * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
 */
var SixDofDragBehavior = /** @class */ (function () {
    /**
     * Instantiates a behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
     */
    function SixDofDragBehavior() {
        this._sceneRenderObserver = null;
        this._targetPosition = new Vector3(0, 0, 0);
        this._moving = false;
        this._startingOrientation = new Quaternion();
        /**
         * How much faster the object should move when the controller is moving towards it. This is useful to bring objects that are far away from the user to them faster. Set this to 0 to avoid any speed increase. (Default: 3)
         */
        this.zDragFactor = 3;
        /**
         * If the object should rotate to face the drag origin
         */
        this.rotateDraggedObject = true;
        /**
         * If the behavior is currently in a dragging state
         */
        this.dragging = false;
        /**
         * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)
         */
        this.dragDeltaRatio = 0.2;
        /**
         * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
         */
        this.currentDraggingPointerID = -1;
        /**
         * If camera controls should be detached during the drag
         */
        this.detachCameraControls = true;
        /**
         * Fires each time a drag starts
         */
        this.onDragStartObservable = new Observable();
        /**
         *  Fires each time a drag ends (eg. mouse release after drag)
         */
        this.onDragEndObservable = new Observable();
    }
    Object.defineProperty(SixDofDragBehavior.prototype, "name", {
        /**
         *  The name of the behavior
         */
        get: function () {
            return "SixDofDrag";
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Initializes the behavior
     */
    SixDofDragBehavior.prototype.init = function () { };
    /**
     * Attaches the scale behavior the passed in mesh
     * @param ownerNode The mesh that will be scaled around once attached
     */
    SixDofDragBehavior.prototype.attach = function (ownerNode) {
        var _this = this;
        this._ownerNode = ownerNode;
        this._scene = this._ownerNode.getScene();
        if (!SixDofDragBehavior._virtualScene) {
            SixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine());
            SixDofDragBehavior._virtualScene.detachControl();
            this._scene.getEngine().scenes.pop();
        }
        var pickedMesh = null;
        var lastSixDofOriginPosition = new Vector3(0, 0, 0);
        // Setup virtual meshes to be used for dragging without dirtying the existing scene
        this._virtualOriginMesh = new AbstractMesh("", SixDofDragBehavior._virtualScene);
        this._virtualOriginMesh.rotationQuaternion = new Quaternion();
        this._virtualDragMesh = new AbstractMesh("", SixDofDragBehavior._virtualScene);
        this._virtualDragMesh.rotationQuaternion = new Quaternion();
        var pickPredicate = function (m) {
            return _this._ownerNode == m || m.isDescendantOf(_this._ownerNode);
        };
        var attachedElement = null;
        this._pointerObserver = this._scene.onPointerObservable.add(function (pointerInfo, eventState) {
            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
                if (!_this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
                    if (_this._scene.activeCamera && _this._scene.activeCamera.cameraRigMode == Camera.RIG_MODE_NONE) {
                        pointerInfo.pickInfo.ray.origin.copyFrom(_this._scene.activeCamera.globalPosition);
                    }
                    pickedMesh = _this._ownerNode;
                    PivotTools._RemoveAndStorePivotPoint(pickedMesh);
                    lastSixDofOriginPosition.copyFrom(pointerInfo.pickInfo.ray.origin);
                    // Set position and orientation of the controller
                    _this._virtualOriginMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
                    _this._virtualOriginMesh.lookAt(pointerInfo.pickInfo.ray.origin.add(pointerInfo.pickInfo.ray.direction));
                    // Attach the virtual drag mesh to the virtual origin mesh so it can be dragged
                    _this._virtualOriginMesh.removeChild(_this._virtualDragMesh);
                    pickedMesh.computeWorldMatrix();
                    _this._virtualDragMesh.position.copyFrom(pickedMesh.absolutePosition);
                    if (!pickedMesh.rotationQuaternion) {
                        pickedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(pickedMesh.rotation.y, pickedMesh.rotation.x, pickedMesh.rotation.z);
                    }
                    var oldParent = pickedMesh.parent;
                    pickedMesh.setParent(null);
                    _this._virtualDragMesh.rotationQuaternion.copyFrom(pickedMesh.rotationQuaternion);
                    pickedMesh.setParent(oldParent);
                    _this._virtualOriginMesh.addChild(_this._virtualDragMesh);
                    // Update state
                    _this._targetPosition.copyFrom(_this._virtualDragMesh.absolutePosition);
                    _this.dragging = true;
                    _this.currentDraggingPointerID = pointerInfo.event.pointerId;
                    // Detatch camera controls
                    if (_this.detachCameraControls && _this._scene.activeCamera && !_this._scene.activeCamera.leftCamera) {
                        if (_this._scene.activeCamera.inputs.attachedElement) {
                            attachedElement = _this._scene.activeCamera.inputs.attachedElement;
                            _this._scene.activeCamera.detachControl(_this._scene.activeCamera.inputs.attachedElement);
                        }
                        else {
                            attachedElement = null;
                        }
                    }
                    PivotTools._RestorePivotPoint(pickedMesh);
                    _this.onDragStartObservable.notifyObservers({});
                }
            }
            else if (pointerInfo.type == PointerEventTypes.POINTERUP) {
                if (_this.currentDraggingPointerID == pointerInfo.event.pointerId) {
                    _this.dragging = false;
                    _this._moving = false;
                    _this.currentDraggingPointerID = -1;
                    pickedMesh = null;
                    _this._virtualOriginMesh.removeChild(_this._virtualDragMesh);
                    // Reattach camera controls
                    if (_this.detachCameraControls && attachedElement && _this._scene.activeCamera && !_this._scene.activeCamera.leftCamera) {
                        _this._scene.activeCamera.attachControl(attachedElement, true);
                    }
                    _this.onDragEndObservable.notifyObservers({});
                }
            }
            else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
                if (_this.currentDraggingPointerID == pointerInfo.event.pointerId && _this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.ray && pickedMesh) {
                    var zDragFactor = _this.zDragFactor;
                    if (_this._scene.activeCamera && _this._scene.activeCamera.cameraRigMode == Camera.RIG_MODE_NONE) {
                        pointerInfo.pickInfo.ray.origin.copyFrom(_this._scene.activeCamera.globalPosition);
                        zDragFactor = 0;
                    }
                    // Calculate controller drag distance in controller space
                    var originDragDifference = pointerInfo.pickInfo.ray.origin.subtract(lastSixDofOriginPosition);
                    lastSixDofOriginPosition.copyFrom(pointerInfo.pickInfo.ray.origin);
                    var localOriginDragDifference = -Vector3.Dot(originDragDifference, pointerInfo.pickInfo.ray.direction);
                    _this._virtualOriginMesh.addChild(_this._virtualDragMesh);
                    // Determine how much the controller moved to/away towards the dragged object and use this to move the object further when its further away
                    _this._virtualDragMesh.position.z -= _this._virtualDragMesh.position.z < 1 ? localOriginDragDifference * _this.zDragFactor : localOriginDragDifference * zDragFactor * _this._virtualDragMesh.position.z;
                    if (_this._virtualDragMesh.position.z < 0) {
                        _this._virtualDragMesh.position.z = 0;
                    }
                    // Update the controller position
                    _this._virtualOriginMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
                    _this._virtualOriginMesh.lookAt(pointerInfo.pickInfo.ray.origin.add(pointerInfo.pickInfo.ray.direction));
                    _this._virtualOriginMesh.removeChild(_this._virtualDragMesh);
                    // Move the virtualObjectsPosition into the picked mesh's space if needed
                    _this._targetPosition.copyFrom(_this._virtualDragMesh.absolutePosition);
                    if (pickedMesh.parent) {
                        Vector3.TransformCoordinatesToRef(_this._targetPosition, Matrix.Invert(pickedMesh.parent.getWorldMatrix()), _this._targetPosition);
                    }
                    if (!_this._moving) {
                        _this._startingOrientation.copyFrom(_this._virtualDragMesh.rotationQuaternion);
                    }
                    _this._moving = true;
                }
            }
        });
        var tmpQuaternion = new Quaternion();
        // On every frame move towards target scaling to avoid jitter caused by vr controllers
        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(function () {
            if (_this.dragging && _this._moving && pickedMesh) {
                PivotTools._RemoveAndStorePivotPoint(pickedMesh);
                // Slowly move mesh to avoid jitter
                pickedMesh.position.addInPlace(_this._targetPosition.subtract(pickedMesh.position).scale(_this.dragDeltaRatio));
                if (_this.rotateDraggedObject) {
                    // Get change in rotation
                    tmpQuaternion.copyFrom(_this._startingOrientation);
                    tmpQuaternion.x = -tmpQuaternion.x;
                    tmpQuaternion.y = -tmpQuaternion.y;
                    tmpQuaternion.z = -tmpQuaternion.z;
                    _this._virtualDragMesh.rotationQuaternion.multiplyToRef(tmpQuaternion, tmpQuaternion);
                    // Convert change in rotation to only y axis rotation
                    Quaternion.RotationYawPitchRollToRef(tmpQuaternion.toEulerAngles("xyz").y, 0, 0, tmpQuaternion);
                    tmpQuaternion.multiplyToRef(_this._startingOrientation, tmpQuaternion);
                    // Slowly move mesh to avoid jitter
                    var oldParent = pickedMesh.parent;
                    // Only rotate the mesh if it's parent has uniform scaling
                    if (!oldParent || (oldParent.scaling && !oldParent.scaling.isNonUniformWithinEpsilon(0.001))) {
                        pickedMesh.setParent(null);
                        Quaternion.SlerpToRef(pickedMesh.rotationQuaternion, tmpQuaternion, _this.dragDeltaRatio, pickedMesh.rotationQuaternion);
                        pickedMesh.setParent(oldParent);
                    }
                }
                PivotTools._RestorePivotPoint(pickedMesh);
            }
        });
    };
    /**
     *  Detaches the behavior from the mesh
     */
    SixDofDragBehavior.prototype.detach = function () {
        if (this._scene) {
            this._scene.onPointerObservable.remove(this._pointerObserver);
        }
        if (this._ownerNode) {
            this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
        }
        if (this._virtualOriginMesh) {
            this._virtualOriginMesh.dispose();
        }
        if (this._virtualDragMesh) {
            this._virtualDragMesh.dispose();
        }
        this.onDragEndObservable.clear();
        this.onDragStartObservable.clear();
    };
    return SixDofDragBehavior;
}());

/**
 * Class used to apply inverse kinematics to bones
 * @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#boneikcontroller
 */
var BoneIKController = /** @class */ (function () {
    /**
     * Creates a new BoneIKController
     * @param mesh defines the mesh to control
     * @param bone defines the bone to control
     * @param options defines options to set up the controller
     */
    function BoneIKController(mesh, bone, options) {
        /**
         * Gets or sets the target position
         */
        this.targetPosition = Vector3.Zero();
        /**
         * Gets or sets the pole target position
         */
        this.poleTargetPosition = Vector3.Zero();
        /**
         * Gets or sets the pole target local offset
         */
        this.poleTargetLocalOffset = Vector3.Zero();
        /**
         * Gets or sets the pole angle
         */
        this.poleAngle = 0;
        /**
         * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
         */
        this.slerpAmount = 1;
        this._bone1Quat = Quaternion.Identity();
        this._bone1Mat = Matrix.Identity();
        this._bone2Ang = Math.PI;
        this._maxAngle = Math.PI;
        this._rightHandedSystem = false;
        this._bendAxis = Vector3.Right();
        this._slerping = false;
        this._adjustRoll = 0;
        this._bone2 = bone;
        this._bone1 = bone.getParent();
        if (!this._bone1) {
            return;
        }
        this.mesh = mesh;
        var bonePos = bone.getPosition();
        if (bone.getAbsoluteTransform().determinant() > 0) {
            this._rightHandedSystem = true;
            this._bendAxis.x = 0;
            this._bendAxis.y = 0;
            this._bendAxis.z = -1;
            if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {
                this._adjustRoll = Math.PI * .5;
                this._bendAxis.z = 1;
            }
        }
        if (this._bone1.length) {
            var boneScale1 = this._bone1.getScale();
            var boneScale2 = this._bone2.getScale();
            this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;
            this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;
        }
        else if (this._bone1.children[0]) {
            mesh.computeWorldMatrix(true);
            var pos1 = this._bone2.children[0].getAbsolutePosition(mesh);
            var pos2 = this._bone2.getAbsolutePosition(mesh);
            var pos3 = this._bone1.getAbsolutePosition(mesh);
            this._bone1Length = Vector3.Distance(pos1, pos2);
            this._bone2Length = Vector3.Distance(pos2, pos3);
        }
        this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);
        this.maxAngle = Math.PI;
        if (options) {
            if (options.targetMesh) {
                this.targetMesh = options.targetMesh;
                this.targetMesh.computeWorldMatrix(true);
            }
            if (options.poleTargetMesh) {
                this.poleTargetMesh = options.poleTargetMesh;
                this.poleTargetMesh.computeWorldMatrix(true);
            }
            else if (options.poleTargetBone) {
                this.poleTargetBone = options.poleTargetBone;
            }
            else if (this._bone1.getParent()) {
                this.poleTargetBone = this._bone1.getParent();
            }
            if (options.poleTargetLocalOffset) {
                this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);
            }
            if (options.poleAngle) {
                this.poleAngle = options.poleAngle;
            }
            if (options.bendAxis) {
                this._bendAxis.copyFrom(options.bendAxis);
            }
            if (options.maxAngle) {
                this.maxAngle = options.maxAngle;
            }
            if (options.slerpAmount) {
                this.slerpAmount = options.slerpAmount;
            }
        }
    }
    Object.defineProperty(BoneIKController.prototype, "maxAngle", {
        /**
         * Gets or sets maximum allowed angle
         */
        get: function () {
            return this._maxAngle;
        },
        set: function (value) {
            this._setMaxAngle(value);
        },
        enumerable: true,
        configurable: true
    });
    BoneIKController.prototype._setMaxAngle = function (ang) {
        if (ang < 0) {
            ang = 0;
        }
        if (ang > Math.PI || ang == undefined) {
            ang = Math.PI;
        }
        this._maxAngle = ang;
        var a = this._bone1Length;
        var b = this._bone2Length;
        this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));
    };
    /**
     * Force the controller to update the bones
     */
    BoneIKController.prototype.update = function () {
        var bone1 = this._bone1;
        if (!bone1) {
            return;
        }
        var target = this.targetPosition;
        var poleTarget = this.poleTargetPosition;
        var mat1 = BoneIKController._tmpMats[0];
        var mat2 = BoneIKController._tmpMats[1];
        if (this.targetMesh) {
            target.copyFrom(this.targetMesh.getAbsolutePosition());
        }
        if (this.poleTargetBone) {
            this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);
        }
        else if (this.poleTargetMesh) {
            Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);
        }
        var bonePos = BoneIKController._tmpVecs[0];
        var zaxis = BoneIKController._tmpVecs[1];
        var xaxis = BoneIKController._tmpVecs[2];
        var yaxis = BoneIKController._tmpVecs[3];
        var upAxis = BoneIKController._tmpVecs[4];
        var _tmpQuat = BoneIKController._tmpQuat;
        bone1.getAbsolutePositionToRef(this.mesh, bonePos);
        poleTarget.subtractToRef(bonePos, upAxis);
        if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {
            upAxis.y = 1;
        }
        else {
            upAxis.normalize();
        }
        target.subtractToRef(bonePos, yaxis);
        yaxis.normalize();
        Vector3.CrossToRef(yaxis, upAxis, zaxis);
        zaxis.normalize();
        Vector3.CrossToRef(yaxis, zaxis, xaxis);
        xaxis.normalize();
        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);
        var a = this._bone1Length;
        var b = this._bone2Length;
        var c = Vector3.Distance(bonePos, target);
        if (this._maxReach > 0) {
            c = Math.min(this._maxReach, c);
        }
        var acosa = (b * b + c * c - a * a) / (2 * b * c);
        var acosb = (c * c + a * a - b * b) / (2 * c * a);
        if (acosa > 1) {
            acosa = 1;
        }
        if (acosb > 1) {
            acosb = 1;
        }
        if (acosa < -1) {
            acosa = -1;
        }
        if (acosb < -1) {
            acosb = -1;
        }
        var angA = Math.acos(acosa);
        var angB = Math.acos(acosb);
        var angC = -angA - angB;
        if (this._rightHandedSystem) {
            Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);
            mat2.multiplyToRef(mat1, mat1);
            Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);
            mat2.multiplyToRef(mat1, mat1);
        }
        else {
            var _tmpVec = BoneIKController._tmpVecs[5];
            _tmpVec.copyFrom(this._bendAxis);
            _tmpVec.x *= -1;
            Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);
            mat2.multiplyToRef(mat1, mat1);
        }
        if (this.poleAngle) {
            Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);
            mat1.multiplyToRef(mat2, mat1);
        }
        if (this._bone1) {
            if (this.slerpAmount < 1) {
                if (!this._slerping) {
                    Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);
                }
                Quaternion.FromRotationMatrixToRef(mat1, _tmpQuat);
                Quaternion.SlerpToRef(this._bone1Quat, _tmpQuat, this.slerpAmount, this._bone1Quat);
                angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;
                this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);
                this._slerping = true;
            }
            else {
                this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);
                this._bone1Mat.copyFrom(mat1);
                this._slerping = false;
            }
        }
        this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);
        this._bone2Ang = angC;
    };
    BoneIKController._tmpVecs = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];
    BoneIKController._tmpQuat = Quaternion.Identity();
    BoneIKController._tmpMats = [Matrix.Identity(), Matrix.Identity()];
    return BoneIKController;
}());

/**
 * Class used to make a bone look toward a point in space
 * @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller
 */
var BoneLookController = /** @class */ (function () {
    /**
     * Create a BoneLookController
     * @param mesh the mesh that the bone belongs to
     * @param bone the bone that will be looking to the target
     * @param target the target Vector3 to look at
     * @param options optional settings:
     * * maxYaw: the maximum angle the bone will yaw to
     * * minYaw: the minimum angle the bone will yaw to
     * * maxPitch: the maximum angle the bone will pitch to
     * * minPitch: the minimum angle the bone will yaw to
     * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.
     * * upAxis: the up axis of the coordinate system
     * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.
     * * yawAxis: set yawAxis if the bone does not yaw on the y axis
     * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis
     * * adjustYaw: used to make an adjustment to the yaw of the bone
     * * adjustPitch: used to make an adjustment to the pitch of the bone
     * * adjustRoll: used to make an adjustment to the roll of the bone
     **/
    function BoneLookController(mesh, bone, target, options) {
        /**
         * The up axis of the coordinate system that is used when the bone is rotated
         */
        this.upAxis = Vector3.Up();
        /**
         * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD
         */
        this.upAxisSpace = Space.LOCAL;
        /**
         * Used to make an adjustment to the yaw of the bone
         */
        this.adjustYaw = 0;
        /**
         * Used to make an adjustment to the pitch of the bone
         */
        this.adjustPitch = 0;
        /**
         * Used to make an adjustment to the roll of the bone
         */
        this.adjustRoll = 0;
        /**
         * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
         */
        this.slerpAmount = 1;
        this._boneQuat = Quaternion.Identity();
        this._slerping = false;
        this._firstFrameSkipped = false;
        this._fowardAxis = Vector3.Forward();
        this.mesh = mesh;
        this.bone = bone;
        this.target = target;
        if (options) {
            if (options.adjustYaw) {
                this.adjustYaw = options.adjustYaw;
            }
            if (options.adjustPitch) {
                this.adjustPitch = options.adjustPitch;
            }
            if (options.adjustRoll) {
                this.adjustRoll = options.adjustRoll;
            }
            if (options.maxYaw != null) {
                this.maxYaw = options.maxYaw;
            }
            else {
                this.maxYaw = Math.PI;
            }
            if (options.minYaw != null) {
                this.minYaw = options.minYaw;
            }
            else {
                this.minYaw = -Math.PI;
            }
            if (options.maxPitch != null) {
                this.maxPitch = options.maxPitch;
            }
            else {
                this.maxPitch = Math.PI;
            }
            if (options.minPitch != null) {
                this.minPitch = options.minPitch;
            }
            else {
                this.minPitch = -Math.PI;
            }
            if (options.slerpAmount != null) {
                this.slerpAmount = options.slerpAmount;
            }
            if (options.upAxis != null) {
                this.upAxis = options.upAxis;
            }
            if (options.upAxisSpace != null) {
                this.upAxisSpace = options.upAxisSpace;
            }
            if (options.yawAxis != null || options.pitchAxis != null) {
                var newYawAxis = Axis.Y;
                var newPitchAxis = Axis.X;
                if (options.yawAxis != null) {
                    newYawAxis = options.yawAxis.clone();
                    newYawAxis.normalize();
                }
                if (options.pitchAxis != null) {
                    newPitchAxis = options.pitchAxis.clone();
                    newPitchAxis.normalize();
                }
                var newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);
                this._transformYawPitch = Matrix.Identity();
                Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);
                this._transformYawPitchInv = this._transformYawPitch.clone();
                this._transformYawPitch.invert();
            }
        }
        if (!bone.getParent() && this.upAxisSpace == Space.BONE) {
            this.upAxisSpace = Space.LOCAL;
        }
    }
    Object.defineProperty(BoneLookController.prototype, "minYaw", {
        /**
         * Gets or sets the minimum yaw angle that the bone can look to
         */
        get: function () {
            return this._minYaw;
        },
        set: function (value) {
            this._minYaw = value;
            this._minYawSin = Math.sin(value);
            this._minYawCos = Math.cos(value);
            if (this._maxYaw != null) {
                this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;
                this._yawRange = this._maxYaw - this._minYaw;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BoneLookController.prototype, "maxYaw", {
        /**
         * Gets or sets the maximum yaw angle that the bone can look to
         */
        get: function () {
            return this._maxYaw;
        },
        set: function (value) {
            this._maxYaw = value;
            this._maxYawSin = Math.sin(value);
            this._maxYawCos = Math.cos(value);
            if (this._minYaw != null) {
                this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;
                this._yawRange = this._maxYaw - this._minYaw;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BoneLookController.prototype, "minPitch", {
        /**
         * Gets or sets the minimum pitch angle that the bone can look to
         */
        get: function () {
            return this._minPitch;
        },
        set: function (value) {
            this._minPitch = value;
            this._minPitchTan = Math.tan(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BoneLookController.prototype, "maxPitch", {
        /**
         * Gets or sets the maximum pitch angle that the bone can look to
         */
        get: function () {
            return this._maxPitch;
        },
        set: function (value) {
            this._maxPitch = value;
            this._maxPitchTan = Math.tan(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())
     */
    BoneLookController.prototype.update = function () {
        //skip the first frame when slerping so that the mesh rotation is correct
        if (this.slerpAmount < 1 && !this._firstFrameSkipped) {
            this._firstFrameSkipped = true;
            return;
        }
        var bone = this.bone;
        var bonePos = BoneLookController._tmpVecs[0];
        bone.getAbsolutePositionToRef(this.mesh, bonePos);
        var target = this.target;
        var _tmpMat1 = BoneLookController._tmpMats[0];
        var _tmpMat2 = BoneLookController._tmpMats[1];
        var mesh = this.mesh;
        var parentBone = bone.getParent();
        var upAxis = BoneLookController._tmpVecs[1];
        upAxis.copyFrom(this.upAxis);
        if (this.upAxisSpace == Space.BONE && parentBone) {
            if (this._transformYawPitch) {
                Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);
            }
            parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);
        }
        else if (this.upAxisSpace == Space.LOCAL) {
            mesh.getDirectionToRef(upAxis, upAxis);
            if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {
                upAxis.normalize();
            }
        }
        var checkYaw = false;
        var checkPitch = false;
        if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {
            checkYaw = true;
        }
        if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {
            checkPitch = true;
        }
        if (checkYaw || checkPitch) {
            var spaceMat = BoneLookController._tmpMats[2];
            var spaceMatInv = BoneLookController._tmpMats[3];
            if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {
                parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);
            }
            else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {
                spaceMat.copyFrom(mesh.getWorldMatrix());
            }
            else {
                var forwardAxis = BoneLookController._tmpVecs[2];
                forwardAxis.copyFrom(this._fowardAxis);
                if (this._transformYawPitch) {
                    Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);
                }
                if (parentBone) {
                    parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);
                }
                else {
                    mesh.getDirectionToRef(forwardAxis, forwardAxis);
                }
                var rightAxis = Vector3.Cross(upAxis, forwardAxis);
                rightAxis.normalize();
                var forwardAxis = Vector3.Cross(rightAxis, upAxis);
                Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);
            }
            spaceMat.invertToRef(spaceMatInv);
            var xzlen = null;
            if (checkPitch) {
                var localTarget = BoneLookController._tmpVecs[3];
                target.subtractToRef(bonePos, localTarget);
                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);
                xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
                var pitch = Math.atan2(localTarget.y, xzlen);
                var newPitch = pitch;
                if (pitch > this._maxPitch) {
                    localTarget.y = this._maxPitchTan * xzlen;
                    newPitch = this._maxPitch;
                }
                else if (pitch < this._minPitch) {
                    localTarget.y = this._minPitchTan * xzlen;
                    newPitch = this._minPitch;
                }
                if (pitch != newPitch) {
                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);
                    localTarget.addInPlace(bonePos);
                    target = localTarget;
                }
            }
            if (checkYaw) {
                var localTarget = BoneLookController._tmpVecs[4];
                target.subtractToRef(bonePos, localTarget);
                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);
                var yaw = Math.atan2(localTarget.x, localTarget.z);
                var newYaw = yaw;
                if (yaw > this._maxYaw || yaw < this._minYaw) {
                    if (xzlen == null) {
                        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
                    }
                    if (this._yawRange > Math.PI) {
                        if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {
                            localTarget.z = this._maxYawCos * xzlen;
                            localTarget.x = this._maxYawSin * xzlen;
                            newYaw = this._maxYaw;
                        }
                        else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {
                            localTarget.z = this._minYawCos * xzlen;
                            localTarget.x = this._minYawSin * xzlen;
                            newYaw = this._minYaw;
                        }
                    }
                    else {
                        if (yaw > this._maxYaw) {
                            localTarget.z = this._maxYawCos * xzlen;
                            localTarget.x = this._maxYawSin * xzlen;
                            newYaw = this._maxYaw;
                        }
                        else if (yaw < this._minYaw) {
                            localTarget.z = this._minYawCos * xzlen;
                            localTarget.x = this._minYawSin * xzlen;
                            newYaw = this._minYaw;
                        }
                    }
                }
                if (this._slerping && this._yawRange > Math.PI) {
                    //are we going to be crossing into the min/max region?
                    var boneFwd = BoneLookController._tmpVecs[8];
                    boneFwd.copyFrom(Axis.Z);
                    if (this._transformYawPitch) {
                        Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);
                    }
                    var boneRotMat = BoneLookController._tmpMats[4];
                    this._boneQuat.toRotationMatrix(boneRotMat);
                    this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);
                    Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);
                    Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);
                    var boneYaw = Math.atan2(boneFwd.x, boneFwd.z);
                    var angBtwTar = this._getAngleBetween(boneYaw, yaw);
                    var angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);
                    if (angBtwTar > angBtwMidYaw) {
                        if (xzlen == null) {
                            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
                        }
                        var angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);
                        var angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);
                        if (angBtwMin < angBtwMax) {
                            newYaw = boneYaw + Math.PI * .75;
                            localTarget.z = Math.cos(newYaw) * xzlen;
                            localTarget.x = Math.sin(newYaw) * xzlen;
                        }
                        else {
                            newYaw = boneYaw - Math.PI * .75;
                            localTarget.z = Math.cos(newYaw) * xzlen;
                            localTarget.x = Math.sin(newYaw) * xzlen;
                        }
                    }
                }
                if (yaw != newYaw) {
                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);
                    localTarget.addInPlace(bonePos);
                    target = localTarget;
                }
            }
        }
        var zaxis = BoneLookController._tmpVecs[5];
        var xaxis = BoneLookController._tmpVecs[6];
        var yaxis = BoneLookController._tmpVecs[7];
        var _tmpQuat = BoneLookController._tmpQuat;
        target.subtractToRef(bonePos, zaxis);
        zaxis.normalize();
        Vector3.CrossToRef(upAxis, zaxis, xaxis);
        xaxis.normalize();
        Vector3.CrossToRef(zaxis, xaxis, yaxis);
        yaxis.normalize();
        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);
        if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {
            return;
        }
        if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {
            return;
        }
        if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {
            return;
        }
        if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {
            Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);
            _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);
        }
        if (this.slerpAmount < 1) {
            if (!this._slerping) {
                this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);
            }
            if (this._transformYawPitch) {
                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);
            }
            Quaternion.FromRotationMatrixToRef(_tmpMat1, _tmpQuat);
            Quaternion.SlerpToRef(this._boneQuat, _tmpQuat, this.slerpAmount, this._boneQuat);
            this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);
            this._slerping = true;
        }
        else {
            if (this._transformYawPitch) {
                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);
            }
            this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);
            this._slerping = false;
        }
    };
    BoneLookController.prototype._getAngleDiff = function (ang1, ang2) {
        var angDiff = ang2 - ang1;
        angDiff %= Math.PI * 2;
        if (angDiff > Math.PI) {
            angDiff -= Math.PI * 2;
        }
        else if (angDiff < -Math.PI) {
            angDiff += Math.PI * 2;
        }
        return angDiff;
    };
    BoneLookController.prototype._getAngleBetween = function (ang1, ang2) {
        ang1 %= (2 * Math.PI);
        ang1 = (ang1 < 0) ? ang1 + (2 * Math.PI) : ang1;
        ang2 %= (2 * Math.PI);
        ang2 = (ang2 < 0) ? ang2 + (2 * Math.PI) : ang2;
        var ab = 0;
        if (ang1 < ang2) {
            ab = ang2 - ang1;
        }
        else {
            ab = ang1 - ang2;
        }
        if (ab > Math.PI) {
            ab = Math.PI * 2 - ab;
        }
        return ab;
    };
    BoneLookController.prototype._isAngleBetween = function (ang, ang1, ang2) {
        ang %= (2 * Math.PI);
        ang = (ang < 0) ? ang + (2 * Math.PI) : ang;
        ang1 %= (2 * Math.PI);
        ang1 = (ang1 < 0) ? ang1 + (2 * Math.PI) : ang1;
        ang2 %= (2 * Math.PI);
        ang2 = (ang2 < 0) ? ang2 + (2 * Math.PI) : ang2;
        if (ang1 < ang2) {
            if (ang > ang1 && ang < ang2) {
                return true;
            }
        }
        else {
            if (ang > ang2 && ang < ang1) {
                return true;
            }
        }
        return false;
    };
    BoneLookController._tmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);
    BoneLookController._tmpQuat = Quaternion.Identity();
    BoneLookController._tmpMats = ArrayTools.BuildArray(5, Matrix.Identity);
    return BoneLookController;
}());

/**
 * Represents a gamepad control stick position
 */
var StickValues = /** @class */ (function () {
    /**
     * Initializes the gamepad x and y control stick values
     * @param x The x component of the gamepad control stick value
     * @param y The y component of the gamepad control stick value
     */
    function StickValues(
    /**
     * The x component of the control stick
     */
    x, 
    /**
     * The y component of the control stick
     */
    y) {
        this.x = x;
        this.y = y;
    }
    return StickValues;
}());
/**
 * Represents a gamepad
 */
var Gamepad = /** @class */ (function () {
    /**
     * Initializes the gamepad
     * @param id The id of the gamepad
     * @param index The index of the gamepad
     * @param browserGamepad The browser gamepad
     * @param leftStickX The x component of the left joystick
     * @param leftStickY The y component of the left joystick
     * @param rightStickX The x component of the right joystick
     * @param rightStickY The y component of the right joystick
     */
    function Gamepad(
    /**
     * The id of the gamepad
     */
    id, 
    /**
     * The index of the gamepad
     */
    index, 
    /**
     * The browser gamepad
     */
    browserGamepad, leftStickX, leftStickY, rightStickX, rightStickY) {
        if (leftStickX === void 0) { leftStickX = 0; }
        if (leftStickY === void 0) { leftStickY = 1; }
        if (rightStickX === void 0) { rightStickX = 2; }
        if (rightStickY === void 0) { rightStickY = 3; }
        this.id = id;
        this.index = index;
        this.browserGamepad = browserGamepad;
        this._leftStick = { x: 0, y: 0 };
        this._rightStick = { x: 0, y: 0 };
        /** @hidden */
        this._isConnected = true;
        /**
         * Specifies whether the left control stick should be Y-inverted
         */
        this._invertLeftStickY = false;
        this.type = Gamepad.GAMEPAD;
        this._leftStickAxisX = leftStickX;
        this._leftStickAxisY = leftStickY;
        this._rightStickAxisX = rightStickX;
        this._rightStickAxisY = rightStickY;
        if (this.browserGamepad.axes.length >= 2) {
            this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
        }
        if (this.browserGamepad.axes.length >= 4) {
            this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
        }
    }
    Object.defineProperty(Gamepad.prototype, "isConnected", {
        /**
         * Specifies if the gamepad has been connected
         */
        get: function () {
            return this._isConnected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Callback triggered when the left joystick has changed
     * @param callback
     */
    Gamepad.prototype.onleftstickchanged = function (callback) {
        this._onleftstickchanged = callback;
    };
    /**
     * Callback triggered when the right joystick has changed
     * @param callback
     */
    Gamepad.prototype.onrightstickchanged = function (callback) {
        this._onrightstickchanged = callback;
    };
    Object.defineProperty(Gamepad.prototype, "leftStick", {
        /**
         * Gets the left joystick
         */
        get: function () {
            return this._leftStick;
        },
        /**
         * Sets the left joystick values
         */
        set: function (newValues) {
            if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {
                this._onleftstickchanged(newValues);
            }
            this._leftStick = newValues;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Gamepad.prototype, "rightStick", {
        /**
         * Gets the right joystick
         */
        get: function () {
            return this._rightStick;
        },
        /**
         * Sets the right joystick value
         */
        set: function (newValues) {
            if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {
                this._onrightstickchanged(newValues);
            }
            this._rightStick = newValues;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the gamepad joystick positions
     */
    Gamepad.prototype.update = function () {
        if (this._leftStick) {
            this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
            if (this._invertLeftStickY) {
                this.leftStick.y *= -1;
            }
        }
        if (this._rightStick) {
            this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
        }
    };
    /**
     * Disposes the gamepad
     */
    Gamepad.prototype.dispose = function () {
    };
    /**
     * Represents a gamepad controller
     */
    Gamepad.GAMEPAD = 0;
    /**
     * Represents a generic controller
     */
    Gamepad.GENERIC = 1;
    /**
     * Represents an XBox controller
     */
    Gamepad.XBOX = 2;
    /**
     * Represents a pose-enabled controller
     */
    Gamepad.POSE_ENABLED = 3;
    return Gamepad;
}());
/**
 * Represents a generic gamepad
 */
var GenericPad = /** @class */ (function (_super) {
    __extends(GenericPad, _super);
    /**
     * Initializes the generic gamepad
     * @param id The id of the generic gamepad
     * @param index The index of the generic gamepad
     * @param browserGamepad The browser gamepad
     */
    function GenericPad(id, index, browserGamepad) {
        var _this = _super.call(this, id, index, browserGamepad) || this;
        /**
         * Observable triggered when a button has been pressed
         */
        _this.onButtonDownObservable = new Observable();
        /**
         * Observable triggered when a button has been released
         */
        _this.onButtonUpObservable = new Observable();
        _this.type = Gamepad.GENERIC;
        _this._buttons = new Array(browserGamepad.buttons.length);
        return _this;
    }
    /**
     * Callback triggered when a button has been pressed
     * @param callback Called when a button has been pressed
     */
    GenericPad.prototype.onbuttondown = function (callback) {
        this._onbuttondown = callback;
    };
    /**
     * Callback triggered when a button has been released
     * @param callback Called when a button has been released
     */
    GenericPad.prototype.onbuttonup = function (callback) {
        this._onbuttonup = callback;
    };
    GenericPad.prototype._setButtonValue = function (newValue, currentValue, buttonIndex) {
        if (newValue !== currentValue) {
            if (newValue === 1) {
                if (this._onbuttondown) {
                    this._onbuttondown(buttonIndex);
                }
                this.onButtonDownObservable.notifyObservers(buttonIndex);
            }
            if (newValue === 0) {
                if (this._onbuttonup) {
                    this._onbuttonup(buttonIndex);
                }
                this.onButtonUpObservable.notifyObservers(buttonIndex);
            }
        }
        return newValue;
    };
    /**
     * Updates the generic gamepad
     */
    GenericPad.prototype.update = function () {
        _super.prototype.update.call(this);
        for (var index = 0; index < this._buttons.length; index++) {
            this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);
        }
    };
    /**
     * Disposes the generic gamepad
     */
    GenericPad.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.onButtonDownObservable.clear();
        this.onButtonUpObservable.clear();
    };
    return GenericPad;
}(Gamepad));

/**
 * Manage the gamepad inputs to control an arc rotate camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var ArcRotateCameraGamepadInput = /** @class */ (function () {
    function ArcRotateCameraGamepadInput() {
        /**
         * Defines the gamepad rotation sensiblity.
         * This is the threshold from when rotation starts to be accounted for to prevent jittering.
         */
        this.gamepadRotationSensibility = 80;
        /**
         * Defines the gamepad move sensiblity.
         * This is the threshold from when moving starts to be accounted for for to prevent jittering.
         */
        this.gamepadMoveSensibility = 40;
    }
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    ArcRotateCameraGamepadInput.prototype.attachControl = function (element, noPreventDefault) {
        var _this = this;
        var manager = this.camera.getScene().gamepadManager;
        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(function (gamepad) {
            if (gamepad.type !== Gamepad.POSE_ENABLED) {
                // prioritize XBOX gamepads.
                if (!_this.gamepad || gamepad.type === Gamepad.XBOX) {
                    _this.gamepad = gamepad;
                }
            }
        });
        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(function (gamepad) {
            if (_this.gamepad === gamepad) {
                _this.gamepad = null;
            }
        });
        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    ArcRotateCameraGamepadInput.prototype.detachControl = function (element) {
        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
        this.gamepad = null;
    };
    /**
     * Update the current camera state depending on the inputs that have been used this frame.
     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
     */
    ArcRotateCameraGamepadInput.prototype.checkInputs = function () {
        if (this.gamepad) {
            var camera = this.camera;
            var RSValues = this.gamepad.rightStick;
            if (RSValues) {
                if (RSValues.x != 0) {
                    var normalizedRX = RSValues.x / this.gamepadRotationSensibility;
                    if (normalizedRX != 0 && Math.abs(normalizedRX) > 0.005) {
                        camera.inertialAlphaOffset += normalizedRX;
                    }
                }
                if (RSValues.y != 0) {
                    var normalizedRY = RSValues.y / this.gamepadRotationSensibility;
                    if (normalizedRY != 0 && Math.abs(normalizedRY) > 0.005) {
                        camera.inertialBetaOffset += normalizedRY;
                    }
                }
            }
            var LSValues = this.gamepad.leftStick;
            if (LSValues && LSValues.y != 0) {
                var normalizedLY = LSValues.y / this.gamepadMoveSensibility;
                if (normalizedLY != 0 && Math.abs(normalizedLY) > 0.005) {
                    this.camera.inertialRadiusOffset -= normalizedLY;
                }
            }
        }
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    ArcRotateCameraGamepadInput.prototype.getClassName = function () {
        return "ArcRotateCameraGamepadInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    ArcRotateCameraGamepadInput.prototype.getSimpleName = function () {
        return "gamepad";
    };
    __decorate([
        serialize()
    ], ArcRotateCameraGamepadInput.prototype, "gamepadRotationSensibility", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraGamepadInput.prototype, "gamepadMoveSensibility", void 0);
    return ArcRotateCameraGamepadInput;
}());
CameraInputTypes["ArcRotateCameraGamepadInput"] = ArcRotateCameraGamepadInput;

/**
 * Manage the keyboard inputs to control the movement of an arc rotate camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var ArcRotateCameraKeyboardMoveInput = /** @class */ (function () {
    function ArcRotateCameraKeyboardMoveInput() {
        /**
         * Defines the list of key codes associated with the up action (increase alpha)
         */
        this.keysUp = [38];
        /**
         * Defines the list of key codes associated with the down action (decrease alpha)
         */
        this.keysDown = [40];
        /**
         * Defines the list of key codes associated with the left action (increase beta)
         */
        this.keysLeft = [37];
        /**
         * Defines the list of key codes associated with the right action (decrease beta)
         */
        this.keysRight = [39];
        /**
         * Defines the list of key codes associated with the reset action.
         * Those keys reset the camera to its last stored state (with the method camera.storeState())
         */
        this.keysReset = [220];
        /**
         * Defines the panning sensibility of the inputs.
         * (How fast is the camera paning)
         */
        this.panningSensibility = 50.0;
        /**
         * Defines the zooming sensibility of the inputs.
         * (How fast is the camera zooming)
         */
        this.zoomingSensibility = 25.0;
        /**
         * Defines wether maintaining the alt key down switch the movement mode from
         * orientation to zoom.
         */
        this.useAltToZoom = true;
        /**
         * Rotation speed of the camera
         */
        this.angularSpeed = 0.01;
        this._keys = new Array();
    }
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    ArcRotateCameraKeyboardMoveInput.prototype.attachControl = function (element, noPreventDefault) {
        var _this = this;
        if (this._onCanvasBlurObserver) {
            return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function () {
            _this._keys = [];
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function (info) {
            var evt = info.event;
            if (!evt.metaKey) {
                if (info.type === KeyboardEventTypes.KEYDOWN) {
                    _this._ctrlPressed = evt.ctrlKey;
                    _this._altPressed = evt.altKey;
                    if (_this.keysUp.indexOf(evt.keyCode) !== -1 ||
                        _this.keysDown.indexOf(evt.keyCode) !== -1 ||
                        _this.keysLeft.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRight.indexOf(evt.keyCode) !== -1 ||
                        _this.keysReset.indexOf(evt.keyCode) !== -1) {
                        var index = _this._keys.indexOf(evt.keyCode);
                        if (index === -1) {
                            _this._keys.push(evt.keyCode);
                        }
                        if (evt.preventDefault) {
                            if (!noPreventDefault) {
                                evt.preventDefault();
                            }
                        }
                    }
                }
                else {
                    if (_this.keysUp.indexOf(evt.keyCode) !== -1 ||
                        _this.keysDown.indexOf(evt.keyCode) !== -1 ||
                        _this.keysLeft.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRight.indexOf(evt.keyCode) !== -1 ||
                        _this.keysReset.indexOf(evt.keyCode) !== -1) {
                        var index = _this._keys.indexOf(evt.keyCode);
                        if (index >= 0) {
                            _this._keys.splice(index, 1);
                        }
                        if (evt.preventDefault) {
                            if (!noPreventDefault) {
                                evt.preventDefault();
                            }
                        }
                    }
                }
            }
        });
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    ArcRotateCameraKeyboardMoveInput.prototype.detachControl = function (element) {
        if (this._scene) {
            if (this._onKeyboardObserver) {
                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
            }
            if (this._onCanvasBlurObserver) {
                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
            }
            this._onKeyboardObserver = null;
            this._onCanvasBlurObserver = null;
        }
        this._keys = [];
    };
    /**
     * Update the current camera state depending on the inputs that have been used this frame.
     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
     */
    ArcRotateCameraKeyboardMoveInput.prototype.checkInputs = function () {
        if (this._onKeyboardObserver) {
            var camera = this.camera;
            for (var index = 0; index < this._keys.length; index++) {
                var keyCode = this._keys[index];
                if (this.keysLeft.indexOf(keyCode) !== -1) {
                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                        camera.inertialPanningX -= 1 / this.panningSensibility;
                    }
                    else {
                        camera.inertialAlphaOffset -= this.angularSpeed;
                    }
                }
                else if (this.keysUp.indexOf(keyCode) !== -1) {
                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                        camera.inertialPanningY += 1 / this.panningSensibility;
                    }
                    else if (this._altPressed && this.useAltToZoom) {
                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;
                    }
                    else {
                        camera.inertialBetaOffset -= this.angularSpeed;
                    }
                }
                else if (this.keysRight.indexOf(keyCode) !== -1) {
                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                        camera.inertialPanningX += 1 / this.panningSensibility;
                    }
                    else {
                        camera.inertialAlphaOffset += this.angularSpeed;
                    }
                }
                else if (this.keysDown.indexOf(keyCode) !== -1) {
                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                        camera.inertialPanningY -= 1 / this.panningSensibility;
                    }
                    else if (this._altPressed && this.useAltToZoom) {
                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;
                    }
                    else {
                        camera.inertialBetaOffset += this.angularSpeed;
                    }
                }
                else if (this.keysReset.indexOf(keyCode) !== -1) {
                    if (camera.useInputToRestoreState) {
                        camera.restoreState();
                    }
                }
            }
        }
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    ArcRotateCameraKeyboardMoveInput.prototype.getClassName = function () {
        return "ArcRotateCameraKeyboardMoveInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    ArcRotateCameraKeyboardMoveInput.prototype.getSimpleName = function () {
        return "keyboard";
    };
    __decorate([
        serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysUp", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysDown", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysLeft", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysRight", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysReset", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "panningSensibility", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "zoomingSensibility", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "useAltToZoom", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "angularSpeed", void 0);
    return ArcRotateCameraKeyboardMoveInput;
}());
CameraInputTypes["ArcRotateCameraKeyboardMoveInput"] = ArcRotateCameraKeyboardMoveInput;

/**
 * Manage the mouse wheel inputs to control an arc rotate camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var ArcRotateCameraMouseWheelInput = /** @class */ (function () {
    function ArcRotateCameraMouseWheelInput() {
        /**
         * Gets or Set the mouse wheel precision or how fast is the camera zooming.
         */
        this.wheelPrecision = 3.0;
        /**
         * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when wheel is used.
         */
        this.wheelDeltaPercentage = 0;
    }
    ArcRotateCameraMouseWheelInput.prototype.computeDeltaFromMouseWheelLegacyEvent = function (mouseWheelLegacyEvent, radius) {
        var delta = 0;
        var wheelDelta = (mouseWheelLegacyEvent.wheelDelta * 0.01 * this.wheelDeltaPercentage) * radius;
        if (mouseWheelLegacyEvent.wheelDelta > 0) {
            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);
        }
        else {
            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);
        }
        return delta;
    };
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    ArcRotateCameraMouseWheelInput.prototype.attachControl = function (element, noPreventDefault) {
        var _this = this;
        this._wheel = function (p, s) {
            //sanity check - this should be a PointerWheel event.
            if (p.type !== PointerEventTypes.POINTERWHEEL) {
                return;
            }
            var event = p.event;
            var delta = 0;
            var mouseWheelLegacyEvent = event;
            if (mouseWheelLegacyEvent.wheelDelta) {
                if (_this.wheelDeltaPercentage) {
                    delta = _this.computeDeltaFromMouseWheelLegacyEvent(mouseWheelLegacyEvent, _this.camera.radius);
                    // If zooming in, estimate the target radius and use that to compute the delta for inertia
                    // this will stop multiple scroll events zooming in from adding too much inertia
                    if (delta > 0) {
                        var estimatedTargetRadius = _this.camera.radius;
                        var targetInertia = _this.camera.inertialRadiusOffset + delta;
                        for (var i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {
                            estimatedTargetRadius -= targetInertia;
                            targetInertia *= _this.camera.inertia;
                        }
                        estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);
                        delta = _this.computeDeltaFromMouseWheelLegacyEvent(mouseWheelLegacyEvent, estimatedTargetRadius);
                    }
                }
                else {
                    delta = mouseWheelLegacyEvent.wheelDelta / (_this.wheelPrecision * 40);
                }
            }
            else {
                var deltaValue = event.deltaY || event.detail;
                delta = -deltaValue / _this.wheelPrecision;
            }
            if (delta) {
                _this.camera.inertialRadiusOffset += delta;
            }
            if (event.preventDefault) {
                if (!noPreventDefault) {
                    event.preventDefault();
                }
            }
        };
        this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    ArcRotateCameraMouseWheelInput.prototype.detachControl = function (element) {
        if (this._observer && element) {
            this.camera.getScene().onPointerObservable.remove(this._observer);
            this._observer = null;
            this._wheel = null;
        }
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    ArcRotateCameraMouseWheelInput.prototype.getClassName = function () {
        return "ArcRotateCameraMouseWheelInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    ArcRotateCameraMouseWheelInput.prototype.getSimpleName = function () {
        return "mousewheel";
    };
    __decorate([
        serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
    return ArcRotateCameraMouseWheelInput;
}());
CameraInputTypes["ArcRotateCameraMouseWheelInput"] = ArcRotateCameraMouseWheelInput;

/**
 * Base class for Camera Pointer Inputs.
 * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts
 * for example usage.
 */
var BaseCameraPointersInput = /** @class */ (function () {
    function BaseCameraPointersInput() {
        /**
         * Defines the buttons associated with the input to handle camera move.
         */
        this.buttons = [0, 1, 2];
    }
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    BaseCameraPointersInput.prototype.attachControl = function (element, noPreventDefault) {
        var _this = this;
        var engine = this.camera.getEngine();
        var previousPinchSquaredDistance = 0;
        var previousMultiTouchPanPosition = null;
        this.pointA = null;
        this.pointB = null;
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._buttonsPressed = 0;
        this._pointerInput = function (p, s) {
            var evt = p.event;
            var isTouch = evt.pointerType === "touch";
            if (engine.isInVRExclusivePointerMode) {
                return;
            }
            if (p.type !== PointerEventTypes.POINTERMOVE &&
                _this.buttons.indexOf(evt.button) === -1) {
                return;
            }
            var srcElement = (evt.srcElement || evt.target);
            _this._altKey = evt.altKey;
            _this._ctrlKey = evt.ctrlKey;
            _this._metaKey = evt.metaKey;
            _this._shiftKey = evt.shiftKey;
            _this._buttonsPressed = evt.buttons;
            if (engine.isPointerLock) {
                var offsetX = evt.movementX ||
                    evt.mozMovementX ||
                    evt.webkitMovementX ||
                    evt.msMovementX ||
                    0;
                var offsetY = evt.movementY ||
                    evt.mozMovementY ||
                    evt.webkitMovementY ||
                    evt.msMovementY ||
                    0;
                _this.onTouch(null, offsetX, offsetY);
                _this.pointA = null;
                _this.pointB = null;
            }
            else if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {
                try {
                    srcElement.setPointerCapture(evt.pointerId);
                }
                catch (e) {
                    //Nothing to do with the error. Execution will continue.
                }
                if (_this.pointA === null) {
                    _this.pointA = { x: evt.clientX,
                        y: evt.clientY,
                        pointerId: evt.pointerId,
                        type: evt.pointerType };
                }
                else if (_this.pointB === null) {
                    _this.pointB = { x: evt.clientX,
                        y: evt.clientY,
                        pointerId: evt.pointerId,
                        type: evt.pointerType };
                }
                _this.onButtonDown(evt);
                if (!noPreventDefault) {
                    evt.preventDefault();
                    element.focus();
                }
            }
            else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {
                _this.onDoubleTap(evt.pointerType);
            }
            else if (p.type === PointerEventTypes.POINTERUP && srcElement) {
                try {
                    srcElement.releasePointerCapture(evt.pointerId);
                }
                catch (e) {
                    //Nothing to do with the error.
                }
                if (!isTouch) {
                    _this.pointB = null; // Mouse and pen are mono pointer
                }
                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,
                //but emptying completely pointers collection is required to fix a bug on iPhone :
                //when changing orientation while pinching camera,
                //one pointer stay pressed forever if we don't release all pointers
                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected
                if (engine._badOS) {
                    _this.pointA = _this.pointB = null;
                }
                else {
                    //only remove the impacted pointer in case of multitouch allowing on most
                    //platforms switching from rotate to zoom and pan seamlessly.
                    if (_this.pointB && _this.pointA && _this.pointA.pointerId == evt.pointerId) {
                        _this.pointA = _this.pointB;
                        _this.pointB = null;
                    }
                    else if (_this.pointA && _this.pointB &&
                        _this.pointB.pointerId == evt.pointerId) {
                        _this.pointB = null;
                    }
                    else {
                        _this.pointA = _this.pointB = null;
                    }
                }
                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {
                    // Previous pinch data is populated but a button has been lifted
                    // so pinch has ended.
                    _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, 0, // pinchSquaredDistance
                    previousMultiTouchPanPosition, null // multiTouchPanPosition
                    );
                    previousPinchSquaredDistance = 0;
                    previousMultiTouchPanPosition = null;
                }
                _this.onButtonUp(evt);
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            }
            else if (p.type === PointerEventTypes.POINTERMOVE) {
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
                // One button down
                if (_this.pointA && _this.pointB === null) {
                    var offsetX = evt.clientX - _this.pointA.x;
                    var offsetY = evt.clientY - _this.pointA.y;
                    _this.onTouch(_this.pointA, offsetX, offsetY);
                    _this.pointA.x = evt.clientX;
                    _this.pointA.y = evt.clientY;
                }
                // Two buttons down: pinch
                else if (_this.pointA && _this.pointB) {
                    var ed = (_this.pointA.pointerId === evt.pointerId) ?
                        _this.pointA : _this.pointB;
                    ed.x = evt.clientX;
                    ed.y = evt.clientY;
                    var distX = _this.pointA.x - _this.pointB.x;
                    var distY = _this.pointA.y - _this.pointB.y;
                    var pinchSquaredDistance = (distX * distX) + (distY * distY);
                    var multiTouchPanPosition = { x: (_this.pointA.x + _this.pointB.x) / 2,
                        y: (_this.pointA.y + _this.pointB.y) / 2,
                        pointerId: evt.pointerId,
                        type: p.type };
                    _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
                    previousMultiTouchPanPosition = multiTouchPanPosition;
                    previousPinchSquaredDistance = pinchSquaredDistance;
                }
            }
        };
        this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP |
            PointerEventTypes.POINTERMOVE);
        this._onLostFocus = function () {
            _this.pointA = _this.pointB = null;
            previousPinchSquaredDistance = 0;
            previousMultiTouchPanPosition = null;
            _this.onLostFocus();
        };
        element.addEventListener("contextmenu", this.onContextMenu.bind(this), false);
        Tools.RegisterTopRootEvents([
            { name: "blur", handler: this._onLostFocus }
        ]);
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    BaseCameraPointersInput.prototype.detachControl = function (element) {
        if (this._onLostFocus) {
            Tools.UnregisterTopRootEvents([
                { name: "blur", handler: this._onLostFocus }
            ]);
        }
        if (element && this._observer) {
            this.camera.getScene().onPointerObservable.remove(this._observer);
            this._observer = null;
            if (this.onContextMenu) {
                element.removeEventListener("contextmenu", this.onContextMenu);
            }
            this._onLostFocus = null;
        }
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._buttonsPressed = 0;
    };
    /**
     * Gets the class name of the current input.
     * @returns the class name
     */
    BaseCameraPointersInput.prototype.getClassName = function () {
        return "BaseCameraPointersInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    BaseCameraPointersInput.prototype.getSimpleName = function () {
        return "pointers";
    };
    /**
     * Called on pointer POINTERDOUBLETAP event.
     * Override this method to provide functionality on POINTERDOUBLETAP event.
     */
    BaseCameraPointersInput.prototype.onDoubleTap = function (type) {
    };
    /**
     * Called on pointer POINTERMOVE event if only a single touch is active.
     * Override this method to provide functionality.
     */
    BaseCameraPointersInput.prototype.onTouch = function (point, offsetX, offsetY) {
    };
    /**
     * Called on pointer POINTERMOVE event if multiple touches are active.
     * Override this method to provide functionality.
     */
    BaseCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
    };
    /**
     * Called on JS contextmenu event.
     * Override this method to provide functionality.
     */
    BaseCameraPointersInput.prototype.onContextMenu = function (evt) {
        evt.preventDefault();
    };
    /**
     * Called each time a new POINTERDOWN event occurs. Ie, for each button
     * press.
     * Override this method to provide functionality.
     */
    BaseCameraPointersInput.prototype.onButtonDown = function (evt) {
    };
    /**
     * Called each time a new POINTERUP event occurs. Ie, for each button
     * release.
     * Override this method to provide functionality.
     */
    BaseCameraPointersInput.prototype.onButtonUp = function (evt) {
    };
    /**
     * Called when window becomes inactive.
     * Override this method to provide functionality.
     */
    BaseCameraPointersInput.prototype.onLostFocus = function () {
    };
    __decorate([
        serialize()
    ], BaseCameraPointersInput.prototype, "buttons", void 0);
    return BaseCameraPointersInput;
}());

/**
 * Manage the pointers inputs to control an arc rotate camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var ArcRotateCameraPointersInput = /** @class */ (function (_super) {
    __extends(ArcRotateCameraPointersInput, _super);
    function ArcRotateCameraPointersInput() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Defines the buttons associated with the input to handle camera move.
         */
        _this.buttons = [0, 1, 2];
        /**
         * Defines the pointer angular sensibility  along the X axis or how fast is
         * the camera rotating.
         */
        _this.angularSensibilityX = 1000.0;
        /**
         * Defines the pointer angular sensibility along the Y axis or how fast is
         * the camera rotating.
         */
        _this.angularSensibilityY = 1000.0;
        /**
         * Defines the pointer pinch precision or how fast is the camera zooming.
         */
        _this.pinchPrecision = 12.0;
        /**
         * pinchDeltaPercentage will be used instead of pinchPrecision if different
         * from 0.
         * It defines the percentage of current camera.radius to use as delta when
         * pinch zoom is used.
         */
        _this.pinchDeltaPercentage = 0;
        /**
         * Defines the pointer panning sensibility or how fast is the camera moving.
         */
        _this.panningSensibility = 1000.0;
        /**
         * Defines whether panning (2 fingers swipe) is enabled through multitouch.
         */
        _this.multiTouchPanning = true;
        /**
         * Defines whether panning is enabled for both pan (2 fingers swipe) and
         * zoom (pinch) through multitouch.
         */
        _this.multiTouchPanAndZoom = true;
        /**
         * Revers pinch action direction.
         */
        _this.pinchInwards = true;
        _this._isPanClick = false;
        _this._twoFingerActivityCount = 0;
        _this._isPinching = false;
        return _this;
    }
    /**
     * Gets the class name of the current input.
     * @returns the class name
     */
    ArcRotateCameraPointersInput.prototype.getClassName = function () {
        return "ArcRotateCameraPointersInput";
    };
    /**
     * Called on pointer POINTERMOVE event if only a single touch is active.
     */
    ArcRotateCameraPointersInput.prototype.onTouch = function (point, offsetX, offsetY) {
        if (this.panningSensibility !== 0 &&
            ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {
            this.camera.inertialPanningX += -offsetX / this.panningSensibility;
            this.camera.inertialPanningY += offsetY / this.panningSensibility;
        }
        else {
            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;
            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;
        }
    };
    /**
     * Called on pointer POINTERDOUBLETAP event.
     */
    ArcRotateCameraPointersInput.prototype.onDoubleTap = function (type) {
        if (this.camera.useInputToRestoreState) {
            this.camera.restoreState();
        }
    };
    /**
     * Called on pointer POINTERMOVE event if multiple touches are active.
     */
    ArcRotateCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
            // First time this method is called for new pinch.
            // Next time this is called there will be a
            // previousPinchSquaredDistance and pinchSquaredDistance to compare.
            return;
        }
        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
            // Last time this method is called at the end of a pinch.
            return;
        }
        var direction = this.pinchInwards ? 1 : -1;
        if (this.multiTouchPanAndZoom) {
            if (this.pinchDeltaPercentage) {
                this.camera.inertialRadiusOffset +=
                    (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 *
                        this.camera.radius * this.pinchDeltaPercentage;
            }
            else {
                this.camera.inertialRadiusOffset +=
                    (pinchSquaredDistance - previousPinchSquaredDistance) /
                        (this.pinchPrecision * direction *
                            (this.angularSensibilityX + this.angularSensibilityY) / 2);
            }
            if (this.panningSensibility !== 0 &&
                previousMultiTouchPanPosition && multiTouchPanPosition) {
                var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
                var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
                this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;
                this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;
            }
        }
        else {
            this._twoFingerActivityCount++;
            var previousPinchDistance = Math.sqrt(previousPinchSquaredDistance);
            var pinchDistance = Math.sqrt(pinchSquaredDistance);
            if (this._isPinching ||
                (this._twoFingerActivityCount < 20 &&
                    Math.abs(pinchDistance - previousPinchDistance) >
                        this.camera.pinchToPanMaxDistance)) {
                // Since pinch has not been active long, assume we intend to zoom.
                if (this.pinchDeltaPercentage) {
                    this.camera.inertialRadiusOffset +=
                        (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 *
                            this.camera.radius * this.pinchDeltaPercentage;
                }
                else {
                    this.camera.inertialRadiusOffset +=
                        (pinchSquaredDistance - previousPinchSquaredDistance) /
                            (this.pinchPrecision * direction *
                                (this.angularSensibilityX + this.angularSensibilityY) / 2);
                }
                // Since we are pinching, remain pinching on next iteration.
                this._isPinching = true;
            }
            else {
                // Pause between pinch starting and moving implies not a zoom event.
                // Pan instead.
                if (this.panningSensibility !== 0 && this.multiTouchPanning &&
                    multiTouchPanPosition && previousMultiTouchPanPosition) {
                    var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
                    var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
                    this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;
                    this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;
                }
            }
        }
    };
    /**
     * Called each time a new POINTERDOWN event occurs. Ie, for each button
     * press.
     */
    ArcRotateCameraPointersInput.prototype.onButtonDown = function (evt) {
        this._isPanClick = evt.button === this.camera._panningMouseButton;
    };
    /**
     * Called each time a new POINTERUP event occurs. Ie, for each button
     * release.
     */
    ArcRotateCameraPointersInput.prototype.onButtonUp = function (evt) {
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
    };
    /**
     * Called when window becomes inactive.
     */
    ArcRotateCameraPointersInput.prototype.onLostFocus = function () {
        this._isPanClick = false;
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
    };
    __decorate([
        serialize()
    ], ArcRotateCameraPointersInput.prototype, "buttons", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraPointersInput.prototype, "angularSensibilityX", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraPointersInput.prototype, "angularSensibilityY", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchPrecision", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchDeltaPercentage", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraPointersInput.prototype, "panningSensibility", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraPointersInput.prototype, "multiTouchPanning", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraPointersInput.prototype, "multiTouchPanAndZoom", void 0);
    return ArcRotateCameraPointersInput;
}(BaseCameraPointersInput));
CameraInputTypes["ArcRotateCameraPointersInput"] =
    ArcRotateCameraPointersInput;

/**
 * Default Inputs manager for the ArcRotateCamera.
 * It groups all the default supported inputs for ease of use.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var ArcRotateCameraInputsManager = /** @class */ (function (_super) {
    __extends(ArcRotateCameraInputsManager, _super);
    /**
     * Instantiates a new ArcRotateCameraInputsManager.
     * @param camera Defines the camera the inputs belong to
     */
    function ArcRotateCameraInputsManager(camera) {
        return _super.call(this, camera) || this;
    }
    /**
     * Add mouse wheel input support to the input manager.
     * @returns the current input manager
     */
    ArcRotateCameraInputsManager.prototype.addMouseWheel = function () {
        this.add(new ArcRotateCameraMouseWheelInput());
        return this;
    };
    /**
     * Add pointers input support to the input manager.
     * @returns the current input manager
     */
    ArcRotateCameraInputsManager.prototype.addPointers = function () {
        this.add(new ArcRotateCameraPointersInput());
        return this;
    };
    /**
     * Add keyboard input support to the input manager.
     * @returns the current input manager
     */
    ArcRotateCameraInputsManager.prototype.addKeyboard = function () {
        this.add(new ArcRotateCameraKeyboardMoveInput());
        return this;
    };
    return ArcRotateCameraInputsManager;
}(CameraInputsManager));

/**
 * Add orientation input support to the input manager.
 * @returns the current input manager
 */
ArcRotateCameraInputsManager.prototype.addVRDeviceOrientation = function () {
    this.add(new ArcRotateCameraVRDeviceOrientationInput());
    return this;
};
/**
 * Manage the device orientation inputs (gyroscope) to control an arc rotate camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var ArcRotateCameraVRDeviceOrientationInput = /** @class */ (function () {
    /**
     * Instantiate a new ArcRotateCameraVRDeviceOrientationInput.
     */
    function ArcRotateCameraVRDeviceOrientationInput() {
        /**
         * Defines a correction factor applied on the alpha value retrieved from the orientation events.
         */
        this.alphaCorrection = 1;
        /**
         * Defines a correction factor applied on the gamma value retrieved from the orientation events.
         */
        this.gammaCorrection = 1;
        this._alpha = 0;
        this._gamma = 0;
        this._dirty = false;
        this._deviceOrientationHandler = this._onOrientationEvent.bind(this);
    }
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    ArcRotateCameraVRDeviceOrientationInput.prototype.attachControl = function (element, noPreventDefault) {
        this.camera.attachControl(element, noPreventDefault);
        window.addEventListener("deviceorientation", this._deviceOrientationHandler);
    };
    /** @hidden */
    ArcRotateCameraVRDeviceOrientationInput.prototype._onOrientationEvent = function (evt) {
        if (evt.alpha !== null) {
            this._alpha = (+evt.alpha | 0) * this.alphaCorrection;
        }
        if (evt.gamma !== null) {
            this._gamma = (+evt.gamma | 0) * this.gammaCorrection;
        }
        this._dirty = true;
    };
    /**
     * Update the current camera state depending on the inputs that have been used this frame.
     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
     */
    ArcRotateCameraVRDeviceOrientationInput.prototype.checkInputs = function () {
        if (this._dirty) {
            this._dirty = false;
            if (this._gamma < 0) {
                this._gamma = 180 + this._gamma;
            }
            this.camera.alpha = (-this._alpha / 180.0 * Math.PI) % Math.PI * 2;
            this.camera.beta = (this._gamma / 180.0 * Math.PI);
        }
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    ArcRotateCameraVRDeviceOrientationInput.prototype.detachControl = function (element) {
        window.removeEventListener("deviceorientation", this._deviceOrientationHandler);
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    ArcRotateCameraVRDeviceOrientationInput.prototype.getClassName = function () {
        return "ArcRotateCameraVRDeviceOrientationInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    ArcRotateCameraVRDeviceOrientationInput.prototype.getSimpleName = function () {
        return "VRDeviceOrientation";
    };
    return ArcRotateCameraVRDeviceOrientationInput;
}());
CameraInputTypes["ArcRotateCameraVRDeviceOrientationInput"] = ArcRotateCameraVRDeviceOrientationInput;

/**
 * Listen to keyboard events to control the camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FlyCameraKeyboardInput = /** @class */ (function () {
    function FlyCameraKeyboardInput() {
        /**
         * The list of keyboard keys used to control the forward move of the camera.
         */
        this.keysForward = [87];
        /**
         * The list of keyboard keys used to control the backward move of the camera.
         */
        this.keysBackward = [83];
        /**
         * The list of keyboard keys used to control the forward move of the camera.
         */
        this.keysUp = [69];
        /**
         * The list of keyboard keys used to control the backward move of the camera.
         */
        this.keysDown = [81];
        /**
         * The list of keyboard keys used to control the right strafe move of the camera.
         */
        this.keysRight = [68];
        /**
         * The list of keyboard keys used to control the left strafe move of the camera.
         */
        this.keysLeft = [65];
        this._keys = new Array();
    }
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    FlyCameraKeyboardInput.prototype.attachControl = function (element, noPreventDefault) {
        var _this = this;
        if (this._onCanvasBlurObserver) {
            return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function () {
            _this._keys = [];
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function (info) {
            var evt = info.event;
            if (info.type === KeyboardEventTypes.KEYDOWN) {
                if (_this.keysForward.indexOf(evt.keyCode) !== -1 ||
                    _this.keysBackward.indexOf(evt.keyCode) !== -1 ||
                    _this.keysUp.indexOf(evt.keyCode) !== -1 ||
                    _this.keysDown.indexOf(evt.keyCode) !== -1 ||
                    _this.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    _this.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = _this._keys.indexOf(evt.keyCode);
                    if (index === -1) {
                        _this._keys.push(evt.keyCode);
                    }
                    if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                }
            }
            else {
                if (_this.keysForward.indexOf(evt.keyCode) !== -1 ||
                    _this.keysBackward.indexOf(evt.keyCode) !== -1 ||
                    _this.keysUp.indexOf(evt.keyCode) !== -1 ||
                    _this.keysDown.indexOf(evt.keyCode) !== -1 ||
                    _this.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    _this.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = _this._keys.indexOf(evt.keyCode);
                    if (index >= 0) {
                        _this._keys.splice(index, 1);
                    }
                    if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                }
            }
        });
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    FlyCameraKeyboardInput.prototype.detachControl = function (element) {
        if (this._scene) {
            if (this._onKeyboardObserver) {
                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
            }
            if (this._onCanvasBlurObserver) {
                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
            }
            this._onKeyboardObserver = null;
            this._onCanvasBlurObserver = null;
        }
        this._keys = [];
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    FlyCameraKeyboardInput.prototype.getClassName = function () {
        return "FlyCameraKeyboardInput";
    };
    /** @hidden */
    FlyCameraKeyboardInput.prototype._onLostFocus = function (e) {
        this._keys = [];
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    FlyCameraKeyboardInput.prototype.getSimpleName = function () {
        return "keyboard";
    };
    /**
     * Update the current camera state depending on the inputs that have been used this frame.
     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
     */
    FlyCameraKeyboardInput.prototype.checkInputs = function () {
        if (this._onKeyboardObserver) {
            var camera = this.camera;
            // Keyboard
            for (var index = 0; index < this._keys.length; index++) {
                var keyCode = this._keys[index];
                var speed = camera._computeLocalCameraSpeed();
                if (this.keysForward.indexOf(keyCode) !== -1) {
                    camera._localDirection.copyFromFloats(0, 0, speed);
                }
                else if (this.keysBackward.indexOf(keyCode) !== -1) {
                    camera._localDirection.copyFromFloats(0, 0, -speed);
                }
                else if (this.keysUp.indexOf(keyCode) !== -1) {
                    camera._localDirection.copyFromFloats(0, speed, 0);
                }
                else if (this.keysDown.indexOf(keyCode) !== -1) {
                    camera._localDirection.copyFromFloats(0, -speed, 0);
                }
                else if (this.keysRight.indexOf(keyCode) !== -1) {
                    camera._localDirection.copyFromFloats(speed, 0, 0);
                }
                else if (this.keysLeft.indexOf(keyCode) !== -1) {
                    camera._localDirection.copyFromFloats(-speed, 0, 0);
                }
                if (camera.getScene().useRightHandedSystem) {
                    camera._localDirection.z *= -1;
                }
                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
                camera.cameraDirection.addInPlace(camera._transformedDirection);
            }
        }
    };
    __decorate([
        serialize()
    ], FlyCameraKeyboardInput.prototype, "keysForward", void 0);
    __decorate([
        serialize()
    ], FlyCameraKeyboardInput.prototype, "keysBackward", void 0);
    __decorate([
        serialize()
    ], FlyCameraKeyboardInput.prototype, "keysUp", void 0);
    __decorate([
        serialize()
    ], FlyCameraKeyboardInput.prototype, "keysDown", void 0);
    __decorate([
        serialize()
    ], FlyCameraKeyboardInput.prototype, "keysRight", void 0);
    __decorate([
        serialize()
    ], FlyCameraKeyboardInput.prototype, "keysLeft", void 0);
    return FlyCameraKeyboardInput;
}());
CameraInputTypes["FlyCameraKeyboardInput"] = FlyCameraKeyboardInput;

/**
 * Listen to mouse events to control the camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FlyCameraMouseInput = /** @class */ (function () {
    /**
     * Listen to mouse events to control the camera.
     * @param touchEnabled Define if touch is enabled. (Default is true.)
     * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    function FlyCameraMouseInput(touchEnabled) {
        /**
         * Defines the buttons associated with the input to handle camera rotation.
         */
        this.buttons = [0, 1, 2];
        /**
         * Assign buttons for Yaw control.
         */
        this.buttonsYaw = [-1, 0, 1];
        /**
        * Assign buttons for Pitch control.
        */
        this.buttonsPitch = [-1, 0, 1];
        /**
        * Assign buttons for Roll control.
        */
        this.buttonsRoll = [2];
        /**
         * Detect if any button is being pressed while mouse is moved.
         * -1 = Mouse locked.
         * 0 = Left button.
         * 1 = Middle Button.
         * 2 = Right Button.
         */
        this.activeButton = -1;
        /**
         * Defines the pointer's angular sensibility, to control the camera rotation speed.
         * Higher values reduce its sensitivity.
         */
        this.angularSensibility = 1000.0;
        this.previousPosition = null;
    }
    /**
     * Attach the mouse control to the HTML DOM element.
     * @param element Defines the element that listens to the input events.
     * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().
     */
    FlyCameraMouseInput.prototype.attachControl = function (element, noPreventDefault) {
        var _this = this;
        this.element = element;
        this.noPreventDefault = noPreventDefault;
        this._observer = this.camera.getScene().onPointerObservable.add(function (p, s) {
            _this._pointerInput(p, s);
        }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
        // Correct Roll by rate, if enabled.
        this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(function () {
            if (_this.camera.rollCorrect) {
                _this.camera.restoreRoll(_this.camera.rollCorrect);
            }
        });
        // Helper function to keep 'this'.
        this._mousemoveCallback = function (e) {
            _this._onMouseMove(e);
        };
        element.addEventListener("mousemove", this._mousemoveCallback, false);
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    FlyCameraMouseInput.prototype.detachControl = function (element) {
        if (this._observer && element) {
            this.camera.getScene().onPointerObservable.remove(this._observer);
            this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);
            if (this._mousemoveCallback) {
                element.removeEventListener("mousemove", this._mousemoveCallback);
            }
            this._observer = null;
            this._rollObserver = null;
            this.previousPosition = null;
            this.noPreventDefault = undefined;
        }
    };
    /**
     * Gets the class name of the current input.
     * @returns the class name.
     */
    FlyCameraMouseInput.prototype.getClassName = function () {
        return "FlyCameraMouseInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input's friendly name.
     */
    FlyCameraMouseInput.prototype.getSimpleName = function () {
        return "mouse";
    };
    // Track mouse movement, when the pointer is not locked.
    FlyCameraMouseInput.prototype._pointerInput = function (p, s) {
        var e = p.event;
        var camera = this.camera;
        var engine = camera.getEngine();
        if (engine.isInVRExclusivePointerMode) {
            return;
        }
        if (!this.touchEnabled && e.pointerType === "touch") {
            return;
        }
        // Mouse is moved but an unknown mouse button is pressed.
        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {
            return;
        }
        var srcElement = (e.srcElement || e.target);
        // Mouse down.
        if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {
            try {
                srcElement.setPointerCapture(e.pointerId);
            }
            catch (e) {
                // Nothing to do with the error. Execution continues.
            }
            this.previousPosition = {
                x: e.clientX,
                y: e.clientY
            };
            this.activeButton = e.button;
            if (!this.noPreventDefault) {
                e.preventDefault();
                this.element.focus();
            }
        }
        else 
        // Mouse up.
        if (p.type === PointerEventTypes.POINTERUP && srcElement) {
            try {
                srcElement.releasePointerCapture(e.pointerId);
            }
            catch (e) {
                // Nothing to do with the error. Execution continues.
            }
            this.activeButton = -1;
            this.previousPosition = null;
            if (!this.noPreventDefault) {
                e.preventDefault();
            }
        }
        else 
        // Mouse move.
        if (p.type === PointerEventTypes.POINTERMOVE) {
            if (!this.previousPosition || engine.isPointerLock) {
                return;
            }
            var offsetX = e.clientX - this.previousPosition.x;
            var offsetY = e.clientY - this.previousPosition.y;
            this.rotateCamera(offsetX, offsetY);
            this.previousPosition = {
                x: e.clientX,
                y: e.clientY
            };
            if (!this.noPreventDefault) {
                e.preventDefault();
            }
        }
    };
    // Track mouse movement, when pointer is locked.
    FlyCameraMouseInput.prototype._onMouseMove = function (e) {
        var camera = this.camera;
        var engine = camera.getEngine();
        if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {
            return;
        }
        var offsetX = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0;
        var offsetY = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;
        this.rotateCamera(offsetX, offsetY);
        this.previousPosition = null;
        if (!this.noPreventDefault) {
            e.preventDefault();
        }
    };
    /**
     * Rotate camera by mouse offset.
     */
    FlyCameraMouseInput.prototype.rotateCamera = function (offsetX, offsetY) {
        var _this = this;
        var camera = this.camera;
        var scene = this.camera.getScene();
        if (scene.useRightHandedSystem) {
            offsetX *= -1;
        }
        if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {
            offsetX *= -1;
        }
        var x = offsetX / this.angularSensibility;
        var y = offsetY / this.angularSensibility;
        // Initialize to current rotation.
        var currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);
        var rotationChange;
        // Pitch.
        if (this.buttonsPitch.some(function (v) { return v === _this.activeButton; })) {
            // Apply change in Radians to vector Angle.
            rotationChange = Quaternion.RotationAxis(Axis.X, y);
            // Apply Pitch to quaternion.
            currentRotation.multiplyInPlace(rotationChange);
        }
        // Yaw.
        if (this.buttonsYaw.some(function (v) { return v === _this.activeButton; })) {
            // Apply change in Radians to vector Angle.
            rotationChange = Quaternion.RotationAxis(Axis.Y, x);
            // Apply Yaw to quaternion.
            currentRotation.multiplyInPlace(rotationChange);
            // Add Roll, if banked turning is enabled, within Roll limit.
            var limit = (camera.bankedTurnLimit) + camera._trackRoll; // Defaults to 90 plus manual roll.
            if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {
                var bankingDelta = camera.bankedTurnMultiplier * -x;
                // Apply change in Radians to vector Angle.
                rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);
                // Apply Yaw to quaternion.
                currentRotation.multiplyInPlace(rotationChange);
            }
        }
        // Roll.
        if (this.buttonsRoll.some(function (v) { return v === _this.activeButton; })) {
            // Apply change in Radians to vector Angle.
            rotationChange = Quaternion.RotationAxis(Axis.Z, -x);
            // Track Rolling.
            camera._trackRoll -= x;
            // Apply Pitch to quaternion.
            currentRotation.multiplyInPlace(rotationChange);
        }
        // Apply rotationQuaternion to Euler camera.rotation.
        currentRotation.toEulerAnglesToRef(camera.rotation);
    };
    __decorate([
        serialize()
    ], FlyCameraMouseInput.prototype, "buttons", void 0);
    __decorate([
        serialize()
    ], FlyCameraMouseInput.prototype, "angularSensibility", void 0);
    return FlyCameraMouseInput;
}());
CameraInputTypes["FlyCameraMouseInput"] = FlyCameraMouseInput;

/**
 * Manage the keyboard inputs to control the movement of a follow camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FollowCameraKeyboardMoveInput = /** @class */ (function () {
    function FollowCameraKeyboardMoveInput() {
        /**
         * Defines the list of key codes associated with the up action (increase heightOffset)
         */
        this.keysHeightOffsetIncr = [38];
        /**
         * Defines the list of key codes associated with the down action (decrease heightOffset)
         */
        this.keysHeightOffsetDecr = [40];
        /**
         * Defines whether the Alt modifier key is required to move up/down (alter heightOffset)
         */
        this.keysHeightOffsetModifierAlt = false;
        /**
         * Defines whether the Ctrl modifier key is required to move up/down (alter heightOffset)
         */
        this.keysHeightOffsetModifierCtrl = false;
        /**
         * Defines whether the Shift modifier key is required to move up/down (alter heightOffset)
         */
        this.keysHeightOffsetModifierShift = false;
        /**
         * Defines the list of key codes associated with the left action (increase rotationOffset)
         */
        this.keysRotationOffsetIncr = [37];
        /**
         * Defines the list of key codes associated with the right action (decrease rotationOffset)
         */
        this.keysRotationOffsetDecr = [39];
        /**
         * Defines whether the Alt modifier key is required to move left/right (alter rotationOffset)
         */
        this.keysRotationOffsetModifierAlt = false;
        /**
         * Defines whether the Ctrl modifier key is required to move left/right (alter rotationOffset)
         */
        this.keysRotationOffsetModifierCtrl = false;
        /**
         * Defines whether the Shift modifier key is required to move left/right (alter rotationOffset)
         */
        this.keysRotationOffsetModifierShift = false;
        /**
         * Defines the list of key codes associated with the zoom-in action (decrease radius)
         */
        this.keysRadiusIncr = [40];
        /**
         * Defines the list of key codes associated with the zoom-out action (increase radius)
         */
        this.keysRadiusDecr = [38];
        /**
         * Defines whether the Alt modifier key is required to zoom in/out (alter radius value)
         */
        this.keysRadiusModifierAlt = true;
        /**
         * Defines whether the Ctrl modifier key is required to zoom in/out (alter radius value)
         */
        this.keysRadiusModifierCtrl = false;
        /**
         * Defines whether the Shift modifier key is required to zoom in/out (alter radius value)
         */
        this.keysRadiusModifierShift = false;
        /**
         * Defines the rate of change of heightOffset.
         */
        this.heightSensibility = 1;
        /**
         * Defines the rate of change of rotationOffset.
         */
        this.rotationSensibility = 1;
        /**
         * Defines the rate of change of radius.
         */
        this.radiusSensibility = 1;
        this._keys = new Array();
    }
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    FollowCameraKeyboardMoveInput.prototype.attachControl = function (element, noPreventDefault) {
        var _this = this;
        if (this._onCanvasBlurObserver) {
            return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function () {
            _this._keys = [];
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function (info) {
            var evt = info.event;
            if (!evt.metaKey) {
                if (info.type === KeyboardEventTypes.KEYDOWN) {
                    _this._ctrlPressed = evt.ctrlKey;
                    _this._altPressed = evt.altKey;
                    _this._shiftPressed = evt.shiftKey;
                    if (_this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {
                        var index = _this._keys.indexOf(evt.keyCode);
                        if (index === -1) {
                            _this._keys.push(evt.keyCode);
                        }
                        if (evt.preventDefault) {
                            if (!noPreventDefault) {
                                evt.preventDefault();
                            }
                        }
                    }
                }
                else {
                    if (_this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||
                        _this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {
                        var index = _this._keys.indexOf(evt.keyCode);
                        if (index >= 0) {
                            _this._keys.splice(index, 1);
                        }
                        if (evt.preventDefault) {
                            if (!noPreventDefault) {
                                evt.preventDefault();
                            }
                        }
                    }
                }
            }
        });
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    FollowCameraKeyboardMoveInput.prototype.detachControl = function (element) {
        if (this._scene) {
            if (this._onKeyboardObserver) {
                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
            }
            if (this._onCanvasBlurObserver) {
                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
            }
            this._onKeyboardObserver = null;
            this._onCanvasBlurObserver = null;
        }
        this._keys = [];
    };
    /**
     * Update the current camera state depending on the inputs that have been used this frame.
     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
     */
    FollowCameraKeyboardMoveInput.prototype.checkInputs = function () {
        var _this = this;
        if (this._onKeyboardObserver) {
            this._keys.forEach(function (keyCode) {
                if (_this.keysHeightOffsetIncr.indexOf(keyCode) !== -1 &&
                    _this._modifierHeightOffset()) {
                    _this.camera.heightOffset += _this.heightSensibility;
                }
                else if (_this.keysHeightOffsetDecr.indexOf(keyCode) !== -1 &&
                    _this._modifierHeightOffset()) {
                    _this.camera.heightOffset -= _this.heightSensibility;
                }
                else if (_this.keysRotationOffsetIncr.indexOf(keyCode) !== -1 &&
                    _this._modifierRotationOffset()) {
                    _this.camera.rotationOffset += _this.rotationSensibility;
                    _this.camera.rotationOffset %= 360;
                }
                else if (_this.keysRotationOffsetDecr.indexOf(keyCode) !== -1 &&
                    _this._modifierRotationOffset()) {
                    _this.camera.rotationOffset -= _this.rotationSensibility;
                    _this.camera.rotationOffset %= 360;
                }
                else if (_this.keysRadiusIncr.indexOf(keyCode) !== -1 &&
                    _this._modifierRadius()) {
                    _this.camera.radius += _this.radiusSensibility;
                }
                else if (_this.keysRadiusDecr.indexOf(keyCode) !== -1 &&
                    _this._modifierRadius()) {
                    _this.camera.radius -= _this.radiusSensibility;
                }
            });
        }
    };
    /**
     * Gets the class name of the current input.
     * @returns the class name
     */
    FollowCameraKeyboardMoveInput.prototype.getClassName = function () {
        return "FollowCameraKeyboardMoveInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    FollowCameraKeyboardMoveInput.prototype.getSimpleName = function () {
        return "keyboard";
    };
    /**
     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to
     * allow modification of the heightOffset value.
     */
    FollowCameraKeyboardMoveInput.prototype._modifierHeightOffset = function () {
        return (this.keysHeightOffsetModifierAlt === this._altPressed &&
            this.keysHeightOffsetModifierCtrl === this._ctrlPressed &&
            this.keysHeightOffsetModifierShift === this._shiftPressed);
    };
    /**
     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to
     * allow modification of the rotationOffset value.
     */
    FollowCameraKeyboardMoveInput.prototype._modifierRotationOffset = function () {
        return (this.keysRotationOffsetModifierAlt === this._altPressed &&
            this.keysRotationOffsetModifierCtrl === this._ctrlPressed &&
            this.keysRotationOffsetModifierShift === this._shiftPressed);
    };
    /**
     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to
     * allow modification of the radius value.
     */
    FollowCameraKeyboardMoveInput.prototype._modifierRadius = function () {
        return (this.keysRadiusModifierAlt === this._altPressed &&
            this.keysRadiusModifierCtrl === this._ctrlPressed &&
            this.keysRadiusModifierShift === this._shiftPressed);
    };
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetIncr", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetDecr", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetModifierAlt", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetModifierCtrl", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetModifierShift", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetIncr", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetDecr", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetModifierAlt", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetModifierCtrl", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetModifierShift", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusIncr", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusDecr", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusModifierAlt", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusModifierCtrl", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusModifierShift", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "heightSensibility", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "rotationSensibility", void 0);
    __decorate([
        serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "radiusSensibility", void 0);
    return FollowCameraKeyboardMoveInput;
}());
CameraInputTypes["FollowCameraKeyboardMoveInput"] = FollowCameraKeyboardMoveInput;

/**
 * Manage the mouse wheel inputs to control a follow camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FollowCameraMouseWheelInput = /** @class */ (function () {
    function FollowCameraMouseWheelInput() {
        /**
         * Moue wheel controls zoom. (Mouse wheel modifies camera.radius value.)
         */
        this.axisControlRadius = true;
        /**
         * Moue wheel controls height. (Mouse wheel modifies camera.heightOffset value.)
         */
        this.axisControlHeight = false;
        /**
         * Moue wheel controls angle. (Mouse wheel modifies camera.rotationOffset value.)
         */
        this.axisControlRotation = false;
        /**
         * Gets or Set the mouse wheel precision or how fast is the camera moves in
         * relation to mouseWheel events.
         */
        this.wheelPrecision = 3.0;
        /**
         * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when wheel is used.
         */
        this.wheelDeltaPercentage = 0;
    }
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    FollowCameraMouseWheelInput.prototype.attachControl = function (element, noPreventDefault) {
        var _this = this;
        this._wheel = function (p, s) {
            // sanity check - this should be a PointerWheel event.
            if (p.type !== PointerEventTypes.POINTERWHEEL) {
                return;
            }
            var event = p.event;
            var delta = 0;
            // Chrome, Safari: event.deltaY
            // IE: event.wheelDelta
            // Firefox: event.detail (inverted)
            var wheelDelta = Math.max(-1, Math.min(1, (event.deltaY || event.wheelDelta || -event.detail)));
            if (_this.wheelDeltaPercentage) {
                console.assert((_this.axisControlRadius +
                    _this.axisControlHeight +
                    _this.axisControlRotation) <= 1, "wheelDeltaPercentage only usable when mouse wheel " +
                    "controlls ONE axis. " +
                    "Currently enabled: " +
                    "axisControlRadius: " + _this.axisControlRadius +
                    ", axisControlHeightOffset: " + _this.axisControlHeight +
                    ", axisControlRotationOffset: " + _this.axisControlRotation);
                if (_this.axisControlRadius) {
                    delta =
                        wheelDelta * 0.01 * _this.wheelDeltaPercentage *
                            _this.camera.radius;
                }
                else if (_this.axisControlHeight) {
                    delta =
                        wheelDelta * 0.01 * _this.wheelDeltaPercentage *
                            _this.camera.heightOffset;
                }
                else if (_this.axisControlRotation) {
                    delta =
                        wheelDelta * 0.01 * _this.wheelDeltaPercentage *
                            _this.camera.rotationOffset;
                }
            }
            else {
                delta = wheelDelta * _this.wheelPrecision;
            }
            if (delta) {
                if (_this.axisControlRadius) {
                    _this.camera.radius += delta;
                }
                else if (_this.axisControlHeight) {
                    _this.camera.heightOffset -= delta;
                }
                else if (_this.axisControlRotation) {
                    _this.camera.rotationOffset -= delta;
                }
            }
            if (event.preventDefault) {
                if (!noPreventDefault) {
                    event.preventDefault();
                }
            }
        };
        this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    FollowCameraMouseWheelInput.prototype.detachControl = function (element) {
        if (this._observer && element) {
            this.camera.getScene().onPointerObservable.remove(this._observer);
            this._observer = null;
            this._wheel = null;
        }
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    FollowCameraMouseWheelInput.prototype.getClassName = function () {
        return "ArcRotateCameraMouseWheelInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    FollowCameraMouseWheelInput.prototype.getSimpleName = function () {
        return "mousewheel";
    };
    __decorate([
        serialize()
    ], FollowCameraMouseWheelInput.prototype, "axisControlRadius", void 0);
    __decorate([
        serialize()
    ], FollowCameraMouseWheelInput.prototype, "axisControlHeight", void 0);
    __decorate([
        serialize()
    ], FollowCameraMouseWheelInput.prototype, "axisControlRotation", void 0);
    __decorate([
        serialize()
    ], FollowCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
    __decorate([
        serialize()
    ], FollowCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
    return FollowCameraMouseWheelInput;
}());
CameraInputTypes["FollowCameraMouseWheelInput"] = FollowCameraMouseWheelInput;

/**
 * Manage the pointers inputs to control an follow camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FollowCameraPointersInput = /** @class */ (function (_super) {
    __extends(FollowCameraPointersInput, _super);
    function FollowCameraPointersInput() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Defines the pointer angular sensibility along the X axis or how fast is
         * the camera rotating.
         * A negative number will reverse the axis direction.
         */
        _this.angularSensibilityX = 1;
        /**
         * Defines the pointer angular sensibility along the Y axis or how fast is
         * the camera rotating.
         * A negative number will reverse the axis direction.
         */
        _this.angularSensibilityY = 1;
        /**
         * Defines the pointer pinch precision or how fast is the camera zooming.
         * A negative number will reverse the axis direction.
         */
        _this.pinchPrecision = 10000.0;
        /**
         * pinchDeltaPercentage will be used instead of pinchPrecision if different
         * from 0.
         * It defines the percentage of current camera.radius to use as delta when
         * pinch zoom is used.
         */
        _this.pinchDeltaPercentage = 0;
        /**
         * Pointer X axis controls zoom. (X axis modifies camera.radius value.)
         */
        _this.axisXControlRadius = false;
        /**
         * Pointer X axis controls height. (X axis modifies camera.heightOffset value.)
         */
        _this.axisXControlHeight = false;
        /**
         * Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)
         */
        _this.axisXControlRotation = true;
        /**
         * Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)
         */
        _this.axisYControlRadius = false;
        /**
         * Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)
         */
        _this.axisYControlHeight = true;
        /**
         * Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)
         */
        _this.axisYControlRotation = false;
        /**
         * Pinch controls zoom. (Pinch modifies camera.radius value.)
         */
        _this.axisPinchControlRadius = true;
        /**
         * Pinch controls height. (Pinch modifies camera.heightOffset value.)
         */
        _this.axisPinchControlHeight = false;
        /**
         * Pinch controls angle. (Pinch modifies camera.rotationOffset value.)
         */
        _this.axisPinchControlRotation = false;
        /**
         * Log error messages if basic misconfiguration has occurred.
         */
        _this.warningEnable = true;
        /* Check for obvious misconfiguration. */
        _this._warningCounter = 0;
        return _this;
    }
    /**
     * Gets the class name of the current input.
     * @returns the class name
     */
    FollowCameraPointersInput.prototype.getClassName = function () {
        return "FollowCameraPointersInput";
    };
    FollowCameraPointersInput.prototype.onTouch = function (pointA, offsetX, offsetY) {
        this._warning();
        if (this.axisXControlRotation) {
            this.camera.rotationOffset += offsetX / this.angularSensibilityX;
        }
        else if (this.axisYControlRotation) {
            this.camera.rotationOffset += offsetY / this.angularSensibilityX;
        }
        if (this.axisXControlHeight) {
            this.camera.heightOffset += offsetX / this.angularSensibilityY;
        }
        else if (this.axisYControlHeight) {
            this.camera.heightOffset += offsetY / this.angularSensibilityY;
        }
        if (this.axisXControlRadius) {
            this.camera.radius -= offsetX / this.angularSensibilityY;
        }
        else if (this.axisYControlRadius) {
            this.camera.radius -= offsetY / this.angularSensibilityY;
        }
    };
    FollowCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
            // First time this method is called for new pinch.
            // Next time this is called there will be a
            // previousPinchSquaredDistance and pinchSquaredDistance to compare.
            return;
        }
        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
            // Last time this method is called at the end of a pinch.
            return;
        }
        var pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) /
            (this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY) / 2);
        if (this.pinchDeltaPercentage) {
            pinchDelta *= 0.01 * this.pinchDeltaPercentage;
            if (this.axisPinchControlRotation) {
                this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;
            }
            if (this.axisPinchControlHeight) {
                this.camera.heightOffset += pinchDelta * this.camera.heightOffset;
            }
            if (this.axisPinchControlRadius) {
                this.camera.radius -= pinchDelta * this.camera.radius;
            }
        }
        else {
            if (this.axisPinchControlRotation) {
                this.camera.rotationOffset += pinchDelta;
            }
            if (this.axisPinchControlHeight) {
                this.camera.heightOffset += pinchDelta;
            }
            if (this.axisPinchControlRadius) {
                this.camera.radius -= pinchDelta;
            }
        }
    };
    FollowCameraPointersInput.prototype._warning = function () {
        if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {
            return;
        }
        var warn = "It probably only makes sense to control ONE camera " +
            "property with each pointer axis. Set 'warningEnable = false' " +
            "if you are sure. Currently enabled: ";
        console.assert((this.axisXControlRotation +
            this.axisXControlHeight +
            this.axisXControlRadius) <= 1, warn +
            "axisXControlRotation: " + this.axisXControlRotation +
            ", axisXControlHeight: " + this.axisXControlHeight +
            ", axisXControlRadius: " + this.axisXControlRadius);
        console.assert((this.axisYControlRotation +
            this.axisYControlHeight +
            this.axisYControlRadius) <= 1, warn +
            "axisYControlRotation: " + this.axisYControlRotation +
            ", axisYControlHeight: " + this.axisYControlHeight +
            ", axisYControlRadius: " + this.axisYControlRadius);
        console.assert((this.axisPinchControlRotation +
            this.axisPinchControlHeight +
            this.axisPinchControlRadius) <= 1, warn +
            "axisPinchControlRotation: " + this.axisPinchControlRotation +
            ", axisPinchControlHeight: " + this.axisPinchControlHeight +
            ", axisPinchControlRadius: " + this.axisPinchControlRadius);
    };
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "angularSensibilityX", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "angularSensibilityY", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "pinchPrecision", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "pinchDeltaPercentage", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "axisXControlRadius", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "axisXControlHeight", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "axisXControlRotation", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "axisYControlRadius", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "axisYControlHeight", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "axisYControlRotation", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "axisPinchControlRadius", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "axisPinchControlHeight", void 0);
    __decorate([
        serialize()
    ], FollowCameraPointersInput.prototype, "axisPinchControlRotation", void 0);
    return FollowCameraPointersInput;
}(BaseCameraPointersInput));
CameraInputTypes["FollowCameraPointersInput"] = FollowCameraPointersInput;

/**
 * Add orientation input support to the input manager.
 * @returns the current input manager
 */
FreeCameraInputsManager.prototype.addDeviceOrientation = function () {
    if (!this._deviceOrientationInput) {
        this._deviceOrientationInput = new FreeCameraDeviceOrientationInput();
        this.add(this._deviceOrientationInput);
    }
    return this;
};
/**
 * Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.
 * Screen rotation is taken into account.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FreeCameraDeviceOrientationInput = /** @class */ (function () {
    /**
     * Instantiates a new input
     * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    function FreeCameraDeviceOrientationInput() {
        var _this = this;
        this._screenOrientationAngle = 0;
        this._screenQuaternion = new Quaternion();
        this._alpha = 0;
        this._beta = 0;
        this._gamma = 0;
        /**
         * @hidden
         */
        this._onDeviceOrientationChangedObservable = new Observable();
        this._orientationChanged = function () {
            _this._screenOrientationAngle = (window.orientation !== undefined ? +window.orientation : (window.screen.orientation && (window.screen.orientation)['angle'] ? (window.screen.orientation).angle : 0));
            _this._screenOrientationAngle = -Tools.ToRadians(_this._screenOrientationAngle / 2);
            _this._screenQuaternion.copyFromFloats(0, Math.sin(_this._screenOrientationAngle), 0, Math.cos(_this._screenOrientationAngle));
        };
        this._deviceOrientation = function (evt) {
            _this._alpha = evt.alpha !== null ? evt.alpha : 0;
            _this._beta = evt.beta !== null ? evt.beta : 0;
            _this._gamma = evt.gamma !== null ? evt.gamma : 0;
            if (evt.alpha !== null) {
                _this._onDeviceOrientationChangedObservable.notifyObservers();
            }
        };
        this._constantTranform = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
        this._orientationChanged();
    }
    Object.defineProperty(FreeCameraDeviceOrientationInput.prototype, "camera", {
        /**
         * Define the camera controlled by the input.
         */
        get: function () {
            return this._camera;
        },
        set: function (camera) {
            var _this = this;
            this._camera = camera;
            if (this._camera != null && !this._camera.rotationQuaternion) {
                this._camera.rotationQuaternion = new Quaternion();
            }
            if (this._camera) {
                this._camera.onDisposeObservable.add(function () {
                    _this._onDeviceOrientationChangedObservable.clear();
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    FreeCameraDeviceOrientationInput.prototype.attachControl = function (element, noPreventDefault) {
        window.addEventListener("orientationchange", this._orientationChanged);
        window.addEventListener("deviceorientation", this._deviceOrientation);
        //In certain cases, the attach control is called AFTER orientation was changed,
        //So this is needed.
        this._orientationChanged();
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    FreeCameraDeviceOrientationInput.prototype.detachControl = function (element) {
        window.removeEventListener("orientationchange", this._orientationChanged);
        window.removeEventListener("deviceorientation", this._deviceOrientation);
        this._alpha = 0;
    };
    /**
     * Update the current camera state depending on the inputs that have been used this frame.
     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
     */
    FreeCameraDeviceOrientationInput.prototype.checkInputs = function () {
        //if no device orientation provided, don't update the rotation.
        //Only testing against alpha under the assumption thatnorientation will never be so exact when set.
        if (!this._alpha) {
            return;
        }
        Quaternion.RotationYawPitchRollToRef(Tools.ToRadians(this._alpha), Tools.ToRadians(this._beta), -Tools.ToRadians(this._gamma), this.camera.rotationQuaternion);
        this._camera.rotationQuaternion.multiplyInPlace(this._screenQuaternion);
        this._camera.rotationQuaternion.multiplyInPlace(this._constantTranform);
        //Mirror on XY Plane
        this._camera.rotationQuaternion.z *= -1;
        this._camera.rotationQuaternion.w *= -1;
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    FreeCameraDeviceOrientationInput.prototype.getClassName = function () {
        return "FreeCameraDeviceOrientationInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    FreeCameraDeviceOrientationInput.prototype.getSimpleName = function () {
        return "deviceOrientation";
    };
    return FreeCameraDeviceOrientationInput;
}());
CameraInputTypes["FreeCameraDeviceOrientationInput"] = FreeCameraDeviceOrientationInput;

/**
 * Manage the gamepad inputs to control a free camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FreeCameraGamepadInput = /** @class */ (function () {
    function FreeCameraGamepadInput() {
        /**
         * Defines the gamepad rotation sensiblity.
         * This is the threshold from when rotation starts to be accounted for to prevent jittering.
         */
        this.gamepadAngularSensibility = 200;
        /**
         * Defines the gamepad move sensiblity.
         * This is the threshold from when moving starts to be accounted for for to prevent jittering.
         */
        this.gamepadMoveSensibility = 40;
        this._cameraTransform = Matrix.Identity();
        this._deltaTransform = Vector3.Zero();
        this._vector3 = Vector3.Zero();
        this._vector2 = Vector2.Zero();
    }
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    FreeCameraGamepadInput.prototype.attachControl = function (element, noPreventDefault) {
        var _this = this;
        var manager = this.camera.getScene().gamepadManager;
        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(function (gamepad) {
            if (gamepad.type !== Gamepad.POSE_ENABLED) {
                // prioritize XBOX gamepads.
                if (!_this.gamepad || gamepad.type === Gamepad.XBOX) {
                    _this.gamepad = gamepad;
                }
            }
        });
        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(function (gamepad) {
            if (_this.gamepad === gamepad) {
                _this.gamepad = null;
            }
        });
        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    FreeCameraGamepadInput.prototype.detachControl = function (element) {
        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
        this.gamepad = null;
    };
    /**
     * Update the current camera state depending on the inputs that have been used this frame.
     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
     */
    FreeCameraGamepadInput.prototype.checkInputs = function () {
        if (this.gamepad && this.gamepad.leftStick) {
            var camera = this.camera;
            var LSValues = this.gamepad.leftStick;
            var normalizedLX = LSValues.x / this.gamepadMoveSensibility;
            var normalizedLY = LSValues.y / this.gamepadMoveSensibility;
            LSValues.x = Math.abs(normalizedLX) > 0.005 ? 0 + normalizedLX : 0;
            LSValues.y = Math.abs(normalizedLY) > 0.005 ? 0 + normalizedLY : 0;
            var RSValues = this.gamepad.rightStick;
            if (RSValues) {
                var normalizedRX = RSValues.x / this.gamepadAngularSensibility;
                var normalizedRY = RSValues.y / this.gamepadAngularSensibility;
                RSValues.x = Math.abs(normalizedRX) > 0.001 ? 0 + normalizedRX : 0;
                RSValues.y = Math.abs(normalizedRY) > 0.001 ? 0 + normalizedRY : 0;
            }
            else {
                RSValues = { x: 0, y: 0 };
            }
            if (!camera.rotationQuaternion) {
                Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);
            }
            else {
                camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);
            }
            var speed = camera._computeLocalCameraSpeed() * 50.0;
            this._vector3.copyFromFloats(LSValues.x * speed, 0, -LSValues.y * speed);
            Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);
            camera.cameraDirection.addInPlace(this._deltaTransform);
            this._vector2.copyFromFloats(RSValues.y, RSValues.x);
            camera.cameraRotation.addInPlace(this._vector2);
        }
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    FreeCameraGamepadInput.prototype.getClassName = function () {
        return "FreeCameraGamepadInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    FreeCameraGamepadInput.prototype.getSimpleName = function () {
        return "gamepad";
    };
    __decorate([
        serialize()
    ], FreeCameraGamepadInput.prototype, "gamepadAngularSensibility", void 0);
    __decorate([
        serialize()
    ], FreeCameraGamepadInput.prototype, "gamepadMoveSensibility", void 0);
    return FreeCameraGamepadInput;
}());
CameraInputTypes["FreeCameraGamepadInput"] = FreeCameraGamepadInput;

// Mainly based on these 2 articles :
// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx
// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/
/**
 * Defines the potential axis of a Joystick
 */
var JoystickAxis;
(function (JoystickAxis) {
    /** X axis */
    JoystickAxis[JoystickAxis["X"] = 0] = "X";
    /** Y axis */
    JoystickAxis[JoystickAxis["Y"] = 1] = "Y";
    /** Z axis */
    JoystickAxis[JoystickAxis["Z"] = 2] = "Z";
})(JoystickAxis || (JoystickAxis = {}));
/**
 * Class used to define virtual joystick (used in touch mode)
 */
var VirtualJoystick = /** @class */ (function () {
    /**
     * Creates a new virtual joystick
     * @param leftJoystick defines that the joystick is for left hand (false by default)
     */
    function VirtualJoystick(leftJoystick) {
        var _this = this;
        if (leftJoystick) {
            this._leftJoystick = true;
        }
        else {
            this._leftJoystick = false;
        }
        VirtualJoystick._globalJoystickIndex++;
        // By default left & right arrow keys are moving the X
        // and up & down keys are moving the Y
        this._axisTargetedByLeftAndRight = JoystickAxis.X;
        this._axisTargetedByUpAndDown = JoystickAxis.Y;
        this.reverseLeftRight = false;
        this.reverseUpDown = false;
        // collections of pointers
        this._touches = new StringDictionary();
        this.deltaPosition = Vector3.Zero();
        this._joystickSensibility = 25;
        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);
        this._onResize = function (evt) {
            VirtualJoystick.vjCanvasWidth = window.innerWidth;
            VirtualJoystick.vjCanvasHeight = window.innerHeight;
            if (VirtualJoystick.Canvas) {
                VirtualJoystick.Canvas.width = VirtualJoystick.vjCanvasWidth;
                VirtualJoystick.Canvas.height = VirtualJoystick.vjCanvasHeight;
            }
            VirtualJoystick.halfWidth = VirtualJoystick.vjCanvasWidth / 2;
        };
        // injecting a canvas element on top of the canvas 3D game
        if (!VirtualJoystick.Canvas) {
            window.addEventListener("resize", this._onResize, false);
            VirtualJoystick.Canvas = document.createElement("canvas");
            VirtualJoystick.vjCanvasWidth = window.innerWidth;
            VirtualJoystick.vjCanvasHeight = window.innerHeight;
            VirtualJoystick.Canvas.width = window.innerWidth;
            VirtualJoystick.Canvas.height = window.innerHeight;
            VirtualJoystick.Canvas.style.width = "100%";
            VirtualJoystick.Canvas.style.height = "100%";
            VirtualJoystick.Canvas.style.position = "absolute";
            VirtualJoystick.Canvas.style.backgroundColor = "transparent";
            VirtualJoystick.Canvas.style.top = "0px";
            VirtualJoystick.Canvas.style.left = "0px";
            VirtualJoystick.Canvas.style.zIndex = "5";
            VirtualJoystick.Canvas.style.msTouchAction = "none";
            // Support for jQuery PEP polyfill
            VirtualJoystick.Canvas.setAttribute("touch-action", "none");
            var context = VirtualJoystick.Canvas.getContext('2d');
            if (!context) {
                throw new Error("Unable to create canvas for virtual joystick");
            }
            VirtualJoystick.vjCanvasContext = context;
            VirtualJoystick.vjCanvasContext.strokeStyle = "#ffffff";
            VirtualJoystick.vjCanvasContext.lineWidth = 2;
            document.body.appendChild(VirtualJoystick.Canvas);
        }
        VirtualJoystick.halfWidth = VirtualJoystick.Canvas.width / 2;
        this.pressed = false;
        // default joystick color
        this._joystickColor = "cyan";
        this._joystickPointerID = -1;
        // current joystick position
        this._joystickPointerPos = new Vector2(0, 0);
        this._joystickPreviousPointerPos = new Vector2(0, 0);
        // origin joystick position
        this._joystickPointerStartPos = new Vector2(0, 0);
        this._deltaJoystickVector = new Vector2(0, 0);
        this._onPointerDownHandlerRef = function (evt) {
            _this._onPointerDown(evt);
        };
        this._onPointerMoveHandlerRef = function (evt) {
            _this._onPointerMove(evt);
        };
        this._onPointerUpHandlerRef = function (evt) {
            _this._onPointerUp(evt);
        };
        VirtualJoystick.Canvas.addEventListener('pointerdown', this._onPointerDownHandlerRef, false);
        VirtualJoystick.Canvas.addEventListener('pointermove', this._onPointerMoveHandlerRef, false);
        VirtualJoystick.Canvas.addEventListener('pointerup', this._onPointerUpHandlerRef, false);
        VirtualJoystick.Canvas.addEventListener('pointerout', this._onPointerUpHandlerRef, false);
        VirtualJoystick.Canvas.addEventListener("contextmenu", function (evt) {
            evt.preventDefault(); // Disables system menu
        }, false);
        requestAnimationFrame(function () { _this._drawVirtualJoystick(); });
    }
    /**
     * Defines joystick sensibility (ie. the ratio beteen a physical move and virtual joystick position change)
     * @param newJoystickSensibility defines the new sensibility
     */
    VirtualJoystick.prototype.setJoystickSensibility = function (newJoystickSensibility) {
        this._joystickSensibility = newJoystickSensibility;
        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);
    };
    VirtualJoystick.prototype._onPointerDown = function (e) {
        var positionOnScreenCondition;
        e.preventDefault();
        if (this._leftJoystick === true) {
            positionOnScreenCondition = (e.clientX < VirtualJoystick.halfWidth);
        }
        else {
            positionOnScreenCondition = (e.clientX > VirtualJoystick.halfWidth);
        }
        if (positionOnScreenCondition && this._joystickPointerID < 0) {
            // First contact will be dedicated to the virtual joystick
            this._joystickPointerID = e.pointerId;
            this._joystickPointerStartPos.x = e.clientX;
            this._joystickPointerStartPos.y = e.clientY;
            this._joystickPointerPos = this._joystickPointerStartPos.clone();
            this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();
            this._deltaJoystickVector.x = 0;
            this._deltaJoystickVector.y = 0;
            this.pressed = true;
            this._touches.add(e.pointerId.toString(), e);
        }
        else {
            // You can only trigger the action buttons with a joystick declared
            if (VirtualJoystick._globalJoystickIndex < 2 && this._action) {
                this._action();
                this._touches.add(e.pointerId.toString(), { x: e.clientX, y: e.clientY, prevX: e.clientX, prevY: e.clientY });
            }
        }
    };
    VirtualJoystick.prototype._onPointerMove = function (e) {
        // If the current pointer is the one associated to the joystick (first touch contact)
        if (this._joystickPointerID == e.pointerId) {
            this._joystickPointerPos.x = e.clientX;
            this._joystickPointerPos.y = e.clientY;
            this._deltaJoystickVector = this._joystickPointerPos.clone();
            this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);
            var directionLeftRight = this.reverseLeftRight ? -1 : 1;
            var deltaJoystickX = directionLeftRight * this._deltaJoystickVector.x / this._inversedSensibility;
            switch (this._axisTargetedByLeftAndRight) {
                case JoystickAxis.X:
                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));
                    break;
                case JoystickAxis.Y:
                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));
                    break;
                case JoystickAxis.Z:
                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));
                    break;
            }
            var directionUpDown = this.reverseUpDown ? 1 : -1;
            var deltaJoystickY = directionUpDown * this._deltaJoystickVector.y / this._inversedSensibility;
            switch (this._axisTargetedByUpAndDown) {
                case JoystickAxis.X:
                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));
                    break;
                case JoystickAxis.Y:
                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));
                    break;
                case JoystickAxis.Z:
                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));
                    break;
            }
        }
        else {
            var data = this._touches.get(e.pointerId.toString());
            if (data) {
                data.x = e.clientX;
                data.y = e.clientY;
            }
        }
    };
    VirtualJoystick.prototype._onPointerUp = function (e) {
        if (this._joystickPointerID == e.pointerId) {
            VirtualJoystick.vjCanvasContext.clearRect(this._joystickPointerStartPos.x - 64, this._joystickPointerStartPos.y - 64, 128, 128);
            VirtualJoystick.vjCanvasContext.clearRect(this._joystickPreviousPointerPos.x - 42, this._joystickPreviousPointerPos.y - 42, 84, 84);
            this._joystickPointerID = -1;
            this.pressed = false;
        }
        else {
            var touch = this._touches.get(e.pointerId.toString());
            if (touch) {
                VirtualJoystick.vjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);
            }
        }
        this._deltaJoystickVector.x = 0;
        this._deltaJoystickVector.y = 0;
        this._touches.remove(e.pointerId.toString());
    };
    /**
    * Change the color of the virtual joystick
    * @param newColor a string that must be a CSS color value (like "red") or the hexa value (like "#FF0000")
    */
    VirtualJoystick.prototype.setJoystickColor = function (newColor) {
        this._joystickColor = newColor;
    };
    /**
     * Defines a callback to call when the joystick is touched
     * @param action defines the callback
     */
    VirtualJoystick.prototype.setActionOnTouch = function (action) {
        this._action = action;
    };
    /**
     * Defines which axis you'd like to control for left & right
     * @param axis defines the axis to use
     */
    VirtualJoystick.prototype.setAxisForLeftRight = function (axis) {
        switch (axis) {
            case JoystickAxis.X:
            case JoystickAxis.Y:
            case JoystickAxis.Z:
                this._axisTargetedByLeftAndRight = axis;
                break;
            default:
                this._axisTargetedByLeftAndRight = JoystickAxis.X;
                break;
        }
    };
    /**
     * Defines which axis you'd like to control for up & down
     * @param axis defines the axis to use
     */
    VirtualJoystick.prototype.setAxisForUpDown = function (axis) {
        switch (axis) {
            case JoystickAxis.X:
            case JoystickAxis.Y:
            case JoystickAxis.Z:
                this._axisTargetedByUpAndDown = axis;
                break;
            default:
                this._axisTargetedByUpAndDown = JoystickAxis.Y;
                break;
        }
    };
    VirtualJoystick.prototype._drawVirtualJoystick = function () {
        var _this = this;
        if (this.pressed) {
            this._touches.forEach(function (key, touch) {
                if (touch.pointerId === _this._joystickPointerID) {
                    VirtualJoystick.vjCanvasContext.clearRect(_this._joystickPointerStartPos.x - 64, _this._joystickPointerStartPos.y - 64, 128, 128);
                    VirtualJoystick.vjCanvasContext.clearRect(_this._joystickPreviousPointerPos.x - 42, _this._joystickPreviousPointerPos.y - 42, 84, 84);
                    VirtualJoystick.vjCanvasContext.beginPath();
                    VirtualJoystick.vjCanvasContext.lineWidth = 6;
                    VirtualJoystick.vjCanvasContext.strokeStyle = _this._joystickColor;
                    VirtualJoystick.vjCanvasContext.arc(_this._joystickPointerStartPos.x, _this._joystickPointerStartPos.y, 40, 0, Math.PI * 2, true);
                    VirtualJoystick.vjCanvasContext.stroke();
                    VirtualJoystick.vjCanvasContext.closePath();
                    VirtualJoystick.vjCanvasContext.beginPath();
                    VirtualJoystick.vjCanvasContext.strokeStyle = _this._joystickColor;
                    VirtualJoystick.vjCanvasContext.lineWidth = 2;
                    VirtualJoystick.vjCanvasContext.arc(_this._joystickPointerStartPos.x, _this._joystickPointerStartPos.y, 60, 0, Math.PI * 2, true);
                    VirtualJoystick.vjCanvasContext.stroke();
                    VirtualJoystick.vjCanvasContext.closePath();
                    VirtualJoystick.vjCanvasContext.beginPath();
                    VirtualJoystick.vjCanvasContext.strokeStyle = _this._joystickColor;
                    VirtualJoystick.vjCanvasContext.arc(_this._joystickPointerPos.x, _this._joystickPointerPos.y, 40, 0, Math.PI * 2, true);
                    VirtualJoystick.vjCanvasContext.stroke();
                    VirtualJoystick.vjCanvasContext.closePath();
                    _this._joystickPreviousPointerPos = _this._joystickPointerPos.clone();
                }
                else {
                    VirtualJoystick.vjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);
                    VirtualJoystick.vjCanvasContext.beginPath();
                    VirtualJoystick.vjCanvasContext.fillStyle = "white";
                    VirtualJoystick.vjCanvasContext.beginPath();
                    VirtualJoystick.vjCanvasContext.strokeStyle = "red";
                    VirtualJoystick.vjCanvasContext.lineWidth = 6;
                    VirtualJoystick.vjCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);
                    VirtualJoystick.vjCanvasContext.stroke();
                    VirtualJoystick.vjCanvasContext.closePath();
                    touch.prevX = touch.x;
                    touch.prevY = touch.y;
                }
            });
        }
        requestAnimationFrame(function () { _this._drawVirtualJoystick(); });
    };
    /**
     * Release internal HTML canvas
     */
    VirtualJoystick.prototype.releaseCanvas = function () {
        if (VirtualJoystick.Canvas) {
            VirtualJoystick.Canvas.removeEventListener('pointerdown', this._onPointerDownHandlerRef);
            VirtualJoystick.Canvas.removeEventListener('pointermove', this._onPointerMoveHandlerRef);
            VirtualJoystick.Canvas.removeEventListener('pointerup', this._onPointerUpHandlerRef);
            VirtualJoystick.Canvas.removeEventListener('pointerout', this._onPointerUpHandlerRef);
            window.removeEventListener("resize", this._onResize);
            document.body.removeChild(VirtualJoystick.Canvas);
            VirtualJoystick.Canvas = null;
        }
    };
    // Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas
    VirtualJoystick._globalJoystickIndex = 0;
    return VirtualJoystick;
}());

/**
* Add virtual joystick input support to the input manager.
* @returns the current input manager
*/
FreeCameraInputsManager.prototype.addVirtualJoystick = function () {
    this.add(new FreeCameraVirtualJoystickInput());
    return this;
};
/**
 * Manage the Virtual Joystick inputs to control the movement of a free camera.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FreeCameraVirtualJoystickInput = /** @class */ (function () {
    function FreeCameraVirtualJoystickInput() {
    }
    /**
     * Gets the left stick of the virtual joystick.
     * @returns The virtual Joystick
     */
    FreeCameraVirtualJoystickInput.prototype.getLeftJoystick = function () {
        return this._leftjoystick;
    };
    /**
     * Gets the right stick of the virtual joystick.
     * @returns The virtual Joystick
     */
    FreeCameraVirtualJoystickInput.prototype.getRightJoystick = function () {
        return this._rightjoystick;
    };
    /**
     * Update the current camera state depending on the inputs that have been used this frame.
     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
     */
    FreeCameraVirtualJoystickInput.prototype.checkInputs = function () {
        if (this._leftjoystick) {
            var camera = this.camera;
            var speed = camera._computeLocalCameraSpeed() * 50;
            var cameraTransform = Matrix.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, 0);
            var deltaTransform = Vector3.TransformCoordinates(new Vector3(this._leftjoystick.deltaPosition.x * speed, this._leftjoystick.deltaPosition.y * speed, this._leftjoystick.deltaPosition.z * speed), cameraTransform);
            camera.cameraDirection = camera.cameraDirection.add(deltaTransform);
            camera.cameraRotation = camera.cameraRotation.addVector3(this._rightjoystick.deltaPosition);
            if (!this._leftjoystick.pressed) {
                this._leftjoystick.deltaPosition = this._leftjoystick.deltaPosition.scale(0.9);
            }
            if (!this._rightjoystick.pressed) {
                this._rightjoystick.deltaPosition = this._rightjoystick.deltaPosition.scale(0.9);
            }
        }
    };
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    FreeCameraVirtualJoystickInput.prototype.attachControl = function (element, noPreventDefault) {
        this._leftjoystick = new VirtualJoystick(true);
        this._leftjoystick.setAxisForUpDown(JoystickAxis.Z);
        this._leftjoystick.setAxisForLeftRight(JoystickAxis.X);
        this._leftjoystick.setJoystickSensibility(0.15);
        this._rightjoystick = new VirtualJoystick(false);
        this._rightjoystick.setAxisForUpDown(JoystickAxis.X);
        this._rightjoystick.setAxisForLeftRight(JoystickAxis.Y);
        this._rightjoystick.reverseUpDown = true;
        this._rightjoystick.setJoystickSensibility(0.05);
        this._rightjoystick.setJoystickColor("yellow");
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param element Defines the element to stop listening the inputs from
     */
    FreeCameraVirtualJoystickInput.prototype.detachControl = function (element) {
        this._leftjoystick.releaseCanvas();
        this._rightjoystick.releaseCanvas();
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    FreeCameraVirtualJoystickInput.prototype.getClassName = function () {
        return "FreeCameraVirtualJoystickInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    FreeCameraVirtualJoystickInput.prototype.getSimpleName = function () {
        return "virtualJoystick";
    };
    return FreeCameraVirtualJoystickInput;
}());
CameraInputTypes["FreeCameraVirtualJoystickInput"] = FreeCameraVirtualJoystickInput;

Node$2.AddNodeConstructor("TouchCamera", function (name, scene) {
    return function () { return new TouchCamera(name, Vector3.Zero(), scene); };
});
/**
 * This represents a FPS type of camera controlled by touch.
 * This is like a universal camera minus the Gamepad controls.
 * @see http://doc.babylonjs.com/features/cameras#universal-camera
 */
var TouchCamera = /** @class */ (function (_super) {
    __extends(TouchCamera, _super);
    /**
     * Instantiates a new touch camera.
     * This represents a FPS type of camera controlled by touch.
     * This is like a universal camera minus the Gamepad controls.
     * @see http://doc.babylonjs.com/features/cameras#universal-camera
     * @param name Define the name of the camera in the scene
     * @param position Define the start position of the camera in the scene
     * @param scene Define the scene the camera belongs to
     */
    function TouchCamera(name, position, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this.inputs.addTouch();
        _this._setupInputs();
        return _this;
    }
    Object.defineProperty(TouchCamera.prototype, "touchAngularSensibility", {
        /**
         * Defines the touch sensibility for rotation.
         * The higher the faster.
         */
        get: function () {
            var touch = this.inputs.attached["touch"];
            if (touch) {
                return touch.touchAngularSensibility;
            }
            return 0;
        },
        set: function (value) {
            var touch = this.inputs.attached["touch"];
            if (touch) {
                touch.touchAngularSensibility = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchCamera.prototype, "touchMoveSensibility", {
        /**
         * Defines the touch sensibility for move.
         * The higher the faster.
         */
        get: function () {
            var touch = this.inputs.attached["touch"];
            if (touch) {
                return touch.touchMoveSensibility;
            }
            return 0;
        },
        set: function (value) {
            var touch = this.inputs.attached["touch"];
            if (touch) {
                touch.touchMoveSensibility = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the current object class name.
     * @return the class name
     */
    TouchCamera.prototype.getClassName = function () {
        return "TouchCamera";
    };
    /** @hidden */
    TouchCamera.prototype._setupInputs = function () {
        var mouse = this.inputs.attached["mouse"];
        if (mouse) {
            mouse.touchEnabled = false;
        }
    };
    return TouchCamera;
}(FreeCamera));

Node$2.AddNodeConstructor("ArcRotateCamera", function (name, scene) {
    return function () { return new ArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene); };
});
/**
 * This represents an orbital type of camera.
 *
 * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.
 * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.
 * @see http://doc.babylonjs.com/babylon101/cameras#arc-rotate-camera
 */
var ArcRotateCamera = /** @class */ (function (_super) {
    __extends(ArcRotateCamera, _super);
    /**
     * Instantiates a new ArcRotateCamera in a given scene
     * @param name Defines the name of the camera
     * @param alpha Defines the camera rotation along the logitudinal axis
     * @param beta Defines the camera rotation along the latitudinal axis
     * @param radius Defines the camera distance from its target
     * @param target Defines the camera target
     * @param scene Defines the scene the camera belongs to
     * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined
     */
    function ArcRotateCamera(name, alpha, beta, radius, target, scene, setActiveOnSceneIfNoneActive) {
        if (setActiveOnSceneIfNoneActive === void 0) { setActiveOnSceneIfNoneActive = true; }
        var _this = _super.call(this, name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive) || this;
        _this._upVector = Vector3.Up();
        /**
         * Current inertia value on the longitudinal axis.
         * The bigger this number the longer it will take for the camera to stop.
         */
        _this.inertialAlphaOffset = 0;
        /**
         * Current inertia value on the latitudinal axis.
         * The bigger this number the longer it will take for the camera to stop.
         */
        _this.inertialBetaOffset = 0;
        /**
         * Current inertia value on the radius axis.
         * The bigger this number the longer it will take for the camera to stop.
         */
        _this.inertialRadiusOffset = 0;
        /**
         * Minimum allowed angle on the longitudinal axis.
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.lowerAlphaLimit = null;
        /**
         * Maximum allowed angle on the longitudinal axis.
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.upperAlphaLimit = null;
        /**
         * Minimum allowed angle on the latitudinal axis.
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.lowerBetaLimit = 0.01;
        /**
         * Maximum allowed angle on the latitudinal axis.
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.upperBetaLimit = Math.PI - 0.01;
        /**
         * Minimum allowed distance of the camera to the target (The camera can not get closer).
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.lowerRadiusLimit = null;
        /**
         * Maximum allowed distance of the camera to the target (The camera can not get further).
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.upperRadiusLimit = null;
        /**
         * Defines the current inertia value used during panning of the camera along the X axis.
         */
        _this.inertialPanningX = 0;
        /**
         * Defines the current inertia value used during panning of the camera along the Y axis.
         */
        _this.inertialPanningY = 0;
        /**
         * Defines the distance used to consider the camera in pan mode vs pinch/zoom.
         * Basically if your fingers moves away from more than this distance you will be considered
         * in pinch mode.
         */
        _this.pinchToPanMaxDistance = 20;
        /**
         * Defines the maximum distance the camera can pan.
         * This could help keeping the cammera always in your scene.
         */
        _this.panningDistanceLimit = null;
        /**
         * Defines the target of the camera before paning.
         */
        _this.panningOriginTarget = Vector3.Zero();
        /**
         * Defines the value of the inertia used during panning.
         * 0 would mean stop inertia and one would mean no decelleration at all.
         */
        _this.panningInertia = 0.9;
        //-- end properties for backward compatibility for inputs
        /**
         * Defines how much the radius should be scaled while zomming on a particular mesh (through the zoomOn function)
         */
        _this.zoomOnFactor = 1;
        /**
         * Defines a screen offset for the camera position.
         */
        _this.targetScreenOffset = Vector2.Zero();
        /**
         * Allows the camera to be completely reversed.
         * If false the camera can not arrive upside down.
         */
        _this.allowUpsideDown = true;
        /**
         * Define if double tap/click is used to restore the previously saved state of the camera.
         */
        _this.useInputToRestoreState = true;
        /** @hidden */
        _this._viewMatrix = new Matrix();
        /**
         * Defines the allowed panning axis.
         */
        _this.panningAxis = new Vector3(1, 1, 0);
        /**
         * Observable triggered when the mesh target has been changed on the camera.
         */
        _this.onMeshTargetChangedObservable = new Observable();
        /**
         * Defines whether the camera should check collision with the objects oh the scene.
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#how-can-i-do-this
         */
        _this.checkCollisions = false;
        /**
         * Defines the collision radius of the camera.
         * This simulates a sphere around the camera.
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera
         */
        _this.collisionRadius = new Vector3(0.5, 0.5, 0.5);
        _this._previousPosition = Vector3.Zero();
        _this._collisionVelocity = Vector3.Zero();
        _this._newPosition = Vector3.Zero();
        _this._computationVector = Vector3.Zero();
        _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {
            if (collidedMesh === void 0) { collidedMesh = null; }
            if (!collidedMesh) {
                _this._previousPosition.copyFrom(_this._position);
            }
            else {
                _this.setPosition(newPosition);
                if (_this.onCollide) {
                    _this.onCollide(collidedMesh);
                }
            }
            // Recompute because of constraints
            var cosa = Math.cos(_this.alpha);
            var sina = Math.sin(_this.alpha);
            var cosb = Math.cos(_this.beta);
            var sinb = Math.sin(_this.beta);
            if (sinb === 0) {
                sinb = 0.0001;
            }
            var target = _this._getTargetPosition();
            _this._computationVector.copyFromFloats(_this.radius * cosa * sinb, _this.radius * cosb, _this.radius * sina * sinb);
            target.addToRef(_this._computationVector, _this._newPosition);
            _this._position.copyFrom(_this._newPosition);
            var up = _this.upVector;
            if (_this.allowUpsideDown && _this.beta < 0) {
                up = up.clone();
                up = up.negate();
            }
            _this._computeViewMatrix(_this._position, target, up);
            _this._viewMatrix.addAtIndex(12, _this.targetScreenOffset.x);
            _this._viewMatrix.addAtIndex(13, _this.targetScreenOffset.y);
            _this._collisionTriggered = false;
        };
        _this._target = Vector3.Zero();
        if (target) {
            _this.setTarget(target);
        }
        _this.alpha = alpha;
        _this.beta = beta;
        _this.radius = radius;
        _this.getViewMatrix();
        _this.inputs = new ArcRotateCameraInputsManager(_this);
        _this.inputs.addKeyboard().addMouseWheel().addPointers();
        return _this;
    }
    Object.defineProperty(ArcRotateCamera.prototype, "target", {
        /**
         * Defines the target point of the camera.
         * The camera looks towards it form the radius distance.
         */
        get: function () {
            return this._target;
        },
        set: function (value) {
            this.setTarget(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "position", {
        /**
         * Define the current local position of the camera in the scene
         */
        get: function () {
            return this._position;
        },
        set: function (newPosition) {
            this.setPosition(newPosition);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "upVector", {
        get: function () {
            return this._upVector;
        },
        /**
         * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())
         * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.
         * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.
         */
        set: function (vec) {
            if (!this._upToYMatrix) {
                this._YToUpMatrix = new Matrix();
                this._upToYMatrix = new Matrix();
                this._upVector = Vector3.Zero();
            }
            vec.normalize();
            this._upVector.copyFrom(vec);
            this.setMatUp();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.
     */
    ArcRotateCamera.prototype.setMatUp = function () {
        // from y-up to custom-up (used in _getViewMatrix)
        Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._YToUpMatrix);
        // from custom-up to y-up (used in rebuildAnglesAndRadius)
        Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);
    };
    Object.defineProperty(ArcRotateCamera.prototype, "angularSensibilityX", {
        //-- begin properties for backward compatibility for inputs
        /**
         * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.
         */
        get: function () {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                return pointers.angularSensibilityX;
            }
            return 0;
        },
        set: function (value) {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                pointers.angularSensibilityX = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "angularSensibilityY", {
        /**
         * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.
         */
        get: function () {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                return pointers.angularSensibilityY;
            }
            return 0;
        },
        set: function (value) {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                pointers.angularSensibilityY = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "pinchPrecision", {
        /**
         * Gets or Set the pointer pinch precision or how fast is the camera zooming.
         */
        get: function () {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                return pointers.pinchPrecision;
            }
            return 0;
        },
        set: function (value) {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                pointers.pinchPrecision = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "pinchDeltaPercentage", {
        /**
         * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.
         * It will be used instead of pinchDeltaPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
         */
        get: function () {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                return pointers.pinchDeltaPercentage;
            }
            return 0;
        },
        set: function (value) {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                pointers.pinchDeltaPercentage = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "panningSensibility", {
        /**
         * Gets or Set the pointer panning sensibility or how fast is the camera moving.
         */
        get: function () {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                return pointers.panningSensibility;
            }
            return 0;
        },
        set: function (value) {
            var pointers = this.inputs.attached["pointers"];
            if (pointers) {
                pointers.panningSensibility = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "keysUp", {
        /**
         * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysUp;
            }
            return [];
        },
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysUp = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "keysDown", {
        /**
         * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysDown;
            }
            return [];
        },
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysDown = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "keysLeft", {
        /**
         * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysLeft;
            }
            return [];
        },
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysLeft = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "keysRight", {
        /**
         * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysRight;
            }
            return [];
        },
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysRight = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "wheelPrecision", {
        /**
         * Gets or Set the mouse wheel precision or how fast is the camera zooming.
         */
        get: function () {
            var mousewheel = this.inputs.attached["mousewheel"];
            if (mousewheel) {
                return mousewheel.wheelPrecision;
            }
            return 0;
        },
        set: function (value) {
            var mousewheel = this.inputs.attached["mousewheel"];
            if (mousewheel) {
                mousewheel.wheelPrecision = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "wheelDeltaPercentage", {
        /**
         * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.
         * It will be used instead of pinchDeltaPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
         */
        get: function () {
            var mousewheel = this.inputs.attached["mousewheel"];
            if (mousewheel) {
                return mousewheel.wheelDeltaPercentage;
            }
            return 0;
        },
        set: function (value) {
            var mousewheel = this.inputs.attached["mousewheel"];
            if (mousewheel) {
                mousewheel.wheelDeltaPercentage = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "bouncingBehavior", {
        /**
         * Gets the bouncing behavior of the camera if it has been enabled.
         * @see http://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior
         */
        get: function () {
            return this._bouncingBehavior;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "useBouncingBehavior", {
        /**
         * Defines if the bouncing behavior of the camera is enabled on the camera.
         * @see http://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior
         */
        get: function () {
            return this._bouncingBehavior != null;
        },
        set: function (value) {
            if (value === this.useBouncingBehavior) {
                return;
            }
            if (value) {
                this._bouncingBehavior = new BouncingBehavior();
                this.addBehavior(this._bouncingBehavior);
            }
            else if (this._bouncingBehavior) {
                this.removeBehavior(this._bouncingBehavior);
                this._bouncingBehavior = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "framingBehavior", {
        /**
         * Gets the framing behavior of the camera if it has been enabled.
         * @see http://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior
         */
        get: function () {
            return this._framingBehavior;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "useFramingBehavior", {
        /**
         * Defines if the framing behavior of the camera is enabled on the camera.
         * @see http://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior
         */
        get: function () {
            return this._framingBehavior != null;
        },
        set: function (value) {
            if (value === this.useFramingBehavior) {
                return;
            }
            if (value) {
                this._framingBehavior = new FramingBehavior();
                this.addBehavior(this._framingBehavior);
            }
            else if (this._framingBehavior) {
                this.removeBehavior(this._framingBehavior);
                this._framingBehavior = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "autoRotationBehavior", {
        /**
         * Gets the auto rotation behavior of the camera if it has been enabled.
         * @see http://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior
         */
        get: function () {
            return this._autoRotationBehavior;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArcRotateCamera.prototype, "useAutoRotationBehavior", {
        /**
         * Defines if the auto rotation behavior of the camera is enabled on the camera.
         * @see http://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior
         */
        get: function () {
            return this._autoRotationBehavior != null;
        },
        set: function (value) {
            if (value === this.useAutoRotationBehavior) {
                return;
            }
            if (value) {
                this._autoRotationBehavior = new AutoRotationBehavior();
                this.addBehavior(this._autoRotationBehavior);
            }
            else if (this._autoRotationBehavior) {
                this.removeBehavior(this._autoRotationBehavior);
                this._autoRotationBehavior = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    // Cache
    /** @hidden */
    ArcRotateCamera.prototype._initCache = function () {
        _super.prototype._initCache.call(this);
        this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.alpha = undefined;
        this._cache.beta = undefined;
        this._cache.radius = undefined;
        this._cache.targetScreenOffset = Vector2.Zero();
    };
    /** @hidden */
    ArcRotateCamera.prototype._updateCache = function (ignoreParentClass) {
        if (!ignoreParentClass) {
            _super.prototype._updateCache.call(this);
        }
        this._cache._target.copyFrom(this._getTargetPosition());
        this._cache.alpha = this.alpha;
        this._cache.beta = this.beta;
        this._cache.radius = this.radius;
        this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);
    };
    ArcRotateCamera.prototype._getTargetPosition = function () {
        if (this._targetHost && this._targetHost.getAbsolutePosition) {
            var pos = this._targetHost.absolutePosition;
            if (this._targetBoundingCenter) {
                pos.addToRef(this._targetBoundingCenter, this._target);
            }
            else {
                this._target.copyFrom(pos);
            }
        }
        var lockedTargetPosition = this._getLockedTargetPosition();
        if (lockedTargetPosition) {
            return lockedTargetPosition;
        }
        return this._target;
    };
    /**
     * Stores the current state of the camera (alpha, beta, radius and target)
     * @returns the camera itself
     */
    ArcRotateCamera.prototype.storeState = function () {
        this._storedAlpha = this.alpha;
        this._storedBeta = this.beta;
        this._storedRadius = this.radius;
        this._storedTarget = this._getTargetPosition().clone();
        return _super.prototype.storeState.call(this);
    };
    /**
     * @hidden
     * Restored camera state. You must call storeState() first
     */
    ArcRotateCamera.prototype._restoreStateValues = function () {
        if (!_super.prototype._restoreStateValues.call(this)) {
            return false;
        }
        this.alpha = this._storedAlpha;
        this.beta = this._storedBeta;
        this.radius = this._storedRadius;
        this.setTarget(this._storedTarget.clone());
        this.inertialAlphaOffset = 0;
        this.inertialBetaOffset = 0;
        this.inertialRadiusOffset = 0;
        this.inertialPanningX = 0;
        this.inertialPanningY = 0;
        return true;
    };
    // Synchronized
    /** @hidden */
    ArcRotateCamera.prototype._isSynchronizedViewMatrix = function () {
        if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {
            return false;
        }
        return this._cache._target.equals(this._getTargetPosition())
            && this._cache.alpha === this.alpha
            && this._cache.beta === this.beta
            && this._cache.radius === this.radius
            && this._cache.targetScreenOffset.equals(this.targetScreenOffset);
    };
    /**
     * Attached controls to the current camera.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     * @param useCtrlForPanning  Defines whether ctrl is used for paning within the controls
     * @param panningMouseButton Defines whether panning is allowed through mouse click button
     */
    ArcRotateCamera.prototype.attachControl = function (element, noPreventDefault, useCtrlForPanning, panningMouseButton) {
        var _this = this;
        if (useCtrlForPanning === void 0) { useCtrlForPanning = true; }
        if (panningMouseButton === void 0) { panningMouseButton = 2; }
        this._useCtrlForPanning = useCtrlForPanning;
        this._panningMouseButton = panningMouseButton;
        this.inputs.attachElement(element, noPreventDefault);
        this._reset = function () {
            _this.inertialAlphaOffset = 0;
            _this.inertialBetaOffset = 0;
            _this.inertialRadiusOffset = 0;
            _this.inertialPanningX = 0;
            _this.inertialPanningY = 0;
        };
    };
    /**
     * Detach the current controls from the camera.
     * The camera will stop reacting to inputs.
     * @param element Defines the element to stop listening the inputs from
     */
    ArcRotateCamera.prototype.detachControl = function (element) {
        this.inputs.detachElement(element);
        if (this._reset) {
            this._reset();
        }
    };
    /** @hidden */
    ArcRotateCamera.prototype._checkInputs = function () {
        //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.
        if (this._collisionTriggered) {
            return;
        }
        this.inputs.checkInputs();
        // Inertia
        if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {
            var inertialAlphaOffset = this.inertialAlphaOffset;
            if (this.beta <= 0) {
                inertialAlphaOffset *= -1;
            }
            if (this.getScene().useRightHandedSystem) {
                inertialAlphaOffset *= -1;
            }
            if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {
                inertialAlphaOffset *= -1;
            }
            this.alpha += inertialAlphaOffset;
            this.beta += this.inertialBetaOffset;
            this.radius -= this.inertialRadiusOffset;
            this.inertialAlphaOffset *= this.inertia;
            this.inertialBetaOffset *= this.inertia;
            this.inertialRadiusOffset *= this.inertia;
            if (Math.abs(this.inertialAlphaOffset) < Epsilon) {
                this.inertialAlphaOffset = 0;
            }
            if (Math.abs(this.inertialBetaOffset) < Epsilon) {
                this.inertialBetaOffset = 0;
            }
            if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {
                this.inertialRadiusOffset = 0;
            }
        }
        // Panning inertia
        if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {
            if (!this._localDirection) {
                this._localDirection = Vector3.Zero();
                this._transformedDirection = Vector3.Zero();
            }
            this._localDirection.copyFromFloats(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);
            this._localDirection.multiplyInPlace(this.panningAxis);
            this._viewMatrix.invertToRef(this._cameraTransformMatrix);
            Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection);
            //Eliminate y if map panning is enabled (panningAxis == 1,0,1)
            if (!this.panningAxis.y) {
                this._transformedDirection.y = 0;
            }
            if (!this._targetHost) {
                if (this.panningDistanceLimit) {
                    this._transformedDirection.addInPlace(this._target);
                    var distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);
                    if (distanceSquared <= (this.panningDistanceLimit * this.panningDistanceLimit)) {
                        this._target.copyFrom(this._transformedDirection);
                    }
                }
                else {
                    this._target.addInPlace(this._transformedDirection);
                }
            }
            this.inertialPanningX *= this.panningInertia;
            this.inertialPanningY *= this.panningInertia;
            if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {
                this.inertialPanningX = 0;
            }
            if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {
                this.inertialPanningY = 0;
            }
        }
        // Limits
        this._checkLimits();
        _super.prototype._checkInputs.call(this);
    };
    ArcRotateCamera.prototype._checkLimits = function () {
        if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {
            if (this.allowUpsideDown && this.beta > Math.PI) {
                this.beta = this.beta - (2 * Math.PI);
            }
        }
        else {
            if (this.beta < this.lowerBetaLimit) {
                this.beta = this.lowerBetaLimit;
            }
        }
        if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {
            if (this.allowUpsideDown && this.beta < -Math.PI) {
                this.beta = this.beta + (2 * Math.PI);
            }
        }
        else {
            if (this.beta > this.upperBetaLimit) {
                this.beta = this.upperBetaLimit;
            }
        }
        if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {
            this.alpha = this.lowerAlphaLimit;
        }
        if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {
            this.alpha = this.upperAlphaLimit;
        }
        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
            this.radius = this.lowerRadiusLimit;
            this.inertialRadiusOffset = 0;
        }
        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
            this.radius = this.upperRadiusLimit;
            this.inertialRadiusOffset = 0;
        }
    };
    /**
     * Rebuilds angles (alpha, beta) and radius from the give position and target
     */
    ArcRotateCamera.prototype.rebuildAnglesAndRadius = function () {
        this._position.subtractToRef(this._getTargetPosition(), this._computationVector);
        // need to rotate to Y up equivalent if up vector not Axis.Y
        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {
            Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);
        }
        this.radius = this._computationVector.length();
        if (this.radius === 0) {
            this.radius = 0.0001; // Just to avoid division by zero
        }
        // Alpha
        if (this._computationVector.x === 0 && this._computationVector.z === 0) {
            this.alpha = Math.PI / 2; // avoid division by zero when looking along up axis, and set to acos(0)
        }
        else {
            this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2)));
        }
        if (this._computationVector.z < 0) {
            this.alpha = 2 * Math.PI - this.alpha;
        }
        // Beta
        this.beta = Math.acos(this._computationVector.y / this.radius);
        this._checkLimits();
    };
    /**
     * Use a position to define the current camera related information like aplha, beta and radius
     * @param position Defines the position to set the camera at
     */
    ArcRotateCamera.prototype.setPosition = function (position) {
        if (this._position.equals(position)) {
            return;
        }
        this._position.copyFrom(position);
        this.rebuildAnglesAndRadius();
    };
    /**
     * Defines the target the camera should look at.
     * This will automatically adapt alpha beta and radius to fit within the new target.
     * @param target Defines the new target as a Vector or a mesh
     * @param toBoundingCenter In case of a mesh target, defines wether to target the mesh position or its bounding information center
     * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)
     */
    ArcRotateCamera.prototype.setTarget = function (target, toBoundingCenter, allowSamePosition) {
        if (toBoundingCenter === void 0) { toBoundingCenter = false; }
        if (allowSamePosition === void 0) { allowSamePosition = false; }
        if (target.getBoundingInfo) {
            if (toBoundingCenter) {
                this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();
            }
            else {
                this._targetBoundingCenter = null;
            }
            target.computeWorldMatrix();
            this._targetHost = target;
            this._target = this._getTargetPosition();
            this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);
        }
        else {
            var newTarget = target;
            var currentTarget = this._getTargetPosition();
            if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {
                return;
            }
            this._targetHost = null;
            this._target = newTarget;
            this._targetBoundingCenter = null;
            this.onMeshTargetChangedObservable.notifyObservers(null);
        }
        this.rebuildAnglesAndRadius();
    };
    /** @hidden */
    ArcRotateCamera.prototype._getViewMatrix = function () {
        // Compute
        var cosa = Math.cos(this.alpha);
        var sina = Math.sin(this.alpha);
        var cosb = Math.cos(this.beta);
        var sinb = Math.sin(this.beta);
        if (sinb === 0) {
            sinb = 0.0001;
        }
        var target = this._getTargetPosition();
        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
        // Rotate according to up vector
        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {
            Vector3.TransformCoordinatesToRef(this._computationVector, this._YToUpMatrix, this._computationVector);
        }
        target.addToRef(this._computationVector, this._newPosition);
        if (this.getScene().collisionsEnabled && this.checkCollisions) {
            var coordinator = this.getScene().collisionCoordinator;
            if (!this._collider) {
                this._collider = coordinator.createCollider();
            }
            this._collider._radius = this.collisionRadius;
            this._newPosition.subtractToRef(this._position, this._collisionVelocity);
            this._collisionTriggered = true;
            coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
        }
        else {
            this._position.copyFrom(this._newPosition);
            var up = this.upVector;
            if (this.allowUpsideDown && sinb < 0) {
                up = up.clone();
                up = up.negate();
            }
            this._computeViewMatrix(this._position, target, up);
            this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
            this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
        }
        this._currentTarget = target;
        return this._viewMatrix;
    };
    /**
     * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.
     * @param meshes Defines the mesh to zoom on
     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
     */
    ArcRotateCamera.prototype.zoomOn = function (meshes, doNotUpdateMaxZ) {
        if (doNotUpdateMaxZ === void 0) { doNotUpdateMaxZ = false; }
        meshes = meshes || this.getScene().meshes;
        var minMaxVector = Mesh.MinMax(meshes);
        var distance = Vector3.Distance(minMaxVector.min, minMaxVector.max);
        this.radius = distance * this.zoomOnFactor;
        this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance: distance }, doNotUpdateMaxZ);
    };
    /**
     * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.
     * The target will be changed but the radius
     * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on
     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
     */
    ArcRotateCamera.prototype.focusOn = function (meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ) {
        if (doNotUpdateMaxZ === void 0) { doNotUpdateMaxZ = false; }
        var meshesOrMinMaxVector;
        var distance;
        if (meshesOrMinMaxVectorAndDistance.min === undefined) { // meshes
            var meshes = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;
            meshesOrMinMaxVector = Mesh.MinMax(meshes);
            distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);
        }
        else { //minMaxVector and distance
            var minMaxVectorAndDistance = meshesOrMinMaxVectorAndDistance;
            meshesOrMinMaxVector = minMaxVectorAndDistance;
            distance = minMaxVectorAndDistance.distance;
        }
        this._target = Mesh.Center(meshesOrMinMaxVector);
        if (!doNotUpdateMaxZ) {
            this.maxZ = distance * 2;
        }
    };
    /**
     * @override
     * Override Camera.createRigCamera
     */
    ArcRotateCamera.prototype.createRigCamera = function (name, cameraIndex) {
        var alphaShift = 0;
        switch (this.cameraRigMode) {
            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
            case Camera.RIG_MODE_VR:
                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);
                break;
            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);
                break;
        }
        var rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());
        rigCam._cameraRigParams = {};
        return rigCam;
    };
    /**
     * @hidden
     * @override
     * Override Camera._updateRigCameras
     */
    ArcRotateCamera.prototype._updateRigCameras = function () {
        var camLeft = this._rigCameras[0];
        var camRight = this._rigCameras[1];
        camLeft.beta = camRight.beta = this.beta;
        switch (this.cameraRigMode) {
            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
            case Camera.RIG_MODE_VR:
                camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
                camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
                break;
            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
                camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
                camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
                break;
        }
        _super.prototype._updateRigCameras.call(this);
    };
    /**
     * Destroy the camera and release the current resources hold by it.
     */
    ArcRotateCamera.prototype.dispose = function () {
        this.inputs.clear();
        _super.prototype.dispose.call(this);
    };
    /**
     * Gets the current object class name.
     * @return the class name
     */
    ArcRotateCamera.prototype.getClassName = function () {
        return "ArcRotateCamera";
    };
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "alpha", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "beta", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "radius", void 0);
    __decorate([
        serializeAsVector3("target")
    ], ArcRotateCamera.prototype, "_target", void 0);
    __decorate([
        serializeAsVector3("upVector")
    ], ArcRotateCamera.prototype, "_upVector", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "inertialAlphaOffset", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "inertialBetaOffset", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "inertialRadiusOffset", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "lowerAlphaLimit", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "upperAlphaLimit", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "lowerBetaLimit", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "upperBetaLimit", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "lowerRadiusLimit", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "upperRadiusLimit", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "inertialPanningX", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "inertialPanningY", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "pinchToPanMaxDistance", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "panningDistanceLimit", void 0);
    __decorate([
        serializeAsVector3()
    ], ArcRotateCamera.prototype, "panningOriginTarget", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "panningInertia", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "zoomOnFactor", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "targetScreenOffset", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "allowUpsideDown", void 0);
    __decorate([
        serialize()
    ], ArcRotateCamera.prototype, "useInputToRestoreState", void 0);
    return ArcRotateCamera;
}(TargetCamera));

Node$2.AddNodeConstructor("DeviceOrientationCamera", function (name, scene) {
    return function () { return new DeviceOrientationCamera(name, Vector3.Zero(), scene); };
});
// We're mainly based on the logic defined into the FreeCamera code
/**
 * This is a camera specifically designed to react to device orientation events such as a modern mobile device
 * being tilted forward or back and left or right.
 */
var DeviceOrientationCamera = /** @class */ (function (_super) {
    __extends(DeviceOrientationCamera, _super);
    /**
     * Creates a new device orientation camera
     * @param name The name of the camera
     * @param position The start position camera
     * @param scene The scene the camera belongs to
     */
    function DeviceOrientationCamera(name, position, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this._tmpDragQuaternion = new Quaternion();
        /**
         * @hidden
         * Disabled pointer input on first orientation sensor update (Default: true)
         */
        _this._disablePointerInputWhenUsingDeviceOrientation = true;
        _this._dragFactor = 0;
        _this._quaternionCache = new Quaternion();
        _this.inputs.addDeviceOrientation();
        // When the orientation sensor fires it's first event, disable mouse input
        if (_this.inputs._deviceOrientationInput) {
            _this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(function () {
                if (_this._disablePointerInputWhenUsingDeviceOrientation) {
                    if (_this.inputs._mouseInput) {
                        _this.inputs._mouseInput._allowCameraRotation = false;
                        _this.inputs._mouseInput.onPointerMovedObservable.add(function (e) {
                            if (_this._dragFactor != 0) {
                                if (!_this._initialQuaternion) {
                                    _this._initialQuaternion = new Quaternion();
                                }
                                // Rotate the initial space around the y axis to allow users to "turn around" via touch/mouse
                                Quaternion.FromEulerAnglesToRef(0, e.offsetX * _this._dragFactor, 0, _this._tmpDragQuaternion);
                                _this._initialQuaternion.multiplyToRef(_this._tmpDragQuaternion, _this._initialQuaternion);
                            }
                        });
                    }
                }
            });
        }
        return _this;
    }
    /**
     * Enabled turning on the y axis when the orientation sensor is active
     * @param dragFactor the factor that controls the turn speed (default: 1/300)
     */
    DeviceOrientationCamera.prototype.enableHorizontalDragging = function (dragFactor) {
        if (dragFactor === void 0) { dragFactor = 1 / 300; }
        this._dragFactor = dragFactor;
    };
    /**
     * Gets the current instance class name ("DeviceOrientationCamera").
     * This helps avoiding instanceof at run time.
     * @returns the class name
     */
    DeviceOrientationCamera.prototype.getClassName = function () {
        return "DeviceOrientationCamera";
    };
    /**
     * @hidden
     * Checks and applies the current values of the inputs to the camera. (Internal use only)
     */
    DeviceOrientationCamera.prototype._checkInputs = function () {
        _super.prototype._checkInputs.call(this);
        this._quaternionCache.copyFrom(this.rotationQuaternion);
        if (this._initialQuaternion) {
            this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
        }
    };
    /**
     * Reset the camera to its default orientation on the specified axis only.
     * @param axis The axis to reset
     */
    DeviceOrientationCamera.prototype.resetToCurrentRotation = function (axis) {
        var _this = this;
        if (axis === void 0) { axis = Axis.Y; }
        //can only work if this camera has a rotation quaternion already.
        if (!this.rotationQuaternion) {
            return;
        }
        if (!this._initialQuaternion) {
            this._initialQuaternion = new Quaternion();
        }
        this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);
        ['x', 'y', 'z'].forEach(function (axisName) {
            if (!axis[axisName]) {
                _this._initialQuaternion[axisName] = 0;
            }
            else {
                _this._initialQuaternion[axisName] *= -1;
            }
        });
        this._initialQuaternion.normalize();
        //force rotation update
        this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    };
    return DeviceOrientationCamera;
}(FreeCamera));

/**
 * Default Inputs manager for the FlyCamera.
 * It groups all the default supported inputs for ease of use.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FlyCameraInputsManager = /** @class */ (function (_super) {
    __extends(FlyCameraInputsManager, _super);
    /**
     * Instantiates a new FlyCameraInputsManager.
     * @param camera Defines the camera the inputs belong to.
     */
    function FlyCameraInputsManager(camera) {
        return _super.call(this, camera) || this;
    }
    /**
     * Add keyboard input support to the input manager.
     * @returns the new FlyCameraKeyboardMoveInput().
     */
    FlyCameraInputsManager.prototype.addKeyboard = function () {
        this.add(new FlyCameraKeyboardInput());
        return this;
    };
    /**
     * Add mouse input support to the input manager.
     * @param touchEnabled Enable touch screen support.
     * @returns the new FlyCameraMouseInput().
     */
    FlyCameraInputsManager.prototype.addMouse = function (touchEnabled) {
        if (touchEnabled === void 0) { touchEnabled = true; }
        this.add(new FlyCameraMouseInput(touchEnabled));
        return this;
    };
    return FlyCameraInputsManager;
}(CameraInputsManager));

/**
 * This is a flying camera, designed for 3D movement and rotation in all directions,
 * such as in a 3D Space Shooter or a Flight Simulator.
 */
var FlyCamera = /** @class */ (function (_super) {
    __extends(FlyCamera, _super);
    /**
     * Instantiates a FlyCamera.
     * This is a flying camera, designed for 3D movement and rotation in all directions,
     * such as in a 3D Space Shooter or a Flight Simulator.
     * @param name Define the name of the camera in the scene.
     * @param position Define the starting position of the camera in the scene.
     * @param scene Define the scene the camera belongs to.
     * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active, if no other camera has been defined as active.
    */
    function FlyCamera(name, position, scene, setActiveOnSceneIfNoneActive) {
        if (setActiveOnSceneIfNoneActive === void 0) { setActiveOnSceneIfNoneActive = true; }
        var _this = _super.call(this, name, position, scene, setActiveOnSceneIfNoneActive) || this;
        /**
         * Define the collision ellipsoid of the camera.
         * This is helpful for simulating a camera body, like a player's body.
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera
         */
        _this.ellipsoid = new Vector3(1, 1, 1);
        /**
         * Define an offset for the position of the ellipsoid around the camera.
         * This can be helpful if the camera is attached away from the player's body center,
         * such as at its head.
         */
        _this.ellipsoidOffset = new Vector3(0, 0, 0);
        /**
         * Enable or disable collisions of the camera with the rest of the scene objects.
         */
        _this.checkCollisions = false;
        /**
         * Enable or disable gravity on the camera.
         */
        _this.applyGravity = false;
        /**
         * Define the current direction the camera is moving to.
         */
        _this.cameraDirection = Vector3.Zero();
        /**
         * Track Roll to maintain the wanted Rolling when looking around.
         */
        _this._trackRoll = 0;
        /**
        * Slowly correct the Roll to its original value after a Pitch+Yaw rotation.
        */
        _this.rollCorrect = 100;
        /**
         * Mimic a banked turn, Rolling the camera when Yawing.
         * It's recommended to use rollCorrect = 10 for faster banking correction.
         */
        _this.bankedTurn = false;
        /**
         * Limit in radians for how much Roll banking will add. (Default: 90)
         */
        _this.bankedTurnLimit = Math.PI / 2;
        /**
         * Value of 0 disables the banked Roll.
         * Value of 1 is equal to the Yaw angle in radians.
         */
        _this.bankedTurnMultiplier = 1;
        _this._needMoveForGravity = false;
        _this._oldPosition = Vector3.Zero();
        _this._diffPosition = Vector3.Zero();
        _this._newPosition = Vector3.Zero();
        // Collisions.
        _this._collisionMask = -1;
        /** @hidden */
        _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {
            if (collidedMesh === void 0) { collidedMesh = null; }
            var updatePosition = function (newPos) {
                _this._newPosition.copyFrom(newPos);
                _this._newPosition.subtractToRef(_this._oldPosition, _this._diffPosition);
                if (_this._diffPosition.length() > Engine.CollisionsEpsilon) {
                    _this.position.addInPlace(_this._diffPosition);
                    if (_this.onCollide && collidedMesh) {
                        _this.onCollide(collidedMesh);
                    }
                }
            };
            updatePosition(newPosition);
        };
        _this.inputs = new FlyCameraInputsManager(_this);
        _this.inputs.addKeyboard().addMouse();
        return _this;
    }
    Object.defineProperty(FlyCamera.prototype, "angularSensibility", {
        /**
         * Gets the input sensibility for mouse input.
         * Higher values reduce sensitivity.
         */
        get: function () {
            var mouse = this.inputs.attached["mouse"];
            if (mouse) {
                return mouse.angularSensibility;
            }
            return 0;
        },
        /**
         * Sets the input sensibility for a mouse input.
         * Higher values reduce sensitivity.
         */
        set: function (value) {
            var mouse = this.inputs.attached["mouse"];
            if (mouse) {
                mouse.angularSensibility = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlyCamera.prototype, "keysForward", {
        /**
         * Get the keys for camera movement forward.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysForward;
            }
            return [];
        },
        /**
        * Set the keys for camera movement forward.
        */
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysForward = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlyCamera.prototype, "keysBackward", {
        /**
         * Get the keys for camera movement backward.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysBackward;
            }
            return [];
        },
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysBackward = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlyCamera.prototype, "keysUp", {
        /**
         * Get the keys for camera movement up.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysUp;
            }
            return [];
        },
        /**
        * Set the keys for camera movement up.
        */
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysUp = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlyCamera.prototype, "keysDown", {
        /**
         * Get the keys for camera movement down.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysDown;
            }
            return [];
        },
        /**
        * Set the keys for camera movement down.
        */
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysDown = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlyCamera.prototype, "keysLeft", {
        /**
         * Get the keys for camera movement left.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysLeft;
            }
            return [];
        },
        /**
        * Set the keys for camera movement left.
        */
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysLeft = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlyCamera.prototype, "keysRight", {
        /**
         * Set the keys for camera movement right.
         */
        get: function () {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                return keyboard.keysRight;
            }
            return [];
        },
        /**
        * Set the keys for camera movement right.
        */
        set: function (value) {
            var keyboard = this.inputs.attached["keyboard"];
            if (keyboard) {
                keyboard.keysRight = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attach a control to the HTML DOM element.
     * @param element Defines the element that listens to the input events.
     * @param noPreventDefault Defines whether events caught by the controls should call preventdefault(). https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault
     */
    FlyCamera.prototype.attachControl = function (element, noPreventDefault) {
        this.inputs.attachElement(element, noPreventDefault);
    };
    /**
     * Detach a control from the HTML DOM element.
     * The camera will stop reacting to that input.
     * @param element Defines the element that listens to the input events.
     */
    FlyCamera.prototype.detachControl = function (element) {
        this.inputs.detachElement(element);
        this.cameraDirection = new Vector3(0, 0, 0);
    };
    Object.defineProperty(FlyCamera.prototype, "collisionMask", {
        /**
         * Get the mask that the camera ignores in collision events.
         */
        get: function () {
            return this._collisionMask;
        },
        /**
        * Set the mask that the camera ignores in collision events.
        */
        set: function (mask) {
            this._collisionMask = !isNaN(mask) ? mask : -1;
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden */
    FlyCamera.prototype._collideWithWorld = function (displacement) {
        var globalPosition;
        if (this.parent) {
            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
        }
        else {
            globalPosition = this.position;
        }
        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
        this._oldPosition.addInPlace(this.ellipsoidOffset);
        var coordinator = this.getScene().collisionCoordinator;
        if (!this._collider) {
            this._collider = coordinator.createCollider();
        }
        this._collider._radius = this.ellipsoid;
        this._collider.collisionMask = this._collisionMask;
        // No need for clone, as long as gravity is not on.
        var actualDisplacement = displacement;
        // Add gravity to direction to prevent dual-collision checking.
        if (this.applyGravity) {
            // This prevents mending with cameraDirection, a global variable of the fly camera class.
            actualDisplacement = displacement.add(this.getScene().gravity);
        }
        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
    };
    /** @hidden */
    FlyCamera.prototype._checkInputs = function () {
        if (!this._localDirection) {
            this._localDirection = Vector3.Zero();
            this._transformedDirection = Vector3.Zero();
        }
        this.inputs.checkInputs();
        _super.prototype._checkInputs.call(this);
    };
    /** @hidden */
    FlyCamera.prototype._decideIfNeedsToMove = function () {
        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
    };
    /** @hidden */
    FlyCamera.prototype._updatePosition = function () {
        if (this.checkCollisions && this.getScene().collisionsEnabled) {
            this._collideWithWorld(this.cameraDirection);
        }
        else {
            _super.prototype._updatePosition.call(this);
        }
    };
    /**
     * Restore the Roll to its target value at the rate specified.
     * @param rate - Higher means slower restoring.
     * @hidden
     */
    FlyCamera.prototype.restoreRoll = function (rate) {
        var limit = this._trackRoll; // Target Roll.
        var z = this.rotation.z; // Current Roll.
        var delta = limit - z; // Difference in Roll.
        var minRad = 0.001; // Tenth of a radian is a barely noticable difference.
        // If the difference is noticable, restore the Roll.
        if (Math.abs(delta) >= minRad) {
            // Change Z rotation towards the target Roll.
            this.rotation.z += delta / rate;
            // Match when near enough.
            if (Math.abs(limit - this.rotation.z) <= minRad) {
                this.rotation.z = limit;
            }
        }
    };
    /**
     * Destroy the camera and release the current resources held by it.
     */
    FlyCamera.prototype.dispose = function () {
        this.inputs.clear();
        _super.prototype.dispose.call(this);
    };
    /**
     * Get the current object class name.
     * @returns the class name.
     */
    FlyCamera.prototype.getClassName = function () {
        return "FlyCamera";
    };
    __decorate([
        serializeAsVector3()
    ], FlyCamera.prototype, "ellipsoid", void 0);
    __decorate([
        serializeAsVector3()
    ], FlyCamera.prototype, "ellipsoidOffset", void 0);
    __decorate([
        serialize()
    ], FlyCamera.prototype, "checkCollisions", void 0);
    __decorate([
        serialize()
    ], FlyCamera.prototype, "applyGravity", void 0);
    return FlyCamera;
}(TargetCamera));

/**
 * Default Inputs manager for the FollowCamera.
 * It groups all the default supported inputs for ease of use.
 * @see http://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var FollowCameraInputsManager = /** @class */ (function (_super) {
    __extends(FollowCameraInputsManager, _super);
    /**
     * Instantiates a new FollowCameraInputsManager.
     * @param camera Defines the camera the inputs belong to
     */
    function FollowCameraInputsManager(camera) {
        return _super.call(this, camera) || this;
    }
    /**
     * Add keyboard input support to the input manager.
     * @returns the current input manager
     */
    FollowCameraInputsManager.prototype.addKeyboard = function () {
        this.add(new FollowCameraKeyboardMoveInput());
        return this;
    };
    /**
     * Add mouse wheel input support to the input manager.
     * @returns the current input manager
     */
    FollowCameraInputsManager.prototype.addMouseWheel = function () {
        this.add(new FollowCameraMouseWheelInput());
        return this;
    };
    /**
     * Add pointers input support to the input manager.
     * @returns the current input manager
     */
    FollowCameraInputsManager.prototype.addPointers = function () {
        this.add(new FollowCameraPointersInput());
        return this;
    };
    /**
     * Add orientation input support to the input manager.
     * @returns the current input manager
     */
    FollowCameraInputsManager.prototype.addVRDeviceOrientation = function () {
        console.warn("DeviceOrientation support not yet implemented for FollowCamera.");
        return this;
    };
    return FollowCameraInputsManager;
}(CameraInputsManager));

Node$2.AddNodeConstructor("FollowCamera", function (name, scene) {
    return function () { return new FollowCamera(name, Vector3.Zero(), scene); };
});
Node$2.AddNodeConstructor("ArcFollowCamera", function (name, scene) {
    return function () { return new ArcFollowCamera(name, 0, 0, 1.0, null, scene); };
});
/**
 * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and
 * an arc rotate version arcFollowCamera are available.
 * @see http://doc.babylonjs.com/features/cameras#follow-camera
 */
var FollowCamera = /** @class */ (function (_super) {
    __extends(FollowCamera, _super);
    /**
     * Instantiates the follow camera.
     * @see http://doc.babylonjs.com/features/cameras#follow-camera
     * @param name Define the name of the camera in the scene
     * @param position Define the position of the camera
     * @param scene Define the scene the camera belong to
     * @param lockedTarget Define the target of the camera
     */
    function FollowCamera(name, position, scene, lockedTarget) {
        if (lockedTarget === void 0) { lockedTarget = null; }
        var _this = _super.call(this, name, position, scene) || this;
        /**
         * Distance the follow camera should follow an object at
         */
        _this.radius = 12;
        /**
         * Minimum allowed distance of the camera to the axis of rotation
         * (The camera can not get closer).
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.lowerRadiusLimit = null;
        /**
         * Maximum allowed distance of the camera to the axis of rotation
         * (The camera can not get further).
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.upperRadiusLimit = null;
        /**
         * Define a rotation offset between the camera and the object it follows
         */
        _this.rotationOffset = 0;
        /**
         * Minimum allowed angle to camera position relative to target object.
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.lowerRotationOffsetLimit = null;
        /**
         * Maximum allowed angle to camera position relative to target object.
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.upperRotationOffsetLimit = null;
        /**
         * Define a height offset between the camera and the object it follows.
         * It can help following an object from the top (like a car chaing a plane)
         */
        _this.heightOffset = 4;
        /**
         * Minimum allowed height of camera position relative to target object.
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.lowerHeightOffsetLimit = null;
        /**
         * Maximum allowed height of camera position relative to target object.
         * This can help limiting how the Camera is able to move in the scene.
         */
        _this.upperHeightOffsetLimit = null;
        /**
         * Define how fast the camera can accelerate to follow it s target.
         */
        _this.cameraAcceleration = 0.05;
        /**
         * Define the speed limit of the camera following an object.
         */
        _this.maxCameraSpeed = 20;
        _this.lockedTarget = lockedTarget;
        _this.inputs = new FollowCameraInputsManager(_this);
        _this.inputs.addKeyboard().addMouseWheel().addPointers();
        return _this;
        // Uncomment the following line when the relevant handlers have been implemented.
        // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();
    }
    FollowCamera.prototype._follow = function (cameraTarget) {
        if (!cameraTarget) {
            return;
        }
        var yRotation;
        if (cameraTarget.rotationQuaternion) {
            var rotMatrix = new Matrix();
            cameraTarget.rotationQuaternion.toRotationMatrix(rotMatrix);
            yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);
        }
        else {
            yRotation = cameraTarget.rotation.y;
        }
        var radians = Tools.ToRadians(this.rotationOffset) + yRotation;
        var targetPosition = cameraTarget.getAbsolutePosition();
        var targetX = targetPosition.x + Math.sin(radians) * this.radius;
        var targetZ = targetPosition.z + Math.cos(radians) * this.radius;
        var dx = targetX - this.position.x;
        var dy = (targetPosition.y + this.heightOffset) - this.position.y;
        var dz = (targetZ) - this.position.z;
        var vx = dx * this.cameraAcceleration * 2; //this is set to .05
        var vy = dy * this.cameraAcceleration;
        var vz = dz * this.cameraAcceleration * 2;
        if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {
            vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
        }
        if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {
            vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
        }
        if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {
            vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
        }
        this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);
        this.setTarget(targetPosition);
    };
    /**
     * Attached controls to the current camera.
     * @param element Defines the element the controls should be listened from
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    FollowCamera.prototype.attachControl = function (element, noPreventDefault) {
        this.inputs.attachElement(element, noPreventDefault);
        this._reset = function () {
        };
    };
    /**
     * Detach the current controls from the camera.
     * The camera will stop reacting to inputs.
     * @param element Defines the element to stop listening the inputs from
     */
    FollowCamera.prototype.detachControl = function (element) {
        this.inputs.detachElement(element);
        if (this._reset) {
            this._reset();
        }
    };
    /** @hidden */
    FollowCamera.prototype._checkInputs = function () {
        this.inputs.checkInputs();
        this._checkLimits();
        _super.prototype._checkInputs.call(this);
        if (this.lockedTarget) {
            this._follow(this.lockedTarget);
        }
    };
    FollowCamera.prototype._checkLimits = function () {
        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
            this.radius = this.lowerRadiusLimit;
        }
        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
            this.radius = this.upperRadiusLimit;
        }
        if (this.lowerHeightOffsetLimit !== null &&
            this.heightOffset < this.lowerHeightOffsetLimit) {
            this.heightOffset = this.lowerHeightOffsetLimit;
        }
        if (this.upperHeightOffsetLimit !== null &&
            this.heightOffset > this.upperHeightOffsetLimit) {
            this.heightOffset = this.upperHeightOffsetLimit;
        }
        if (this.lowerRotationOffsetLimit !== null &&
            this.rotationOffset < this.lowerRotationOffsetLimit) {
            this.rotationOffset = this.lowerRotationOffsetLimit;
        }
        if (this.upperRotationOffsetLimit !== null &&
            this.rotationOffset > this.upperRotationOffsetLimit) {
            this.rotationOffset = this.upperRotationOffsetLimit;
        }
    };
    /**
     * Gets the camera class name.
     * @returns the class name
     */
    FollowCamera.prototype.getClassName = function () {
        return "FollowCamera";
    };
    __decorate([
        serialize()
    ], FollowCamera.prototype, "radius", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "lowerRadiusLimit", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "upperRadiusLimit", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "rotationOffset", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "lowerRotationOffsetLimit", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "upperRotationOffsetLimit", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "heightOffset", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "lowerHeightOffsetLimit", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "upperHeightOffsetLimit", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "cameraAcceleration", void 0);
    __decorate([
        serialize()
    ], FollowCamera.prototype, "maxCameraSpeed", void 0);
    __decorate([
        serializeAsMeshReference("lockedTargetId")
    ], FollowCamera.prototype, "lockedTarget", void 0);
    return FollowCamera;
}(TargetCamera));
/**
 * Arc Rotate version of the follow camera.
 * It still follows a Defined mesh but in an Arc Rotate Camera fashion.
 * @see http://doc.babylonjs.com/features/cameras#follow-camera
 */
var ArcFollowCamera = /** @class */ (function (_super) {
    __extends(ArcFollowCamera, _super);
    /**
     * Instantiates a new ArcFollowCamera
     * @see http://doc.babylonjs.com/features/cameras#follow-camera
     * @param name Define the name of the camera
     * @param alpha Define the rotation angle of the camera around the logitudinal axis
     * @param beta Define the rotation angle of the camera around the elevation axis
     * @param radius Define the radius of the camera from its target point
     * @param target Define the target of the camera
     * @param scene Define the scene the camera belongs to
     */
    function ArcFollowCamera(name, 
    /** The longitudinal angle of the camera */
    alpha, 
    /** The latitudinal angle of the camera */
    beta, 
    /** The radius of the camera from its target */
    radius, 
    /** Define the camera target (the messh it should follow) */
    target, scene) {
        var _this = _super.call(this, name, Vector3.Zero(), scene) || this;
        _this.alpha = alpha;
        _this.beta = beta;
        _this.radius = radius;
        _this.target = target;
        _this._cartesianCoordinates = Vector3.Zero();
        _this._follow();
        return _this;
    }
    ArcFollowCamera.prototype._follow = function () {
        if (!this.target) {
            return;
        }
        this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);
        this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);
        this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);
        var targetPosition = this.target.getAbsolutePosition();
        this.position = targetPosition.add(this._cartesianCoordinates);
        this.setTarget(targetPosition);
    };
    /** @hidden */
    ArcFollowCamera.prototype._checkInputs = function () {
        _super.prototype._checkInputs.call(this);
        this._follow();
    };
    /**
     * Returns the class name of the object.
     * It is mostly used internally for serialization purposes.
     */
    ArcFollowCamera.prototype.getClassName = function () {
        return "ArcFollowCamera";
    };
    return ArcFollowCamera;
}(TargetCamera));

/**
* Defines the types of pose enabled controllers that are supported
*/
var PoseEnabledControllerType;
(function (PoseEnabledControllerType) {
    /**
     * HTC Vive
     */
    PoseEnabledControllerType[PoseEnabledControllerType["VIVE"] = 0] = "VIVE";
    /**
     * Oculus Rift
     */
    PoseEnabledControllerType[PoseEnabledControllerType["OCULUS"] = 1] = "OCULUS";
    /**
     * Windows mixed reality
     */
    PoseEnabledControllerType[PoseEnabledControllerType["WINDOWS"] = 2] = "WINDOWS";
    /**
     * Samsung gear VR
     */
    PoseEnabledControllerType[PoseEnabledControllerType["GEAR_VR"] = 3] = "GEAR_VR";
    /**
     * Google Daydream
     */
    PoseEnabledControllerType[PoseEnabledControllerType["DAYDREAM"] = 4] = "DAYDREAM";
    /**
     * Generic
     */
    PoseEnabledControllerType[PoseEnabledControllerType["GENERIC"] = 5] = "GENERIC";
})(PoseEnabledControllerType || (PoseEnabledControllerType = {}));
/**
 * Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
 */
var PoseEnabledControllerHelper = /** @class */ (function () {
    function PoseEnabledControllerHelper() {
    }
    /**
     * Initializes a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
     * @param vrGamepad the gamepad to initialized
     * @returns a vr controller of the type the gamepad identified as
     */
    PoseEnabledControllerHelper.InitiateController = function (vrGamepad) {
        for (var _i = 0, _a = this._ControllerFactories; _i < _a.length; _i++) {
            var factory = _a[_i];
            if (factory.canCreate(vrGamepad)) {
                return factory.create(vrGamepad);
            }
        }
        if (this._DefaultControllerFactory) {
            return this._DefaultControllerFactory(vrGamepad);
        }
        throw "The type of gamepad you are trying to load needs to be imported first or is not supported.";
    };
    /** @hidden */
    PoseEnabledControllerHelper._ControllerFactories = [];
    /** @hidden */
    PoseEnabledControllerHelper._DefaultControllerFactory = null;
    return PoseEnabledControllerHelper;
}());
/**
 * Defines the PoseEnabledController object that contains state of a vr capable controller
 */
var PoseEnabledController = /** @class */ (function (_super) {
    __extends(PoseEnabledController, _super);
    /**
     * Creates a new PoseEnabledController from a gamepad
     * @param browserGamepad the gamepad that the PoseEnabledController should be created from
     */
    function PoseEnabledController(browserGamepad) {
        var _this = _super.call(this, browserGamepad.id, browserGamepad.index, browserGamepad) || this;
        // Represents device position and rotation in room space. Should only be used to help calculate babylon space values
        _this._deviceRoomPosition = Vector3.Zero();
        _this._deviceRoomRotationQuaternion = new Quaternion();
        /**
         * The device position in babylon space
         */
        _this.devicePosition = Vector3.Zero();
        /**
         * The device rotation in babylon space
         */
        _this.deviceRotationQuaternion = new Quaternion();
        /**
         * The scale factor of the device in babylon space
         */
        _this.deviceScaleFactor = 1;
        // Used to convert 6dof controllers to 3dof
        _this._trackPosition = true;
        _this._maxRotationDistFromHeadset = Math.PI / 5;
        _this._draggedRoomRotation = 0;
        _this._leftHandSystemQuaternion = new Quaternion();
        /**
         * Internal, matrix used to convert room space to babylon space
         * @hidden
         */
        _this._deviceToWorld = Matrix.Identity();
        /**
         * Node to be used when casting a ray from the controller
         * @hidden
         */
        _this._pointingPoseNode = null;
        _this._workingMatrix = Matrix.Identity();
        /**
         * @hidden
         */
        _this._meshAttachedObservable = new Observable();
        _this.type = Gamepad.POSE_ENABLED;
        _this.controllerType = PoseEnabledControllerType.GENERIC;
        _this.position = Vector3.Zero();
        _this.rotationQuaternion = new Quaternion();
        _this._calculatedPosition = Vector3.Zero();
        _this._calculatedRotation = new Quaternion();
        Quaternion.RotationYawPitchRollToRef(Math.PI, 0, 0, _this._leftHandSystemQuaternion);
        return _this;
    }
    /**
     * @hidden
     */
    PoseEnabledController.prototype._disableTrackPosition = function (fixedPosition) {
        if (this._trackPosition) {
            this._calculatedPosition.copyFrom(fixedPosition);
            this._trackPosition = false;
        }
    };
    /**
     * Updates the state of the pose enbaled controller and mesh based on the current position and rotation of the controller
     */
    PoseEnabledController.prototype.update = function () {
        _super.prototype.update.call(this);
        this._updatePoseAndMesh();
    };
    /**
     * Updates only the pose device and mesh without doing any button event checking
     */
    PoseEnabledController.prototype._updatePoseAndMesh = function () {
        var pose = this.browserGamepad.pose;
        this.updateFromDevice(pose);
        if (!this._trackPosition && EngineStore.LastCreatedScene && EngineStore.LastCreatedScene.activeCamera && EngineStore.LastCreatedScene.activeCamera.devicePosition) {
            var camera = EngineStore.LastCreatedScene.activeCamera;
            camera._computeDevicePosition();
            this._deviceToWorld.setTranslation(camera.devicePosition);
            if (camera.deviceRotationQuaternion) {
                var camera = camera;
                camera._deviceRoomRotationQuaternion.toEulerAnglesToRef(Tmp.Vector3[0]);
                // Find the radian distance away that the headset is from the controllers rotation
                var distanceAway = Math.atan2(Math.sin(Tmp.Vector3[0].y - this._draggedRoomRotation), Math.cos(Tmp.Vector3[0].y - this._draggedRoomRotation));
                if (Math.abs(distanceAway) > this._maxRotationDistFromHeadset) {
                    // Only rotate enouph to be within the _maxRotationDistFromHeadset
                    var rotationAmount = distanceAway - (distanceAway < 0 ? -this._maxRotationDistFromHeadset : this._maxRotationDistFromHeadset);
                    this._draggedRoomRotation += rotationAmount;
                    // Rotate controller around headset
                    var sin = Math.sin(-rotationAmount);
                    var cos = Math.cos(-rotationAmount);
                    this._calculatedPosition.x = this._calculatedPosition.x * cos - this._calculatedPosition.z * sin;
                    this._calculatedPosition.z = this._calculatedPosition.x * sin + this._calculatedPosition.z * cos;
                }
            }
        }
        Vector3.TransformCoordinatesToRef(this._calculatedPosition, this._deviceToWorld, this.devicePosition);
        this._deviceToWorld.getRotationMatrixToRef(this._workingMatrix);
        Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);
        this.deviceRotationQuaternion.multiplyInPlace(this._calculatedRotation);
        if (this._mesh) {
            this._mesh.position.copyFrom(this.devicePosition);
            if (this._mesh.rotationQuaternion) {
                this._mesh.rotationQuaternion.copyFrom(this.deviceRotationQuaternion);
            }
        }
    };
    /**
     * Updates the state of the pose enbaled controller based on the raw pose data from the device
     * @param poseData raw pose fromthe device
     */
    PoseEnabledController.prototype.updateFromDevice = function (poseData) {
        if (poseData) {
            this.rawPose = poseData;
            if (poseData.position) {
                this._deviceRoomPosition.copyFromFloats(poseData.position[0], poseData.position[1], -poseData.position[2]);
                if (this._mesh && this._mesh.getScene().useRightHandedSystem) {
                    this._deviceRoomPosition.z *= -1;
                }
                if (this._trackPosition) {
                    this._deviceRoomPosition.scaleToRef(this.deviceScaleFactor, this._calculatedPosition);
                }
                this._calculatedPosition.addInPlace(this.position);
            }
            var pose = this.rawPose;
            if (poseData.orientation && pose.orientation) {
                this._deviceRoomRotationQuaternion.copyFromFloats(pose.orientation[0], pose.orientation[1], -pose.orientation[2], -pose.orientation[3]);
                if (this._mesh) {
                    if (this._mesh.getScene().useRightHandedSystem) {
                        this._deviceRoomRotationQuaternion.z *= -1;
                        this._deviceRoomRotationQuaternion.w *= -1;
                    }
                    else {
                        this._deviceRoomRotationQuaternion.multiplyToRef(this._leftHandSystemQuaternion, this._deviceRoomRotationQuaternion);
                    }
                }
                // if the camera is set, rotate to the camera's rotation
                this._deviceRoomRotationQuaternion.multiplyToRef(this.rotationQuaternion, this._calculatedRotation);
            }
        }
    };
    /**
     * Attaches a mesh to the controller
     * @param mesh the mesh to be attached
     */
    PoseEnabledController.prototype.attachToMesh = function (mesh) {
        if (this._mesh) {
            this._mesh.parent = null;
        }
        this._mesh = mesh;
        if (this._poseControlledCamera) {
            this._mesh.parent = this._poseControlledCamera;
        }
        if (!this._mesh.rotationQuaternion) {
            this._mesh.rotationQuaternion = new Quaternion();
        }
        // Sync controller mesh and pointing pose node's state with controller, this is done to avoid a frame where position is 0,0,0 when attaching mesh
        this._updatePoseAndMesh();
        if (this._pointingPoseNode) {
            var parents = [];
            var obj = this._pointingPoseNode;
            while (obj.parent) {
                parents.push(obj.parent);
                obj = obj.parent;
            }
            parents.reverse().forEach(function (p) { p.computeWorldMatrix(true); });
        }
        this._meshAttachedObservable.notifyObservers(mesh);
    };
    /**
     * Attaches the controllers mesh to a camera
     * @param camera the camera the mesh should be attached to
     */
    PoseEnabledController.prototype.attachToPoseControlledCamera = function (camera) {
        this._poseControlledCamera = camera;
        if (this._mesh) {
            this._mesh.parent = this._poseControlledCamera;
        }
    };
    /**
     * Disposes of the controller
     */
    PoseEnabledController.prototype.dispose = function () {
        if (this._mesh) {
            this._mesh.dispose();
        }
        this._mesh = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(PoseEnabledController.prototype, "mesh", {
        /**
         * The mesh that is attached to the controller
         */
        get: function () {
            return this._mesh;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the ray of the controller in the direction the controller is pointing
     * @param length the length the resulting ray should be
     * @returns a ray in the direction the controller is pointing
     */
    PoseEnabledController.prototype.getForwardRay = function (length) {
        if (length === void 0) { length = 100; }
        if (!this.mesh) {
            return new Ray(Vector3.Zero(), new Vector3(0, 0, 1), length);
        }
        var m = this._pointingPoseNode ? this._pointingPoseNode.getWorldMatrix() : this.mesh.getWorldMatrix();
        var origin = m.getTranslation();
        var forward = new Vector3(0, 0, -1);
        var forwardWorld = Vector3.TransformNormal(forward, m);
        var direction = Vector3.Normalize(forwardWorld);
        return new Ray(origin, direction, length);
    };
    /**
     * Name of the child mesh that can be used to cast a ray from the controller
     */
    PoseEnabledController.POINTING_POSE = "POINTING_POSE";
    return PoseEnabledController;
}(Gamepad));

/**
 * Defines supported buttons for XBox360 compatible gamepads
 */
var Xbox360Button;
(function (Xbox360Button) {
    /** A */
    Xbox360Button[Xbox360Button["A"] = 0] = "A";
    /** B */
    Xbox360Button[Xbox360Button["B"] = 1] = "B";
    /** X */
    Xbox360Button[Xbox360Button["X"] = 2] = "X";
    /** Y */
    Xbox360Button[Xbox360Button["Y"] = 3] = "Y";
    /** Start */
    Xbox360Button[Xbox360Button["Start"] = 4] = "Start";
    /** Back */
    Xbox360Button[Xbox360Button["Back"] = 5] = "Back";
    /** Left button */
    Xbox360Button[Xbox360Button["LB"] = 6] = "LB";
    /** Right button */
    Xbox360Button[Xbox360Button["RB"] = 7] = "RB";
    /** Left stick */
    Xbox360Button[Xbox360Button["LeftStick"] = 8] = "LeftStick";
    /** Right stick */
    Xbox360Button[Xbox360Button["RightStick"] = 9] = "RightStick";
})(Xbox360Button || (Xbox360Button = {}));
/** Defines values for XBox360 DPad  */
var Xbox360Dpad;
(function (Xbox360Dpad) {
    /** Up */
    Xbox360Dpad[Xbox360Dpad["Up"] = 0] = "Up";
    /** Down */
    Xbox360Dpad[Xbox360Dpad["Down"] = 1] = "Down";
    /** Left */
    Xbox360Dpad[Xbox360Dpad["Left"] = 2] = "Left";
    /** Right */
    Xbox360Dpad[Xbox360Dpad["Right"] = 3] = "Right";
})(Xbox360Dpad || (Xbox360Dpad = {}));
/**
 * Defines a XBox360 gamepad
 */
var Xbox360Pad = /** @class */ (function (_super) {
    __extends(Xbox360Pad, _super);
    /**
     * Creates a new XBox360 gamepad object
     * @param id defines the id of this gamepad
     * @param index defines its index
     * @param gamepad defines the internal HTML gamepad object
     * @param xboxOne defines if it is a XBox One gamepad
     */
    function Xbox360Pad(id, index, gamepad, xboxOne) {
        if (xboxOne === void 0) { xboxOne = false; }
        var _this = _super.call(this, id, index, gamepad, 0, 1, 2, 3) || this;
        _this._leftTrigger = 0;
        _this._rightTrigger = 0;
        /** Observable raised when a button is pressed */
        _this.onButtonDownObservable = new Observable();
        /** Observable raised when a button is released */
        _this.onButtonUpObservable = new Observable();
        /** Observable raised when a pad is pressed */
        _this.onPadDownObservable = new Observable();
        /** Observable raised when a pad is released */
        _this.onPadUpObservable = new Observable();
        _this._buttonA = 0;
        _this._buttonB = 0;
        _this._buttonX = 0;
        _this._buttonY = 0;
        _this._buttonBack = 0;
        _this._buttonStart = 0;
        _this._buttonLB = 0;
        _this._buttonRB = 0;
        _this._buttonLeftStick = 0;
        _this._buttonRightStick = 0;
        _this._dPadUp = 0;
        _this._dPadDown = 0;
        _this._dPadLeft = 0;
        _this._dPadRight = 0;
        _this._isXboxOnePad = false;
        _this.type = Gamepad.XBOX;
        _this._isXboxOnePad = xboxOne;
        return _this;
    }
    /**
     * Defines the callback to call when left trigger is pressed
     * @param callback defines the callback to use
     */
    Xbox360Pad.prototype.onlefttriggerchanged = function (callback) {
        this._onlefttriggerchanged = callback;
    };
    /**
     * Defines the callback to call when right trigger is pressed
     * @param callback defines the callback to use
     */
    Xbox360Pad.prototype.onrighttriggerchanged = function (callback) {
        this._onrighttriggerchanged = callback;
    };
    Object.defineProperty(Xbox360Pad.prototype, "leftTrigger", {
        /**
         * Gets the left trigger value
         */
        get: function () {
            return this._leftTrigger;
        },
        /**
         * Sets the left trigger value
         */
        set: function (newValue) {
            if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {
                this._onlefttriggerchanged(newValue);
            }
            this._leftTrigger = newValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "rightTrigger", {
        /**
         * Gets the right trigger value
         */
        get: function () {
            return this._rightTrigger;
        },
        /**
         * Sets the right trigger value
         */
        set: function (newValue) {
            if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {
                this._onrighttriggerchanged(newValue);
            }
            this._rightTrigger = newValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Defines the callback to call when a button is pressed
     * @param callback defines the callback to use
     */
    Xbox360Pad.prototype.onbuttondown = function (callback) {
        this._onbuttondown = callback;
    };
    /**
     * Defines the callback to call when a button is released
     * @param callback defines the callback to use
     */
    Xbox360Pad.prototype.onbuttonup = function (callback) {
        this._onbuttonup = callback;
    };
    /**
     * Defines the callback to call when a pad is pressed
     * @param callback defines the callback to use
     */
    Xbox360Pad.prototype.ondpaddown = function (callback) {
        this._ondpaddown = callback;
    };
    /**
     * Defines the callback to call when a pad is released
     * @param callback defines the callback to use
     */
    Xbox360Pad.prototype.ondpadup = function (callback) {
        this._ondpadup = callback;
    };
    Xbox360Pad.prototype._setButtonValue = function (newValue, currentValue, buttonType) {
        if (newValue !== currentValue) {
            if (newValue === 1) {
                if (this._onbuttondown) {
                    this._onbuttondown(buttonType);
                }
                this.onButtonDownObservable.notifyObservers(buttonType);
            }
            if (newValue === 0) {
                if (this._onbuttonup) {
                    this._onbuttonup(buttonType);
                }
                this.onButtonUpObservable.notifyObservers(buttonType);
            }
        }
        return newValue;
    };
    Xbox360Pad.prototype._setDPadValue = function (newValue, currentValue, buttonType) {
        if (newValue !== currentValue) {
            if (newValue === 1) {
                if (this._ondpaddown) {
                    this._ondpaddown(buttonType);
                }
                this.onPadDownObservable.notifyObservers(buttonType);
            }
            if (newValue === 0) {
                if (this._ondpadup) {
                    this._ondpadup(buttonType);
                }
                this.onPadUpObservable.notifyObservers(buttonType);
            }
        }
        return newValue;
    };
    Object.defineProperty(Xbox360Pad.prototype, "buttonA", {
        /**
         * Gets the value of the `A` button
         */
        get: function () {
            return this._buttonA;
        },
        /**
         * Sets the value of the `A` button
         */
        set: function (value) {
            this._buttonA = this._setButtonValue(value, this._buttonA, Xbox360Button.A);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "buttonB", {
        /**
         * Gets the value of the `B` button
         */
        get: function () {
            return this._buttonB;
        },
        /**
         * Sets the value of the `B` button
         */
        set: function (value) {
            this._buttonB = this._setButtonValue(value, this._buttonB, Xbox360Button.B);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "buttonX", {
        /**
         * Gets the value of the `X` button
         */
        get: function () {
            return this._buttonX;
        },
        /**
         * Sets the value of the `X` button
         */
        set: function (value) {
            this._buttonX = this._setButtonValue(value, this._buttonX, Xbox360Button.X);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "buttonY", {
        /**
         * Gets the value of the `Y` button
         */
        get: function () {
            return this._buttonY;
        },
        /**
         * Sets the value of the `Y` button
         */
        set: function (value) {
            this._buttonY = this._setButtonValue(value, this._buttonY, Xbox360Button.Y);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "buttonStart", {
        /**
         * Gets the value of the `Start` button
         */
        get: function () {
            return this._buttonStart;
        },
        /**
         * Sets the value of the `Start` button
         */
        set: function (value) {
            this._buttonStart = this._setButtonValue(value, this._buttonStart, Xbox360Button.Start);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "buttonBack", {
        /**
         * Gets the value of the `Back` button
         */
        get: function () {
            return this._buttonBack;
        },
        /**
         * Sets the value of the `Back` button
         */
        set: function (value) {
            this._buttonBack = this._setButtonValue(value, this._buttonBack, Xbox360Button.Back);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "buttonLB", {
        /**
         * Gets the value of the `Left` button
         */
        get: function () {
            return this._buttonLB;
        },
        /**
         * Sets the value of the `Left` button
         */
        set: function (value) {
            this._buttonLB = this._setButtonValue(value, this._buttonLB, Xbox360Button.LB);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "buttonRB", {
        /**
         * Gets the value of the `Right` button
         */
        get: function () {
            return this._buttonRB;
        },
        /**
         * Sets the value of the `Right` button
         */
        set: function (value) {
            this._buttonRB = this._setButtonValue(value, this._buttonRB, Xbox360Button.RB);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "buttonLeftStick", {
        /**
         * Gets the value of the Left joystick
         */
        get: function () {
            return this._buttonLeftStick;
        },
        /**
         * Sets the value of the Left joystick
         */
        set: function (value) {
            this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, Xbox360Button.LeftStick);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "buttonRightStick", {
        /**
         * Gets the value of the Right joystick
         */
        get: function () {
            return this._buttonRightStick;
        },
        /**
         * Sets the value of the Right joystick
         */
        set: function (value) {
            this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, Xbox360Button.RightStick);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "dPadUp", {
        /**
         * Gets the value of D-pad up
         */
        get: function () {
            return this._dPadUp;
        },
        /**
         * Sets the value of D-pad up
         */
        set: function (value) {
            this._dPadUp = this._setDPadValue(value, this._dPadUp, Xbox360Dpad.Up);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "dPadDown", {
        /**
         * Gets the value of D-pad down
         */
        get: function () {
            return this._dPadDown;
        },
        /**
         * Sets the value of D-pad down
         */
        set: function (value) {
            this._dPadDown = this._setDPadValue(value, this._dPadDown, Xbox360Dpad.Down);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "dPadLeft", {
        /**
         * Gets the value of D-pad left
         */
        get: function () {
            return this._dPadLeft;
        },
        /**
         * Sets the value of D-pad left
         */
        set: function (value) {
            this._dPadLeft = this._setDPadValue(value, this._dPadLeft, Xbox360Dpad.Left);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Xbox360Pad.prototype, "dPadRight", {
        /**
         * Gets the value of D-pad right
         */
        get: function () {
            return this._dPadRight;
        },
        /**
         * Sets the value of D-pad right
         */
        set: function (value) {
            this._dPadRight = this._setDPadValue(value, this._dPadRight, Xbox360Dpad.Right);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Force the gamepad to synchronize with device values
     */
    Xbox360Pad.prototype.update = function () {
        _super.prototype.update.call(this);
        if (this._isXboxOnePad) {
            this.buttonA = this.browserGamepad.buttons[0].value;
            this.buttonB = this.browserGamepad.buttons[1].value;
            this.buttonX = this.browserGamepad.buttons[2].value;
            this.buttonY = this.browserGamepad.buttons[3].value;
            this.buttonLB = this.browserGamepad.buttons[4].value;
            this.buttonRB = this.browserGamepad.buttons[5].value;
            this.leftTrigger = this.browserGamepad.axes[2];
            this.rightTrigger = this.browserGamepad.axes[5];
            this.buttonBack = this.browserGamepad.buttons[9].value;
            this.buttonStart = this.browserGamepad.buttons[8].value;
            this.buttonLeftStick = this.browserGamepad.buttons[6].value;
            this.buttonRightStick = this.browserGamepad.buttons[7].value;
            this.dPadUp = this.browserGamepad.buttons[11].value;
            this.dPadDown = this.browserGamepad.buttons[12].value;
            this.dPadLeft = this.browserGamepad.buttons[13].value;
            this.dPadRight = this.browserGamepad.buttons[14].value;
        }
        else {
            this.buttonA = this.browserGamepad.buttons[0].value;
            this.buttonB = this.browserGamepad.buttons[1].value;
            this.buttonX = this.browserGamepad.buttons[2].value;
            this.buttonY = this.browserGamepad.buttons[3].value;
            this.buttonLB = this.browserGamepad.buttons[4].value;
            this.buttonRB = this.browserGamepad.buttons[5].value;
            this.leftTrigger = this.browserGamepad.buttons[6].value;
            this.rightTrigger = this.browserGamepad.buttons[7].value;
            this.buttonBack = this.browserGamepad.buttons[8].value;
            this.buttonStart = this.browserGamepad.buttons[9].value;
            this.buttonLeftStick = this.browserGamepad.buttons[10].value;
            this.buttonRightStick = this.browserGamepad.buttons[11].value;
            this.dPadUp = this.browserGamepad.buttons[12].value;
            this.dPadDown = this.browserGamepad.buttons[13].value;
            this.dPadLeft = this.browserGamepad.buttons[14].value;
            this.dPadRight = this.browserGamepad.buttons[15].value;
        }
    };
    /**
     * Disposes the gamepad
     */
    Xbox360Pad.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.onButtonDownObservable.clear();
        this.onButtonUpObservable.clear();
        this.onPadDownObservable.clear();
        this.onPadUpObservable.clear();
    };
    return Xbox360Pad;
}(Gamepad));

/**
 * Manager for handling gamepads
 */
var GamepadManager = /** @class */ (function () {
    /**
     * Initializes the gamepad manager
     * @param _scene BabylonJS scene
     */
    function GamepadManager(_scene) {
        var _this = this;
        this._scene = _scene;
        this._babylonGamepads = [];
        this._oneGamepadConnected = false;
        /** @hidden */
        this._isMonitoring = false;
        /**
         * observable to be triggered when the gamepad controller has been disconnected
         */
        this.onGamepadDisconnectedObservable = new Observable();
        if (!DomManagement.IsWindowObjectExist()) {
            this._gamepadEventSupported = false;
        }
        else {
            this._gamepadEventSupported = 'GamepadEvent' in window;
            this._gamepadSupport = (navigator.getGamepads ||
                navigator.webkitGetGamepads || navigator.msGetGamepads || navigator.webkitGamepads);
        }
        this.onGamepadConnectedObservable = new Observable(function (observer) {
            // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected
            for (var i in _this._babylonGamepads) {
                var gamepad = _this._babylonGamepads[i];
                if (gamepad && gamepad._isConnected) {
                    _this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);
                }
            }
        });
        this._onGamepadConnectedEvent = function (evt) {
            var gamepad = evt.gamepad;
            if (gamepad.index in _this._babylonGamepads) {
                if (_this._babylonGamepads[gamepad.index].isConnected) {
                    return;
                }
            }
            var newGamepad;
            if (_this._babylonGamepads[gamepad.index]) {
                newGamepad = _this._babylonGamepads[gamepad.index];
                newGamepad.browserGamepad = gamepad;
                newGamepad._isConnected = true;
            }
            else {
                newGamepad = _this._addNewGamepad(gamepad);
            }
            _this.onGamepadConnectedObservable.notifyObservers(newGamepad);
            _this._startMonitoringGamepads();
        };
        this._onGamepadDisconnectedEvent = function (evt) {
            var gamepad = evt.gamepad;
            // Remove the gamepad from the list of gamepads to monitor.
            for (var i in _this._babylonGamepads) {
                if (_this._babylonGamepads[i].index === gamepad.index) {
                    var disconnectedGamepad = _this._babylonGamepads[i];
                    disconnectedGamepad._isConnected = false;
                    _this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);
                    break;
                }
            }
        };
        if (this._gamepadSupport) {
            //first add already-connected gamepads
            this._updateGamepadObjects();
            if (this._babylonGamepads.length) {
                this._startMonitoringGamepads();
            }
            // Checking if the gamepad connected event is supported (like in Firefox)
            if (this._gamepadEventSupported) {
                window.addEventListener('gamepadconnected', this._onGamepadConnectedEvent, false);
                window.addEventListener('gamepaddisconnected', this._onGamepadDisconnectedEvent, false);
            }
            else {
                this._startMonitoringGamepads();
            }
        }
    }
    Object.defineProperty(GamepadManager.prototype, "gamepads", {
        /**
         * The gamepads in the game pad manager
         */
        get: function () {
            return this._babylonGamepads;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the gamepad controllers based on type
     * @param type The type of gamepad controller
     * @returns Nullable gamepad
     */
    GamepadManager.prototype.getGamepadByType = function (type) {
        if (type === void 0) { type = Gamepad.XBOX; }
        for (var _i = 0, _a = this._babylonGamepads; _i < _a.length; _i++) {
            var gamepad = _a[_i];
            if (gamepad && gamepad.type === type) {
                return gamepad;
            }
        }
        return null;
    };
    /**
     * Disposes the gamepad manager
     */
    GamepadManager.prototype.dispose = function () {
        if (this._gamepadEventSupported) {
            if (this._onGamepadConnectedEvent) {
                window.removeEventListener('gamepadconnected', this._onGamepadConnectedEvent);
            }
            if (this._onGamepadDisconnectedEvent) {
                window.removeEventListener('gamepaddisconnected', this._onGamepadDisconnectedEvent);
            }
            this._onGamepadConnectedEvent = null;
            this._onGamepadDisconnectedEvent = null;
        }
        this._babylonGamepads.forEach(function (gamepad) {
            gamepad.dispose();
        });
        this.onGamepadConnectedObservable.clear();
        this.onGamepadDisconnectedObservable.clear();
        this._oneGamepadConnected = false;
        this._stopMonitoringGamepads();
        this._babylonGamepads = [];
    };
    GamepadManager.prototype._addNewGamepad = function (gamepad) {
        if (!this._oneGamepadConnected) {
            this._oneGamepadConnected = true;
        }
        var newGamepad;
        var xboxOne = (gamepad.id.search("Xbox One") !== -1);
        if (xboxOne || gamepad.id.search("Xbox 360") !== -1 || gamepad.id.search("xinput") !== -1) {
            newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);
        }
        // if pose is supported, use the (WebVR) pose enabled controller
        else if (gamepad.pose) {
            newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);
        }
        else {
            newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);
        }
        this._babylonGamepads[newGamepad.index] = newGamepad;
        return newGamepad;
    };
    GamepadManager.prototype._startMonitoringGamepads = function () {
        if (!this._isMonitoring) {
            this._isMonitoring = true;
            //back-comp
            if (!this._scene) {
                this._checkGamepadsStatus();
            }
        }
    };
    GamepadManager.prototype._stopMonitoringGamepads = function () {
        this._isMonitoring = false;
    };
    /** @hidden */
    GamepadManager.prototype._checkGamepadsStatus = function () {
        var _this = this;
        // Hack to be compatible Chrome
        this._updateGamepadObjects();
        for (var i in this._babylonGamepads) {
            var gamepad = this._babylonGamepads[i];
            if (!gamepad || !gamepad.isConnected) {
                continue;
            }
            gamepad.update();
        }
        if (this._isMonitoring && !this._scene) {
            Tools.QueueNewFrame(function () { _this._checkGamepadsStatus(); });
        }
    };
    // This function is called only on Chrome, which does not properly support
    // connection/disconnection events and forces you to recopy again the gamepad object
    GamepadManager.prototype._updateGamepadObjects = function () {
        var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
        for (var i = 0; i < gamepads.length; i++) {
            var gamepad = gamepads[i];
            if (gamepad) {
                if (!this._babylonGamepads[gamepad.index]) {
                    var newGamepad = this._addNewGamepad(gamepad);
                    this.onGamepadConnectedObservable.notifyObservers(newGamepad);
                }
                else {
                    // Forced to copy again this object for Chrome for unknown reason
                    this._babylonGamepads[i].browserGamepad = gamepad;
                    if (!this._babylonGamepads[i].isConnected) {
                        this._babylonGamepads[i]._isConnected = true;
                        this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);
                    }
                }
            }
        }
    };
    return GamepadManager;
}());

Object.defineProperty(Scene.prototype, "gamepadManager", {
    get: function () {
        if (!this._gamepadManager) {
            this._gamepadManager = new GamepadManager(this);
            var component = this._getComponent(SceneComponentConstants.NAME_GAMEPAD);
            if (!component) {
                component = new GamepadSystemSceneComponent(this);
                this._addComponent(component);
            }
        }
        return this._gamepadManager;
    },
    enumerable: true,
    configurable: true
});
/**
 * Adds a gamepad to the free camera inputs manager
 */
FreeCameraInputsManager.prototype.addGamepad = function () {
    this.add(new FreeCameraGamepadInput());
    return this;
};
/**
 * Adds a gamepad to the arc rotate camera inputs manager
 */
ArcRotateCameraInputsManager.prototype.addGamepad = function () {
    this.add(new ArcRotateCameraGamepadInput());
    return this;
};
/**
  * Defines the gamepad scene component responsible to manage gamepads in a given scene
  */
var GamepadSystemSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function GamepadSystemSceneComponent(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_GAMEPAD;
        this.scene = scene;
    }
    /**
     * Registers the component in a given scene
     */
    GamepadSystemSceneComponent.prototype.register = function () {
        this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_GAMEPAD, this, this._beforeCameraUpdate);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    GamepadSystemSceneComponent.prototype.rebuild = function () {
        // Nothing to do for gamepads
    };
    /**
     * Disposes the component and the associated ressources
     */
    GamepadSystemSceneComponent.prototype.dispose = function () {
        var gamepadManager = this.scene._gamepadManager;
        if (gamepadManager) {
            gamepadManager.dispose();
            this.scene._gamepadManager = null;
        }
    };
    GamepadSystemSceneComponent.prototype._beforeCameraUpdate = function () {
        var gamepadManager = this.scene._gamepadManager;
        if (gamepadManager && gamepadManager._isMonitoring) {
            gamepadManager._checkGamepadsStatus();
        }
    };
    return GamepadSystemSceneComponent;
}());

Node$2.AddNodeConstructor("FreeCamera", function (name, scene) {
    // Forcing to use the Universal camera
    return function () { return new UniversalCamera(name, Vector3.Zero(), scene); };
});
/**
 * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
 * which still works and will still be found in many Playgrounds.
 * @see http://doc.babylonjs.com/features/cameras#universal-camera
 */
var UniversalCamera = /** @class */ (function (_super) {
    __extends(UniversalCamera, _super);
    /**
     * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
     * which still works and will still be found in many Playgrounds.
     * @see http://doc.babylonjs.com/features/cameras#universal-camera
     * @param name Define the name of the camera in the scene
     * @param position Define the start position of the camera in the scene
     * @param scene Define the scene the camera belongs to
     */
    function UniversalCamera(name, position, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this.inputs.addGamepad();
        return _this;
    }
    Object.defineProperty(UniversalCamera.prototype, "gamepadAngularSensibility", {
        /**
         * Defines the gamepad rotation sensiblity.
         * This is the threshold from when rotation starts to be accounted for to prevent jittering.
         */
        get: function () {
            var gamepad = this.inputs.attached["gamepad"];
            if (gamepad) {
                return gamepad.gamepadAngularSensibility;
            }
            return 0;
        },
        set: function (value) {
            var gamepad = this.inputs.attached["gamepad"];
            if (gamepad) {
                gamepad.gamepadAngularSensibility = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UniversalCamera.prototype, "gamepadMoveSensibility", {
        /**
         * Defines the gamepad move sensiblity.
         * This is the threshold from when moving starts to be accounted for for to prevent jittering.
         */
        get: function () {
            var gamepad = this.inputs.attached["gamepad"];
            if (gamepad) {
                return gamepad.gamepadMoveSensibility;
            }
            return 0;
        },
        set: function (value) {
            var gamepad = this.inputs.attached["gamepad"];
            if (gamepad) {
                gamepad.gamepadMoveSensibility = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the current object class name.
     * @return the class name
     */
    UniversalCamera.prototype.getClassName = function () {
        return "UniversalCamera";
    };
    return UniversalCamera;
}(TouchCamera));
Camera._createDefaultParsedCamera = function (name, scene) {
    return new UniversalCamera(name, Vector3.Zero(), scene);
};

Node$2.AddNodeConstructor("GamepadCamera", function (name, scene) {
    return function () { return new GamepadCamera(name, Vector3.Zero(), scene); };
});
/**
 * This represents a FPS type of camera. This is only here for back compat purpose.
 * Please use the UniversalCamera instead as both are identical.
 * @see http://doc.babylonjs.com/features/cameras#universal-camera
 */
var GamepadCamera = /** @class */ (function (_super) {
    __extends(GamepadCamera, _super);
    /**
     * Instantiates a new Gamepad Camera
     * This represents a FPS type of camera. This is only here for back compat purpose.
     * Please use the UniversalCamera instead as both are identical.
     * @see http://doc.babylonjs.com/features/cameras#universal-camera
     * @param name Define the name of the camera in the scene
     * @param position Define the start position of the camera in the scene
     * @param scene Define the scene the camera belongs to
     */
    function GamepadCamera(name, position, scene) {
        return _super.call(this, name, position, scene) || this;
    }
    /**
     * Gets the current object class name.
     * @return the class name
     */
    GamepadCamera.prototype.getClassName = function () {
        return "GamepadCamera";
    };
    return GamepadCamera;
}(UniversalCamera));

var name = 'passPixelShader';
var shader = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nvoid main(void)\n{\ngl_FragColor=texture2D(textureSampler,vUV);\n}";
Effect.ShadersStore[name] = shader;

var name$1 = 'passCubePixelShader';
var shader$1 = "\nvarying vec2 vUV;\nuniform samplerCube textureSampler;\nvoid main(void)\n{\nvec2 uv=vUV*2.0-1.0;\n#ifdef POSITIVEX\ngl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));\n#endif\n#ifdef NEGATIVEX\ngl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));\n#endif\n#ifdef POSITIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));\n#endif\n#ifdef NEGATIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));\n#endif\n#ifdef POSITIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,1.001));\n#endif\n#ifdef NEGATIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));\n#endif\n}";
Effect.ShadersStore[name$1] = shader$1;

/**
 * PassPostProcess which produces an output the same as it's input
 */
var PassPostProcess = /** @class */ (function (_super) {
    __extends(PassPostProcess, _super);
    /**
     * Creates the PassPostProcess
     * @param name The name of the effect.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType The type of texture to be used when performing the post processing.
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function PassPostProcess(name, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (camera === void 0) { camera = null; }
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        return _super.call(this, name, "pass", null, null, options, camera, samplingMode, engine, reusable, undefined, textureType, undefined, null, blockCompilation) || this;
    }
    return PassPostProcess;
}(PostProcess));
/**
 * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)
 */
var PassCubePostProcess = /** @class */ (function (_super) {
    __extends(PassCubePostProcess, _super);
    /**
     * Creates the PassCubePostProcess
     * @param name The name of the effect.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType The type of texture to be used when performing the post processing.
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function PassCubePostProcess(name, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (camera === void 0) { camera = null; }
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "passCube", null, null, options, camera, samplingMode, engine, reusable, "#define POSITIVEX", textureType, undefined, null, blockCompilation) || this;
        _this._face = 0;
        return _this;
    }
    Object.defineProperty(PassCubePostProcess.prototype, "face", {
        /**
         * Gets or sets the cube face to display.
         *  * 0 is +X
         *  * 1 is -X
         *  * 2 is +Y
         *  * 3 is -Y
         *  * 4 is +Z
         *  * 5 is -Z
         */
        get: function () {
            return this._face;
        },
        set: function (value) {
            if (value < 0 || value > 5) {
                return;
            }
            this._face = value;
            switch (this._face) {
                case 0:
                    this.updateEffect("#define POSITIVEX");
                    break;
                case 1:
                    this.updateEffect("#define NEGATIVEX");
                    break;
                case 2:
                    this.updateEffect("#define POSITIVEY");
                    break;
                case 3:
                    this.updateEffect("#define NEGATIVEY");
                    break;
                case 4:
                    this.updateEffect("#define POSITIVEZ");
                    break;
                case 5:
                    this.updateEffect("#define NEGATIVEZ");
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    return PassCubePostProcess;
}(PostProcess));
Engine._RescalePostProcessFactory = function (engine) {
    return new PassPostProcess("rescale", 1, null, Engine.TEXTURE_BILINEAR_SAMPLINGMODE, engine, false, Engine.TEXTURETYPE_UNSIGNED_INT);
};

var name$2 = 'anaglyphPixelShader';
var shader$2 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D leftSampler;\nvoid main(void)\n{\nvec4 leftFrag=texture2D(leftSampler,vUV);\nleftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);\nvec4 rightFrag=texture2D(textureSampler,vUV);\nrightFrag=vec4(rightFrag.r,1.0,1.0,1.0);\ngl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);\n}";
Effect.ShadersStore[name$2] = shader$2;

/**
 * Postprocess used to generate anaglyphic rendering
 */
var AnaglyphPostProcess = /** @class */ (function (_super) {
    __extends(AnaglyphPostProcess, _super);
    /**
     * Creates a new AnaglyphPostProcess
     * @param name defines postprocess name
     * @param options defines creation options or target ratio scale
     * @param rigCameras defines cameras using this postprocess
     * @param samplingMode defines required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)
     * @param engine defines hosting engine
     * @param reusable defines if the postprocess will be reused multiple times per frame
     */
    function AnaglyphPostProcess(name, options, rigCameras, samplingMode, engine, reusable) {
        var _this = _super.call(this, name, "anaglyph", null, ["leftSampler"], options, rigCameras[1], samplingMode, engine, reusable) || this;
        _this._passedProcess = rigCameras[0]._rigPostProcess;
        _this.onApplyObservable.add(function (effect) {
            effect.setTextureFromPostProcess("leftSampler", _this._passedProcess);
        });
        return _this;
    }
    return AnaglyphPostProcess;
}(PostProcess));

Camera._setStereoscopicAnaglyphRigMode = function (camera) {
    camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + "_passthru", 1.0, camera._rigCameras[0]);
    camera._rigCameras[1]._rigPostProcess = new AnaglyphPostProcess(camera.name + "_anaglyph", 1.0, camera._rigCameras);
};

Node$2.AddNodeConstructor("AnaglyphArcRotateCamera", function (name, scene, options) {
    return function () { return new AnaglyphArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), options.interaxial_distance, scene); };
});
/**
 * Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)
 * @see http://doc.babylonjs.com/features/cameras#anaglyph-cameras
 */
var AnaglyphArcRotateCamera = /** @class */ (function (_super) {
    __extends(AnaglyphArcRotateCamera, _super);
    /**
     * Creates a new AnaglyphArcRotateCamera
     * @param name defines camera name
     * @param alpha defines alpha angle (in radians)
     * @param beta defines beta angle (in radians)
     * @param radius defines radius
     * @param target defines camera target
     * @param interaxialDistance defines distance between each color axis
     * @param scene defines the hosting scene
     */
    function AnaglyphArcRotateCamera(name, alpha, beta, radius, target, interaxialDistance, scene) {
        var _this = _super.call(this, name, alpha, beta, radius, target, scene) || this;
        _this.interaxialDistance = interaxialDistance;
        _this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });
        return _this;
    }
    /**
     * Gets camera class name
     * @returns AnaglyphArcRotateCamera
     */
    AnaglyphArcRotateCamera.prototype.getClassName = function () {
        return "AnaglyphArcRotateCamera";
    };
    return AnaglyphArcRotateCamera;
}(ArcRotateCamera));

Node$2.AddNodeConstructor("AnaglyphFreeCamera", function (name, scene, options) {
    return function () { return new AnaglyphFreeCamera(name, Vector3.Zero(), options.interaxial_distance, scene); };
});
/**
 * Camera used to simulate anaglyphic rendering (based on FreeCamera)
 * @see http://doc.babylonjs.com/features/cameras#anaglyph-cameras
 */
var AnaglyphFreeCamera = /** @class */ (function (_super) {
    __extends(AnaglyphFreeCamera, _super);
    /**
     * Creates a new AnaglyphFreeCamera
     * @param name defines camera name
     * @param position defines initial position
     * @param interaxialDistance defines distance between each color axis
     * @param scene defines the hosting scene
     */
    function AnaglyphFreeCamera(name, position, interaxialDistance, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this.interaxialDistance = interaxialDistance;
        _this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });
        return _this;
    }
    /**
     * Gets camera class name
     * @returns AnaglyphFreeCamera
     */
    AnaglyphFreeCamera.prototype.getClassName = function () {
        return "AnaglyphFreeCamera";
    };
    return AnaglyphFreeCamera;
}(FreeCamera));

Node$2.AddNodeConstructor("AnaglyphGamepadCamera", function (name, scene, options) {
    return function () { return new AnaglyphGamepadCamera(name, Vector3.Zero(), options.interaxial_distance, scene); };
});
/**
 * Camera used to simulate anaglyphic rendering (based on GamepadCamera)
 * @see http://doc.babylonjs.com/features/cameras#anaglyph-cameras
 */
var AnaglyphGamepadCamera = /** @class */ (function (_super) {
    __extends(AnaglyphGamepadCamera, _super);
    /**
     * Creates a new AnaglyphGamepadCamera
     * @param name defines camera name
     * @param position defines initial position
     * @param interaxialDistance defines distance between each color axis
     * @param scene defines the hosting scene
     */
    function AnaglyphGamepadCamera(name, position, interaxialDistance, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this.interaxialDistance = interaxialDistance;
        _this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });
        return _this;
    }
    /**
     * Gets camera class name
     * @returns AnaglyphGamepadCamera
     */
    AnaglyphGamepadCamera.prototype.getClassName = function () {
        return "AnaglyphGamepadCamera";
    };
    return AnaglyphGamepadCamera;
}(GamepadCamera));

Node$2.AddNodeConstructor("AnaglyphUniversalCamera", function (name, scene, options) {
    return function () { return new AnaglyphUniversalCamera(name, Vector3.Zero(), options.interaxial_distance, scene); };
});
/**
 * Camera used to simulate anaglyphic rendering (based on UniversalCamera)
 * @see http://doc.babylonjs.com/features/cameras#anaglyph-cameras
 */
var AnaglyphUniversalCamera = /** @class */ (function (_super) {
    __extends(AnaglyphUniversalCamera, _super);
    /**
     * Creates a new AnaglyphUniversalCamera
     * @param name defines camera name
     * @param position defines initial position
     * @param interaxialDistance defines distance between each color axis
     * @param scene defines the hosting scene
     */
    function AnaglyphUniversalCamera(name, position, interaxialDistance, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this.interaxialDistance = interaxialDistance;
        _this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });
        return _this;
    }
    /**
     * Gets camera class name
     * @returns AnaglyphUniversalCamera
     */
    AnaglyphUniversalCamera.prototype.getClassName = function () {
        return "AnaglyphUniversalCamera";
    };
    return AnaglyphUniversalCamera;
}(UniversalCamera));

var name$3 = 'stereoscopicInterlacePixelShader';
var shader$3 = "const vec3 TWO=vec3(2.0,2.0,2.0);\nvarying vec2 vUV;\nuniform sampler2D camASampler;\nuniform sampler2D textureSampler;\nuniform vec2 stepSize;\nvoid main(void)\n{\nbool useCamB;\nvec2 texCoord1;\nvec2 texCoord2;\nvec3 frag1;\nvec3 frag2;\n#ifdef IS_STEREOSCOPIC_HORIZ\nuseCamB=vUV.x>0.5;\ntexCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);\ntexCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\n#else\nuseCamB=vUV.y>0.5;\ntexCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);\ntexCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\n#endif\n\nif (useCamB){\nfrag1=texture2D(textureSampler,texCoord1).rgb;\nfrag2=texture2D(textureSampler,texCoord2).rgb;\n}else{\nfrag1=texture2D(camASampler ,texCoord1).rgb;\nfrag2=texture2D(camASampler ,texCoord2).rgb;\n}\ngl_FragColor=vec4((frag1+frag2)/TWO,1.0);\n}";
Effect.ShadersStore[name$3] = shader$3;

/**
 * StereoscopicInterlacePostProcess used to render stereo views from a rigged camera
 */
var StereoscopicInterlacePostProcess = /** @class */ (function (_super) {
    __extends(StereoscopicInterlacePostProcess, _super);
    /**
     * Initializes a StereoscopicInterlacePostProcess
     * @param name The name of the effect.
     * @param rigCameras The rig cameras to be appled to the post process
     * @param isStereoscopicHoriz If the rendered results are horizontal or verticle
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     */
    function StereoscopicInterlacePostProcess(name, rigCameras, isStereoscopicHoriz, samplingMode, engine, reusable) {
        var _this = _super.call(this, name, "stereoscopicInterlace", ['stepSize'], ['camASampler'], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicHoriz ? "#define IS_STEREOSCOPIC_HORIZ 1" : undefined) || this;
        _this._passedProcess = rigCameras[0]._rigPostProcess;
        _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);
        _this.onSizeChangedObservable.add(function () {
            _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);
        });
        _this.onApplyObservable.add(function (effect) {
            effect.setTextureFromPostProcess("camASampler", _this._passedProcess);
            effect.setFloat2("stepSize", _this._stepSize.x, _this._stepSize.y);
        });
        return _this;
    }
    return StereoscopicInterlacePostProcess;
}(PostProcess));

Camera._setStereoscopicRigMode = function (camera) {
    var isStereoscopicHoriz = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL || camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;
    camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + "_passthru", 1.0, camera._rigCameras[0]);
    camera._rigCameras[1]._rigPostProcess = new StereoscopicInterlacePostProcess(camera.name + "_stereoInterlace", camera._rigCameras, isStereoscopicHoriz);
};

Node$2.AddNodeConstructor("StereoscopicArcRotateCamera", function (name, scene, options) {
    return function () { return new StereoscopicArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene); };
});
/**
 * Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)
 * @see http://doc.babylonjs.com/features/cameras
 */
var StereoscopicArcRotateCamera = /** @class */ (function (_super) {
    __extends(StereoscopicArcRotateCamera, _super);
    /**
     * Creates a new StereoscopicArcRotateCamera
     * @param name defines camera name
     * @param alpha defines alpha angle (in radians)
     * @param beta defines beta angle (in radians)
     * @param radius defines radius
     * @param target defines camera target
     * @param interaxialDistance defines distance between each color axis
     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
     * @param scene defines the hosting scene
     */
    function StereoscopicArcRotateCamera(name, alpha, beta, radius, target, interaxialDistance, isStereoscopicSideBySide, scene) {
        var _this = _super.call(this, name, alpha, beta, radius, target, scene) || this;
        _this.interaxialDistance = interaxialDistance;
        _this.isStereoscopicSideBySide = isStereoscopicSideBySide;
        _this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance: interaxialDistance });
        return _this;
    }
    /**
     * Gets camera class name
     * @returns StereoscopicArcRotateCamera
     */
    StereoscopicArcRotateCamera.prototype.getClassName = function () {
        return "StereoscopicArcRotateCamera";
    };
    return StereoscopicArcRotateCamera;
}(ArcRotateCamera));

Node$2.AddNodeConstructor("StereoscopicFreeCamera", function (name, scene, options) {
    return function () { return new StereoscopicFreeCamera(name, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene); };
});
/**
 * Camera used to simulate stereoscopic rendering (based on FreeCamera)
 * @see http://doc.babylonjs.com/features/cameras
 */
var StereoscopicFreeCamera = /** @class */ (function (_super) {
    __extends(StereoscopicFreeCamera, _super);
    /**
     * Creates a new StereoscopicFreeCamera
     * @param name defines camera name
     * @param position defines initial position
     * @param interaxialDistance defines distance between each color axis
     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
     * @param scene defines the hosting scene
     */
    function StereoscopicFreeCamera(name, position, interaxialDistance, isStereoscopicSideBySide, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this.interaxialDistance = interaxialDistance;
        _this.isStereoscopicSideBySide = isStereoscopicSideBySide;
        _this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance: interaxialDistance });
        return _this;
    }
    /**
     * Gets camera class name
     * @returns StereoscopicFreeCamera
     */
    StereoscopicFreeCamera.prototype.getClassName = function () {
        return "StereoscopicFreeCamera";
    };
    return StereoscopicFreeCamera;
}(FreeCamera));

Node$2.AddNodeConstructor("StereoscopicGamepadCamera", function (name, scene, options) {
    return function () { return new StereoscopicGamepadCamera(name, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene); };
});
/**
 * Camera used to simulate stereoscopic rendering (based on GamepadCamera)
 * @see http://doc.babylonjs.com/features/cameras
 */
var StereoscopicGamepadCamera = /** @class */ (function (_super) {
    __extends(StereoscopicGamepadCamera, _super);
    /**
     * Creates a new StereoscopicGamepadCamera
     * @param name defines camera name
     * @param position defines initial position
     * @param interaxialDistance defines distance between each color axis
     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
     * @param scene defines the hosting scene
     */
    function StereoscopicGamepadCamera(name, position, interaxialDistance, isStereoscopicSideBySide, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this.interaxialDistance = interaxialDistance;
        _this.isStereoscopicSideBySide = isStereoscopicSideBySide;
        _this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance: interaxialDistance });
        return _this;
    }
    /**
     * Gets camera class name
     * @returns StereoscopicGamepadCamera
     */
    StereoscopicGamepadCamera.prototype.getClassName = function () {
        return "StereoscopicGamepadCamera";
    };
    return StereoscopicGamepadCamera;
}(GamepadCamera));

Node$2.AddNodeConstructor("StereoscopicFreeCamera", function (name, scene, options) {
    return function () { return new StereoscopicUniversalCamera(name, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene); };
});
/**
 * Camera used to simulate stereoscopic rendering (based on UniversalCamera)
 * @see http://doc.babylonjs.com/features/cameras
 */
var StereoscopicUniversalCamera = /** @class */ (function (_super) {
    __extends(StereoscopicUniversalCamera, _super);
    /**
     * Creates a new StereoscopicUniversalCamera
     * @param name defines camera name
     * @param position defines initial position
     * @param interaxialDistance defines distance between each color axis
     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
     * @param scene defines the hosting scene
     */
    function StereoscopicUniversalCamera(name, position, interaxialDistance, isStereoscopicSideBySide, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this.interaxialDistance = interaxialDistance;
        _this.isStereoscopicSideBySide = isStereoscopicSideBySide;
        _this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance: interaxialDistance });
        return _this;
    }
    /**
     * Gets camera class name
     * @returns StereoscopicUniversalCamera
     */
    StereoscopicUniversalCamera.prototype.getClassName = function () {
        return "StereoscopicUniversalCamera";
    };
    return StereoscopicUniversalCamera;
}(UniversalCamera));

Node$2.AddNodeConstructor("VirtualJoysticksCamera", function (name, scene) {
    return function () { return new VirtualJoysticksCamera(name, Vector3.Zero(), scene); };
});
/**
 * This represents a free type of camera. It can be useful in First Person Shooter game for instance.
 * It is identical to the Free Camera and simply adds by default a virtual joystick.
 * Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.
 * @see http://doc.babylonjs.com/features/cameras#virtual-joysticks-camera
 */
var VirtualJoysticksCamera = /** @class */ (function (_super) {
    __extends(VirtualJoysticksCamera, _super);
    /**
     * Intantiates a VirtualJoysticksCamera. It can be useful in First Person Shooter game for instance.
     * It is identical to the Free Camera and simply adds by default a virtual joystick.
     * Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.
     * @see http://doc.babylonjs.com/features/cameras#virtual-joysticks-camera
     * @param name Define the name of the camera in the scene
     * @param position Define the start position of the camera in the scene
     * @param scene Define the scene the camera belongs to
     */
    function VirtualJoysticksCamera(name, position, scene) {
        var _this = _super.call(this, name, position, scene) || this;
        _this.inputs.addVirtualJoystick();
        return _this;
    }
    /**
     * Gets the current object class name.
     * @return the class name
     */
    VirtualJoysticksCamera.prototype.getClassName = function () {
        return "VirtualJoysticksCamera";
    };
    return VirtualJoysticksCamera;
}(FreeCamera));

/**
 * This represents all the required metrics to create a VR camera.
 * @see http://doc.babylonjs.com/babylon101/cameras#device-orientation-camera
 */
var VRCameraMetrics = /** @class */ (function () {
    function VRCameraMetrics() {
        /**
         * Define if the current vr camera should compensate the distortion of the lense or not.
         */
        this.compensateDistortion = true;
        /**
         * Defines if multiview should be enabled when rendering (Default: false)
         */
        this.multiviewEnabled = false;
    }
    Object.defineProperty(VRCameraMetrics.prototype, "aspectRatio", {
        /**
         * Gets the rendering aspect ratio based on the provided resolutions.
         */
        get: function () {
            return this.hResolution / (2 * this.vResolution);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRCameraMetrics.prototype, "aspectRatioFov", {
        /**
         * Gets the aspect ratio based on the FOV, scale factors, and real screen sizes.
         */
        get: function () {
            return (2 * Math.atan((this.postProcessScaleFactor * this.vScreenSize) / (2 * this.eyeToScreenDistance)));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRCameraMetrics.prototype, "leftHMatrix", {
        /**
         * @hidden
         */
        get: function () {
            var meters = (this.hScreenSize / 4) - (this.lensSeparationDistance / 2);
            var h = (4 * meters) / this.hScreenSize;
            return Matrix.Translation(h, 0, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRCameraMetrics.prototype, "rightHMatrix", {
        /**
         * @hidden
         */
        get: function () {
            var meters = (this.hScreenSize / 4) - (this.lensSeparationDistance / 2);
            var h = (4 * meters) / this.hScreenSize;
            return Matrix.Translation(-h, 0, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRCameraMetrics.prototype, "leftPreViewMatrix", {
        /**
         * @hidden
         */
        get: function () {
            return Matrix.Translation(0.5 * this.interpupillaryDistance, 0, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRCameraMetrics.prototype, "rightPreViewMatrix", {
        /**
         * @hidden
         */
        get: function () {
            return Matrix.Translation(-0.5 * this.interpupillaryDistance, 0, 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the default VRMetrics based on the most generic setup.
     * @returns the default vr metrics
     */
    VRCameraMetrics.GetDefault = function () {
        var result = new VRCameraMetrics();
        result.hResolution = 1280;
        result.vResolution = 800;
        result.hScreenSize = 0.149759993;
        result.vScreenSize = 0.0935999975;
        result.vScreenCenter = 0.0467999987;
        result.eyeToScreenDistance = 0.0410000011;
        result.lensSeparationDistance = 0.0635000020;
        result.interpupillaryDistance = 0.0640000030;
        result.distortionK = [1.0, 0.219999999, 0.239999995, 0.0];
        result.chromaAbCorrection = [0.995999992, -0.00400000019, 1.01400006, 0.0];
        result.postProcessScaleFactor = 1.714605507808412;
        result.lensCenterOffset = 0.151976421;
        return result;
    };
    return VRCameraMetrics;
}());

var name$4 = 'vrDistortionCorrectionPixelShader';
var shader$4 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 LensCenter;\nuniform vec2 Scale;\nuniform vec2 ScaleIn;\nuniform vec4 HmdWarpParam;\nvec2 HmdWarp(vec2 in01) {\nvec2 theta=(in01-LensCenter)*ScaleIn;\nfloat rSq=theta.x*theta.x+theta.y*theta.y;\nvec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);\nreturn LensCenter+Scale*rvector;\n}\nvoid main(void)\n{\nvec2 tc=HmdWarp(vUV);\nif (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\ngl_FragColor=vec4(0.0,0.0,0.0,0.0);\nelse{\ngl_FragColor=texture2D(textureSampler,tc);\n}\n}";
Effect.ShadersStore[name$4] = shader$4;

/**
 * VRDistortionCorrectionPostProcess used for mobile VR
 */
var VRDistortionCorrectionPostProcess = /** @class */ (function (_super) {
    __extends(VRDistortionCorrectionPostProcess, _super);
    /**
     * Initializes the VRDistortionCorrectionPostProcess
     * @param name The name of the effect.
     * @param camera The camera to apply the render pass to.
     * @param isRightEye If this is for the right eye distortion
     * @param vrMetrics All the required metrics for the VR camera
     */
    function VRDistortionCorrectionPostProcess(name, camera, isRightEye, vrMetrics) {
        var _this = _super.call(this, name, "vrDistortionCorrection", [
            'LensCenter',
            'Scale',
            'ScaleIn',
            'HmdWarpParam'
        ], null, vrMetrics.postProcessScaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE) || this;
        _this._isRightEye = isRightEye;
        _this._distortionFactors = vrMetrics.distortionK;
        _this._postProcessScaleFactor = vrMetrics.postProcessScaleFactor;
        _this._lensCenterOffset = vrMetrics.lensCenterOffset;
        _this.adaptScaleToCurrentViewport = true;
        _this.onSizeChangedObservable.add(function () {
            _this._scaleIn = new Vector2(2, 2 / _this.aspectRatio);
            _this._scaleFactor = new Vector2(.5 * (1 / _this._postProcessScaleFactor), .5 * (1 / _this._postProcessScaleFactor) * _this.aspectRatio);
            _this._lensCenter = new Vector2(_this._isRightEye ? 0.5 - _this._lensCenterOffset * 0.5 : 0.5 + _this._lensCenterOffset * 0.5, 0.5);
        });
        _this.onApplyObservable.add(function (effect) {
            effect.setFloat2("LensCenter", _this._lensCenter.x, _this._lensCenter.y);
            effect.setFloat2("Scale", _this._scaleFactor.x, _this._scaleFactor.y);
            effect.setFloat2("ScaleIn", _this._scaleIn.x, _this._scaleIn.y);
            effect.setFloat4("HmdWarpParam", _this._distortionFactors[0], _this._distortionFactors[1], _this._distortionFactors[2], _this._distortionFactors[3]);
        });
        return _this;
    }
    return VRDistortionCorrectionPostProcess;
}(PostProcess));

var name$5 = 'vrMultiviewToSingleviewPixelShader';
var shader$5 = "#ifdef GL_ES\nprecision mediump sampler2DArray;\n#endif\nvarying vec2 vUV;\nuniform sampler2DArray multiviewSampler;\nuniform int imageIndex;\nvoid main(void)\n{\ngl_FragColor=texture(multiviewSampler,vec3(vUV,imageIndex));\n}";
Effect.ShadersStore[name$5] = shader$5;

/**
 * Renders to multiple views with a single draw call
 * @see https://www.khronos.org/registry/webgl/extensions/WEBGL_multiview/
 */
var MultiviewRenderTarget = /** @class */ (function (_super) {
    __extends(MultiviewRenderTarget, _super);
    /**
     * Creates a multiview render target
     * @param scene scene used with the render target
     * @param size the size of the render target (used for each view)
     */
    function MultiviewRenderTarget(scene, size) {
        if (size === void 0) { size = 512; }
        var _this = _super.call(this, "multiview rtt", size, scene, false, true, InternalTexture.DATASOURCE_UNKNOWN, false, undefined, false, false, true, undefined, true) || this;
        var internalTexture = scene.getEngine().createMultiviewRenderTargetTexture(_this.getRenderWidth(), _this.getRenderHeight());
        internalTexture.isMultiview = true;
        _this._texture = internalTexture;
        return _this;
    }
    /**
     * @hidden
     * @param faceIndex the face index, if its a cube texture
     */
    MultiviewRenderTarget.prototype._bindFrameBuffer = function (faceIndex) {
        if (!this._texture) {
            return;
        }
        this.getScene().getEngine().bindMultiviewFramebuffer(this._texture);
    };
    /**
     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)
     * @returns the view count
     */
    MultiviewRenderTarget.prototype.getViewCount = function () {
        return 2;
    };
    return MultiviewRenderTarget;
}(RenderTargetTexture));

Engine.prototype.createMultiviewRenderTargetTexture = function (width, height) {
    var gl = this._gl;
    if (!this.getCaps().multiview) {
        throw "Multiview is not supported";
    }
    var internalTexture = new InternalTexture(this, InternalTexture.DATASOURCE_UNKNOWN, true);
    internalTexture.width = width;
    internalTexture.height = height;
    internalTexture._framebuffer = gl.createFramebuffer();
    internalTexture._colorTextureArray = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, internalTexture._colorTextureArray);
    gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);
    internalTexture._depthStencilTextureArray = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, internalTexture._depthStencilTextureArray);
    gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.DEPTH32F_STENCIL8, width, height, 2);
    internalTexture.isReady = true;
    return internalTexture;
};
Engine.prototype.bindMultiviewFramebuffer = function (multiviewTexture) {
    var gl = this._gl;
    var ext = this.getCaps().multiview;
    this.bindFramebuffer(multiviewTexture, undefined, undefined, undefined, true);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);
    if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {
        ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);
        ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);
    }
    else {
        throw "Invalid multiview frame buffer";
    }
};
Camera.prototype._useMultiviewToSingleView = false;
Camera.prototype._multiviewTexture = null;
Camera.prototype._resizeOrCreateMultiviewTexture = function (width, height) {
    if (!this._multiviewTexture) {
        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });
    }
    else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {
        this._multiviewTexture.dispose();
        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });
    }
};
Scene.prototype._transformMatrixR = Matrix.Zero();
Scene.prototype._multiviewSceneUbo = null;
Scene.prototype._createMultiviewUbo = function () {
    this._multiviewSceneUbo = new UniformBuffer(this.getEngine(), undefined, true);
    this._multiviewSceneUbo.addUniform("viewProjection", 16);
    this._multiviewSceneUbo.addUniform("viewProjectionR", 16);
    this._multiviewSceneUbo.addUniform("view", 16);
};
Scene.prototype._updateMultiviewUbo = function (viewR, projectionR) {
    if (viewR && projectionR) {
        viewR.multiplyToRef(projectionR, this._transformMatrixR);
    }
    if (viewR && projectionR) {
        viewR.multiplyToRef(projectionR, Tmp.Matrix[0]);
        Frustum.GetRightPlaneToRef(Tmp.Matrix[0], this._frustumPlanes[3]); // Replace right plane by second camera right plane
    }
    if (this._multiviewSceneUbo) {
        this._multiviewSceneUbo.updateMatrix("viewProjection", this.getTransformMatrix());
        this._multiviewSceneUbo.updateMatrix("viewProjectionR", this._transformMatrixR);
        this._multiviewSceneUbo.updateMatrix("view", this._viewMatrix);
        this._multiviewSceneUbo.update();
    }
};
Scene.prototype._renderMultiviewToSingleView = function (camera) {
    // Multiview is only able to be displayed directly for API's such as webXR
    // This displays a multiview image by rendering to the multiview image and then
    // copying the result into the sub cameras instead of rendering them and proceeding as normal from there
    // Render to a multiview texture
    camera._resizeOrCreateMultiviewTexture((camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0) ? camera._rigPostProcess.width / 2 : this.getEngine().getRenderWidth(true) / 2, (camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0) ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true));
    if (!this._multiviewSceneUbo) {
        this._createMultiviewUbo();
    }
    camera.outputRenderTarget = camera._multiviewTexture;
    this._renderForCamera(camera);
    camera.outputRenderTarget = null;
    // Consume the multiview texture through a shader for each eye
    for (var index = 0; index < camera._rigCameras.length; index++) {
        var engine = this.getEngine();
        this._activeCamera = camera._rigCameras[index];
        engine.setViewport(this._activeCamera.viewport);
        if (this.postProcessManager) {
            this.postProcessManager._prepareFrame();
            this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);
        }
    }
};

/**
 * VRMultiviewToSingleview used to convert multiview texture arrays to standard textures for scenarios such as webVR
 * This will not be used for webXR as it supports displaying texture arrays directly
 */
var VRMultiviewToSingleviewPostProcess = /** @class */ (function (_super) {
    __extends(VRMultiviewToSingleviewPostProcess, _super);
    /**
     * Initializes a VRMultiviewToSingleview
     * @param name name of the post process
     * @param camera camera to be applied to
     * @param scaleFactor scaling factor to the size of the output texture
     */
    function VRMultiviewToSingleviewPostProcess(name, camera, scaleFactor) {
        var _this = _super.call(this, name, "vrMultiviewToSingleview", ["imageIndex"], ["multiviewSampler"], scaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE) || this;
        _this.onSizeChangedObservable.add(function () {
        });
        _this.onApplyObservable.add(function (effect) {
            if (camera._scene.activeCamera && camera._scene.activeCamera.isLeftCamera) {
                effect.setInt("imageIndex", 0);
            }
            else {
                effect.setInt("imageIndex", 1);
            }
            effect.setTexture("multiviewSampler", camera._multiviewTexture);
        });
        return _this;
    }
    return VRMultiviewToSingleviewPostProcess;
}(PostProcess));

Camera._setVRRigMode = function (camera, rigParams) {
    var metrics = rigParams.vrCameraMetrics || VRCameraMetrics.GetDefault();
    camera._rigCameras[0]._cameraRigParams.vrMetrics = metrics;
    camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);
    camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();
    camera._rigCameras[0]._cameraRigParams.vrHMatrix = metrics.leftHMatrix;
    camera._rigCameras[0]._cameraRigParams.vrPreViewMatrix = metrics.leftPreViewMatrix;
    camera._rigCameras[0].getProjectionMatrix = camera._rigCameras[0]._getVRProjectionMatrix;
    camera._rigCameras[1]._cameraRigParams.vrMetrics = metrics;
    camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);
    camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();
    camera._rigCameras[1]._cameraRigParams.vrHMatrix = metrics.rightHMatrix;
    camera._rigCameras[1]._cameraRigParams.vrPreViewMatrix = metrics.rightPreViewMatrix;
    camera._rigCameras[1].getProjectionMatrix = camera._rigCameras[1]._getVRProjectionMatrix;
    // For multiview on a webVR camera
    // First multiview will be rendered to camera._multiviewTexture
    // Then this postprocess will run on each eye to copy the right texture to each eye
    if (metrics.multiviewEnabled) {
        if (!camera.getScene().getEngine().getCaps().multiview) {
            Logger.Warn("Multiview is not supported, falling back to standard rendering");
            metrics.multiviewEnabled = false;
        }
        else {
            camera._useMultiviewToSingleView = true;
            camera._rigPostProcess = new VRMultiviewToSingleviewPostProcess("VRMultiviewToSingleview", camera, metrics.postProcessScaleFactor);
        }
    }
    if (metrics.compensateDistortion) {
        camera._rigCameras[0]._rigPostProcess = new VRDistortionCorrectionPostProcess("VR_Distort_Compensation_Left", camera._rigCameras[0], false, metrics);
        camera._rigCameras[1]._rigPostProcess = new VRDistortionCorrectionPostProcess("VR_Distort_Compensation_Right", camera._rigCameras[1], true, metrics);
    }
};

Node$2.AddNodeConstructor("VRDeviceOrientationFreeCamera", function (name, scene) {
    return function () { return new VRDeviceOrientationArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene); };
});
/**
 * Camera used to simulate VR rendering (based on ArcRotateCamera)
 * @see http://doc.babylonjs.com/babylon101/cameras#vr-device-orientation-cameras
 */
var VRDeviceOrientationArcRotateCamera = /** @class */ (function (_super) {
    __extends(VRDeviceOrientationArcRotateCamera, _super);
    /**
     * Creates a new VRDeviceOrientationArcRotateCamera
     * @param name defines camera name
     * @param alpha defines the camera rotation along the logitudinal axis
     * @param beta defines the camera rotation along the latitudinal axis
     * @param radius defines the camera distance from its target
     * @param target defines the camera target
     * @param scene defines the scene the camera belongs to
     * @param compensateDistortion defines if the camera needs to compensate the lens distorsion
     * @param vrCameraMetrics defines the vr metrics associated to the camera
     */
    function VRDeviceOrientationArcRotateCamera(name, alpha, beta, radius, target, scene, compensateDistortion, vrCameraMetrics) {
        if (compensateDistortion === void 0) { compensateDistortion = true; }
        if (vrCameraMetrics === void 0) { vrCameraMetrics = VRCameraMetrics.GetDefault(); }
        var _this = _super.call(this, name, alpha, beta, radius, target, scene) || this;
        vrCameraMetrics.compensateDistortion = compensateDistortion;
        _this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics: vrCameraMetrics });
        _this.inputs.addVRDeviceOrientation();
        return _this;
    }
    /**
     * Gets camera class name
     * @returns VRDeviceOrientationArcRotateCamera
     */
    VRDeviceOrientationArcRotateCamera.prototype.getClassName = function () {
        return "VRDeviceOrientationArcRotateCamera";
    };
    return VRDeviceOrientationArcRotateCamera;
}(ArcRotateCamera));

Node$2.AddNodeConstructor("VRDeviceOrientationFreeCamera", function (name, scene) {
    return function () { return new VRDeviceOrientationFreeCamera(name, Vector3.Zero(), scene); };
});
/**
 * Camera used to simulate VR rendering (based on FreeCamera)
 * @see http://doc.babylonjs.com/babylon101/cameras#vr-device-orientation-cameras
 */
var VRDeviceOrientationFreeCamera = /** @class */ (function (_super) {
    __extends(VRDeviceOrientationFreeCamera, _super);
    /**
     * Creates a new VRDeviceOrientationFreeCamera
     * @param name defines camera name
     * @param position defines the start position of the camera
     * @param scene defines the scene the camera belongs to
     * @param compensateDistortion defines if the camera needs to compensate the lens distorsion
     * @param vrCameraMetrics defines the vr metrics associated to the camera
     */
    function VRDeviceOrientationFreeCamera(name, position, scene, compensateDistortion, vrCameraMetrics) {
        if (compensateDistortion === void 0) { compensateDistortion = true; }
        if (vrCameraMetrics === void 0) { vrCameraMetrics = VRCameraMetrics.GetDefault(); }
        var _this = _super.call(this, name, position, scene) || this;
        vrCameraMetrics.compensateDistortion = compensateDistortion;
        _this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics: vrCameraMetrics });
        return _this;
    }
    /**
     * Gets camera class name
     * @returns VRDeviceOrientationFreeCamera
     */
    VRDeviceOrientationFreeCamera.prototype.getClassName = function () {
        return "VRDeviceOrientationFreeCamera";
    };
    return VRDeviceOrientationFreeCamera;
}(DeviceOrientationCamera));

Node$2.AddNodeConstructor("VRDeviceOrientationGamepadCamera", function (name, scene) {
    return function () { return new VRDeviceOrientationGamepadCamera(name, Vector3.Zero(), scene); };
});
/**
 * Camera used to simulate VR rendering (based on VRDeviceOrientationFreeCamera)
 * @see http://doc.babylonjs.com/babylon101/cameras#vr-device-orientation-cameras
 */
var VRDeviceOrientationGamepadCamera = /** @class */ (function (_super) {
    __extends(VRDeviceOrientationGamepadCamera, _super);
    /**
     * Creates a new VRDeviceOrientationGamepadCamera
     * @param name defines camera name
     * @param position defines the start position of the camera
     * @param scene defines the scene the camera belongs to
     * @param compensateDistortion defines if the camera needs to compensate the lens distorsion
     * @param vrCameraMetrics defines the vr metrics associated to the camera
     */
    function VRDeviceOrientationGamepadCamera(name, position, scene, compensateDistortion, vrCameraMetrics) {
        if (compensateDistortion === void 0) { compensateDistortion = true; }
        if (vrCameraMetrics === void 0) { vrCameraMetrics = VRCameraMetrics.GetDefault(); }
        var _this = _super.call(this, name, position, scene, compensateDistortion, vrCameraMetrics) || this;
        _this.inputs.addGamepad();
        return _this;
    }
    /**
     * Gets camera class name
     * @returns VRDeviceOrientationGamepadCamera
     */
    VRDeviceOrientationGamepadCamera.prototype.getClassName = function () {
        return "VRDeviceOrientationGamepadCamera";
    };
    return VRDeviceOrientationGamepadCamera;
}(VRDeviceOrientationFreeCamera));

Camera._setWebVRRigMode = function (camera, rigParams) {
    if (rigParams.vrDisplay) {
        var leftEye = rigParams.vrDisplay.getEyeParameters('left');
        var rightEye = rigParams.vrDisplay.getEyeParameters('right');
        //Left eye
        camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);
        camera._rigCameras[0].setCameraRigParameter("left", true);
        //leaving this for future reference
        camera._rigCameras[0].setCameraRigParameter("specs", rigParams.specs);
        camera._rigCameras[0].setCameraRigParameter("eyeParameters", leftEye);
        camera._rigCameras[0].setCameraRigParameter("frameData", rigParams.frameData);
        camera._rigCameras[0].setCameraRigParameter("parentCamera", rigParams.parentCamera);
        camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();
        camera._rigCameras[0].getProjectionMatrix = camera._getWebVRProjectionMatrix;
        camera._rigCameras[0].parent = camera;
        camera._rigCameras[0]._getViewMatrix = camera._getWebVRViewMatrix;
        //Right eye
        camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);
        camera._rigCameras[1].setCameraRigParameter('eyeParameters', rightEye);
        camera._rigCameras[1].setCameraRigParameter("specs", rigParams.specs);
        camera._rigCameras[1].setCameraRigParameter("frameData", rigParams.frameData);
        camera._rigCameras[1].setCameraRigParameter("parentCamera", rigParams.parentCamera);
        camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();
        camera._rigCameras[1].getProjectionMatrix = camera._getWebVRProjectionMatrix;
        camera._rigCameras[1].parent = camera;
        camera._rigCameras[1]._getViewMatrix = camera._getWebVRViewMatrix;
    }
};

Object.defineProperty(Engine.prototype, "isInVRExclusivePointerMode", {
    get: function () {
        return this._vrExclusivePointerMode;
    },
    enumerable: true,
    configurable: true
});
Engine.prototype._prepareVRComponent = function () {
    this._vrSupported = false;
    this._vrExclusivePointerMode = false;
    this.onVRDisplayChangedObservable = new Observable();
    this.onVRRequestPresentComplete = new Observable();
    this.onVRRequestPresentStart = new Observable();
};
Engine.prototype.isVRDevicePresent = function () {
    return !!this._vrDisplay;
};
Engine.prototype.getVRDevice = function () {
    return this._vrDisplay;
};
Engine.prototype.initWebVR = function () {
    this.initWebVRAsync();
    return this.onVRDisplayChangedObservable;
};
Engine.prototype.initWebVRAsync = function () {
    var _this = this;
    var notifyObservers = function () {
        var eventArgs = {
            vrDisplay: _this._vrDisplay,
            vrSupported: _this._vrSupported
        };
        _this.onVRDisplayChangedObservable.notifyObservers(eventArgs);
        _this._webVRInitPromise = new Promise(function (res) { res(eventArgs); });
    };
    if (!this._onVrDisplayConnect) {
        this._onVrDisplayConnect = function (event) {
            _this._vrDisplay = event.display;
            notifyObservers();
        };
        this._onVrDisplayDisconnect = function () {
            _this._vrDisplay.cancelAnimationFrame(_this._frameHandler);
            _this._vrDisplay = undefined;
            _this._frameHandler = Tools.QueueNewFrame(_this._bindedRenderFunction);
            notifyObservers();
        };
        this._onVrDisplayPresentChange = function () {
            _this._vrExclusivePointerMode = _this._vrDisplay && _this._vrDisplay.isPresenting;
        };
        window.addEventListener('vrdisplayconnect', this._onVrDisplayConnect);
        window.addEventListener('vrdisplaydisconnect', this._onVrDisplayDisconnect);
        window.addEventListener('vrdisplaypresentchange', this._onVrDisplayPresentChange);
    }
    this._webVRInitPromise = this._webVRInitPromise || this._getVRDisplaysAsync();
    this._webVRInitPromise.then(notifyObservers);
    return this._webVRInitPromise;
};
Engine.prototype._getVRDisplaysAsync = function () {
    var _this = this;
    return new Promise(function (res) {
        if (navigator.getVRDisplays) {
            navigator.getVRDisplays().then(function (devices) {
                _this._vrSupported = true;
                // note that devices may actually be an empty array. This is fine;
                // we expect this._vrDisplay to be undefined in this case.
                _this._vrDisplay = devices[0];
                res({
                    vrDisplay: _this._vrDisplay,
                    vrSupported: _this._vrSupported
                });
            });
        }
        else {
            _this._vrDisplay = undefined;
            _this._vrSupported = false;
            res({
                vrDisplay: _this._vrDisplay,
                vrSupported: _this._vrSupported
            });
        }
    });
};
Engine.prototype.enableVR = function () {
    var _this = this;
    if (this._vrDisplay && !this._vrDisplay.isPresenting) {
        var onResolved = function () {
            _this.onVRRequestPresentComplete.notifyObservers(true);
            _this._onVRFullScreenTriggered();
        };
        var onRejected = function () {
            _this.onVRRequestPresentComplete.notifyObservers(false);
        };
        this.onVRRequestPresentStart.notifyObservers(this);
        this._vrDisplay.requestPresent([{ source: this.getRenderingCanvas() }]).then(onResolved).catch(onRejected);
    }
};
Engine.prototype._onVRFullScreenTriggered = function () {
    if (this._vrDisplay && this._vrDisplay.isPresenting) {
        //get the old size before we change
        this._oldSize = new Size(this.getRenderWidth(), this.getRenderHeight());
        this._oldHardwareScaleFactor = this.getHardwareScalingLevel();
        //get the width and height, change the render size
        var leftEye = this._vrDisplay.getEyeParameters('left');
        this.setHardwareScalingLevel(1);
        this.setSize(leftEye.renderWidth * 2, leftEye.renderHeight);
    }
    else {
        this.setHardwareScalingLevel(this._oldHardwareScaleFactor);
        this.setSize(this._oldSize.width, this._oldSize.height);
    }
};
Engine.prototype.disableVR = function () {
    var _this = this;
    if (this._vrDisplay && this._vrDisplay.isPresenting) {
        this._vrDisplay.exitPresent()
            .then(function () { return _this._onVRFullScreenTriggered(); })
            .catch(function () { return _this._onVRFullScreenTriggered(); });
    }
    if (DomManagement.IsWindowObjectExist()) {
        window.removeEventListener('vrdisplaypointerrestricted', this._onVRDisplayPointerRestricted);
        window.removeEventListener('vrdisplaypointerunrestricted', this._onVRDisplayPointerUnrestricted);
        if (this._onVrDisplayConnect) {
            window.removeEventListener('vrdisplayconnect', this._onVrDisplayConnect);
            if (this._onVrDisplayDisconnect) {
                window.removeEventListener('vrdisplaydisconnect', this._onVrDisplayDisconnect);
            }
            if (this._onVrDisplayPresentChange) {
                window.removeEventListener('vrdisplaypresentchange', this._onVrDisplayPresentChange);
            }
            this._onVrDisplayConnect = null;
            this._onVrDisplayDisconnect = null;
        }
    }
};
Engine.prototype._connectVREvents = function (canvas, document) {
    this._onVRDisplayPointerRestricted = function () {
        if (canvas) {
            canvas.requestPointerLock();
        }
    };
    this._onVRDisplayPointerUnrestricted = function () {
        if (!document.exitPointerLock) {
            return;
        }
        document.exitPointerLock();
    };
    if (DomManagement.IsWindowObjectExist()) {
        window.addEventListener('vrdisplaypointerrestricted', this._onVRDisplayPointerRestricted, false);
        window.addEventListener('vrdisplaypointerunrestricted', this._onVRDisplayPointerUnrestricted, false);
    }
};
Engine.prototype._submitVRFrame = function () {
    // Submit frame to the vr device, if enabled
    if (this._vrDisplay && this._vrDisplay.isPresenting) {
        // TODO: We should only submit the frame if we read frameData successfully.
        try {
            this._vrDisplay.submitFrame();
        }
        catch (e) {
            Tools.Warn("webVR submitFrame has had an unexpected failure: " + e);
        }
    }
};
Engine.prototype.isVRPresenting = function () {
    return this._vrDisplay && this._vrDisplay.isPresenting;
};
Engine.prototype._requestVRFrame = function () {
    this._frameHandler = Tools.QueueNewFrame(this._bindedRenderFunction, this._vrDisplay);
};

Node$2.AddNodeConstructor("WebVRFreeCamera", function (name, scene) {
    return function () { return new WebVRFreeCamera(name, Vector3.Zero(), scene); };
});
Node$2.AddNodeConstructor("WebVRGamepadCamera", function (name, scene) {
    return function () { return new WebVRFreeCamera(name, Vector3.Zero(), scene); };
});
/**
 * This represents a WebVR camera.
 * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
 * @example http://doc.babylonjs.com/how_to/webvr_camera
 */
var WebVRFreeCamera = /** @class */ (function (_super) {
    __extends(WebVRFreeCamera, _super);
    /**
     * Instantiates a WebVRFreeCamera.
     * @param name The name of the WebVRFreeCamera
     * @param position The starting anchor position for the camera
     * @param scene The scene the camera belongs to
     * @param webVROptions a set of customizable options for the webVRCamera
     */
    function WebVRFreeCamera(name, position, scene, webVROptions) {
        if (webVROptions === void 0) { webVROptions = {}; }
        var _this = _super.call(this, name, position, scene) || this;
        _this.webVROptions = webVROptions;
        /**
         * @hidden
         * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay
         */
        _this._vrDevice = null;
        /**
         * The rawPose of the vrDevice.
         */
        _this.rawPose = null;
        _this._specsVersion = "1.1";
        _this._attached = false;
        _this._descendants = [];
        // Represents device position and rotation in room space. Should only be used to help calculate babylon space values
        _this._deviceRoomPosition = Vector3.Zero();
        /** @hidden */
        _this._deviceRoomRotationQuaternion = Quaternion.Identity();
        _this._standingMatrix = null;
        /**
         * Represents device position in babylon space.
         */
        _this.devicePosition = Vector3.Zero();
        /**
         * Represents device rotation in babylon space.
         */
        _this.deviceRotationQuaternion = Quaternion.Identity();
        /**
         * The scale of the device to be used when translating from device space to babylon space.
         */
        _this.deviceScaleFactor = 1;
        _this._deviceToWorld = Matrix.Identity();
        _this._worldToDevice = Matrix.Identity();
        /**
         * References to the webVR controllers for the vrDevice.
         */
        _this.controllers = [];
        /**
         * Emits an event when a controller is attached.
         */
        _this.onControllersAttachedObservable = new Observable();
        /**
         * Emits an event when a controller's mesh has been loaded;
         */
        _this.onControllerMeshLoadedObservable = new Observable();
        /**
         * Emits an event when the HMD's pose has been updated.
         */
        _this.onPoseUpdatedFromDeviceObservable = new Observable();
        _this._poseSet = false;
        /**
         * If the rig cameras be used as parent instead of this camera.
         */
        _this.rigParenting = true;
        _this._defaultHeight = undefined;
        _this._htmlElementAttached = null;
        _this._detachIfAttached = function () {
            var vrDisplay = _this.getEngine().getVRDevice();
            if (vrDisplay && !vrDisplay.isPresenting && _this._htmlElementAttached) {
                _this.detachControl(_this._htmlElementAttached);
            }
        };
        _this._workingVector = Vector3.Zero();
        _this._oneVector = Vector3.One();
        _this._workingMatrix = Matrix.Identity();
        _this._tmpMatrix = new Matrix();
        _this._cache.position = Vector3.Zero();
        if (webVROptions.defaultHeight) {
            _this._defaultHeight = webVROptions.defaultHeight;
            _this.position.y = _this._defaultHeight;
        }
        _this.minZ = 0.1;
        //legacy support - the compensation boolean was removed.
        if (arguments.length === 5) {
            _this.webVROptions = arguments[4];
        }
        // default webVR options
        if (_this.webVROptions.trackPosition == undefined) {
            _this.webVROptions.trackPosition = true;
        }
        if (_this.webVROptions.controllerMeshes == undefined) {
            _this.webVROptions.controllerMeshes = true;
        }
        if (_this.webVROptions.defaultLightingOnControllers == undefined) {
            _this.webVROptions.defaultLightingOnControllers = true;
        }
        _this.rotationQuaternion = new Quaternion();
        if (_this.webVROptions && _this.webVROptions.positionScale) {
            _this.deviceScaleFactor = _this.webVROptions.positionScale;
        }
        //enable VR
        var engine = _this.getEngine();
        _this._onVREnabled = function (success) { if (success) {
            _this.initControllers();
        } };
        engine.onVRRequestPresentComplete.add(_this._onVREnabled);
        engine.initWebVR().add(function (event) {
            if (!event.vrDisplay || _this._vrDevice === event.vrDisplay) {
                return;
            }
            _this._vrDevice = event.vrDisplay;
            //reset the rig parameters.
            _this.setCameraRigMode(Camera.RIG_MODE_WEBVR, { parentCamera: _this, vrDisplay: _this._vrDevice, frameData: _this._frameData, specs: _this._specsVersion });
            if (_this._attached) {
                _this.getEngine().enableVR();
            }
        });
        if (typeof (VRFrameData) !== "undefined") {
            _this._frameData = new VRFrameData();
        }
        if (webVROptions.useMultiview) {
            if (!_this.getScene().getEngine().getCaps().multiview) {
                Logger.Warn("Multiview is not supported, falling back to standard rendering");
                _this._useMultiviewToSingleView = false;
            }
            else {
                _this._useMultiviewToSingleView = true;
                _this._rigPostProcess = new VRMultiviewToSingleviewPostProcess("VRMultiviewToSingleview", _this, 1.0);
            }
        }
        /**
         * The idea behind the following lines:
         * objects that have the camera as parent should actually have the rig cameras as a parent.
         * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,
         * the second will not show it correctly.
         *
         * To solve this - each object that has the camera as parent will be added to a protected array.
         * When the rig camera renders, it will take this array and set all of those to be its children.
         * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.
         * Amazing!
         */
        scene.onBeforeCameraRenderObservable.add(function (camera) {
            if (camera.parent === _this && _this.rigParenting) {
                _this._descendants = _this.getDescendants(true, function (n) {
                    // don't take the cameras or the controllers!
                    var isController = _this.controllers.some(function (controller) { return controller._mesh === n; });
                    var isRigCamera = _this._rigCameras.indexOf(n) !== -1;
                    return !isController && !isRigCamera;
                });
                _this._descendants.forEach(function (node) {
                    node.parent = camera;
                });
            }
        });
        scene.onAfterCameraRenderObservable.add(function (camera) {
            if (camera.parent === _this && _this.rigParenting) {
                _this._descendants.forEach(function (node) {
                    node.parent = _this;
                });
            }
        });
        return _this;
    }
    /**
     * Gets the device distance from the ground in meters.
     * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.
     */
    WebVRFreeCamera.prototype.deviceDistanceToRoomGround = function () {
        if (this._standingMatrix) {
            // Add standing matrix offset to get real offset from ground in room
            this._standingMatrix.getTranslationToRef(this._workingVector);
            return this._deviceRoomPosition.y + this._workingVector.y;
        }
        //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.
        return this._defaultHeight || 0;
    };
    /**
     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
     * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.
     */
    WebVRFreeCamera.prototype.useStandingMatrix = function (callback) {
        var _this = this;
        if (callback === void 0) { callback = function (bool) { }; }
        // Use standing matrix if available
        this.getEngine().initWebVRAsync().then(function (result) {
            if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !_this.webVROptions.trackPosition) {
                callback(false);
            }
            else {
                _this._standingMatrix = new Matrix();
                Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, _this._standingMatrix);
                if (!_this.getScene().useRightHandedSystem) {
                    if (_this._standingMatrix) {
                        _this._standingMatrix.toggleModelMatrixHandInPlace();
                    }
                }
                callback(true);
            }
        });
    };
    /**
     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
     * @returns A promise with a boolean set to if the standing matrix is supported.
     */
    WebVRFreeCamera.prototype.useStandingMatrixAsync = function () {
        var _this = this;
        return new Promise(function (res) {
            _this.useStandingMatrix(function (supported) {
                res(supported);
            });
        });
    };
    /**
     * Disposes the camera
     */
    WebVRFreeCamera.prototype.dispose = function () {
        this._detachIfAttached();
        this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);
        if (this._updateCacheWhenTrackingDisabledObserver) {
            this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * Gets a vrController by name.
     * @param name The name of the controller to retreive
     * @returns the controller matching the name specified or null if not found
     */
    WebVRFreeCamera.prototype.getControllerByName = function (name) {
        for (var _i = 0, _a = this.controllers; _i < _a.length; _i++) {
            var gp = _a[_i];
            if (gp.hand === name) {
                return gp;
            }
        }
        return null;
    };
    Object.defineProperty(WebVRFreeCamera.prototype, "leftController", {
        /**
         * The controller corrisponding to the users left hand.
         */
        get: function () {
            if (!this._leftController) {
                this._leftController = this.getControllerByName("left");
            }
            return this._leftController;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebVRFreeCamera.prototype, "rightController", {
        /**
         * The controller corrisponding to the users right hand.
         */
        get: function () {
            if (!this._rightController) {
                this._rightController = this.getControllerByName("right");
            }
            return this._rightController;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Casts a ray forward from the vrCamera's gaze.
     * @param length Length of the ray (default: 100)
     * @returns the ray corrisponding to the gaze
     */
    WebVRFreeCamera.prototype.getForwardRay = function (length) {
        if (length === void 0) { length = 100; }
        if (this.leftCamera) {
            // Use left eye to avoid computation to compute center on every call
            return _super.prototype.getForwardRay.call(this, length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera
        }
        else {
            return _super.prototype.getForwardRay.call(this, length);
        }
    };
    /**
     * @hidden
     * Updates the camera based on device's frame data
     */
    WebVRFreeCamera.prototype._checkInputs = function () {
        if (this._vrDevice && this._vrDevice.isPresenting) {
            this._vrDevice.getFrameData(this._frameData);
            this.updateFromDevice(this._frameData.pose);
        }
        _super.prototype._checkInputs.call(this);
    };
    /**
     * Updates the poseControlled values based on the input device pose.
     * @param poseData Pose coming from the device
     */
    WebVRFreeCamera.prototype.updateFromDevice = function (poseData) {
        if (poseData && poseData.orientation) {
            this.rawPose = poseData;
            this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);
            if (this.getScene().useRightHandedSystem) {
                this._deviceRoomRotationQuaternion.z *= -1;
                this._deviceRoomRotationQuaternion.w *= -1;
            }
            if (this.webVROptions.trackPosition && this.rawPose.position) {
                this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);
                if (this.getScene().useRightHandedSystem) {
                    this._deviceRoomPosition.z *= -1;
                }
            }
            this._poseSet = true;
        }
    };
    /**
     * WebVR's attach control will start broadcasting frames to the device.
     * Note that in certain browsers (chrome for example) this function must be called
     * within a user-interaction callback. Example:
     * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>
     *
     * @param element html element to attach the vrDevice to
     * @param noPreventDefault prevent the default html element operation when attaching the vrDevice
     */
    WebVRFreeCamera.prototype.attachControl = function (element, noPreventDefault) {
        _super.prototype.attachControl.call(this, element, noPreventDefault);
        this._attached = true;
        this._htmlElementAttached = element;
        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
        if (this._vrDevice) {
            this.getEngine().enableVR();
        }
        window.addEventListener('vrdisplaypresentchange', this._detachIfAttached);
    };
    /**
     * Detaches the camera from the html element and disables VR
     *
     * @param element html element to detach from
     */
    WebVRFreeCamera.prototype.detachControl = function (element) {
        this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
        this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
        _super.prototype.detachControl.call(this, element);
        this._attached = false;
        this.getEngine().disableVR();
        window.removeEventListener('vrdisplaypresentchange', this._detachIfAttached);
    };
    /**
     * @returns the name of this class
     */
    WebVRFreeCamera.prototype.getClassName = function () {
        return "WebVRFreeCamera";
    };
    /**
     * Calls resetPose on the vrDisplay
     * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose
     */
    WebVRFreeCamera.prototype.resetToCurrentRotation = function () {
        //uses the vrDisplay's "resetPose()".
        //pitch and roll won't be affected.
        this._vrDevice.resetPose();
    };
    /**
     * @hidden
     * Updates the rig cameras (left and right eye)
     */
    WebVRFreeCamera.prototype._updateRigCameras = function () {
        var camLeft = this._rigCameras[0];
        var camRight = this._rigCameras[1];
        camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);
        camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);
        camLeft.position.copyFrom(this._deviceRoomPosition);
        camRight.position.copyFrom(this._deviceRoomPosition);
    };
    // Remove translation from 6dof headset if trackposition is set to false
    WebVRFreeCamera.prototype._correctPositionIfNotTrackPosition = function (matrix, isViewMatrix) {
        if (isViewMatrix === void 0) { isViewMatrix = false; }
        if (this.rawPose && this.rawPose.position && !this.webVROptions.trackPosition) {
            Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);
            if (!isViewMatrix) {
                this._tmpMatrix.invert();
            }
            this._tmpMatrix.multiplyToRef(matrix, matrix);
        }
    };
    /**
     * @hidden
     * Updates the cached values of the camera
     * @param ignoreParentClass ignores updating the parent class's cache (default: false)
     */
    WebVRFreeCamera.prototype._updateCache = function (ignoreParentClass) {
        var _this = this;
        if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {
            // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition
            if (!this.updateCacheCalled) {
                // make sure it is only called once per loop. this.update() might cause an infinite loop.
                this.updateCacheCalled = true;
                this.update();
            }
            // Set working vector to the device position in room space rotated by the new rotation
            this.rotationQuaternion.toRotationMatrix(this._workingMatrix);
            Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector);
            // Subtract this vector from the current device position in world to get the translation for the device world matrix
            this.devicePosition.subtractToRef(this._workingVector, this._workingVector);
            Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld);
            // Add translation from anchor position
            this._deviceToWorld.getTranslationToRef(this._workingVector);
            this._workingVector.addInPlace(this.position);
            this._workingVector.subtractInPlace(this._cache.position);
            this._deviceToWorld.setTranslation(this._workingVector);
            // Set an inverted matrix to be used when updating the camera
            this._deviceToWorld.invertToRef(this._worldToDevice);
            // Update the gamepad to ensure the mesh is updated on the same frame as camera
            this.controllers.forEach(function (controller) {
                controller._deviceToWorld.copyFrom(_this._deviceToWorld);
                _this._correctPositionIfNotTrackPosition(controller._deviceToWorld);
                controller.update();
            });
        }
        if (!ignoreParentClass) {
            _super.prototype._updateCache.call(this);
        }
        this.updateCacheCalled = false;
    };
    /**
     * @hidden
     * Get current device position in babylon world
     */
    WebVRFreeCamera.prototype._computeDevicePosition = function () {
        Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);
    };
    /**
     * Updates the current device position and rotation in the babylon world
     */
    WebVRFreeCamera.prototype.update = function () {
        this._computeDevicePosition();
        // Get current device rotation in babylon world
        Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);
        this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);
        Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);
        if (this._poseSet) {
            this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);
        }
        _super.prototype.update.call(this);
    };
    /**
     * @hidden
     * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)
     * @returns an identity matrix
     */
    WebVRFreeCamera.prototype._getViewMatrix = function () {
        return Matrix.Identity();
    };
    /**
     * This function is called by the two RIG cameras.
     * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)
     * @hidden
     */
    WebVRFreeCamera.prototype._getWebVRViewMatrix = function () {
        // Update the parent camera prior to using a child camera to avoid desynchronization
        var parentCamera = this._cameraRigParams["parentCamera"];
        parentCamera._updateCache();
        //WebVR 1.1
        var viewArray = this._cameraRigParams["left"] ? this._cameraRigParams["frameData"].leftViewMatrix : this._cameraRigParams["frameData"].rightViewMatrix;
        Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);
        if (!this.getScene().useRightHandedSystem) {
            this._webvrViewMatrix.toggleModelMatrixHandInPlace();
        }
        // update the camera rotation matrix
        this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);
        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
        // Computing target and final matrix
        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
        // should the view matrix be updated with scale and position offset?
        if (parentCamera.deviceScaleFactor !== 1) {
            this._webvrViewMatrix.invert();
            // scale the position, if set
            if (parentCamera.deviceScaleFactor) {
                this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);
                this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);
                this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);
            }
            this._webvrViewMatrix.invert();
        }
        // Remove translation from 6dof headset if trackposition is set to false
        parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);
        parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix);
        // Compute global position
        this._workingMatrix = this._workingMatrix || Matrix.Identity();
        this._webvrViewMatrix.invertToRef(this._workingMatrix);
        this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);
        this._workingMatrix.getTranslationToRef(this._globalPosition);
        this._markSyncedWithParent();
        return this._webvrViewMatrix;
    };
    /** @hidden */
    WebVRFreeCamera.prototype._getWebVRProjectionMatrix = function () {
        var parentCamera = this.parent;
        parentCamera._vrDevice.depthNear = parentCamera.minZ;
        parentCamera._vrDevice.depthFar = parentCamera.maxZ;
        var projectionArray = this._cameraRigParams["left"] ? this._cameraRigParams["frameData"].leftProjectionMatrix : this._cameraRigParams["frameData"].rightProjectionMatrix;
        Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);
        //babylon compatible matrix
        if (!this.getScene().useRightHandedSystem) {
            this._projectionMatrix.toggleProjectionMatrixHandInPlace();
        }
        return this._projectionMatrix;
    };
    /**
     * Initializes the controllers and their meshes
     */
    WebVRFreeCamera.prototype.initControllers = function () {
        var _this = this;
        this.controllers = [];
        var manager = this.getScene().gamepadManager;
        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(function (gamepad) {
            if (gamepad.type === Gamepad.POSE_ENABLED) {
                var webVrController = gamepad;
                if (webVrController.defaultModel) {
                    webVrController.defaultModel.setEnabled(false);
                }
                if (webVrController.hand === "right") {
                    _this._rightController = null;
                }
                if (webVrController.hand === "left") {
                    _this._leftController = null;
                }
                var controllerIndex = _this.controllers.indexOf(webVrController);
                if (controllerIndex !== -1) {
                    _this.controllers.splice(controllerIndex, 1);
                }
            }
        });
        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(function (gamepad) {
            if (gamepad.type === Gamepad.POSE_ENABLED) {
                var webVrController_1 = gamepad;
                if (!_this.webVROptions.trackPosition) {
                    webVrController_1._disableTrackPosition(new Vector3(webVrController_1.hand == "left" ? -0.15 : 0.15, -0.5, 0.25));
                    // Cache must be updated before rendering controllers to avoid them being one frame behind
                    if (!_this._updateCacheWhenTrackingDisabledObserver) {
                        _this._updateCacheWhenTrackingDisabledObserver = _this._scene.onBeforeRenderObservable.add(function () {
                            _this._updateCache();
                        });
                    }
                }
                webVrController_1.deviceScaleFactor = _this.deviceScaleFactor;
                webVrController_1._deviceToWorld.copyFrom(_this._deviceToWorld);
                _this._correctPositionIfNotTrackPosition(webVrController_1._deviceToWorld);
                if (_this.webVROptions.controllerMeshes) {
                    if (webVrController_1.defaultModel) {
                        webVrController_1.defaultModel.setEnabled(true);
                    }
                    else {
                        // Load the meshes
                        webVrController_1.initControllerMesh(_this.getScene(), function (loadedMesh) {
                            loadedMesh.scaling.scaleInPlace(_this.deviceScaleFactor);
                            _this.onControllerMeshLoadedObservable.notifyObservers(webVrController_1);
                            if (_this.webVROptions.defaultLightingOnControllers) {
                                if (!_this._lightOnControllers) {
                                    _this._lightOnControllers = new HemisphericLight("vrControllersLight", new Vector3(0, 1, 0), _this.getScene());
                                }
                                var activateLightOnSubMeshes_1 = function (mesh, light) {
                                    var children = mesh.getChildren();
                                    if (children && children.length !== 0) {
                                        children.forEach(function (mesh) {
                                            light.includedOnlyMeshes.push(mesh);
                                            activateLightOnSubMeshes_1(mesh, light);
                                        });
                                    }
                                };
                                _this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);
                                activateLightOnSubMeshes_1(loadedMesh, _this._lightOnControllers);
                            }
                        });
                    }
                }
                webVrController_1.attachToPoseControlledCamera(_this);
                // since this is async - sanity check. Is the controller already stored?
                if (_this.controllers.indexOf(webVrController_1) === -1) {
                    //add to the controllers array
                    _this.controllers.push(webVrController_1);
                    // Forced to add some control code for Vive as it doesn't always fill properly the "hand" property
                    // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...
                    // So we're overriding setting left & right manually to be sure
                    var firstViveWandDetected = false;
                    for (var i = 0; i < _this.controllers.length; i++) {
                        if (_this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {
                            if (!firstViveWandDetected) {
                                firstViveWandDetected = true;
                                _this.controllers[i].hand = "left";
                            }
                            else {
                                _this.controllers[i].hand = "right";
                            }
                        }
                    }
                    //did we find enough controllers? Great! let the developer know.
                    if (_this.controllers.length >= 2) {
                        _this.onControllersAttachedObservable.notifyObservers(_this.controllers);
                    }
                }
            }
        });
    };
    return WebVRFreeCamera;
}(FreeCamera));

/**
 * Defines the WebVRController object that represents controllers tracked in 3D space
 */
var WebVRController = /** @class */ (function (_super) {
    __extends(WebVRController, _super);
    /**
     * Creates a new WebVRController from a gamepad
     * @param vrGamepad the gamepad that the WebVRController should be created from
     */
    function WebVRController(vrGamepad) {
        var _this = _super.call(this, vrGamepad) || this;
        // Observables
        /**
         * Fired when the trigger state has changed
         */
        _this.onTriggerStateChangedObservable = new Observable();
        /**
         * Fired when the main button state has changed
         */
        _this.onMainButtonStateChangedObservable = new Observable();
        /**
         * Fired when the secondary button state has changed
         */
        _this.onSecondaryButtonStateChangedObservable = new Observable();
        /**
         * Fired when the pad state has changed
         */
        _this.onPadStateChangedObservable = new Observable();
        /**
         * Fired when controllers stick values have changed
         */
        _this.onPadValuesChangedObservable = new Observable();
        /**
         * X and Y axis corrisponding to the controllers joystick
         */
        _this.pad = { x: 0, y: 0 };
        // avoid GC, store state in a tmp object
        _this._changes = {
            pressChanged: false,
            touchChanged: false,
            valueChanged: false,
            changed: false
        };
        _this._buttons = new Array(vrGamepad.buttons.length);
        _this.hand = vrGamepad.hand;
        return _this;
    }
    /**
     * Fired when a controller button's state has changed
     * @param callback the callback containing the button that was modified
     */
    WebVRController.prototype.onButtonStateChange = function (callback) {
        this._onButtonStateChange = callback;
    };
    Object.defineProperty(WebVRController.prototype, "defaultModel", {
        /**
         * The default controller model for the controller
         */
        get: function () {
            return this._defaultModel;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the state of the controller and mesh based on the current position and rotation of the controller
     */
    WebVRController.prototype.update = function () {
        _super.prototype.update.call(this);
        for (var index = 0; index < this._buttons.length; index++) {
            this._setButtonValue(this.browserGamepad.buttons[index], this._buttons[index], index);
        }
        if (this.leftStick.x !== this.pad.x || this.leftStick.y !== this.pad.y) {
            this.pad.x = this.leftStick.x;
            this.pad.y = this.leftStick.y;
            this.onPadValuesChangedObservable.notifyObservers(this.pad);
        }
    };
    WebVRController.prototype._setButtonValue = function (newState, currentState, buttonIndex) {
        if (!newState) {
            newState = {
                pressed: false,
                touched: false,
                value: 0
            };
        }
        if (!currentState) {
            this._buttons[buttonIndex] = {
                pressed: newState.pressed,
                touched: newState.touched,
                value: newState.value
            };
            return;
        }
        this._checkChanges(newState, currentState);
        if (this._changes.changed) {
            this._onButtonStateChange && this._onButtonStateChange(this.index, buttonIndex, newState);
            this._handleButtonChange(buttonIndex, newState, this._changes);
        }
        this._buttons[buttonIndex].pressed = newState.pressed;
        this._buttons[buttonIndex].touched = newState.touched;
        // oculus triggers are never 0, thou not touched.
        this._buttons[buttonIndex].value = newState.value < 0.00000001 ? 0 : newState.value;
    };
    WebVRController.prototype._checkChanges = function (newState, currentState) {
        this._changes.pressChanged = newState.pressed !== currentState.pressed;
        this._changes.touchChanged = newState.touched !== currentState.touched;
        this._changes.valueChanged = newState.value !== currentState.value;
        this._changes.changed = this._changes.pressChanged || this._changes.touchChanged || this._changes.valueChanged;
        return this._changes;
    };
    /**
     * Disposes of th webVRCOntroller
     */
    WebVRController.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.onTriggerStateChangedObservable.clear();
        this.onMainButtonStateChangedObservable.clear();
        this.onSecondaryButtonStateChangedObservable.clear();
        this.onPadStateChangedObservable.clear();
        this.onPadValuesChangedObservable.clear();
    };
    return WebVRController;
}(PoseEnabledController));

var name$6 = 'imageProcessingPixelShader';
var shader$6 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\nvoid main(void)\n{\nvec4 result=texture2D(textureSampler,vUV);\n#ifdef IMAGEPROCESSING\n#ifndef FROMLINEARSPACE\n\nresult.rgb=toLinearSpace(result.rgb);\n#endif\nresult=applyImageProcessing(result);\n#else\n\n#ifdef FROMLINEARSPACE\nresult=applyImageProcessing(result);\n#endif\n#endif\ngl_FragColor=result;\n}";
Effect.ShadersStore[name$6] = shader$6;

/**
 * ImageProcessingPostProcess
 * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#imageprocessing
 */
var ImageProcessingPostProcess = /** @class */ (function (_super) {
    __extends(ImageProcessingPostProcess, _super);
    function ImageProcessingPostProcess(name, options, camera, samplingMode, engine, reusable, textureType, imageProcessingConfiguration) {
        if (camera === void 0) { camera = null; }
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        var _this = _super.call(this, name, "imageProcessing", [], [], options, camera, samplingMode, engine, reusable, null, textureType, "postprocess", null, true) || this;
        _this._fromLinearSpace = true;
        /**
         * Defines cache preventing GC.
         */
        _this._defines = {
            IMAGEPROCESSING: false,
            VIGNETTE: false,
            VIGNETTEBLENDMODEMULTIPLY: false,
            VIGNETTEBLENDMODEOPAQUE: false,
            TONEMAPPING: false,
            TONEMAPPING_ACES: false,
            CONTRAST: false,
            COLORCURVES: false,
            COLORGRADING: false,
            COLORGRADING3D: false,
            FROMLINEARSPACE: false,
            SAMPLER3DGREENDEPTH: false,
            SAMPLER3DBGRMAP: false,
            IMAGEPROCESSINGPOSTPROCESS: false,
            EXPOSURE: false,
        };
        // Setup the configuration as forced by the constructor. This would then not force the
        // scene materials output in linear space and let untouched the default forward pass.
        if (imageProcessingConfiguration) {
            imageProcessingConfiguration.applyByPostProcess = true;
            _this._attachImageProcessingConfiguration(imageProcessingConfiguration, true);
            // This will cause the shader to be compiled
            _this.fromLinearSpace = false;
        }
        // Setup the default processing configuration to the scene.
        else {
            _this._attachImageProcessingConfiguration(null, true);
            _this.imageProcessingConfiguration.applyByPostProcess = true;
        }
        _this.onApply = function (effect) {
            _this.imageProcessingConfiguration.bind(effect, _this.aspectRatio);
        };
        return _this;
    }
    Object.defineProperty(ImageProcessingPostProcess.prototype, "imageProcessingConfiguration", {
        /**
         * Gets the image processing configuration used either in this material.
         */
        get: function () {
            return this._imageProcessingConfiguration;
        },
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        set: function (value) {
            this._attachImageProcessingConfiguration(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attaches a new image processing configuration to the PBR Material.
     * @param configuration
     */
    ImageProcessingPostProcess.prototype._attachImageProcessingConfiguration = function (configuration, doNotBuild) {
        var _this = this;
        if (doNotBuild === void 0) { doNotBuild = false; }
        if (configuration === this._imageProcessingConfiguration) {
            return;
        }
        // Detaches observer.
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        // Pick the scene configuration if needed.
        if (!configuration) {
            var scene = null;
            var engine = this.getEngine();
            var camera = this.getCamera();
            if (camera) {
                scene = camera.getScene();
            }
            else if (engine && engine.scenes) {
                var scenes = engine.scenes;
                scene = scenes[scenes.length - 1];
            }
            else {
                scene = EngineStore.LastCreatedScene;
            }
            this._imageProcessingConfiguration = scene.imageProcessingConfiguration;
        }
        else {
            this._imageProcessingConfiguration = configuration;
        }
        // Attaches observer.
        if (this._imageProcessingConfiguration) {
            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {
                _this._updateParameters();
            });
        }
        // Ensure the effect will be rebuilt.
        if (!doNotBuild) {
            this._updateParameters();
        }
    };
    Object.defineProperty(ImageProcessingPostProcess.prototype, "colorCurves", {
        /**
         * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .
         */
        get: function () {
            return this.imageProcessingConfiguration.colorCurves;
        },
        /**
         * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .
         */
        set: function (value) {
            this.imageProcessingConfiguration.colorCurves = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "colorCurvesEnabled", {
        /**
         * Gets wether the color curves effect is enabled.
         */
        get: function () {
            return this.imageProcessingConfiguration.colorCurvesEnabled;
        },
        /**
         * Sets wether the color curves effect is enabled.
         */
        set: function (value) {
            this.imageProcessingConfiguration.colorCurvesEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "colorGradingTexture", {
        /**
         * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
         */
        get: function () {
            return this.imageProcessingConfiguration.colorGradingTexture;
        },
        /**
         * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
         */
        set: function (value) {
            this.imageProcessingConfiguration.colorGradingTexture = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "colorGradingEnabled", {
        /**
         * Gets wether the color grading effect is enabled.
         */
        get: function () {
            return this.imageProcessingConfiguration.colorGradingEnabled;
        },
        /**
         * Gets wether the color grading effect is enabled.
         */
        set: function (value) {
            this.imageProcessingConfiguration.colorGradingEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "exposure", {
        /**
         * Gets exposure used in the effect.
         */
        get: function () {
            return this.imageProcessingConfiguration.exposure;
        },
        /**
         * Sets exposure used in the effect.
         */
        set: function (value) {
            this.imageProcessingConfiguration.exposure = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "toneMappingEnabled", {
        /**
         * Gets wether tonemapping is enabled or not.
         */
        get: function () {
            return this._imageProcessingConfiguration.toneMappingEnabled;
        },
        /**
         * Sets wether tonemapping is enabled or not
         */
        set: function (value) {
            this._imageProcessingConfiguration.toneMappingEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "toneMappingType", {
        /**
         * Gets the type of tone mapping effect.
         */
        get: function () {
            return this._imageProcessingConfiguration.toneMappingType;
        },
        /**
         * Sets the type of tone mapping effect.
         */
        set: function (value) {
            this._imageProcessingConfiguration.toneMappingType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "contrast", {
        /**
         * Gets contrast used in the effect.
         */
        get: function () {
            return this.imageProcessingConfiguration.contrast;
        },
        /**
         * Sets contrast used in the effect.
         */
        set: function (value) {
            this.imageProcessingConfiguration.contrast = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "vignetteStretch", {
        /**
         * Gets Vignette stretch size.
         */
        get: function () {
            return this.imageProcessingConfiguration.vignetteStretch;
        },
        /**
         * Sets Vignette stretch size.
         */
        set: function (value) {
            this.imageProcessingConfiguration.vignetteStretch = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "vignetteCentreX", {
        /**
         * Gets Vignette centre X Offset.
         */
        get: function () {
            return this.imageProcessingConfiguration.vignetteCentreX;
        },
        /**
         * Sets Vignette centre X Offset.
         */
        set: function (value) {
            this.imageProcessingConfiguration.vignetteCentreX = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "vignetteCentreY", {
        /**
         * Gets Vignette centre Y Offset.
         */
        get: function () {
            return this.imageProcessingConfiguration.vignetteCentreY;
        },
        /**
         * Sets Vignette centre Y Offset.
         */
        set: function (value) {
            this.imageProcessingConfiguration.vignetteCentreY = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "vignetteWeight", {
        /**
         * Gets Vignette weight or intensity of the vignette effect.
         */
        get: function () {
            return this.imageProcessingConfiguration.vignetteWeight;
        },
        /**
         * Sets Vignette weight or intensity of the vignette effect.
         */
        set: function (value) {
            this.imageProcessingConfiguration.vignetteWeight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "vignetteColor", {
        /**
         * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
         * if vignetteEnabled is set to true.
         */
        get: function () {
            return this.imageProcessingConfiguration.vignetteColor;
        },
        /**
         * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
         * if vignetteEnabled is set to true.
         */
        set: function (value) {
            this.imageProcessingConfiguration.vignetteColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "vignetteCameraFov", {
        /**
         * Gets Camera field of view used by the Vignette effect.
         */
        get: function () {
            return this.imageProcessingConfiguration.vignetteCameraFov;
        },
        /**
         * Sets Camera field of view used by the Vignette effect.
         */
        set: function (value) {
            this.imageProcessingConfiguration.vignetteCameraFov = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "vignetteBlendMode", {
        /**
         * Gets the vignette blend mode allowing different kind of effect.
         */
        get: function () {
            return this.imageProcessingConfiguration.vignetteBlendMode;
        },
        /**
         * Sets the vignette blend mode allowing different kind of effect.
         */
        set: function (value) {
            this.imageProcessingConfiguration.vignetteBlendMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "vignetteEnabled", {
        /**
         * Gets wether the vignette effect is enabled.
         */
        get: function () {
            return this.imageProcessingConfiguration.vignetteEnabled;
        },
        /**
         * Sets wether the vignette effect is enabled.
         */
        set: function (value) {
            this.imageProcessingConfiguration.vignetteEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageProcessingPostProcess.prototype, "fromLinearSpace", {
        /**
         * Gets wether the input of the processing is in Gamma or Linear Space.
         */
        get: function () {
            return this._fromLinearSpace;
        },
        /**
         * Sets wether the input of the processing is in Gamma or Linear Space.
         */
        set: function (value) {
            if (this._fromLinearSpace === value) {
                return;
            }
            this._fromLinearSpace = value;
            this._updateParameters();
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  "ImageProcessingPostProcess"
     * @returns "ImageProcessingPostProcess"
     */
    ImageProcessingPostProcess.prototype.getClassName = function () {
        return "ImageProcessingPostProcess";
    };
    ImageProcessingPostProcess.prototype._updateParameters = function () {
        this._defines.FROMLINEARSPACE = this._fromLinearSpace;
        this.imageProcessingConfiguration.prepareDefines(this._defines, true);
        var defines = "";
        for (var define in this._defines) {
            if (this._defines[define]) {
                defines += "#define " + define + ";\r\n";
            }
        }
        var samplers = ["textureSampler"];
        var uniforms = ["scale"];
        if (ImageProcessingConfiguration) {
            ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);
            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);
        }
        this.updateEffect(defines, uniforms, samplers);
    };
    ImageProcessingPostProcess.prototype.dispose = function (camera) {
        _super.prototype.dispose.call(this, camera);
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        if (this._imageProcessingConfiguration) {
            this.imageProcessingConfiguration.applyByPostProcess = false;
        }
    };
    __decorate([
        serialize()
    ], ImageProcessingPostProcess.prototype, "_fromLinearSpace", void 0);
    return ImageProcessingPostProcess;
}(PostProcess));

Mesh._GroundMeshParser = function (parsedMesh, scene) {
    return GroundMesh.Parse(parsedMesh, scene);
};
/**
 * Mesh representing the gorund
 */
var GroundMesh = /** @class */ (function (_super) {
    __extends(GroundMesh, _super);
    function GroundMesh(name, scene) {
        var _this = _super.call(this, name, scene) || this;
        /** If octree should be generated */
        _this.generateOctree = false;
        return _this;
    }
    /**
     * "GroundMesh"
     * @returns "GroundMesh"
     */
    GroundMesh.prototype.getClassName = function () {
        return "GroundMesh";
    };
    Object.defineProperty(GroundMesh.prototype, "subdivisions", {
        /**
         * The minimum of x and y subdivisions
         */
        get: function () {
            return Math.min(this._subdivisionsX, this._subdivisionsY);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GroundMesh.prototype, "subdivisionsX", {
        /**
         * X subdivisions
         */
        get: function () {
            return this._subdivisionsX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GroundMesh.prototype, "subdivisionsY", {
        /**
         * Y subdivisions
         */
        get: function () {
            return this._subdivisionsY;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.
     * Please note that you must have a decent number of submeshes to get performance improvements when using an octree
     * @param chunksCount the number of subdivisions for x and y
     * @param octreeBlocksSize (Default: 32)
     */
    GroundMesh.prototype.optimize = function (chunksCount, octreeBlocksSize) {
        if (octreeBlocksSize === void 0) { octreeBlocksSize = 32; }
        this._subdivisionsX = chunksCount;
        this._subdivisionsY = chunksCount;
        this.subdivide(chunksCount);
        // Call the octree system optimization if it is defined.
        var thisAsAny = this;
        if (thisAsAny.createOrUpdateSubmeshesOctree) {
            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);
        }
    };
    /**
     * Returns a height (y) value in the Worl system :
     * the ground altitude at the coordinates (x, z) expressed in the World system.
     * @param x x coordinate
     * @param z z coordinate
     * @returns the ground y position if (x, z) are outside the ground surface.
     */
    GroundMesh.prototype.getHeightAtCoordinates = function (x, z) {
        var world = this.getWorldMatrix();
        var invMat = Tmp.Matrix[5];
        world.invertToRef(invMat);
        var tmpVect = Tmp.Vector3[8];
        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space
        x = tmpVect.x;
        z = tmpVect.z;
        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
            return this.position.y;
        }
        if (!this._heightQuads || this._heightQuads.length == 0) {
            this._initHeightQuads();
            this._computeHeightQuads();
        }
        var facet = this._getFacetAt(x, z);
        var y = -(facet.x * x + facet.z * z + facet.w) / facet.y;
        // return y in the World system
        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);
        return tmpVect.y;
    };
    /**
     * Returns a normalized vector (Vector3) orthogonal to the ground
     * at the ground coordinates (x, z) expressed in the World system.
     * @param x x coordinate
     * @param z z coordinate
     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
     */
    GroundMesh.prototype.getNormalAtCoordinates = function (x, z) {
        var normal = new Vector3(0.0, 1.0, 0.0);
        this.getNormalAtCoordinatesToRef(x, z, normal);
        return normal;
    };
    /**
     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
     * at the ground coordinates (x, z) expressed in the World system.
     * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.
     * @param x x coordinate
     * @param z z coordinate
     * @param ref vector to store the result
     * @returns the GroundMesh.
     */
    GroundMesh.prototype.getNormalAtCoordinatesToRef = function (x, z, ref) {
        var world = this.getWorldMatrix();
        var tmpMat = Tmp.Matrix[5];
        world.invertToRef(tmpMat);
        var tmpVect = Tmp.Vector3[8];
        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space
        x = tmpVect.x;
        z = tmpVect.z;
        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
            return this;
        }
        if (!this._heightQuads || this._heightQuads.length == 0) {
            this._initHeightQuads();
            this._computeHeightQuads();
        }
        var facet = this._getFacetAt(x, z);
        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);
        return this;
    };
    /**
    * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
    * if the ground has been updated.
    * This can be used in the render loop.
    * @returns the GroundMesh.
    */
    GroundMesh.prototype.updateCoordinateHeights = function () {
        if (!this._heightQuads || this._heightQuads.length == 0) {
            this._initHeightQuads();
        }
        this._computeHeightQuads();
        return this;
    };
    // Returns the element "facet" from the heightQuads array relative to (x, z) local coordinates
    GroundMesh.prototype._getFacetAt = function (x, z) {
        // retrieve col and row from x, z coordinates in the ground local system
        var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);
        var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);
        var quad = this._heightQuads[row * this._subdivisionsX + col];
        var facet;
        if (z < quad.slope.x * x + quad.slope.y) {
            facet = quad.facet1;
        }
        else {
            facet = quad.facet2;
        }
        return facet;
    };
    //  Creates and populates the heightMap array with "facet" elements :
    // a quad is two triangular facets separated by a slope, so a "facet" element is 1 slope + 2 facets
    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h
    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
    // Returns the GroundMesh.
    GroundMesh.prototype._initHeightQuads = function () {
        var subdivisionsX = this._subdivisionsX;
        var subdivisionsY = this._subdivisionsY;
        this._heightQuads = new Array();
        for (var row = 0; row < subdivisionsY; row++) {
            for (var col = 0; col < subdivisionsX; col++) {
                var quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };
                this._heightQuads[row * subdivisionsX + col] = quad;
            }
        }
        return this;
    };
    // Compute each quad element values and update the the heightMap array :
    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h
    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
    // Returns the GroundMesh.
    GroundMesh.prototype._computeHeightQuads = function () {
        var positions = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positions) {
            return this;
        }
        var v1 = Tmp.Vector3[3];
        var v2 = Tmp.Vector3[2];
        var v3 = Tmp.Vector3[1];
        var v4 = Tmp.Vector3[0];
        var v1v2 = Tmp.Vector3[4];
        var v1v3 = Tmp.Vector3[5];
        var v1v4 = Tmp.Vector3[6];
        var norm1 = Tmp.Vector3[7];
        var norm2 = Tmp.Vector3[8];
        var i = 0;
        var j = 0;
        var k = 0;
        var cd = 0; // 2D slope coefficient : z = cd * x + h
        var h = 0;
        var d1 = 0; // facet plane equation : ax + by + cz + d = 0
        var d2 = 0;
        var subdivisionsX = this._subdivisionsX;
        var subdivisionsY = this._subdivisionsY;
        for (var row = 0; row < subdivisionsY; row++) {
            for (var col = 0; col < subdivisionsX; col++) {
                i = col * 3;
                j = row * (subdivisionsX + 1) * 3;
                k = (row + 1) * (subdivisionsX + 1) * 3;
                v1.x = positions[j + i];
                v1.y = positions[j + i + 1];
                v1.z = positions[j + i + 2];
                v2.x = positions[j + i + 3];
                v2.y = positions[j + i + 4];
                v2.z = positions[j + i + 5];
                v3.x = positions[k + i];
                v3.y = positions[k + i + 1];
                v3.z = positions[k + i + 2];
                v4.x = positions[k + i + 3];
                v4.y = positions[k + i + 4];
                v4.z = positions[k + i + 5];
                // 2D slope V1V4
                cd = (v4.z - v1.z) / (v4.x - v1.x);
                h = v1.z - cd * v1.x; // v1 belongs to the slope
                // facet equations :
                // we compute each facet normal vector
                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0
                // we compute the value d by applying the equation to v1 which belongs to the plane
                // then we store the facet equation in a Vector4
                v2.subtractToRef(v1, v1v2);
                v3.subtractToRef(v1, v1v3);
                v4.subtractToRef(v1, v1v4);
                Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class
                Vector3.CrossToRef(v1v2, v1v4, norm2);
                norm1.normalize();
                norm2.normalize();
                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);
                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);
                var quad = this._heightQuads[row * subdivisionsX + col];
                quad.slope.copyFromFloats(cd, h);
                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);
                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);
            }
        }
        return this;
    };
    /**
     * Serializes this ground mesh
     * @param serializationObject object to write serialization to
     */
    GroundMesh.prototype.serialize = function (serializationObject) {
        _super.prototype.serialize.call(this, serializationObject);
        serializationObject.subdivisionsX = this._subdivisionsX;
        serializationObject.subdivisionsY = this._subdivisionsY;
        serializationObject.minX = this._minX;
        serializationObject.maxX = this._maxX;
        serializationObject.minZ = this._minZ;
        serializationObject.maxZ = this._maxZ;
        serializationObject.width = this._width;
        serializationObject.height = this._height;
    };
    /**
     * Parses a serialized ground mesh
     * @param parsedMesh the serialized mesh
     * @param scene the scene to create the ground mesh in
     * @returns the created ground mesh
     */
    GroundMesh.Parse = function (parsedMesh, scene) {
        var result = new GroundMesh(parsedMesh.name, scene);
        result._subdivisionsX = parsedMesh.subdivisionsX || 1;
        result._subdivisionsY = parsedMesh.subdivisionsY || 1;
        result._minX = parsedMesh.minX;
        result._maxX = parsedMesh.maxX;
        result._minZ = parsedMesh.minZ;
        result._maxZ = parsedMesh.maxZ;
        result._width = parsedMesh.width;
        result._height = parsedMesh.height;
        return result;
    };
    return GroundMesh;
}(Mesh));

VertexData.CreateGround = function (options) {
    var indices = [];
    var positions = [];
    var normals = [];
    var uvs = [];
    var row, col;
    var width = options.width || 1;
    var height = options.height || 1;
    var subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
    var subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
    for (row = 0; row <= subdivisionsY; row++) {
        for (col = 0; col <= subdivisionsX; col++) {
            var position = new Vector3((col * width) / subdivisionsX - (width / 2.0), 0, ((subdivisionsY - row) * height) / subdivisionsY - (height / 2.0));
            var normal = new Vector3(0, 1.0, 0);
            positions.push(position.x, position.y, position.z);
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(col / subdivisionsX, 1.0 - row / subdivisionsY);
        }
    }
    for (row = 0; row < subdivisionsY; row++) {
        for (col = 0; col < subdivisionsX; col++) {
            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
            indices.push(col + 1 + row * (subdivisionsX + 1));
            indices.push(col + row * (subdivisionsX + 1));
            indices.push(col + (row + 1) * (subdivisionsX + 1));
            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
            indices.push(col + row * (subdivisionsX + 1));
        }
    }
    // Result
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    return vertexData;
};
VertexData.CreateTiledGround = function (options) {
    var xmin = (options.xmin !== undefined && options.xmin !== null) ? options.xmin : -1.0;
    var zmin = (options.zmin !== undefined && options.zmin !== null) ? options.zmin : -1.0;
    var xmax = (options.xmax !== undefined && options.xmax !== null) ? options.xmax : 1.0;
    var zmax = (options.zmax !== undefined && options.zmax !== null) ? options.zmax : 1.0;
    var subdivisions = options.subdivisions || { w: 1, h: 1 };
    var precision = options.precision || { w: 1, h: 1 };
    var indices = new Array();
    var positions = new Array();
    var normals = new Array();
    var uvs = new Array();
    var row, col, tileRow, tileCol;
    subdivisions.h = (subdivisions.h < 1) ? 1 : subdivisions.h;
    subdivisions.w = (subdivisions.w < 1) ? 1 : subdivisions.w;
    precision.w = (precision.w < 1) ? 1 : precision.w;
    precision.h = (precision.h < 1) ? 1 : precision.h;
    var tileSize = {
        'w': (xmax - xmin) / subdivisions.w,
        'h': (zmax - zmin) / subdivisions.h
    };
    function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {
        // Indices
        var base = positions.length / 3;
        var rowLength = precision.w + 1;
        for (row = 0; row < precision.h; row++) {
            for (col = 0; col < precision.w; col++) {
                var square = [
                    base + col + row * rowLength,
                    base + (col + 1) + row * rowLength,
                    base + (col + 1) + (row + 1) * rowLength,
                    base + col + (row + 1) * rowLength
                ];
                indices.push(square[1]);
                indices.push(square[2]);
                indices.push(square[3]);
                indices.push(square[0]);
                indices.push(square[1]);
                indices.push(square[3]);
            }
        }
        // Position, normals and uvs
        var position = Vector3.Zero();
        var normal = new Vector3(0, 1.0, 0);
        for (row = 0; row <= precision.h; row++) {
            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;
            for (col = 0; col <= precision.w; col++) {
                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;
                position.y = 0;
                positions.push(position.x, position.y, position.z);
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(col / precision.w, row / precision.h);
            }
        }
    }
    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {
        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {
            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);
        }
    }
    // Result
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    return vertexData;
};
VertexData.CreateGroundFromHeightMap = function (options) {
    var indices = [];
    var positions = [];
    var normals = [];
    var uvs = [];
    var row, col;
    var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
    var alphaFilter = options.alphaFilter || 0.0;
    var invert = false;
    if (options.minHeight > options.maxHeight) {
        invert = true;
        var temp = options.maxHeight;
        options.maxHeight = options.minHeight;
        options.minHeight = temp;
    }
    // Vertices
    for (row = 0; row <= options.subdivisions; row++) {
        for (col = 0; col <= options.subdivisions; col++) {
            var position = new Vector3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0));
            // Compute height
            var heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;
            var heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;
            var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;
            var r = options.buffer[pos] / 255.0;
            var g = options.buffer[pos + 1] / 255.0;
            var b = options.buffer[pos + 2] / 255.0;
            var a = options.buffer[pos + 3] / 255.0;
            if (invert) {
                r = 1.0 - r;
                g = 1.0 - g;
                b = 1.0 - b;
            }
            var gradient = r * filter.r + g * filter.g + b * filter.b;
            // If our alpha channel is not within our filter then we will assign a 'special' height
            // Then when building the indices, we will ignore any vertex that is using the special height
            if (a >= alphaFilter) {
                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;
            }
            else {
                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.
            }
            // Add  vertex
            positions.push(position.x, position.y, position.z);
            normals.push(0, 0, 0);
            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);
        }
    }
    // Indices
    for (row = 0; row < options.subdivisions; row++) {
        for (col = 0; col < options.subdivisions; col++) {
            // Calculate Indices
            var idx1 = (col + 1 + (row + 1) * (options.subdivisions + 1));
            var idx2 = (col + 1 + row * (options.subdivisions + 1));
            var idx3 = (col + row * (options.subdivisions + 1));
            var idx4 = (col + (row + 1) * (options.subdivisions + 1));
            // Check that all indices are visible (based on our special height)
            // Only display the vertex if all Indices are visible
            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height
            var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;
            var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;
            var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;
            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {
                indices.push(idx1);
                indices.push(idx2);
                indices.push(idx3);
            }
            var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;
            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {
                indices.push(idx4);
                indices.push(idx1);
                indices.push(idx3);
            }
        }
    }
    // Normals
    VertexData.ComputeNormals(positions, indices, normals);
    // Result
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    return vertexData;
};
Mesh.CreateGround = function (name, width, height, subdivisions, scene, updatable) {
    var options = {
        width: width,
        height: height,
        subdivisions: subdivisions,
        updatable: updatable
    };
    return GroundBuilder.CreateGround(name, options, scene);
};
Mesh.CreateTiledGround = function (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {
    var options = {
        xmin: xmin,
        zmin: zmin,
        xmax: xmax,
        zmax: zmax,
        subdivisions: subdivisions,
        precision: precision,
        updatable: updatable
    };
    return GroundBuilder.CreateTiledGround(name, options, scene);
};
Mesh.CreateGroundFromHeightMap = function (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {
    var options = {
        width: width,
        height: height,
        subdivisions: subdivisions,
        minHeight: minHeight,
        maxHeight: maxHeight,
        updatable: updatable,
        onReady: onReady,
        alphaFilter: alphaFilter
    };
    return GroundBuilder.CreateGroundFromHeightMap(name, url, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var GroundBuilder = /** @class */ (function () {
    function GroundBuilder() {
    }
    /**
     * Creates a ground mesh
     * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
     * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the ground mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#ground
     */
    GroundBuilder.CreateGround = function (name, options, scene) {
        var ground = new GroundMesh(name, scene);
        ground._setReady(false);
        ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
        ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
        ground._width = options.width || 1;
        ground._height = options.height || 1;
        ground._maxX = ground._width / 2;
        ground._maxZ = ground._height / 2;
        ground._minX = -ground._maxX;
        ground._minZ = -ground._maxZ;
        var vertexData = VertexData.CreateGround(options);
        vertexData.applyToMesh(ground, options.updatable);
        ground._setReady(true);
        return ground;
    };
    /**
     * Creates a tiled ground mesh
     * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
     * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
     * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
     * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the tiled ground mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground
     */
    GroundBuilder.CreateTiledGround = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var tiledGround = new Mesh(name, scene);
        var vertexData = VertexData.CreateTiledGround(options);
        vertexData.applyToMesh(tiledGround, options.updatable);
        return tiledGround;
    };
    /**
     * Creates a ground mesh from a height map
     * * The parameter `url` sets the URL of the height map image resource.
     * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
     * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
     * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
     * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
     * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
     * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
     * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param url defines the url to the height map
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the ground mesh
     * @see https://doc.babylonjs.com/babylon101/height_map
     * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map
     */
    GroundBuilder.CreateGroundFromHeightMap = function (name, url, options, scene) {
        if (scene === void 0) { scene = null; }
        var width = options.width || 10.0;
        var height = options.height || 10.0;
        var subdivisions = options.subdivisions || 1 | 0;
        var minHeight = options.minHeight || 0.0;
        var maxHeight = options.maxHeight || 1.0;
        var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
        var alphaFilter = options.alphaFilter || 0.0;
        var updatable = options.updatable;
        var onReady = options.onReady;
        scene = scene || EngineStore.LastCreatedScene;
        var ground = new GroundMesh(name, scene);
        ground._subdivisionsX = subdivisions;
        ground._subdivisionsY = subdivisions;
        ground._width = width;
        ground._height = height;
        ground._maxX = ground._width / 2.0;
        ground._maxZ = ground._height / 2.0;
        ground._minX = -ground._maxX;
        ground._minZ = -ground._maxZ;
        ground._setReady(false);
        var onload = function (img) {
            // Getting height map data
            var canvas = document.createElement("canvas");
            var context = canvas.getContext("2d");
            if (!context) {
                throw new Error("Unable to get 2d context for CreateGroundFromHeightMap");
            }
            if (scene.isDisposed) {
                return;
            }
            var bufferWidth = img.width;
            var bufferHeight = img.height;
            canvas.width = bufferWidth;
            canvas.height = bufferHeight;
            context.drawImage(img, 0, 0);
            // Create VertexData from map data
            // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949
            var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;
            var vertexData = VertexData.CreateGroundFromHeightMap({
                width: width, height: height,
                subdivisions: subdivisions,
                minHeight: minHeight, maxHeight: maxHeight, colorFilter: filter,
                buffer: buffer, bufferWidth: bufferWidth, bufferHeight: bufferHeight,
                alphaFilter: alphaFilter
            });
            vertexData.applyToMesh(ground, updatable);
            //execute ready callback, if set
            if (onReady) {
                onReady(ground);
            }
            ground._setReady(true);
        };
        Tools.LoadImage(url, onload, function () { }, scene.offlineProvider);
        return ground;
    };
    return GroundBuilder;
}());

VertexData.CreateTorus = function (options) {
    var indices = [];
    var positions = [];
    var normals = [];
    var uvs = [];
    var diameter = options.diameter || 1;
    var thickness = options.thickness || 0.5;
    var tessellation = options.tessellation || 16;
    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
    var stride = tessellation + 1;
    for (var i = 0; i <= tessellation; i++) {
        var u = i / tessellation;
        var outerAngle = i * Math.PI * 2.0 / tessellation - Math.PI / 2.0;
        var transform = Matrix.Translation(diameter / 2.0, 0, 0).multiply(Matrix.RotationY(outerAngle));
        for (var j = 0; j <= tessellation; j++) {
            var v = 1 - j / tessellation;
            var innerAngle = j * Math.PI * 2.0 / tessellation + Math.PI;
            var dx = Math.cos(innerAngle);
            var dy = Math.sin(innerAngle);
            // Create a vertex.
            var normal = new Vector3(dx, dy, 0);
            var position = normal.scale(thickness / 2);
            var textureCoordinate = new Vector2(u, v);
            position = Vector3.TransformCoordinates(position, transform);
            normal = Vector3.TransformNormal(normal, transform);
            positions.push(position.x, position.y, position.z);
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(textureCoordinate.x, textureCoordinate.y);
            // And create indices for two triangles.
            var nextI = (i + 1) % stride;
            var nextJ = (j + 1) % stride;
            indices.push(i * stride + j);
            indices.push(i * stride + nextJ);
            indices.push(nextI * stride + j);
            indices.push(i * stride + nextJ);
            indices.push(nextI * stride + nextJ);
            indices.push(nextI * stride + j);
        }
    }
    // Sides
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
    // Result
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    return vertexData;
};
Mesh.CreateTorus = function (name, diameter, thickness, tessellation, scene, updatable, sideOrientation) {
    var options = {
        diameter: diameter,
        thickness: thickness,
        tessellation: tessellation,
        sideOrientation: sideOrientation,
        updatable: updatable
    };
    return TorusBuilder.CreateTorus(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var TorusBuilder = /** @class */ (function () {
    function TorusBuilder() {
    }
    /**
     * Creates a torus mesh
     * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
     * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
     * * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the torus mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#torus
     */
    TorusBuilder.CreateTorus = function (name, options, scene) {
        var torus = new Mesh(name, scene);
        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        torus._originalBuilderSideOrientation = options.sideOrientation;
        var vertexData = VertexData.CreateTorus(options);
        vertexData.applyToMesh(torus, options.updatable);
        return torus;
    };
    return TorusBuilder;
}());

VertexData.CreateCylinder = function (options) {
    var height = options.height || 2;
    var diameterTop = (options.diameterTop === 0) ? 0 : options.diameterTop || options.diameter || 1;
    var diameterBottom = (options.diameterBottom === 0) ? 0 : options.diameterBottom || options.diameter || 1;
    var tessellation = options.tessellation || 24;
    var subdivisions = options.subdivisions || 1;
    var hasRings = options.hasRings ? true : false;
    var enclose = options.enclose ? true : false;
    var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;
    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
    var faceUV = options.faceUV || new Array(3);
    var faceColors = options.faceColors;
    // default face colors and UV if undefined
    var quadNb = (arc !== 1 && enclose) ? 2 : 0;
    var ringNb = (hasRings) ? subdivisions : 1;
    var surfaceNb = 2 + (1 + quadNb) * ringNb;
    var f;
    for (f = 0; f < surfaceNb; f++) {
        if (faceColors && faceColors[f] === undefined) {
            faceColors[f] = new Color4(1, 1, 1, 1);
        }
    }
    for (f = 0; f < surfaceNb; f++) {
        if (faceUV && faceUV[f] === undefined) {
            faceUV[f] = new Vector4(0, 0, 1, 1);
        }
    }
    var indices = new Array();
    var positions = new Array();
    var normals = new Array();
    var uvs = new Array();
    var colors = new Array();
    var angle_step = Math.PI * 2 * arc / tessellation;
    var angle;
    var h;
    var radius;
    var tan = (diameterBottom - diameterTop) / 2 / height;
    var ringVertex = Vector3.Zero();
    var ringNormal = Vector3.Zero();
    var ringFirstVertex = Vector3.Zero();
    var ringFirstNormal = Vector3.Zero();
    var quadNormal = Vector3.Zero();
    var Y = Axis.Y;
    // positions, normals, uvs
    var i;
    var j;
    var r;
    var ringIdx = 1;
    var s = 1; // surface index
    var cs = 0;
    var v = 0;
    for (i = 0; i <= subdivisions; i++) {
        h = i / subdivisions;
        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;
        ringIdx = (hasRings && i !== 0 && i !== subdivisions) ? 2 : 1;
        for (r = 0; r < ringIdx; r++) {
            if (hasRings) {
                s += r;
            }
            if (enclose) {
                s += 2 * r;
            }
            for (j = 0; j <= tessellation; j++) {
                angle = j * angle_step;
                // position
                ringVertex.x = Math.cos(-angle) * radius;
                ringVertex.y = -height / 2 + h * height;
                ringVertex.z = Math.sin(-angle) * radius;
                // normal
                if (diameterTop === 0 && i === subdivisions) {
                    // if no top cap, reuse former normals
                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];
                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];
                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];
                }
                else {
                    ringNormal.x = ringVertex.x;
                    ringNormal.z = ringVertex.z;
                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;
                    ringNormal.normalize();
                }
                // keep first ring vertex values for enclose
                if (j === 0) {
                    ringFirstVertex.copyFrom(ringVertex);
                    ringFirstNormal.copyFrom(ringNormal);
                }
                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);
                if (hasRings) {
                    v = (cs !== s) ? faceUV[s].y : faceUV[s].w;
                }
                else {
                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;
                }
                uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, v);
                if (faceColors) {
                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);
                }
            }
            // if enclose, add four vertices and their dedicated normals
            if (arc !== 1 && enclose) {
                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
                positions.push(0, ringVertex.y, 0);
                positions.push(0, ringVertex.y, 0);
                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);
                Vector3.CrossToRef(Y, ringNormal, quadNormal);
                quadNormal.normalize();
                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);
                quadNormal.normalize();
                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
                if (hasRings) {
                    v = (cs !== s) ? faceUV[s + 1].y : faceUV[s + 1].w;
                }
                else {
                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;
                }
                uvs.push(faceUV[s + 1].x, v);
                uvs.push(faceUV[s + 1].z, v);
                if (hasRings) {
                    v = (cs !== s) ? faceUV[s + 2].y : faceUV[s + 2].w;
                }
                else {
                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;
                }
                uvs.push(faceUV[s + 2].x, v);
                uvs.push(faceUV[s + 2].z, v);
                if (faceColors) {
                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
                }
            }
            if (cs !== s) {
                cs = s;
            }
        }
    }
    // indices
    var e = (arc !== 1 && enclose) ? tessellation + 4 : tessellation; // correction of number of iteration if enclose
    var s;
    i = 0;
    for (s = 0; s < subdivisions; s++) {
        var i0 = 0;
        var i1 = 0;
        var i2 = 0;
        var i3 = 0;
        for (j = 0; j < tessellation; j++) {
            i0 = i * (e + 1) + j;
            i1 = (i + 1) * (e + 1) + j;
            i2 = i * (e + 1) + (j + 1);
            i3 = (i + 1) * (e + 1) + (j + 1);
            indices.push(i0, i1, i2);
            indices.push(i3, i2, i1);
        }
        if (arc !== 1 && enclose) { // if enclose, add two quads
            indices.push(i0 + 2, i1 + 2, i2 + 2);
            indices.push(i3 + 2, i2 + 2, i1 + 2);
            indices.push(i0 + 4, i1 + 4, i2 + 4);
            indices.push(i3 + 4, i2 + 4, i1 + 4);
        }
        i = (hasRings) ? (i + 2) : (i + 1);
    }
    // Caps
    var createCylinderCap = function (isTop) {
        var radius = isTop ? diameterTop / 2 : diameterBottom / 2;
        if (radius === 0) {
            return;
        }
        // Cap positions, normals & uvs
        var angle;
        var circleVector;
        var i;
        var u = (isTop) ? faceUV[surfaceNb - 1] : faceUV[0];
        var c = null;
        if (faceColors) {
            c = (isTop) ? faceColors[surfaceNb - 1] : faceColors[0];
        }
        // cap center
        var vbase = positions.length / 3;
        var offset = isTop ? height / 2 : -height / 2;
        var center = new Vector3(0, offset, 0);
        positions.push(center.x, center.y, center.z);
        normals.push(0, isTop ? 1 : -1, 0);
        uvs.push(u.x + (u.z - u.x) * 0.5, u.y + (u.w - u.y) * 0.5);
        if (c) {
            colors.push(c.r, c.g, c.b, c.a);
        }
        var textureScale = new Vector2(0.5, 0.5);
        for (i = 0; i <= tessellation; i++) {
            angle = Math.PI * 2 * i * arc / tessellation;
            var cos = Math.cos(-angle);
            var sin = Math.sin(-angle);
            circleVector = new Vector3(cos * radius, offset, sin * radius);
            var textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);
            positions.push(circleVector.x, circleVector.y, circleVector.z);
            normals.push(0, isTop ? 1 : -1, 0);
            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, u.y + (u.w - u.y) * textureCoordinate.y);
            if (c) {
                colors.push(c.r, c.g, c.b, c.a);
            }
        }
        // Cap indices
        for (i = 0; i < tessellation; i++) {
            if (!isTop) {
                indices.push(vbase);
                indices.push(vbase + (i + 1));
                indices.push(vbase + (i + 2));
            }
            else {
                indices.push(vbase);
                indices.push(vbase + (i + 2));
                indices.push(vbase + (i + 1));
            }
        }
    };
    // add caps to geometry
    createCylinderCap(false);
    createCylinderCap(true);
    // Sides
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    if (faceColors) {
        vertexData.colors = colors;
    }
    return vertexData;
};
Mesh.CreateCylinder = function (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {
    if (scene === undefined || !(scene instanceof Scene)) {
        if (scene !== undefined) {
            sideOrientation = updatable || Mesh.DEFAULTSIDE;
            updatable = scene;
        }
        scene = subdivisions;
        subdivisions = 1;
    }
    var options = {
        height: height,
        diameterTop: diameterTop,
        diameterBottom: diameterBottom,
        tessellation: tessellation,
        subdivisions: subdivisions,
        sideOrientation: sideOrientation,
        updatable: updatable
    };
    return CylinderBuilder.CreateCylinder(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var CylinderBuilder = /** @class */ (function () {
    function CylinderBuilder() {
    }
    /**
     * Creates a cylinder or a cone mesh
     * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
     * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
     * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
     * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
     * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
     * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
     * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
     * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
     * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
     * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
     * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
     * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
     * * If `enclose` is false, a ring surface is one element.
     * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
     * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the cylinder mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone
     */
    CylinderBuilder.CreateCylinder = function (name, options, scene) {
        var cylinder = new Mesh(name, scene);
        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        cylinder._originalBuilderSideOrientation = options.sideOrientation;
        var vertexData = VertexData.CreateCylinder(options);
        vertexData.applyToMesh(cylinder, options.updatable);
        return cylinder;
    };
    return CylinderBuilder;
}());

var VRExperienceHelperGazer = /** @class */ (function () {
    function VRExperienceHelperGazer(scene, gazeTrackerToClone) {
        if (gazeTrackerToClone === void 0) { gazeTrackerToClone = null; }
        this.scene = scene;
        /** @hidden */
        this._pointerDownOnMeshAsked = false;
        /** @hidden */
        this._isActionableMesh = false;
        /** @hidden */
        this._teleportationRequestInitiated = false;
        /** @hidden */
        this._teleportationBackRequestInitiated = false;
        /** @hidden */
        this._rotationRightAsked = false;
        /** @hidden */
        this._rotationLeftAsked = false;
        /** @hidden */
        this._dpadPressed = true;
        /** @hidden */
        this._activePointer = false;
        this._id = VRExperienceHelperGazer._idCounter++;
        // Gaze tracker
        if (!gazeTrackerToClone) {
            this._gazeTracker = Mesh.CreateTorus("gazeTracker", 0.0035, 0.0025, 20, scene, false);
            this._gazeTracker.bakeCurrentTransformIntoVertices();
            this._gazeTracker.isPickable = false;
            this._gazeTracker.isVisible = false;
            var targetMat = new StandardMaterial("targetMat", scene);
            targetMat.specularColor = Color3.Black();
            targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);
            targetMat.backFaceCulling = false;
            this._gazeTracker.material = targetMat;
        }
        else {
            this._gazeTracker = gazeTrackerToClone.clone("gazeTracker");
        }
    }
    /** @hidden */
    VRExperienceHelperGazer.prototype._getForwardRay = function (length) {
        return new Ray(Vector3.Zero(), new Vector3(0, 0, length));
    };
    /** @hidden */
    VRExperienceHelperGazer.prototype._selectionPointerDown = function () {
        this._pointerDownOnMeshAsked = true;
        if (this._currentHit) {
            this.scene.simulatePointerDown(this._currentHit, { pointerId: this._id });
        }
    };
    /** @hidden */
    VRExperienceHelperGazer.prototype._selectionPointerUp = function () {
        if (this._currentHit) {
            this.scene.simulatePointerUp(this._currentHit, { pointerId: this._id });
        }
        this._pointerDownOnMeshAsked = false;
    };
    /** @hidden */
    VRExperienceHelperGazer.prototype._activatePointer = function () {
        this._activePointer = true;
    };
    /** @hidden */
    VRExperienceHelperGazer.prototype._deactivatePointer = function () {
        this._activePointer = false;
    };
    /** @hidden */
    VRExperienceHelperGazer.prototype._updatePointerDistance = function (distance) {
    };
    VRExperienceHelperGazer.prototype.dispose = function () {
        this._interactionsEnabled = false;
        this._teleportationEnabled = false;
        if (this._gazeTracker) {
            this._gazeTracker.dispose();
        }
    };
    VRExperienceHelperGazer._idCounter = 0;
    return VRExperienceHelperGazer;
}());
var VRExperienceHelperControllerGazer = /** @class */ (function (_super) {
    __extends(VRExperienceHelperControllerGazer, _super);
    function VRExperienceHelperControllerGazer(webVRController, scene, gazeTrackerToClone) {
        var _this = _super.call(this, scene, gazeTrackerToClone) || this;
        _this.webVRController = webVRController;
        // Laser pointer
        _this._laserPointer = Mesh.CreateCylinder("laserPointer", 1, 0.004, 0.0002, 20, 1, scene, false);
        var laserPointerMaterial = new StandardMaterial("laserPointerMat", scene);
        laserPointerMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);
        laserPointerMaterial.alpha = 0.6;
        _this._laserPointer.material = laserPointerMaterial;
        _this._laserPointer.rotation.x = Math.PI / 2;
        _this._laserPointer.position.z = -0.5;
        _this._laserPointer.isVisible = false;
        _this._laserPointer.isPickable = false;
        if (!webVRController.mesh) {
            // Create an empty mesh that is used prior to loading the high quality model
            var preloadMesh = new Mesh("preloadControllerMesh", scene);
            var preloadPointerPose = new Mesh(PoseEnabledController.POINTING_POSE, scene);
            preloadPointerPose.rotation.x = -0.7;
            preloadMesh.addChild(preloadPointerPose);
            webVRController.attachToMesh(preloadMesh);
        }
        _this._setLaserPointerParent(webVRController.mesh);
        _this._meshAttachedObserver = webVRController._meshAttachedObservable.add(function (mesh) {
            _this._setLaserPointerParent(mesh);
        });
        return _this;
    }
    VRExperienceHelperControllerGazer.prototype._getForwardRay = function (length) {
        return this.webVRController.getForwardRay(length);
    };
    /** @hidden */
    VRExperienceHelperControllerGazer.prototype._activatePointer = function () {
        _super.prototype._activatePointer.call(this);
        this._laserPointer.isVisible = true;
    };
    /** @hidden */
    VRExperienceHelperControllerGazer.prototype._deactivatePointer = function () {
        _super.prototype._deactivatePointer.call(this);
        this._laserPointer.isVisible = false;
    };
    /** @hidden */
    VRExperienceHelperControllerGazer.prototype._setLaserPointerColor = function (color) {
        this._laserPointer.material.emissiveColor = color;
    };
    /** @hidden */
    VRExperienceHelperControllerGazer.prototype._setLaserPointerParent = function (mesh) {
        var makeNotPick = function (root) {
            root.isPickable = false;
            root.getChildMeshes().forEach(function (c) {
                makeNotPick(c);
            });
        };
        makeNotPick(mesh);
        var meshChildren = mesh.getChildren(undefined, false);
        var laserParent = mesh;
        this.webVRController._pointingPoseNode = null;
        for (var i = 0; i < meshChildren.length; i++) {
            if (meshChildren[i].name && meshChildren[i].name.indexOf(PoseEnabledController.POINTING_POSE) >= 0) {
                laserParent = meshChildren[i];
                this.webVRController._pointingPoseNode = laserParent;
                break;
            }
        }
        this._laserPointer.parent = laserParent;
    };
    VRExperienceHelperControllerGazer.prototype._updatePointerDistance = function (distance) {
        if (distance === void 0) { distance = 100; }
        this._laserPointer.scaling.y = distance;
        this._laserPointer.position.z = -distance / 2;
    };
    VRExperienceHelperControllerGazer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._laserPointer.dispose();
        if (this._meshAttachedObserver) {
            this.webVRController._meshAttachedObservable.remove(this._meshAttachedObserver);
        }
    };
    return VRExperienceHelperControllerGazer;
}(VRExperienceHelperGazer));
var VRExperienceHelperCameraGazer = /** @class */ (function (_super) {
    __extends(VRExperienceHelperCameraGazer, _super);
    function VRExperienceHelperCameraGazer(getCamera, scene) {
        var _this = _super.call(this, scene) || this;
        _this.getCamera = getCamera;
        return _this;
    }
    VRExperienceHelperCameraGazer.prototype._getForwardRay = function (length) {
        var camera = this.getCamera();
        if (camera) {
            return camera.getForwardRay(length);
        }
        else {
            return new Ray(Vector3.Zero(), Vector3.Forward());
        }
    };
    return VRExperienceHelperCameraGazer;
}(VRExperienceHelperGazer));
/**
 * Event containing information after VR has been entered
 */
var OnAfterEnteringVRObservableEvent = /** @class */ (function () {
    function OnAfterEnteringVRObservableEvent() {
    }
    return OnAfterEnteringVRObservableEvent;
}());
/**
 * Helps to quickly add VR support to an existing scene.
 * See http://doc.babylonjs.com/how_to/webvr_helper
 */
var VRExperienceHelper = /** @class */ (function () {
    /**
     * Instantiates a VRExperienceHelper.
     * Helps to quickly add VR support to an existing scene.
     * @param scene The scene the VRExperienceHelper belongs to.
     * @param webVROptions Options to modify the vr experience helper's behavior.
     */
    function VRExperienceHelper(scene, 
    /** Options to modify the vr experience helper's behavior. */
    webVROptions) {
        var _this = this;
        if (webVROptions === void 0) { webVROptions = {}; }
        this.webVROptions = webVROptions;
        // Can the system support WebVR, even if a headset isn't plugged in?
        this._webVRsupported = false;
        // If WebVR is supported, is a headset plugged in and are we ready to present?
        this._webVRready = false;
        // Are we waiting for the requestPresent callback to complete?
        this._webVRrequesting = false;
        // Are we presenting to the headset right now? (this is the vrDevice state)
        this._webVRpresenting = false;
        // Are we presenting in the fullscreen fallback?
        this._fullscreenVRpresenting = false;
        /**
         * Observable raised right before entering VR.
         */
        this.onEnteringVRObservable = new Observable();
        /**
         * Observable raised when entering VR has completed.
         */
        this.onAfterEnteringVRObservable = new Observable();
        /**
         * Observable raised when exiting VR.
         */
        this.onExitingVRObservable = new Observable();
        /**
         * Observable raised when controller mesh is loaded.
         */
        this.onControllerMeshLoadedObservable = new Observable();
        this._useCustomVRButton = false;
        this._teleportationRequested = false;
        this._teleportActive = false;
        this._floorMeshesCollection = [];
        this._rotationAllowed = true;
        this._teleportBackwardsVector = new Vector3(0, -1, -1);
        this._isDefaultTeleportationTarget = true;
        this._teleportationFillColor = "#444444";
        this._teleportationBorderColor = "#FFFFFF";
        this._rotationAngle = 0;
        this._haloCenter = new Vector3(0, 0, 0);
        this._padSensibilityUp = 0.65;
        this._padSensibilityDown = 0.35;
        this._leftController = null;
        this._rightController = null;
        /**
         * Observable raised when a new mesh is selected based on meshSelectionPredicate
         */
        this.onNewMeshSelected = new Observable();
        /**
         * Observable raised when a new mesh is picked based on meshSelectionPredicate
         */
        this.onNewMeshPicked = new Observable();
        /**
         * Observable raised before camera teleportation
        */
        this.onBeforeCameraTeleport = new Observable();
        /**
         *  Observable raised after camera teleportation
        */
        this.onAfterCameraTeleport = new Observable();
        /**
        * Observable raised when current selected mesh gets unselected
        */
        this.onSelectedMeshUnselected = new Observable();
        /**
         * Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.
         */
        this.teleportationEnabled = true;
        this._teleportationInitialized = false;
        this._interactionsEnabled = false;
        this._interactionsRequested = false;
        this._displayGaze = true;
        this._displayLaserPointer = true;
        /**
         * If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes
         */
        this.updateGazeTrackerScale = true;
        /**
         * If the gaze trackers color should be updated when selecting meshes
         */
        this.updateGazeTrackerColor = true;
        /**
         * Defines wether or not Pointer lock should be requested when switching to
         * full screen.
         */
        this.requestPointerLockOnFullScreen = true;
        this._onResize = function () {
            _this.moveButtonToBottomRight();
            if (_this._fullscreenVRpresenting && _this._webVRready) {
                _this.exitVR();
            }
        };
        this._onFullscreenChange = function () {
            var anyDoc = document;
            if (anyDoc.fullscreen !== undefined) {
                _this._fullscreenVRpresenting = document.fullscreen;
            }
            else if (anyDoc.mozFullScreen !== undefined) {
                _this._fullscreenVRpresenting = anyDoc.mozFullScreen;
            }
            else if (anyDoc.webkitIsFullScreen !== undefined) {
                _this._fullscreenVRpresenting = anyDoc.webkitIsFullScreen;
            }
            else if (anyDoc.msIsFullScreen !== undefined) {
                _this._fullscreenVRpresenting = anyDoc.msIsFullScreen;
            }
            else if (document.msFullscreenElement !== undefined) {
                _this._fullscreenVRpresenting = document.msFullscreenElement;
            }
            if (!_this._fullscreenVRpresenting && _this._canvas) {
                _this.exitVR();
                if (!_this._useCustomVRButton) {
                    _this._btnVR.style.top = _this._canvas.offsetTop + _this._canvas.offsetHeight - 70 + "px";
                    _this._btnVR.style.left = _this._canvas.offsetLeft + _this._canvas.offsetWidth - 100 + "px";
                }
            }
        };
        this._cachedAngularSensibility = { angularSensibilityX: null, angularSensibilityY: null, angularSensibility: null };
        this.beforeRender = function () {
            if (_this._leftController && _this._leftController._activePointer) {
                _this._castRayAndSelectObject(_this._leftController);
            }
            if (_this._rightController && _this._rightController._activePointer) {
                _this._castRayAndSelectObject(_this._rightController);
            }
            if (_this._noControllerIsActive) {
                _this._castRayAndSelectObject(_this._cameraGazer);
            }
            else {
                _this._cameraGazer._gazeTracker.isVisible = false;
            }
        };
        this._onNewGamepadConnected = function (gamepad) {
            if (gamepad.type !== Gamepad.POSE_ENABLED) {
                if (gamepad.leftStick) {
                    gamepad.onleftstickchanged(function (stickValues) {
                        if (_this._teleportationInitialized && _this.teleportationEnabled) {
                            // Listening to classic/xbox gamepad only if no VR controller is active
                            if ((!_this._leftController && !_this._rightController) ||
                                ((_this._leftController && !_this._leftController._activePointer) &&
                                    (_this._rightController && !_this._rightController._activePointer))) {
                                _this._checkTeleportWithRay(stickValues, _this._cameraGazer);
                                _this._checkTeleportBackwards(stickValues, _this._cameraGazer);
                            }
                        }
                    });
                }
                if (gamepad.rightStick) {
                    gamepad.onrightstickchanged(function (stickValues) {
                        if (_this._teleportationInitialized) {
                            _this._checkRotate(stickValues, _this._cameraGazer);
                        }
                    });
                }
                if (gamepad.type === Gamepad.XBOX) {
                    gamepad.onbuttondown(function (buttonPressed) {
                        if (_this._interactionsEnabled && buttonPressed === Xbox360Button.A) {
                            _this._cameraGazer._selectionPointerDown();
                        }
                    });
                    gamepad.onbuttonup(function (buttonPressed) {
                        if (_this._interactionsEnabled && buttonPressed === Xbox360Button.A) {
                            _this._cameraGazer._selectionPointerUp();
                        }
                    });
                }
            }
            else {
                var webVRController = gamepad;
                var controller = new VRExperienceHelperControllerGazer(webVRController, _this._scene, _this._cameraGazer._gazeTracker);
                if (webVRController.hand === "right" || (_this._leftController && _this._leftController.webVRController != webVRController)) {
                    _this._rightController = controller;
                }
                else {
                    _this._leftController = controller;
                }
                _this._tryEnableInteractionOnController(controller);
            }
        };
        // This only succeeds if the controller's mesh exists for the controller so this must be called whenever new controller is connected or when mesh is loaded
        this._tryEnableInteractionOnController = function (controller) {
            if (_this._interactionsRequested && !controller._interactionsEnabled) {
                _this._enableInteractionOnController(controller);
            }
            if (_this._teleportationRequested && !controller._teleportationEnabled) {
                _this._enableTeleportationOnController(controller);
            }
        };
        this._onNewGamepadDisconnected = function (gamepad) {
            if (gamepad instanceof WebVRController) {
                if (gamepad.hand === "left" && _this._leftController != null) {
                    _this._leftController.dispose();
                    _this._leftController = null;
                }
                if (gamepad.hand === "right" && _this._rightController != null) {
                    _this._rightController.dispose();
                    _this._rightController = null;
                }
            }
        };
        this._workingVector = Vector3.Zero();
        this._workingQuaternion = Quaternion.Identity();
        this._workingMatrix = Matrix.Identity();
        this._scene = scene;
        this._canvas = scene.getEngine().getRenderingCanvas();
        // Parse options
        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera === undefined) {
            webVROptions.createFallbackVRDeviceOrientationFreeCamera = true;
        }
        if (webVROptions.createDeviceOrientationCamera === undefined) {
            webVROptions.createDeviceOrientationCamera = true;
        }
        if (webVROptions.laserToggle === undefined) {
            webVROptions.laserToggle = true;
        }
        if (webVROptions.defaultHeight === undefined) {
            webVROptions.defaultHeight = 1.7;
        }
        if (webVROptions.useCustomVRButton) {
            this._useCustomVRButton = true;
            if (webVROptions.customVRButton) {
                this._btnVR = webVROptions.customVRButton;
            }
        }
        if (webVROptions.rayLength) {
            this._rayLength = webVROptions.rayLength;
        }
        this._defaultHeight = webVROptions.defaultHeight;
        if (webVROptions.positionScale) {
            this._rayLength *= webVROptions.positionScale;
            this._defaultHeight *= webVROptions.positionScale;
        }
        this._hasEnteredVR = false;
        // Set position
        if (this._scene.activeCamera) {
            this._position = this._scene.activeCamera.position.clone();
        }
        else {
            this._position = new Vector3(0, this._defaultHeight, 0);
        }
        // Set non-vr camera
        if (webVROptions.createDeviceOrientationCamera || !this._scene.activeCamera) {
            this._deviceOrientationCamera = new DeviceOrientationCamera("deviceOrientationVRHelper", this._position.clone(), scene);
            // Copy data from existing camera
            if (this._scene.activeCamera) {
                this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ;
                this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ;
                // Set rotation from previous camera
                if (this._scene.activeCamera instanceof TargetCamera && this._scene.activeCamera.rotation) {
                    var targetCamera = this._scene.activeCamera;
                    if (targetCamera.rotationQuaternion) {
                        this._deviceOrientationCamera.rotationQuaternion.copyFrom(targetCamera.rotationQuaternion);
                    }
                    else {
                        this._deviceOrientationCamera.rotationQuaternion.copyFrom(Quaternion.RotationYawPitchRoll(targetCamera.rotation.y, targetCamera.rotation.x, targetCamera.rotation.z));
                    }
                    this._deviceOrientationCamera.rotation = targetCamera.rotation.clone();
                }
            }
            this._scene.activeCamera = this._deviceOrientationCamera;
            if (this._canvas) {
                this._scene.activeCamera.attachControl(this._canvas);
            }
        }
        else {
            this._existingCamera = this._scene.activeCamera;
        }
        // Create VR cameras
        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {
            if (webVROptions.useMultiview) {
                if (!webVROptions.vrDeviceOrientationCameraMetrics) {
                    webVROptions.vrDeviceOrientationCameraMetrics = VRCameraMetrics.GetDefault();
                }
                webVROptions.vrDeviceOrientationCameraMetrics.multiviewEnabled = true;
            }
            this._vrDeviceOrientationCamera = new VRDeviceOrientationFreeCamera("VRDeviceOrientationVRHelper", this._position, this._scene, true, webVROptions.vrDeviceOrientationCameraMetrics);
            this._vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;
        }
        this._webVRCamera = new WebVRFreeCamera("WebVRHelper", this._position, this._scene, webVROptions);
        this._webVRCamera.useStandingMatrix();
        this._cameraGazer = new VRExperienceHelperCameraGazer(function () { return _this.currentVRCamera; }, scene);
        // Create default button
        if (!this._useCustomVRButton) {
            this._btnVR = document.createElement("BUTTON");
            this._btnVR.className = "babylonVRicon";
            this._btnVR.id = "babylonVRiconbtn";
            this._btnVR.title = "Click to switch to VR";
            var css = ".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }";
            css += ".babylonVRicon.vrdisplaypresenting { display: none; }";
            // TODO: Add user feedback so that they know what state the VRDisplay is in (disconnected, connected, entering-VR)
            // css += ".babylonVRicon.vrdisplaysupported { }";
            // css += ".babylonVRicon.vrdisplayready { }";
            // css += ".babylonVRicon.vrdisplayrequesting { }";
            var style = document.createElement('style');
            style.appendChild(document.createTextNode(css));
            document.getElementsByTagName('head')[0].appendChild(style);
            this.moveButtonToBottomRight();
        }
        // VR button click event
        if (this._btnVR) {
            this._btnVR.addEventListener("click", function () {
                if (!_this.isInVRMode) {
                    _this.enterVR();
                }
                else {
                    _this.exitVR();
                }
            });
        }
        // Window events
        window.addEventListener("resize", this._onResize);
        document.addEventListener("fullscreenchange", this._onFullscreenChange, false);
        document.addEventListener("mozfullscreenchange", this._onFullscreenChange, false);
        document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, false);
        document.addEventListener("msfullscreenchange", this._onFullscreenChange, false);
        document.onmsfullscreenchange = this._onFullscreenChange;
        // Display vr button when headset is connected
        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {
            this.displayVRButton();
        }
        else {
            this._scene.getEngine().onVRDisplayChangedObservable.add(function (e) {
                if (e.vrDisplay) {
                    _this.displayVRButton();
                }
            });
        }
        // Exiting VR mode using 'ESC' key on desktop
        this._onKeyDown = function (event) {
            if (event.keyCode === 27 && _this.isInVRMode) {
                _this.exitVR();
            }
        };
        document.addEventListener("keydown", this._onKeyDown);
        // Exiting VR mode double tapping the touch screen
        this._scene.onPrePointerObservable.add(function () {
            if (_this.isInVRMode) {
                _this.exitVR();
                if (_this._fullscreenVRpresenting) {
                    _this._scene.getEngine().exitFullscreen();
                }
            }
        }, PointerEventTypes.POINTERDOUBLETAP, false);
        // Listen for WebVR display changes
        this._onVRDisplayChanged = function (eventArgs) { return _this.onVRDisplayChanged(eventArgs); };
        this._onVrDisplayPresentChange = function () { return _this.onVrDisplayPresentChange(); };
        this._onVRRequestPresentStart = function () {
            _this._webVRrequesting = true;
            _this.updateButtonVisibility();
        };
        this._onVRRequestPresentComplete = function () {
            _this._webVRrequesting = false;
            _this.updateButtonVisibility();
        };
        scene.getEngine().onVRDisplayChangedObservable.add(this._onVRDisplayChanged);
        scene.getEngine().onVRRequestPresentStart.add(this._onVRRequestPresentStart);
        scene.getEngine().onVRRequestPresentComplete.add(this._onVRRequestPresentComplete);
        window.addEventListener('vrdisplaypresentchange', this._onVrDisplayPresentChange);
        scene.onDisposeObservable.add(function () {
            _this.dispose();
        });
        // Gamepad connection events
        this._webVRCamera.onControllerMeshLoadedObservable.add(function (webVRController) { return _this._onDefaultMeshLoaded(webVRController); });
        this._scene.gamepadManager.onGamepadConnectedObservable.add(this._onNewGamepadConnected);
        this._scene.gamepadManager.onGamepadDisconnectedObservable.add(this._onNewGamepadDisconnected);
        this.updateButtonVisibility();
        //create easing functions
        this._circleEase = new CircleEase();
        this._circleEase.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
        if (this.webVROptions.floorMeshes) {
            this.enableTeleportation({ floorMeshes: this.webVROptions.floorMeshes });
        }
    }
    Object.defineProperty(VRExperienceHelper.prototype, "onEnteringVR", {
        /** Return this.onEnteringVRObservable
         * Note: This one is for backward compatibility. Please use onEnteringVRObservable directly
         */
        get: function () {
            return this.onEnteringVRObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "onExitingVR", {
        /** Return this.onExitingVRObservable
         * Note: This one is for backward compatibility. Please use onExitingVRObservable directly
         */
        get: function () {
            return this.onExitingVRObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "onControllerMeshLoaded", {
        /** Return this.onControllerMeshLoadedObservable
         * Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly
         */
        get: function () {
            return this.onControllerMeshLoadedObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "teleportationTarget", {
        /**
         * The mesh used to display where the user is going to teleport.
         */
        get: function () {
            return this._teleportationTarget;
        },
        /**
         * Sets the mesh to be used to display where the user is going to teleport.
         */
        set: function (value) {
            if (value) {
                value.name = "teleportationTarget";
                this._isDefaultTeleportationTarget = false;
                this._teleportationTarget = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "gazeTrackerMesh", {
        /**
         * The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller
         * when set bakeCurrentTransformIntoVertices will be called on the mesh.
         * See http://doc.babylonjs.com/resources/baking_transformations
         */
        get: function () {
            return this._cameraGazer._gazeTracker;
        },
        set: function (value) {
            if (value) {
                // Dispose of existing meshes
                if (this._cameraGazer._gazeTracker) {
                    this._cameraGazer._gazeTracker.dispose();
                }
                if (this._leftController && this._leftController._gazeTracker) {
                    this._leftController._gazeTracker.dispose();
                }
                if (this._rightController && this._rightController._gazeTracker) {
                    this._rightController._gazeTracker.dispose();
                }
                // Set and create gaze trackers on head and controllers
                this._cameraGazer._gazeTracker = value;
                this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices();
                this._cameraGazer._gazeTracker.isPickable = false;
                this._cameraGazer._gazeTracker.isVisible = false;
                this._cameraGazer._gazeTracker.name = "gazeTracker";
                if (this._leftController) {
                    this._leftController._gazeTracker = this._cameraGazer._gazeTracker.clone("gazeTracker");
                }
                if (this._rightController) {
                    this._rightController._gazeTracker = this._cameraGazer._gazeTracker.clone("gazeTracker");
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "leftControllerGazeTrackerMesh", {
        /**
         * The gaze tracking mesh corresponding to the left controller
         */
        get: function () {
            if (this._leftController) {
                return this._leftController._gazeTracker;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "rightControllerGazeTrackerMesh", {
        /**
         * The gaze tracking mesh corresponding to the right controller
         */
        get: function () {
            if (this._rightController) {
                return this._rightController._gazeTracker;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "displayGaze", {
        /**
         * If the ray of the gaze should be displayed.
         */
        get: function () {
            return this._displayGaze;
        },
        /**
         * Sets if the ray of the gaze should be displayed.
         */
        set: function (value) {
            this._displayGaze = value;
            if (!value) {
                this._cameraGazer._gazeTracker.isVisible = false;
                if (this._leftController) {
                    this._leftController._gazeTracker.isVisible = false;
                }
                if (this._rightController) {
                    this._rightController._gazeTracker.isVisible = false;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "displayLaserPointer", {
        /**
         * If the ray of the LaserPointer should be displayed.
         */
        get: function () {
            return this._displayLaserPointer;
        },
        /**
         * Sets if the ray of the LaserPointer should be displayed.
         */
        set: function (value) {
            this._displayLaserPointer = value;
            if (!value) {
                if (this._rightController) {
                    this._rightController._deactivatePointer();
                    this._rightController._gazeTracker.isVisible = false;
                }
                if (this._leftController) {
                    this._leftController._deactivatePointer();
                    this._leftController._gazeTracker.isVisible = false;
                }
            }
            else {
                if (this._rightController) {
                    this._rightController._activatePointer();
                }
                if (this._leftController) {
                    this._leftController._activatePointer();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "deviceOrientationCamera", {
        /**
         * The deviceOrientationCamera used as the camera when not in VR.
         */
        get: function () {
            return this._deviceOrientationCamera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "currentVRCamera", {
        /**
         * Based on the current WebVR support, returns the current VR camera used.
         */
        get: function () {
            if (this._webVRready) {
                return this._webVRCamera;
            }
            else {
                return this._scene.activeCamera;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "webVRCamera", {
        /**
         * The webVRCamera which is used when in VR.
         */
        get: function () {
            return this._webVRCamera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "vrDeviceOrientationCamera", {
        /**
         * The deviceOrientationCamera that is used as a fallback when vr device is not connected.
         */
        get: function () {
            return this._vrDeviceOrientationCamera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VRExperienceHelper.prototype, "_teleportationRequestInitiated", {
        get: function () {
            var result = this._cameraGazer._teleportationRequestInitiated
                || (this._leftController !== null && this._leftController._teleportationRequestInitiated)
                || (this._rightController !== null && this._rightController._teleportationRequestInitiated);
            return result;
        },
        enumerable: true,
        configurable: true
    });
    // Raised when one of the controller has loaded successfully its associated default mesh
    VRExperienceHelper.prototype._onDefaultMeshLoaded = function (webVRController) {
        if (this._leftController && this._leftController.webVRController == webVRController) {
            if (webVRController.mesh) {
                this._leftController._setLaserPointerParent(webVRController.mesh);
            }
        }
        if (this._rightController && this._rightController.webVRController == webVRController) {
            if (webVRController.mesh) {
                this._rightController._setLaserPointerParent(webVRController.mesh);
            }
        }
        try {
            this.onControllerMeshLoadedObservable.notifyObservers(webVRController);
        }
        catch (err) {
            Logger.Warn("Error in your custom logic onControllerMeshLoaded: " + err);
        }
    };
    Object.defineProperty(VRExperienceHelper.prototype, "isInVRMode", {
        /**
         * Gets a value indicating if we are currently in VR mode.
         */
        get: function () {
            return this._webVRpresenting || this._fullscreenVRpresenting;
        },
        enumerable: true,
        configurable: true
    });
    VRExperienceHelper.prototype.onVrDisplayPresentChange = function () {
        var vrDisplay = this._scene.getEngine().getVRDevice();
        if (vrDisplay) {
            var wasPresenting = this._webVRpresenting;
            this._webVRpresenting = vrDisplay.isPresenting;
            if (wasPresenting && !this._webVRpresenting) {
                this.exitVR();
            }
        }
        else {
            Logger.Warn('Detected VRDisplayPresentChange on an unknown VRDisplay. Did you can enterVR on the vrExperienceHelper?');
        }
        this.updateButtonVisibility();
    };
    VRExperienceHelper.prototype.onVRDisplayChanged = function (eventArgs) {
        this._webVRsupported = eventArgs.vrSupported;
        this._webVRready = !!eventArgs.vrDisplay;
        this._webVRpresenting = eventArgs.vrDisplay && eventArgs.vrDisplay.isPresenting;
        this.updateButtonVisibility();
    };
    VRExperienceHelper.prototype.moveButtonToBottomRight = function () {
        if (this._canvas && !this._useCustomVRButton) {
            this._btnVR.style.top = this._canvas.offsetTop + this._canvas.offsetHeight - 70 + "px";
            this._btnVR.style.left = this._canvas.offsetLeft + this._canvas.offsetWidth - 100 + "px";
        }
    };
    VRExperienceHelper.prototype.displayVRButton = function () {
        if (!this._useCustomVRButton && !this._btnVRDisplayed) {
            document.body.appendChild(this._btnVR);
            this._btnVRDisplayed = true;
        }
    };
    VRExperienceHelper.prototype.updateButtonVisibility = function () {
        if (!this._btnVR || this._useCustomVRButton) {
            return;
        }
        this._btnVR.className = "babylonVRicon";
        if (this.isInVRMode) {
            this._btnVR.className += " vrdisplaypresenting";
        }
        else {
            if (this._webVRready) {
                this._btnVR.className += " vrdisplayready";
            }
            if (this._webVRsupported) {
                this._btnVR.className += " vrdisplaysupported";
            }
            if (this._webVRrequesting) {
                this._btnVR.className += " vrdisplayrequesting";
            }
        }
    };
    /**
     * Attempt to enter VR. If a headset is connected and ready, will request present on that.
     * Otherwise, will use the fullscreen API.
     */
    VRExperienceHelper.prototype.enterVR = function () {
        var _this = this;
        if (this.onEnteringVRObservable) {
            try {
                this.onEnteringVRObservable.notifyObservers(this);
            }
            catch (err) {
                Logger.Warn("Error in your custom logic onEnteringVR: " + err);
            }
        }
        if (this._scene.activeCamera) {
            this._position = this._scene.activeCamera.position.clone();
            if (this.vrDeviceOrientationCamera) {
                this.vrDeviceOrientationCamera.rotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles();
                this.vrDeviceOrientationCamera.angularSensibility = 2000;
            }
            if (this.webVRCamera) {
                var currentYRotation = this.webVRCamera.deviceRotationQuaternion.toEulerAngles().y;
                var desiredYRotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles().y;
                var delta = desiredYRotation - currentYRotation;
                var currentGlobalRotation = this.webVRCamera.rotationQuaternion.toEulerAngles().y;
                this.webVRCamera.rotationQuaternion = Quaternion.FromEulerAngles(0, currentGlobalRotation + delta, 0);
            }
            // make sure that we return to the last active camera
            this._existingCamera = this._scene.activeCamera;
            // Remove and cache angular sensability to avoid camera rotation when in VR
            if (this._existingCamera.angularSensibilityX) {
                this._cachedAngularSensibility.angularSensibilityX = this._existingCamera.angularSensibilityX;
                this._existingCamera.angularSensibilityX = Number.MAX_VALUE;
            }
            if (this._existingCamera.angularSensibilityY) {
                this._cachedAngularSensibility.angularSensibilityY = this._existingCamera.angularSensibilityY;
                this._existingCamera.angularSensibilityY = Number.MAX_VALUE;
            }
            if (this._existingCamera.angularSensibility) {
                this._cachedAngularSensibility.angularSensibility = this._existingCamera.angularSensibility;
                this._existingCamera.angularSensibility = Number.MAX_VALUE;
            }
        }
        if (this._webVRrequesting) {
            return;
        }
        // If WebVR is supported and a headset is connected
        if (this._webVRready) {
            if (!this._webVRpresenting) {
                this._scene.getEngine().onVRRequestPresentComplete.addOnce(function (result) {
                    _this.onAfterEnteringVRObservable.notifyObservers({ success: result });
                });
                this._webVRCamera.position = this._position;
                this._scene.activeCamera = this._webVRCamera;
            }
        }
        else if (this._vrDeviceOrientationCamera) {
            this._vrDeviceOrientationCamera.position = this._position;
            if (this._scene.activeCamera) {
                this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ;
            }
            this._scene.activeCamera = this._vrDeviceOrientationCamera;
            this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen);
            this.updateButtonVisibility();
            this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(function () {
                _this.onAfterEnteringVRObservable.notifyObservers({ success: true });
            });
        }
        if (this._scene.activeCamera && this._canvas) {
            this._scene.activeCamera.attachControl(this._canvas);
        }
        if (this._interactionsEnabled) {
            this._scene.registerBeforeRender(this.beforeRender);
        }
        if (this._displayLaserPointer) {
            [this._leftController, this._rightController].forEach(function (controller) {
                if (controller) {
                    controller._activatePointer();
                }
            });
        }
        this._hasEnteredVR = true;
    };
    /**
     * Attempt to exit VR, or fullscreen.
     */
    VRExperienceHelper.prototype.exitVR = function () {
        if (this._hasEnteredVR) {
            if (this.onExitingVRObservable) {
                try {
                    this.onExitingVRObservable.notifyObservers(this);
                }
                catch (err) {
                    Logger.Warn("Error in your custom logic onExitingVR: " + err);
                }
            }
            if (this._webVRpresenting) {
                this._scene.getEngine().disableVR();
            }
            if (this._scene.activeCamera) {
                this._position = this._scene.activeCamera.position.clone();
            }
            if (this.vrDeviceOrientationCamera) {
                this.vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;
            }
            if (this._deviceOrientationCamera) {
                this._deviceOrientationCamera.position = this._position;
                this._scene.activeCamera = this._deviceOrientationCamera;
                if (this._canvas) {
                    this._scene.activeCamera.attachControl(this._canvas);
                }
                // Restore angular sensibility
                if (this._cachedAngularSensibility.angularSensibilityX) {
                    this._deviceOrientationCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;
                    this._cachedAngularSensibility.angularSensibilityX = null;
                }
                if (this._cachedAngularSensibility.angularSensibilityY) {
                    this._deviceOrientationCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;
                    this._cachedAngularSensibility.angularSensibilityY = null;
                }
                if (this._cachedAngularSensibility.angularSensibility) {
                    this._deviceOrientationCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;
                    this._cachedAngularSensibility.angularSensibility = null;
                }
            }
            else if (this._existingCamera) {
                this._existingCamera.position = this._position;
                this._scene.activeCamera = this._existingCamera;
                // Restore angular sensibility
                if (this._cachedAngularSensibility.angularSensibilityX) {
                    this._existingCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;
                    this._cachedAngularSensibility.angularSensibilityX = null;
                }
                if (this._cachedAngularSensibility.angularSensibilityY) {
                    this._existingCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;
                    this._cachedAngularSensibility.angularSensibilityY = null;
                }
                if (this._cachedAngularSensibility.angularSensibility) {
                    this._existingCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;
                    this._cachedAngularSensibility.angularSensibility = null;
                }
            }
            this.updateButtonVisibility();
            if (this._interactionsEnabled) {
                this._scene.unregisterBeforeRender(this.beforeRender);
                this._cameraGazer._gazeTracker.isVisible = false;
                if (this._leftController) {
                    this._leftController._gazeTracker.isVisible = false;
                }
                if (this._rightController) {
                    this._rightController._gazeTracker.isVisible = false;
                }
            }
            // resize to update width and height when exiting vr exits fullscreen
            this._scene.getEngine().resize();
            [this._leftController, this._rightController].forEach(function (controller) {
                if (controller) {
                    controller._deactivatePointer();
                }
            });
            this._hasEnteredVR = false;
            // Update engine state to re enable non-vr camera input
            var engine = this._scene.getEngine();
            if (engine._onVrDisplayPresentChange) {
                engine._onVrDisplayPresentChange();
            }
        }
    };
    Object.defineProperty(VRExperienceHelper.prototype, "position", {
        /**
         * The position of the vr experience helper.
         */
        get: function () {
            return this._position;
        },
        /**
         * Sets the position of the vr experience helper.
         */
        set: function (value) {
            this._position = value;
            if (this._scene.activeCamera) {
                this._scene.activeCamera.position = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Enables controllers and user interactions such as selecting and object or clicking on an object.
     */
    VRExperienceHelper.prototype.enableInteractions = function () {
        var _this = this;
        if (!this._interactionsEnabled) {
            this._interactionsRequested = true;
            if (this._leftController) {
                this._enableInteractionOnController(this._leftController);
            }
            if (this._rightController) {
                this._enableInteractionOnController(this._rightController);
            }
            this.raySelectionPredicate = function (mesh) {
                return mesh.isVisible && (mesh.isPickable || mesh.name === _this._floorMeshName);
            };
            this.meshSelectionPredicate = function () {
                return true;
            };
            this._raySelectionPredicate = function (mesh) {
                if (_this._isTeleportationFloor(mesh) || (mesh.name.indexOf("gazeTracker") === -1
                    && mesh.name.indexOf("teleportationTarget") === -1
                    && mesh.name.indexOf("torusTeleportation") === -1)) {
                    return _this.raySelectionPredicate(mesh);
                }
                return false;
            };
            this._interactionsEnabled = true;
        }
    };
    Object.defineProperty(VRExperienceHelper.prototype, "_noControllerIsActive", {
        get: function () {
            return !(this._leftController && this._leftController._activePointer) && !(this._rightController && this._rightController._activePointer);
        },
        enumerable: true,
        configurable: true
    });
    VRExperienceHelper.prototype._isTeleportationFloor = function (mesh) {
        for (var i = 0; i < this._floorMeshesCollection.length; i++) {
            if (this._floorMeshesCollection[i].id === mesh.id) {
                return true;
            }
        }
        if (this._floorMeshName && mesh.name === this._floorMeshName) {
            return true;
        }
        return false;
    };
    /**
     * Adds a floor mesh to be used for teleportation.
     * @param floorMesh the mesh to be used for teleportation.
     */
    VRExperienceHelper.prototype.addFloorMesh = function (floorMesh) {
        if (!this._floorMeshesCollection) {
            return;
        }
        if (this._floorMeshesCollection.indexOf(floorMesh) > -1) {
            return;
        }
        this._floorMeshesCollection.push(floorMesh);
    };
    /**
     * Removes a floor mesh from being used for teleportation.
     * @param floorMesh the mesh to be removed.
     */
    VRExperienceHelper.prototype.removeFloorMesh = function (floorMesh) {
        if (!this._floorMeshesCollection) {
            return;
        }
        var meshIndex = this._floorMeshesCollection.indexOf(floorMesh);
        if (meshIndex !== -1) {
            this._floorMeshesCollection.splice(meshIndex, 1);
        }
    };
    /**
     * Enables interactions and teleportation using the VR controllers and gaze.
     * @param vrTeleportationOptions options to modify teleportation behavior.
     */
    VRExperienceHelper.prototype.enableTeleportation = function (vrTeleportationOptions) {
        if (vrTeleportationOptions === void 0) { vrTeleportationOptions = {}; }
        if (!this._teleportationInitialized) {
            this._teleportationRequested = true;
            this.enableInteractions();
            if (vrTeleportationOptions.floorMeshName) {
                this._floorMeshName = vrTeleportationOptions.floorMeshName;
            }
            if (vrTeleportationOptions.floorMeshes) {
                this._floorMeshesCollection = vrTeleportationOptions.floorMeshes;
            }
            if (this._leftController != null) {
                this._enableTeleportationOnController(this._leftController);
            }
            if (this._rightController != null) {
                this._enableTeleportationOnController(this._rightController);
            }
            // Creates an image processing post process for the vignette not relying
            // on the main scene configuration for image processing to reduce setup and spaces
            // (gamma/linear) conflicts.
            var imageProcessingConfiguration = new ImageProcessingConfiguration();
            imageProcessingConfiguration.vignetteColor = new Color4(0, 0, 0, 0);
            imageProcessingConfiguration.vignetteEnabled = true;
            this._postProcessMove = new ImageProcessingPostProcess("postProcessMove", 1.0, this._webVRCamera, undefined, undefined, undefined, undefined, imageProcessingConfiguration);
            this._webVRCamera.detachPostProcess(this._postProcessMove);
            this._teleportationInitialized = true;
            if (this._isDefaultTeleportationTarget) {
                this._createTeleportationCircles();
                this._teleportationTarget.scaling.scaleInPlace(this._webVRCamera.deviceScaleFactor);
            }
        }
    };
    VRExperienceHelper.prototype._enableInteractionOnController = function (controller) {
        var _this = this;
        var controllerMesh = controller.webVRController.mesh;
        if (controllerMesh) {
            controller._interactionsEnabled = true;
            if (this.isInVRMode && this._displayLaserPointer) {
                controller._activatePointer();
            }
            if (this.webVROptions.laserToggle) {
                controller.webVRController.onMainButtonStateChangedObservable.add(function (stateObject) {
                    // Enabling / disabling laserPointer
                    if (_this._displayLaserPointer && stateObject.value === 1) {
                        if (controller._activePointer) {
                            controller._deactivatePointer();
                        }
                        else {
                            controller._activatePointer();
                        }
                        if (_this.displayGaze) {
                            controller._gazeTracker.isVisible = controller._activePointer;
                        }
                    }
                });
            }
            controller.webVRController.onTriggerStateChangedObservable.add(function (stateObject) {
                var gazer = controller;
                if (_this._noControllerIsActive) {
                    gazer = _this._cameraGazer;
                }
                if (!gazer._pointerDownOnMeshAsked) {
                    if (stateObject.value > _this._padSensibilityUp) {
                        gazer._selectionPointerDown();
                    }
                }
                else if (stateObject.value < _this._padSensibilityDown) {
                    gazer._selectionPointerUp();
                }
            });
        }
    };
    VRExperienceHelper.prototype._checkTeleportWithRay = function (stateObject, gazer) {
        // Dont teleport if another gaze already requested teleportation
        if (this._teleportationRequestInitiated && !gazer._teleportationRequestInitiated) {
            return;
        }
        if (!gazer._teleportationRequestInitiated) {
            if (stateObject.y < -this._padSensibilityUp && gazer._dpadPressed) {
                gazer._activatePointer();
                gazer._teleportationRequestInitiated = true;
            }
        }
        else {
            // Listening to the proper controller values changes to confirm teleportation
            if (Math.sqrt(stateObject.y * stateObject.y + stateObject.x * stateObject.x) < this._padSensibilityDown) {
                if (this._teleportActive) {
                    this.teleportCamera(this._haloCenter);
                }
                gazer._teleportationRequestInitiated = false;
            }
        }
    };
    VRExperienceHelper.prototype._checkRotate = function (stateObject, gazer) {
        // Only rotate when user is not currently selecting a teleportation location
        if (gazer._teleportationRequestInitiated) {
            return;
        }
        if (!gazer._rotationLeftAsked) {
            if (stateObject.x < -this._padSensibilityUp && gazer._dpadPressed) {
                gazer._rotationLeftAsked = true;
                if (this._rotationAllowed) {
                    this._rotateCamera(false);
                }
            }
        }
        else {
            if (stateObject.x > -this._padSensibilityDown) {
                gazer._rotationLeftAsked = false;
            }
        }
        if (!gazer._rotationRightAsked) {
            if (stateObject.x > this._padSensibilityUp && gazer._dpadPressed) {
                gazer._rotationRightAsked = true;
                if (this._rotationAllowed) {
                    this._rotateCamera(true);
                }
            }
        }
        else {
            if (stateObject.x < this._padSensibilityDown) {
                gazer._rotationRightAsked = false;
            }
        }
    };
    VRExperienceHelper.prototype._checkTeleportBackwards = function (stateObject, gazer) {
        // Only teleport backwards when user is not currently selecting a teleportation location
        if (gazer._teleportationRequestInitiated) {
            return;
        }
        // Teleport backwards
        if (stateObject.y > this._padSensibilityUp && gazer._dpadPressed) {
            if (!gazer._teleportationBackRequestInitiated) {
                if (!this.currentVRCamera) {
                    return;
                }
                // Get rotation and position of the current camera
                var rotation = Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix());
                var position = this.currentVRCamera.position;
                // If the camera has device position, use that instead
                if (this.currentVRCamera.devicePosition && this.currentVRCamera.deviceRotationQuaternion) {
                    rotation = this.currentVRCamera.deviceRotationQuaternion;
                    position = this.currentVRCamera.devicePosition;
                }
                // Get matrix with only the y rotation of the device rotation
                rotation.toEulerAnglesToRef(this._workingVector);
                this._workingVector.z = 0;
                this._workingVector.x = 0;
                Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion);
                this._workingQuaternion.toRotationMatrix(this._workingMatrix);
                // Rotate backwards ray by device rotation to cast at the ground behind the user
                Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector);
                // Teleport if ray hit the ground and is not to far away eg. backwards off a cliff
                var ray = new Ray(position, this._workingVector);
                var hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);
                if (hit && hit.pickedPoint && hit.pickedMesh && this._isTeleportationFloor(hit.pickedMesh) && hit.distance < 5) {
                    this.teleportCamera(hit.pickedPoint);
                }
                gazer._teleportationBackRequestInitiated = true;
            }
        }
        else {
            gazer._teleportationBackRequestInitiated = false;
        }
    };
    VRExperienceHelper.prototype._enableTeleportationOnController = function (controller) {
        var _this = this;
        var controllerMesh = controller.webVRController.mesh;
        if (controllerMesh) {
            if (!controller._interactionsEnabled) {
                this._enableInteractionOnController(controller);
            }
            controller._interactionsEnabled = true;
            controller._teleportationEnabled = true;
            if (controller.webVRController.controllerType === PoseEnabledControllerType.VIVE) {
                controller._dpadPressed = false;
                controller.webVRController.onPadStateChangedObservable.add(function (stateObject) {
                    controller._dpadPressed = stateObject.pressed;
                    if (!controller._dpadPressed) {
                        controller._rotationLeftAsked = false;
                        controller._rotationRightAsked = false;
                        controller._teleportationBackRequestInitiated = false;
                    }
                });
            }
            controller.webVRController.onPadValuesChangedObservable.add(function (stateObject) {
                if (_this.teleportationEnabled) {
                    _this._checkTeleportBackwards(stateObject, controller);
                    _this._checkTeleportWithRay(stateObject, controller);
                }
                _this._checkRotate(stateObject, controller);
            });
        }
    };
    VRExperienceHelper.prototype._createTeleportationCircles = function () {
        this._teleportationTarget = Mesh.CreateGround("teleportationTarget", 2, 2, 2, this._scene);
        this._teleportationTarget.isPickable = false;
        var length = 512;
        var dynamicTexture = new DynamicTexture("DynamicTexture", length, this._scene, true);
        dynamicTexture.hasAlpha = true;
        var context = dynamicTexture.getContext();
        var centerX = length / 2;
        var centerY = length / 2;
        var radius = 200;
        context.beginPath();
        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
        context.fillStyle = this._teleportationFillColor;
        context.fill();
        context.lineWidth = 10;
        context.strokeStyle = this._teleportationBorderColor;
        context.stroke();
        context.closePath();
        dynamicTexture.update();
        var teleportationCircleMaterial = new StandardMaterial("TextPlaneMaterial", this._scene);
        teleportationCircleMaterial.diffuseTexture = dynamicTexture;
        this._teleportationTarget.material = teleportationCircleMaterial;
        var torus = Mesh.CreateTorus("torusTeleportation", 0.75, 0.1, 25, this._scene, false);
        torus.isPickable = false;
        torus.parent = this._teleportationTarget;
        var animationInnerCircle = new Animation("animationInnerCircle", "position.y", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
        var keys = [];
        keys.push({
            frame: 0,
            value: 0
        });
        keys.push({
            frame: 30,
            value: 0.4
        });
        keys.push({
            frame: 60,
            value: 0
        });
        animationInnerCircle.setKeys(keys);
        var easingFunction = new SineEase();
        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
        animationInnerCircle.setEasingFunction(easingFunction);
        torus.animations = [];
        torus.animations.push(animationInnerCircle);
        this._scene.beginAnimation(torus, 0, 60, true);
        this._hideTeleportationTarget();
    };
    VRExperienceHelper.prototype._displayTeleportationTarget = function () {
        this._teleportActive = true;
        if (this._teleportationInitialized) {
            this._teleportationTarget.isVisible = true;
            if (this._isDefaultTeleportationTarget) {
                this._teleportationTarget.getChildren()[0].isVisible = true;
            }
        }
    };
    VRExperienceHelper.prototype._hideTeleportationTarget = function () {
        this._teleportActive = false;
        if (this._teleportationInitialized) {
            this._teleportationTarget.isVisible = false;
            if (this._isDefaultTeleportationTarget) {
                this._teleportationTarget.getChildren()[0].isVisible = false;
            }
        }
    };
    VRExperienceHelper.prototype._rotateCamera = function (right) {
        var _this = this;
        if (!(this.currentVRCamera instanceof FreeCamera)) {
            return;
        }
        if (right) {
            this._rotationAngle++;
        }
        else {
            this._rotationAngle--;
        }
        this.currentVRCamera.animations = [];
        var target = Quaternion.FromRotationMatrix(Matrix.RotationY(Math.PI / 4 * this._rotationAngle));
        var animationRotation = new Animation("animationRotation", "rotationQuaternion", 90, Animation.ANIMATIONTYPE_QUATERNION, Animation.ANIMATIONLOOPMODE_CONSTANT);
        var animationRotationKeys = [];
        animationRotationKeys.push({
            frame: 0,
            value: this.currentVRCamera.rotationQuaternion
        });
        animationRotationKeys.push({
            frame: 6,
            value: target
        });
        animationRotation.setKeys(animationRotationKeys);
        animationRotation.setEasingFunction(this._circleEase);
        this.currentVRCamera.animations.push(animationRotation);
        this._postProcessMove.animations = [];
        var animationPP = new Animation("animationPP", "vignetteWeight", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
        var vignetteWeightKeys = [];
        vignetteWeightKeys.push({
            frame: 0,
            value: 0
        });
        vignetteWeightKeys.push({
            frame: 3,
            value: 4
        });
        vignetteWeightKeys.push({
            frame: 6,
            value: 0
        });
        animationPP.setKeys(vignetteWeightKeys);
        animationPP.setEasingFunction(this._circleEase);
        this._postProcessMove.animations.push(animationPP);
        var animationPP2 = new Animation("animationPP2", "vignetteStretch", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
        var vignetteStretchKeys = [];
        vignetteStretchKeys.push({
            frame: 0,
            value: 0
        });
        vignetteStretchKeys.push({
            frame: 3,
            value: 10
        });
        vignetteStretchKeys.push({
            frame: 6,
            value: 0
        });
        animationPP2.setKeys(vignetteStretchKeys);
        animationPP2.setEasingFunction(this._circleEase);
        this._postProcessMove.animations.push(animationPP2);
        this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;
        this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;
        this._postProcessMove.samples = 4;
        this._webVRCamera.attachPostProcess(this._postProcessMove);
        this._scene.beginAnimation(this._postProcessMove, 0, 6, false, 1, function () {
            _this._webVRCamera.detachPostProcess(_this._postProcessMove);
        });
        this._scene.beginAnimation(this.currentVRCamera, 0, 6, false, 1);
    };
    VRExperienceHelper.prototype._moveTeleportationSelectorTo = function (hit, gazer, ray) {
        if (hit.pickedPoint) {
            if (gazer._teleportationRequestInitiated) {
                this._displayTeleportationTarget();
                this._haloCenter.copyFrom(hit.pickedPoint);
                this._teleportationTarget.position.copyFrom(hit.pickedPoint);
            }
            var pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(true, false), ray);
            if (pickNormal) {
                var axis1 = Vector3.Cross(Axis.Y, pickNormal);
                var axis2 = Vector3.Cross(pickNormal, axis1);
                Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, this._teleportationTarget.rotation);
            }
            this._teleportationTarget.position.y += 0.1;
        }
    };
    /**
     * Teleports the users feet to the desired location
     * @param location The location where the user's feet should be placed
     */
    VRExperienceHelper.prototype.teleportCamera = function (location) {
        var _this = this;
        if (!(this.currentVRCamera instanceof FreeCamera)) {
            return;
        }
        // Teleport the hmd to where the user is looking by moving the anchor to where they are looking minus the
        // offset of the headset from the anchor.
        if (this.webVRCamera.leftCamera) {
            this._workingVector.copyFrom(this.webVRCamera.leftCamera.globalPosition);
            this._workingVector.subtractInPlace(this.webVRCamera.position);
            location.subtractToRef(this._workingVector, this._workingVector);
        }
        else {
            this._workingVector.copyFrom(location);
        }
        // Add height to account for user's height offset
        if (this.isInVRMode) {
            this._workingVector.y += this.webVRCamera.deviceDistanceToRoomGround() * this._webVRCamera.deviceScaleFactor;
        }
        else {
            this._workingVector.y += this._defaultHeight;
        }
        this.onBeforeCameraTeleport.notifyObservers(this._workingVector);
        // Create animation from the camera's position to the new location
        this.currentVRCamera.animations = [];
        var animationCameraTeleportation = new Animation("animationCameraTeleportation", "position", 90, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
        var animationCameraTeleportationKeys = [{
                frame: 0,
                value: this.currentVRCamera.position
            },
            {
                frame: 11,
                value: this._workingVector
            }
        ];
        animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);
        animationCameraTeleportation.setEasingFunction(this._circleEase);
        this.currentVRCamera.animations.push(animationCameraTeleportation);
        this._postProcessMove.animations = [];
        var animationPP = new Animation("animationPP", "vignetteWeight", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
        var vignetteWeightKeys = [];
        vignetteWeightKeys.push({
            frame: 0,
            value: 0
        });
        vignetteWeightKeys.push({
            frame: 5,
            value: 8
        });
        vignetteWeightKeys.push({
            frame: 11,
            value: 0
        });
        animationPP.setKeys(vignetteWeightKeys);
        this._postProcessMove.animations.push(animationPP);
        var animationPP2 = new Animation("animationPP2", "vignetteStretch", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
        var vignetteStretchKeys = [];
        vignetteStretchKeys.push({
            frame: 0,
            value: 0
        });
        vignetteStretchKeys.push({
            frame: 5,
            value: 10
        });
        vignetteStretchKeys.push({
            frame: 11,
            value: 0
        });
        animationPP2.setKeys(vignetteStretchKeys);
        this._postProcessMove.animations.push(animationPP2);
        this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;
        this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;
        this._webVRCamera.attachPostProcess(this._postProcessMove);
        this._scene.beginAnimation(this._postProcessMove, 0, 11, false, 1, function () {
            _this._webVRCamera.detachPostProcess(_this._postProcessMove);
        });
        this._scene.beginAnimation(this.currentVRCamera, 0, 11, false, 1, function () {
            _this.onAfterCameraTeleport.notifyObservers(_this._workingVector);
        });
        this._hideTeleportationTarget();
    };
    VRExperienceHelper.prototype._convertNormalToDirectionOfRay = function (normal, ray) {
        if (normal) {
            var angle = Math.acos(Vector3.Dot(normal, ray.direction));
            if (angle < Math.PI / 2) {
                normal.scaleInPlace(-1);
            }
        }
        return normal;
    };
    VRExperienceHelper.prototype._castRayAndSelectObject = function (gazer) {
        if (!(this.currentVRCamera instanceof FreeCamera)) {
            return;
        }
        var ray = gazer._getForwardRay(this._rayLength);
        var hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);
        if (hit) {
            // Populate the contrllers mesh that can be used for drag/drop
            if (gazer._laserPointer) {
                hit.originMesh = gazer._laserPointer.parent;
            }
            this._scene.simulatePointerMove(hit, { pointerId: gazer._id });
        }
        gazer._currentHit = hit;
        // Moving the gazeTracker on the mesh face targetted
        if (hit && hit.pickedPoint) {
            if (this._displayGaze) {
                var multiplier = 1;
                gazer._gazeTracker.isVisible = true;
                if (gazer._isActionableMesh) {
                    multiplier = 3;
                }
                if (this.updateGazeTrackerScale) {
                    gazer._gazeTracker.scaling.x = hit.distance * multiplier;
                    gazer._gazeTracker.scaling.y = hit.distance * multiplier;
                    gazer._gazeTracker.scaling.z = hit.distance * multiplier;
                }
                var pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(), ray);
                // To avoid z-fighting
                var deltaFighting = 0.002;
                if (pickNormal) {
                    var axis1 = Vector3.Cross(Axis.Y, pickNormal);
                    var axis2 = Vector3.Cross(pickNormal, axis1);
                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, gazer._gazeTracker.rotation);
                }
                gazer._gazeTracker.position.copyFrom(hit.pickedPoint);
                if (gazer._gazeTracker.position.x < 0) {
                    gazer._gazeTracker.position.x += deltaFighting;
                }
                else {
                    gazer._gazeTracker.position.x -= deltaFighting;
                }
                if (gazer._gazeTracker.position.y < 0) {
                    gazer._gazeTracker.position.y += deltaFighting;
                }
                else {
                    gazer._gazeTracker.position.y -= deltaFighting;
                }
                if (gazer._gazeTracker.position.z < 0) {
                    gazer._gazeTracker.position.z += deltaFighting;
                }
                else {
                    gazer._gazeTracker.position.z -= deltaFighting;
                }
            }
            // Changing the size of the laser pointer based on the distance from the targetted point
            gazer._updatePointerDistance(hit.distance);
        }
        else {
            gazer._updatePointerDistance();
            gazer._gazeTracker.isVisible = false;
        }
        if (hit && hit.pickedMesh) {
            // The object selected is the floor, we're in a teleportation scenario
            if (this._teleportationInitialized && this._isTeleportationFloor(hit.pickedMesh) && hit.pickedPoint) {
                // Moving the teleportation area to this targetted point
                //Raise onSelectedMeshUnselected observable if ray collided floor mesh/meshes and a non floor mesh was previously selected
                if (gazer._currentMeshSelected && !this._isTeleportationFloor(gazer._currentMeshSelected)) {
                    this._notifySelectedMeshUnselected(gazer._currentMeshSelected);
                }
                gazer._currentMeshSelected = null;
                if (gazer._teleportationRequestInitiated) {
                    this._moveTeleportationSelectorTo(hit, gazer, ray);
                }
                return;
            }
            // If not, we're in a selection scenario
            //this._teleportationAllowed = false;
            if (hit.pickedMesh !== gazer._currentMeshSelected) {
                if (this.meshSelectionPredicate(hit.pickedMesh)) {
                    this.onNewMeshPicked.notifyObservers(hit);
                    gazer._currentMeshSelected = hit.pickedMesh;
                    if (hit.pickedMesh.isPickable && hit.pickedMesh.actionManager) {
                        this.changeGazeColor(new Color3(0, 0, 1));
                        this.changeLaserColor(new Color3(0.2, 0.2, 1));
                        gazer._isActionableMesh = true;
                    }
                    else {
                        this.changeGazeColor(new Color3(0.7, 0.7, 0.7));
                        this.changeLaserColor(new Color3(0.7, 0.7, 0.7));
                        gazer._isActionableMesh = false;
                    }
                    try {
                        this.onNewMeshSelected.notifyObservers(hit.pickedMesh);
                    }
                    catch (err) {
                        Logger.Warn("Error in your custom logic onNewMeshSelected: " + err);
                    }
                }
                else {
                    this._notifySelectedMeshUnselected(gazer._currentMeshSelected);
                    gazer._currentMeshSelected = null;
                    this.changeGazeColor(new Color3(0.7, 0.7, 0.7));
                    this.changeLaserColor(new Color3(0.7, 0.7, 0.7));
                }
            }
        }
        else {
            this._notifySelectedMeshUnselected(gazer._currentMeshSelected);
            gazer._currentMeshSelected = null;
            //this._teleportationAllowed = false;
            this.changeGazeColor(new Color3(0.7, 0.7, 0.7));
            this.changeLaserColor(new Color3(0.7, 0.7, 0.7));
        }
    };
    VRExperienceHelper.prototype._notifySelectedMeshUnselected = function (mesh) {
        if (mesh) {
            this.onSelectedMeshUnselected.notifyObservers(mesh);
        }
    };
    /**
     * Sets the color of the laser ray from the vr controllers.
     * @param color new color for the ray.
     */
    VRExperienceHelper.prototype.changeLaserColor = function (color) {
        if (this._leftController) {
            this._leftController._setLaserPointerColor(color);
        }
        if (this._rightController) {
            this._rightController._setLaserPointerColor(color);
        }
    };
    /**
     * Sets the color of the ray from the vr headsets gaze.
     * @param color new color for the ray.
     */
    VRExperienceHelper.prototype.changeGazeColor = function (color) {
        if (!this.updateGazeTrackerColor) {
            return;
        }
        if (!this._cameraGazer._gazeTracker.material) {
            return;
        }
        this._cameraGazer._gazeTracker.material.emissiveColor = color;
        if (this._leftController) {
            this._leftController._gazeTracker.material.emissiveColor = color;
        }
        if (this._rightController) {
            this._rightController._gazeTracker.material.emissiveColor = color;
        }
    };
    /**
     * Exits VR and disposes of the vr experience helper
     */
    VRExperienceHelper.prototype.dispose = function () {
        if (this.isInVRMode) {
            this.exitVR();
        }
        if (this._postProcessMove) {
            this._postProcessMove.dispose();
        }
        if (this._webVRCamera) {
            this._webVRCamera.dispose();
        }
        if (this._vrDeviceOrientationCamera) {
            this._vrDeviceOrientationCamera.dispose();
        }
        if (!this._useCustomVRButton && this._btnVR.parentNode) {
            document.body.removeChild(this._btnVR);
        }
        if (this._deviceOrientationCamera && (this._scene.activeCamera != this._deviceOrientationCamera)) {
            this._deviceOrientationCamera.dispose();
        }
        if (this._cameraGazer) {
            this._cameraGazer.dispose();
        }
        if (this._leftController) {
            this._leftController.dispose();
        }
        if (this._rightController) {
            this._rightController.dispose();
        }
        if (this._teleportationTarget) {
            this._teleportationTarget.dispose();
        }
        this._floorMeshesCollection = [];
        document.removeEventListener("keydown", this._onKeyDown);
        window.removeEventListener('vrdisplaypresentchange', this._onVrDisplayPresentChange);
        window.removeEventListener("resize", this._onResize);
        document.removeEventListener("fullscreenchange", this._onFullscreenChange);
        document.removeEventListener("mozfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("msfullscreenchange", this._onFullscreenChange);
        document.onmsfullscreenchange = null;
        this._scene.getEngine().onVRDisplayChangedObservable.removeCallback(this._onVRDisplayChanged);
        this._scene.getEngine().onVRRequestPresentStart.removeCallback(this._onVRRequestPresentStart);
        this._scene.getEngine().onVRRequestPresentComplete.removeCallback(this._onVRRequestPresentComplete);
        window.removeEventListener('vrdisplaypresentchange', this._onVrDisplayPresentChange);
        this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected);
        this._scene.gamepadManager.onGamepadDisconnectedObservable.removeCallback(this._onNewGamepadDisconnected);
        this._scene.unregisterBeforeRender(this.beforeRender);
    };
    /**
     * Gets the name of the VRExperienceHelper class
     * @returns "VRExperienceHelper"
     */
    VRExperienceHelper.prototype.getClassName = function () {
        return "VRExperienceHelper";
    };
    return VRExperienceHelper;
}());

/**
 * WebXR Camera which holds the views for the xrSession
 * @see https://doc.babylonjs.com/how_to/webxr
 */
var WebXRCamera = /** @class */ (function (_super) {
    __extends(WebXRCamera, _super);
    /**
     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager
     * @param name the name of the camera
     * @param scene the scene to add the camera to
     */
    function WebXRCamera(name, scene) {
        var _this = _super.call(this, name, Vector3.Zero(), scene) || this;
        // Initial camera configuration
        _this.minZ = 0;
        _this.rotationQuaternion = new Quaternion();
        _this.cameraRigMode = Camera.RIG_MODE_CUSTOM;
        _this.updateUpVectorFromRotation = true;
        _this._updateNumberOfRigCameras(1);
        return _this;
    }
    WebXRCamera.prototype._updateNumberOfRigCameras = function (viewCount) {
        if (viewCount === void 0) { viewCount = 1; }
        while (this.rigCameras.length < viewCount) {
            var newCamera = new TargetCamera("view: " + this.rigCameras.length, Vector3.Zero(), this.getScene());
            newCamera.minZ = 0;
            newCamera.parent = this;
            newCamera.rotationQuaternion = new Quaternion();
            newCamera.updateUpVectorFromRotation = true;
            this.rigCameras.push(newCamera);
        }
        while (this.rigCameras.length > viewCount) {
            var removedCamera = this.rigCameras.pop();
            if (removedCamera) {
                removedCamera.dispose();
            }
        }
    };
    /** @hidden */
    WebXRCamera.prototype._updateForDualEyeDebugging = function (pupilDistance) {
        if (pupilDistance === void 0) { pupilDistance = 0.01; }
        // Create initial camera rigs
        this._updateNumberOfRigCameras(2);
        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);
        this.rigCameras[0].position.x = -pupilDistance / 2;
        this.rigCameras[0].outputRenderTarget = null;
        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);
        this.rigCameras[1].position.x = pupilDistance / 2;
        this.rigCameras[1].outputRenderTarget = null;
    };
    /**
     * Updates the cameras position from the current pose information of the  XR session
     * @param xrSessionManager the session containing pose information
     * @returns true if the camera has been updated, false if the session did not contain pose or frame data
     */
    WebXRCamera.prototype.updateFromXRSessionManager = function (xrSessionManager) {
        var _this = this;
        // Ensure all frame data is available
        if (!xrSessionManager._currentXRFrame || !xrSessionManager._currentXRFrame.getDevicePose) {
            return false;
        }
        var pose = xrSessionManager._currentXRFrame.getDevicePose(xrSessionManager._frameOfReference);
        if (!pose || !pose.poseModelMatrix) {
            return false;
        }
        // Update the parent cameras matrix
        Matrix.FromFloat32ArrayToRefScaled(pose.poseModelMatrix, 0, 1, WebXRCamera._TmpMatrix);
        if (!this._scene.useRightHandedSystem) {
            WebXRCamera._TmpMatrix.toggleModelMatrixHandInPlace();
        }
        WebXRCamera._TmpMatrix.getTranslationToRef(this.position);
        WebXRCamera._TmpMatrix.getRotationMatrixToRef(WebXRCamera._TmpMatrix);
        Quaternion.FromRotationMatrixToRef(WebXRCamera._TmpMatrix, this.rotationQuaternion);
        this.computeWorldMatrix();
        // Update camera rigs
        this._updateNumberOfRigCameras(xrSessionManager._currentXRFrame.views.length);
        xrSessionManager._currentXRFrame.views.forEach(function (view, i) {
            // Update view/projection matrix
            Matrix.FromFloat32ArrayToRefScaled(pose.getViewMatrix(view), 0, 1, _this.rigCameras[i]._computedViewMatrix);
            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, _this.rigCameras[i]._projectionMatrix);
            if (!_this._scene.useRightHandedSystem) {
                _this.rigCameras[i]._computedViewMatrix.toggleModelMatrixHandInPlace();
                _this.rigCameras[i]._projectionMatrix.toggleProjectionMatrixHandInPlace();
            }
            // Update viewport
            var viewport = xrSessionManager._xrSession.baseLayer.getViewport(view);
            var width = xrSessionManager._xrSession.baseLayer.framebufferWidth;
            var height = xrSessionManager._xrSession.baseLayer.framebufferHeight;
            _this.rigCameras[i].viewport.width = viewport.width / width;
            _this.rigCameras[i].viewport.height = viewport.height / height;
            _this.rigCameras[i].viewport.x = viewport.x / width;
            _this.rigCameras[i].viewport.y = viewport.y / height;
            // Set cameras to render to the session's render target
            _this.rigCameras[i].outputRenderTarget = xrSessionManager._sessionRenderTargetTexture;
        });
        return true;
    };
    WebXRCamera._TmpMatrix = new Matrix();
    return WebXRCamera;
}(FreeCamera));

/**
 * Manages an XRSession
 * @see https://doc.babylonjs.com/how_to/webxr
 */
var WebXRSessionManager = /** @class */ (function () {
    /**
     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage
     * @param scene The scene which the session should be created for
     */
    function WebXRSessionManager(scene) {
        this.scene = scene;
        /**
         * Fires every time a new xrFrame arrives which can be used to update the camera
         */
        this.onXRFrameObservable = new Observable();
        /**
         * Fires when the xr session is ended either by the device or manually done
         */
        this.onXRSessionEnded = new Observable();
        /** @hidden */
        this._sessionRenderTargetTexture = null;
        this._tmpMatrix = new Matrix();
    }
    /**
     * Initializes the manager
     * After initialization enterXR can be called to start an XR session
     * @returns Promise which resolves after it is initialized
     */
    WebXRSessionManager.prototype.initializeAsync = function () {
        var _this = this;
        Logger.Warn("The WebXR APIs are still under development and are subject to change in the future.");
        // Check if the browser supports webXR
        this._xrNavigator = navigator;
        if (!this._xrNavigator.xr) {
            return Promise.reject("webXR not supported by this browser");
        }
        // Request the webXR device
        return this._xrNavigator.xr.requestDevice().then(function (device) {
            _this._xrDevice = device;
            return _this.scene.getEngine()._gl.setCompatibleXRDevice(_this._xrDevice);
        });
    };
    /**
     * Enters XR with the desired XR session options, this must be done with a user action (eg. button click event)
     * @param sessionCreationOptions xr options to create the session with
     * @param frameOfReferenceType option to configure how the xr pose is expressed
     * @returns Promise which resolves after it enters XR
     */
    WebXRSessionManager.prototype.enterXRAsync = function (sessionCreationOptions, frameOfReferenceType) {
        var _this = this;
        // initialize session
        return this._xrDevice.requestSession(sessionCreationOptions).then(function (session) {
            _this._xrSession = session;
            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)
            _this._xrSession.addEventListener("end", function () {
                // Remove render target texture and notify frame obervers
                _this._sessionRenderTargetTexture = null;
                // Restore frame buffer to avoid clear on xr framebuffer after session end
                _this.scene.getEngine().restoreDefaultFramebuffer();
                // Need to restart render loop as after the session is ended the last request for new frame will never call callback
                _this.scene.getEngine().customAnimationFrameRequester = null;
                _this.onXRSessionEnded.notifyObservers(null);
                _this.scene.getEngine()._renderLoop();
            }, { once: true });
            _this._xrSession.baseLayer = new XRWebGLLayer(_this._xrSession, _this.scene.getEngine()._gl);
            return _this._xrSession.requestFrameOfReference(frameOfReferenceType);
        }).then(function (frameOfRef) {
            _this._frameOfReference = frameOfRef;
            // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information
            _this.scene.getEngine().customAnimationFrameRequester = {
                requestAnimationFrame: _this._xrSession.requestAnimationFrame.bind(_this._xrSession),
                renderFunction: function (timestamp, xrFrame) {
                    // Store the XR frame in the manager to be consumed by the XR camera to update pose
                    _this._currentXRFrame = xrFrame;
                    _this.onXRFrameObservable.notifyObservers(null);
                    _this.scene.getEngine()._renderLoop();
                }
            };
            // Create render target texture from xr's webgl render target
            _this._sessionRenderTargetTexture = WebXRSessionManager._CreateRenderTargetTextureFromSession(_this._xrSession, _this.scene);
            // Stop window's animation frame and trigger sessions animation frame
            window.cancelAnimationFrame(_this.scene.getEngine()._frameHandler);
            _this.scene.getEngine()._renderLoop();
        });
    };
    /**
     * Stops the xrSession and restores the renderloop
     * @returns Promise which resolves after it exits XR
     */
    WebXRSessionManager.prototype.exitXRAsync = function () {
        return this._xrSession.end();
    };
    /**
     * Fires a ray and returns the closest hit in the xr sessions enviornment, useful to place objects in AR
     * @param ray ray to cast into the environment
     * @returns Promise which resolves with a collision point in the environment if it exists
     */
    WebXRSessionManager.prototype.environmentPointHitTestAsync = function (ray) {
        var _this = this;
        return new Promise(function (res) {
            // Compute left handed inputs to request hit test
            var origin = new Float32Array([ray.origin.x, ray.origin.y, ray.origin.z]);
            var direction = new Float32Array([ray.direction.x, ray.direction.y, ray.direction.z]);
            if (!_this.scene.useRightHandedSystem) {
                origin[2] *= -1;
                direction[2] *= -1;
            }
            // Fire hittest
            _this._xrSession.requestHitTest(origin, direction, _this._frameOfReference)
                .then(function (hits) {
                if (hits.length > 0) {
                    Matrix.FromFloat32ArrayToRefScaled(hits[0].hitMatrix, 0, 1.0, _this._tmpMatrix);
                    var hitPoint = _this._tmpMatrix.getTranslation();
                    if (!_this.scene.useRightHandedSystem) {
                        hitPoint.z *= -1;
                    }
                    res(hitPoint);
                }
                else {
                    res(null);
                }
            }).catch(function () {
                res(null);
            });
        });
    };
    /**
     * Checks if a session would be supported for the creation options specified
     * @param options creation options to check if they are supported
     * @returns true if supported
     */
    WebXRSessionManager.prototype.supportsSessionAsync = function (options) {
        return this._xrDevice.supportsSession(options).then(function () {
            return true;
        }).catch(function () {
            return false;
        });
    };
    /**
     * @hidden
     * Converts the render layer of xrSession to a render target
     * @param session session to create render target for
     * @param scene scene the new render target should be created for
     */
    WebXRSessionManager._CreateRenderTargetTextureFromSession = function (session, scene) {
        // Create internal texture
        var internalTexture = new InternalTexture(scene.getEngine(), InternalTexture.DATASOURCE_UNKNOWN, true);
        internalTexture.width = session.baseLayer.framebufferWidth;
        internalTexture.height = session.baseLayer.framebufferHeight;
        internalTexture._framebuffer = session.baseLayer.framebuffer;
        // Create render target texture from the internal texture
        var renderTargetTexture = new RenderTargetTexture("XR renderTargetTexture", { width: internalTexture.width, height: internalTexture.height }, scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);
        renderTargetTexture._texture = internalTexture;
        return renderTargetTexture;
    };
    /**
     * Disposes of the session manager
     */
    WebXRSessionManager.prototype.dispose = function () {
        this.onXRFrameObservable.clear();
        this.onXRSessionEnded.clear();
    };
    return WebXRSessionManager;
}());

/**
 * States of the webXR experience
 */
var WebXRState;
(function (WebXRState) {
    /**
     * Transitioning to being in XR mode
     */
    WebXRState[WebXRState["ENTERING_XR"] = 0] = "ENTERING_XR";
    /**
     * Transitioning to non XR mode
     */
    WebXRState[WebXRState["EXITING_XR"] = 1] = "EXITING_XR";
    /**
     * In XR mode and presenting
     */
    WebXRState[WebXRState["IN_XR"] = 2] = "IN_XR";
    /**
     * Not entered XR mode
     */
    WebXRState[WebXRState["NOT_IN_XR"] = 3] = "NOT_IN_XR";
})(WebXRState || (WebXRState = {}));
/**
 * Helper class used to enable XR
 * @see https://doc.babylonjs.com/how_to/webxr
 */
var WebXRExperienceHelper = /** @class */ (function () {
    /**
     * Creates a WebXRExperienceHelper
     * @param scene The scene the helper should be created in
     */
    function WebXRExperienceHelper(scene) {
        this.scene = scene;
        /**
         * The current state of the XR experience (eg. transitioning, in XR or not in XR)
         */
        this.state = WebXRState.NOT_IN_XR;
        /**
         * Fires when the state of the experience helper has changed
         */
        this.onStateChangedObservable = new Observable();
        this._nonVRCamera = null;
        this._originalSceneAutoClear = true;
        this._supported = false;
        this.camera = new WebXRCamera("", scene);
        this._sessionManager = new WebXRSessionManager(scene);
        this.container = new AbstractMesh("", scene);
        this.camera.parent = this.container;
    }
    WebXRExperienceHelper.prototype._setState = function (val) {
        this.state = val;
        this.onStateChangedObservable.notifyObservers(this.state);
    };
    /**
     * Creates the experience helper
     * @param scene the scene to attach the experience helper to
     * @returns a promise for the experience helper
     */
    WebXRExperienceHelper.CreateAsync = function (scene) {
        var helper = new WebXRExperienceHelper(scene);
        return helper._sessionManager.initializeAsync().then(function () {
            helper._supported = true;
            return helper;
        }).catch(function () {
            return helper;
        });
    };
    /**
     * Exits XR mode and returns the scene to its original state
     * @returns promise that resolves after xr mode has exited
     */
    WebXRExperienceHelper.prototype.exitXRAsync = function () {
        this._setState(WebXRState.EXITING_XR);
        return this._sessionManager.exitXRAsync();
    };
    /**
     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)
     * @param sessionCreationOptions options for the XR session
     * @param frameOfReference frame of reference of the XR session
     * @returns promise that resolves after xr mode has entered
     */
    WebXRExperienceHelper.prototype.enterXRAsync = function (sessionCreationOptions, frameOfReference) {
        var _this = this;
        if (!this._supported) {
            throw "XR session not supported by this browser";
        }
        this._setState(WebXRState.ENTERING_XR);
        return this._sessionManager.enterXRAsync(sessionCreationOptions, frameOfReference).then(function () {
            // Cache pre xr scene settings
            _this._originalSceneAutoClear = _this.scene.autoClear;
            _this._nonVRCamera = _this.scene.activeCamera;
            // Overwrite current scene settings
            _this.scene.autoClear = false;
            _this.scene.activeCamera = _this.camera;
            _this._sessionManager.onXRFrameObservable.add(function () {
                _this.camera.updateFromXRSessionManager(_this._sessionManager);
            });
            _this._sessionManager.onXRSessionEnded.addOnce(function () {
                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends
                _this.camera.rigCameras.forEach(function (c) {
                    c.outputRenderTarget = null;
                });
                // Restore scene settings
                _this.scene.autoClear = _this._originalSceneAutoClear;
                _this.scene.activeCamera = _this._nonVRCamera;
                _this._sessionManager.onXRFrameObservable.clear();
                _this._setState(WebXRState.NOT_IN_XR);
            });
            _this._setState(WebXRState.IN_XR);
        });
    };
    /**
     * Fires a ray and returns the closest hit in the xr sessions enviornment, useful to place objects in AR
     * @param ray ray to cast into the environment
     * @returns Promise which resolves with a collision point in the environment if it exists
     */
    WebXRExperienceHelper.prototype.environmentPointHitTestAsync = function (ray) {
        return this._sessionManager.environmentPointHitTestAsync(ray);
    };
    /**
     * Updates the global position of the camera by moving the camera's container
     * This should be used instead of modifying the camera's position as it will be overwritten by an xrSessions's update frame
     * @param position The desired global position of the camera
     */
    WebXRExperienceHelper.prototype.setPositionOfCameraUsingContainer = function (position) {
        this.camera.globalPosition.subtractToRef(position, WebXRExperienceHelper._TmpVector);
        this.container.position.subtractInPlace(WebXRExperienceHelper._TmpVector);
    };
    /**
     * Rotates the xr camera by rotating the camera's container around the camera's position
     * This should be used instead of modifying the camera's rotation as it will be overwritten by an xrSessions's update frame
     * @param rotation the desired quaternion rotation to apply to the camera
     */
    WebXRExperienceHelper.prototype.rotateCameraByQuaternionUsingContainer = function (rotation) {
        if (!this.container.rotationQuaternion) {
            this.container.rotationQuaternion = Quaternion.FromEulerVector(this.container.rotation);
        }
        this.container.rotationQuaternion.multiplyInPlace(rotation);
        this.container.position.rotateByQuaternionAroundPointToRef(rotation, this.camera.globalPosition, this.container.position);
    };
    /**
     * Checks if the creation options are supported by the xr session
     * @param options creation options
     * @returns true if supported
     */
    WebXRExperienceHelper.prototype.supportsSessionAsync = function (options) {
        if (!this._supported) {
            return Promise.resolve(false);
        }
        return this._sessionManager.supportsSessionAsync(options);
    };
    /**
     * Disposes of the experience helper
     */
    WebXRExperienceHelper.prototype.dispose = function () {
        this.camera.dispose();
        this.container.dispose();
        this.onStateChangedObservable.clear();
        this._sessionManager.dispose();
    };
    WebXRExperienceHelper._TmpVector = new Vector3();
    return WebXRExperienceHelper;
}());

/**
 * Button which can be used to enter a different mode of XR
 */
var WebXREnterExitUIButton = /** @class */ (function () {
    /**
     * Creates a WebXREnterExitUIButton
     * @param element button element
     * @param initializationOptions XR initialization options for the button
     */
    function WebXREnterExitUIButton(
    /** button element */
    element, 
    /** XR initialization options for the button */
    initializationOptions) {
        this.element = element;
        this.initializationOptions = initializationOptions;
    }
    /**
     * Overwritable function which can be used to update the button's visuals when the state changes
     * @param activeButton the current active button in the UI
     */
    WebXREnterExitUIButton.prototype.update = function (activeButton) {
    };
    return WebXREnterExitUIButton;
}());
/**
 * Options to create the webXR UI
 */
var WebXREnterExitUIOptions = /** @class */ (function () {
    function WebXREnterExitUIOptions() {
    }
    return WebXREnterExitUIOptions;
}());
/**
 * UI to allow the user to enter/exit XR mode
 */
var WebXREnterExitUI = /** @class */ (function () {
    function WebXREnterExitUI(scene, options) {
        var _this = this;
        this.scene = scene;
        this._buttons = [];
        this._activeButton = null;
        /**
         * Fired every time the active button is changed.
         *
         * When xr is entered via a button that launches xr that button will be the callback parameter
         *
         * When exiting xr the callback parameter will be null)
         */
        this.activeButtonChangedObservable = new Observable();
        this._overlay = document.createElement("div");
        this._overlay.style.cssText = "z-index:11;position: absolute; right: 20px;bottom: 50px;";
        if (options.customButtons) {
            this._buttons = options.customButtons;
        }
        else {
            var hmdBtn = document.createElement("button");
            hmdBtn.style.cssText = "color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-repeat:no-repeat; background-position: center; outline: none;";
            hmdBtn.innerText = "HMD";
            this._buttons.push(new WebXREnterExitUIButton(hmdBtn, { immersive: true, outputContext: options.outputCanvasContext }));
            this._buttons[this._buttons.length - 1].update = function (activeButton) {
                this.element.style.display = (activeButton === null || activeButton === this) ? "" : "none";
                this.element.innerText = activeButton === this ? "EXIT" : "HMD";
            };
            var windowBtn = document.createElement("button");
            windowBtn.style.cssText = hmdBtn.style.cssText;
            windowBtn.innerText = "Window";
            this._buttons.push(new WebXREnterExitUIButton(windowBtn, { immersive: false, environmentIntegration: true, outputContext: options.outputCanvasContext }));
            this._buttons[this._buttons.length - 1].update = function (activeButton) {
                this.element.style.display = (activeButton === null || activeButton === this) ? "" : "none";
                this.element.innerText = activeButton === this ? "EXIT" : "Window";
            };
            this._updateButtons(null);
        }
        var renderCanvas = scene.getEngine().getRenderingCanvas();
        if (renderCanvas && renderCanvas.parentNode) {
            renderCanvas.parentNode.appendChild(this._overlay);
            scene.onDisposeObservable.addOnce(function () {
                _this.dispose();
            });
        }
    }
    /**
     * Creates UI to allow the user to enter/exit XR mode
     * @param scene the scene to add the ui to
     * @param helper the xr experience helper to enter/exit xr with
     * @param options options to configure the UI
     * @returns the created ui
     */
    WebXREnterExitUI.CreateAsync = function (scene, helper, options) {
        var _this = this;
        var ui = new WebXREnterExitUI(scene, options);
        var supportedPromises = ui._buttons.map(function (btn) {
            return helper.supportsSessionAsync(btn.initializationOptions);
        });
        helper.onStateChangedObservable.add(function (state) {
            if (state == WebXRState.NOT_IN_XR) {
                ui._updateButtons(null);
            }
        });
        return Promise.all(supportedPromises).then(function (results) {
            results.forEach(function (supported, i) {
                if (supported) {
                    ui._overlay.appendChild(ui._buttons[i].element);
                    ui._buttons[i].element.onclick = function () { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(helper.state == WebXRState.IN_XR)) return [3 /*break*/, 2];
                                    ui._updateButtons(null);
                                    return [4 /*yield*/, helper.exitXRAsync()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 2:
                                    if (!(helper.state == WebXRState.NOT_IN_XR)) return [3 /*break*/, 4];
                                    ui._updateButtons(ui._buttons[i]);
                                    return [4 /*yield*/, helper.enterXRAsync(ui._buttons[i].initializationOptions, "eye-level")];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    }); };
                }
            });
            return ui;
        });
    };
    WebXREnterExitUI.prototype._updateButtons = function (activeButton) {
        var _this = this;
        this._activeButton = activeButton;
        this._buttons.forEach(function (b) {
            b.update(_this._activeButton);
        });
        this.activeButtonChangedObservable.notifyObservers(this._activeButton);
    };
    /**
     * Disposes of the object
     */
    WebXREnterExitUI.prototype.dispose = function () {
        var renderCanvas = this.scene.getEngine().getRenderingCanvas();
        if (renderCanvas && renderCanvas.parentNode && renderCanvas.parentNode.contains(this._overlay)) {
            renderCanvas.parentNode.removeChild(this._overlay);
        }
        this.activeButtonChangedObservable.clear();
    };
    return WebXREnterExitUI;
}());

/**
 * Represents an XR input
 */
var WebXRController = /** @class */ (function () {
    /**
     * Creates the controller
     * @see https://doc.babylonjs.com/how_to/webxr
     * @param scene the scene which the controller should be associated to
     */
    function WebXRController(scene) {
        this.pointer = new AbstractMesh("controllerPointer", scene);
    }
    /**
     * Disposes of the object
     */
    WebXRController.prototype.dispose = function () {
        if (this.grip) {
            this.grip.dispose();
        }
        this.pointer.dispose();
    };
    return WebXRController;
}());
/**
 * XR input used to track XR inputs such as controllers/rays
 */
var WebXRInput = /** @class */ (function () {
    /**
     * Initializes the WebXRInput
     * @param helper experience helper which the input should be created for
     */
    function WebXRInput(helper) {
        var _this = this;
        this.helper = helper;
        /**
         * XR controllers being tracked
         */
        this.controllers = [];
        this._tmpMatrix = new Matrix();
        this._frameObserver = helper._sessionManager.onXRFrameObservable.add(function () {
            if (!helper._sessionManager._currentXRFrame || !helper._sessionManager._currentXRFrame.getDevicePose) {
                return;
            }
            var xrFrame = helper._sessionManager._currentXRFrame;
            var inputSources = helper._sessionManager._xrSession.getInputSources();
            inputSources.forEach(function (input, i) {
                var inputPose = xrFrame.getInputPose(input, helper._sessionManager._frameOfReference);
                if (inputPose) {
                    if (_this.controllers.length <= i) {
                        _this.controllers.push(new WebXRController(helper.container.getScene()));
                    }
                    var controller = _this.controllers[i];
                    // Manage the grip if it exists
                    if (inputPose.gripMatrix) {
                        if (!controller.grip) {
                            controller.grip = new AbstractMesh("controllerGrip", helper.container.getScene());
                        }
                        Matrix.FromFloat32ArrayToRefScaled(inputPose.gripMatrix, 0, 1, _this._tmpMatrix);
                        if (!controller.grip.getScene().useRightHandedSystem) {
                            _this._tmpMatrix.toggleModelMatrixHandInPlace();
                        }
                        if (!controller.grip.rotationQuaternion) {
                            controller.grip.rotationQuaternion = new Quaternion();
                        }
                        _this._tmpMatrix.decompose(controller.grip.scaling, controller.grip.rotationQuaternion, controller.grip.position);
                    }
                    // Manager pointer of controller
                    Matrix.FromFloat32ArrayToRefScaled(inputPose.targetRay.transformMatrix, 0, 1, _this._tmpMatrix);
                    if (!controller.pointer.getScene().useRightHandedSystem) {
                        _this._tmpMatrix.toggleModelMatrixHandInPlace();
                    }
                    if (!controller.pointer.rotationQuaternion) {
                        controller.pointer.rotationQuaternion = new Quaternion();
                    }
                    _this._tmpMatrix.decompose(controller.pointer.scaling, controller.pointer.rotationQuaternion, controller.pointer.position);
                }
            });
        });
    }
    /**
     * Disposes of the object
     */
    WebXRInput.prototype.dispose = function () {
        this.controllers.forEach(function (c) {
            c.dispose();
        });
        this.helper._sessionManager.onXRFrameObservable.remove(this._frameObserver);
    };
    return WebXRInput;
}());

/**
 * Creates a canvas that is added/removed from the webpage when entering/exiting XR
 */
var WebXRManagedOutputCanvas = /** @class */ (function () {
    /**
     * Initializes the canvas to be added/removed upon entering/exiting xr
     * @param helper the xr experience helper used to trigger adding/removing of the canvas
     * @param canvas The canvas to be added/removed (If not specified a full screen canvas will be created)
     */
    function WebXRManagedOutputCanvas(helper, canvas) {
        var _this = this;
        this._canvas = null;
        /**
         * xrpresent context of the canvas which can be used to display/mirror xr content
         */
        this.canvasContext = null;
        if (!canvas) {
            canvas = document.createElement('canvas');
            canvas.style.cssText = "position:absolute; bottom:0px;right:0px;z-index:10;width:100%;height:100%;background-color: #000000;";
        }
        this._setManagedOutputCanvas(canvas);
        helper.onStateChangedObservable.add(function (stateInfo) {
            if (stateInfo == WebXRState.ENTERING_XR) {
                // The canvas is added to the screen before entering XR because currently the xr session must be initialized while the canvas is added render properly
                _this._addCanvas();
            }
            else if (helper.state == WebXRState.NOT_IN_XR) {
                _this._removeCanvas();
            }
        });
    }
    /**
     * Disposes of the object
     */
    WebXRManagedOutputCanvas.prototype.dispose = function () {
        this._removeCanvas();
        this._setManagedOutputCanvas(null);
    };
    WebXRManagedOutputCanvas.prototype._setManagedOutputCanvas = function (canvas) {
        this._removeCanvas();
        if (!canvas) {
            this._canvas = null;
            this.canvasContext = null;
        }
        else {
            this._canvas = canvas;
            this.canvasContext = this._canvas.getContext('xrpresent');
        }
    };
    WebXRManagedOutputCanvas.prototype._addCanvas = function () {
        if (this._canvas) {
            document.body.appendChild(this._canvas);
        }
    };
    WebXRManagedOutputCanvas.prototype._removeCanvas = function () {
        if (this._canvas && document.body.contains(this._canvas)) {
            document.body.removeChild(this._canvas);
        }
    };
    return WebXRManagedOutputCanvas;
}());

var intersectBoxAASphere = function (boxMin, boxMax, sphereCenter, sphereRadius) {
    if (boxMin.x > sphereCenter.x + sphereRadius) {
        return false;
    }
    if (sphereCenter.x - sphereRadius > boxMax.x) {
        return false;
    }
    if (boxMin.y > sphereCenter.y + sphereRadius) {
        return false;
    }
    if (sphereCenter.y - sphereRadius > boxMax.y) {
        return false;
    }
    if (boxMin.z > sphereCenter.z + sphereRadius) {
        return false;
    }
    if (sphereCenter.z - sphereRadius > boxMax.z) {
        return false;
    }
    return true;
};
var getLowestRoot = (function () {
    var result = { root: 0, found: false };
    return function (a, b, c, maxR) {
        result.root = 0;
        result.found = false;
        var determinant = b * b - 4.0 * a * c;
        if (determinant < 0) {
            return result;
        }
        var sqrtD = Math.sqrt(determinant);
        var r1 = (-b - sqrtD) / (2.0 * a);
        var r2 = (-b + sqrtD) / (2.0 * a);
        if (r1 > r2) {
            var temp = r2;
            r2 = r1;
            r1 = temp;
        }
        if (r1 > 0 && r1 < maxR) {
            result.root = r1;
            result.found = true;
            return result;
        }
        if (r2 > 0 && r2 < maxR) {
            result.root = r2;
            result.found = true;
            return result;
        }
        return result;
    };
})();
/** @hidden */
var Collider = /** @class */ (function () {
    function Collider() {
        this._collisionPoint = Vector3.Zero();
        this._planeIntersectionPoint = Vector3.Zero();
        this._tempVector = Vector3.Zero();
        this._tempVector2 = Vector3.Zero();
        this._tempVector3 = Vector3.Zero();
        this._tempVector4 = Vector3.Zero();
        this._edge = Vector3.Zero();
        this._baseToVertex = Vector3.Zero();
        this._destinationPoint = Vector3.Zero();
        this._slidePlaneNormal = Vector3.Zero();
        this._displacementVector = Vector3.Zero();
        /** @hidden */
        this._radius = Vector3.One();
        /** @hidden */
        this._retry = 0;
        /** @hidden */
        this._basePointWorld = Vector3.Zero();
        this._velocityWorld = Vector3.Zero();
        this._normalizedVelocity = Vector3.Zero();
        this._collisionMask = -1;
    }
    Object.defineProperty(Collider.prototype, "collisionMask", {
        get: function () {
            return this._collisionMask;
        },
        set: function (mask) {
            this._collisionMask = !isNaN(mask) ? mask : -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Collider.prototype, "slidePlaneNormal", {
        /**
         * Gets the plane normal used to compute the sliding response (in local space)
         */
        get: function () {
            return this._slidePlaneNormal;
        },
        enumerable: true,
        configurable: true
    });
    // Methods
    /** @hidden */
    Collider.prototype._initialize = function (source, dir, e) {
        this._velocity = dir;
        Vector3.NormalizeToRef(dir, this._normalizedVelocity);
        this._basePoint = source;
        source.multiplyToRef(this._radius, this._basePointWorld);
        dir.multiplyToRef(this._radius, this._velocityWorld);
        this._velocityWorldLength = this._velocityWorld.length();
        this._epsilon = e;
        this.collisionFound = false;
    };
    /** @hidden */
    Collider.prototype._checkPointInTriangle = function (point, pa, pb, pc, n) {
        pa.subtractToRef(point, this._tempVector);
        pb.subtractToRef(point, this._tempVector2);
        Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);
        var d = Vector3.Dot(this._tempVector4, n);
        if (d < 0) {
            return false;
        }
        pc.subtractToRef(point, this._tempVector3);
        Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);
        d = Vector3.Dot(this._tempVector4, n);
        if (d < 0) {
            return false;
        }
        Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);
        d = Vector3.Dot(this._tempVector4, n);
        return d >= 0;
    };
    /** @hidden */
    Collider.prototype._canDoCollision = function (sphereCenter, sphereRadius, vecMin, vecMax) {
        var distance = Vector3.Distance(this._basePointWorld, sphereCenter);
        var max = Math.max(this._radius.x, this._radius.y, this._radius.z);
        if (distance > this._velocityWorldLength + max + sphereRadius) {
            return false;
        }
        if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {
            return false;
        }
        return true;
    };
    /** @hidden */
    Collider.prototype._testTriangle = function (faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial) {
        var t0;
        var embeddedInPlane = false;
        //defensive programming, actually not needed.
        if (!trianglePlaneArray) {
            trianglePlaneArray = [];
        }
        if (!trianglePlaneArray[faceIndex]) {
            trianglePlaneArray[faceIndex] = new Plane$1(0, 0, 0, 0);
            trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);
        }
        var trianglePlane = trianglePlaneArray[faceIndex];
        if ((!hasMaterial) && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {
            return;
        }
        var signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);
        var normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);
        if (normalDotVelocity == 0) {
            if (Math.abs(signedDistToTrianglePlane) >= 1.0) {
                return;
            }
            embeddedInPlane = true;
            t0 = 0;
        }
        else {
            t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;
            var t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;
            if (t0 > t1) {
                var temp = t1;
                t1 = t0;
                t0 = temp;
            }
            if (t0 > 1.0 || t1 < 0.0) {
                return;
            }
            if (t0 < 0) {
                t0 = 0;
            }
            if (t0 > 1.0) {
                t0 = 1.0;
            }
        }
        this._collisionPoint.copyFromFloats(0, 0, 0);
        var found = false;
        var t = 1.0;
        if (!embeddedInPlane) {
            this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);
            this._velocity.scaleToRef(t0, this._tempVector);
            this._planeIntersectionPoint.addInPlace(this._tempVector);
            if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {
                found = true;
                t = t0;
                this._collisionPoint.copyFrom(this._planeIntersectionPoint);
            }
        }
        if (!found) {
            var velocitySquaredLength = this._velocity.lengthSquared();
            var a = velocitySquaredLength;
            this._basePoint.subtractToRef(p1, this._tempVector);
            var b = 2.0 * (Vector3.Dot(this._velocity, this._tempVector));
            var c = this._tempVector.lengthSquared() - 1.0;
            var lowestRoot = getLowestRoot(a, b, c, t);
            if (lowestRoot.found) {
                t = lowestRoot.root;
                found = true;
                this._collisionPoint.copyFrom(p1);
            }
            this._basePoint.subtractToRef(p2, this._tempVector);
            b = 2.0 * (Vector3.Dot(this._velocity, this._tempVector));
            c = this._tempVector.lengthSquared() - 1.0;
            lowestRoot = getLowestRoot(a, b, c, t);
            if (lowestRoot.found) {
                t = lowestRoot.root;
                found = true;
                this._collisionPoint.copyFrom(p2);
            }
            this._basePoint.subtractToRef(p3, this._tempVector);
            b = 2.0 * (Vector3.Dot(this._velocity, this._tempVector));
            c = this._tempVector.lengthSquared() - 1.0;
            lowestRoot = getLowestRoot(a, b, c, t);
            if (lowestRoot.found) {
                t = lowestRoot.root;
                found = true;
                this._collisionPoint.copyFrom(p3);
            }
            p2.subtractToRef(p1, this._edge);
            p1.subtractToRef(this._basePoint, this._baseToVertex);
            var edgeSquaredLength = this._edge.lengthSquared();
            var edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);
            var edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);
            a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;
            b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;
            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
            lowestRoot = getLowestRoot(a, b, c, t);
            if (lowestRoot.found) {
                var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;
                if (f >= 0.0 && f <= 1.0) {
                    t = lowestRoot.root;
                    found = true;
                    this._edge.scaleInPlace(f);
                    p1.addToRef(this._edge, this._collisionPoint);
                }
            }
            p3.subtractToRef(p2, this._edge);
            p2.subtractToRef(this._basePoint, this._baseToVertex);
            edgeSquaredLength = this._edge.lengthSquared();
            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);
            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);
            a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;
            b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;
            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
            lowestRoot = getLowestRoot(a, b, c, t);
            if (lowestRoot.found) {
                f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;
                if (f >= 0.0 && f <= 1.0) {
                    t = lowestRoot.root;
                    found = true;
                    this._edge.scaleInPlace(f);
                    p2.addToRef(this._edge, this._collisionPoint);
                }
            }
            p1.subtractToRef(p3, this._edge);
            p3.subtractToRef(this._basePoint, this._baseToVertex);
            edgeSquaredLength = this._edge.lengthSquared();
            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);
            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);
            a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;
            b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;
            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
            lowestRoot = getLowestRoot(a, b, c, t);
            if (lowestRoot.found) {
                f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;
                if (f >= 0.0 && f <= 1.0) {
                    t = lowestRoot.root;
                    found = true;
                    this._edge.scaleInPlace(f);
                    p3.addToRef(this._edge, this._collisionPoint);
                }
            }
        }
        if (found) {
            var distToCollision = t * this._velocity.length();
            if (!this.collisionFound || distToCollision < this._nearestDistance) {
                if (!this.intersectionPoint) {
                    this.intersectionPoint = this._collisionPoint.clone();
                }
                else {
                    this.intersectionPoint.copyFrom(this._collisionPoint);
                }
                this._nearestDistance = distToCollision;
                this.collisionFound = true;
            }
        }
    };
    /** @hidden */
    Collider.prototype._collide = function (trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial) {
        for (var i = indexStart; i < indexEnd; i += 3) {
            var p1 = pts[indices[i] - decal];
            var p2 = pts[indices[i + 1] - decal];
            var p3 = pts[indices[i + 2] - decal];
            this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial);
        }
    };
    /** @hidden */
    Collider.prototype._getResponse = function (pos, vel) {
        pos.addToRef(vel, this._destinationPoint);
        vel.scaleInPlace((this._nearestDistance / vel.length()));
        this._basePoint.addToRef(vel, pos);
        pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);
        this._slidePlaneNormal.normalize();
        this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);
        pos.addInPlace(this._displacementVector);
        this.intersectionPoint.addInPlace(this._displacementVector);
        this._slidePlaneNormal.scaleInPlace(Plane$1.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));
        this._destinationPoint.subtractInPlace(this._slidePlaneNormal);
        this._destinationPoint.subtractToRef(this.intersectionPoint, vel);
    };
    return Collider;
}());

/** @hidden */
var DefaultCollisionCoordinator = /** @class */ (function () {
    function DefaultCollisionCoordinator() {
        this._scaledPosition = Vector3.Zero();
        this._scaledVelocity = Vector3.Zero();
        this._finalPosition = Vector3.Zero();
    }
    DefaultCollisionCoordinator.prototype.getNewPosition = function (position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {
        position.divideToRef(collider._radius, this._scaledPosition);
        displacement.divideToRef(collider._radius, this._scaledVelocity);
        collider.collidedMesh = null;
        collider._retry = 0;
        collider._initialVelocity = this._scaledVelocity;
        collider._initialPosition = this._scaledPosition;
        this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);
        this._finalPosition.multiplyInPlace(collider._radius);
        //run the callback
        onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);
    };
    DefaultCollisionCoordinator.prototype.createCollider = function () {
        return new Collider();
    };
    DefaultCollisionCoordinator.prototype.init = function (scene) {
        this._scene = scene;
    };
    DefaultCollisionCoordinator.prototype._collideWithWorld = function (position, velocity, collider, maximumRetry, finalPosition, excludedMesh) {
        if (excludedMesh === void 0) { excludedMesh = null; }
        var closeDistance = Engine.CollisionsEpsilon * 10.0;
        if (collider._retry >= maximumRetry) {
            finalPosition.copyFrom(position);
            return;
        }
        // Check if this is a mesh else camera or -1
        var collisionMask = (excludedMesh ? excludedMesh.collisionMask : collider.collisionMask);
        collider._initialize(position, velocity, closeDistance);
        // Check all meshes
        for (var index = 0; index < this._scene.meshes.length; index++) {
            var mesh = this._scene.meshes[index];
            if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && ((collisionMask & mesh.collisionGroup) !== 0)) {
                mesh._checkCollision(collider);
            }
        }
        if (!collider.collisionFound) {
            position.addToRef(velocity, finalPosition);
            return;
        }
        if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {
            collider._getResponse(position, velocity);
        }
        if (velocity.length() <= closeDistance) {
            finalPosition.copyFrom(position);
            return;
        }
        collider._retry++;
        this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);
    };
    return DefaultCollisionCoordinator;
}());
Scene.CollisionCoordinatorFactory = function () {
    return new DefaultCollisionCoordinator();
};

/**
 * Class used to store a cell in an octree
 * @see http://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
 */
var OctreeBlock = /** @class */ (function () {
    /**
     * Creates a new block
     * @param minPoint defines the minimum vector (in world space) of the block's bounding box
     * @param maxPoint defines the maximum vector (in world space) of the block's bounding box
     * @param capacity defines the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)
     * @param depth defines the current depth of this block in the octree
     * @param maxDepth defines the maximal depth allowed (beyond this value, the capacity is ignored)
     * @param creationFunc defines a callback to call when an element is added to the block
     */
    function OctreeBlock(minPoint, maxPoint, capacity, depth, maxDepth, creationFunc) {
        /**
         * Gets the content of the current block
         */
        this.entries = new Array();
        this._boundingVectors = new Array();
        this._capacity = capacity;
        this._depth = depth;
        this._maxDepth = maxDepth;
        this._creationFunc = creationFunc;
        this._minPoint = minPoint;
        this._maxPoint = maxPoint;
        this._boundingVectors.push(minPoint.clone());
        this._boundingVectors.push(maxPoint.clone());
        this._boundingVectors.push(minPoint.clone());
        this._boundingVectors[2].x = maxPoint.x;
        this._boundingVectors.push(minPoint.clone());
        this._boundingVectors[3].y = maxPoint.y;
        this._boundingVectors.push(minPoint.clone());
        this._boundingVectors[4].z = maxPoint.z;
        this._boundingVectors.push(maxPoint.clone());
        this._boundingVectors[5].z = minPoint.z;
        this._boundingVectors.push(maxPoint.clone());
        this._boundingVectors[6].x = minPoint.x;
        this._boundingVectors.push(maxPoint.clone());
        this._boundingVectors[7].y = minPoint.y;
    }
    Object.defineProperty(OctreeBlock.prototype, "capacity", {
        // Property
        /**
         * Gets the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)
         */
        get: function () {
            return this._capacity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OctreeBlock.prototype, "minPoint", {
        /**
         * Gets the minimum vector (in world space) of the block's bounding box
         */
        get: function () {
            return this._minPoint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OctreeBlock.prototype, "maxPoint", {
        /**
         * Gets the maximum vector (in world space) of the block's bounding box
         */
        get: function () {
            return this._maxPoint;
        },
        enumerable: true,
        configurable: true
    });
    // Methods
    /**
     * Add a new element to this block
     * @param entry defines the element to add
     */
    OctreeBlock.prototype.addEntry = function (entry) {
        if (this.blocks) {
            for (var index = 0; index < this.blocks.length; index++) {
                var block = this.blocks[index];
                block.addEntry(entry);
            }
            return;
        }
        this._creationFunc(entry, this);
        if (this.entries.length > this.capacity && this._depth < this._maxDepth) {
            this.createInnerBlocks();
        }
    };
    /**
     * Remove an element from this block
     * @param entry defines the element to remove
     */
    OctreeBlock.prototype.removeEntry = function (entry) {
        if (this.blocks) {
            for (var index = 0; index < this.blocks.length; index++) {
                var block = this.blocks[index];
                block.removeEntry(entry);
            }
            return;
        }
        var entryIndex = this.entries.indexOf(entry);
        if (entryIndex > -1) {
            this.entries.splice(entryIndex, 1);
        }
    };
    /**
     * Add an array of elements to this block
     * @param entries defines the array of elements to add
     */
    OctreeBlock.prototype.addEntries = function (entries) {
        for (var index = 0; index < entries.length; index++) {
            var mesh = entries[index];
            this.addEntry(mesh);
        }
    };
    /**
     * Test if the current block intersects the furstum planes and if yes, then add its content to the selection array
     * @param frustumPlanes defines the frustum planes to test
     * @param selection defines the array to store current content if selection is positive
     * @param allowDuplicate defines if the selection array can contains duplicated entries
     */
    OctreeBlock.prototype.select = function (frustumPlanes, selection, allowDuplicate) {
        if (BoundingBox.IsInFrustum(this._boundingVectors, frustumPlanes)) {
            if (this.blocks) {
                for (var index = 0; index < this.blocks.length; index++) {
                    var block = this.blocks[index];
                    block.select(frustumPlanes, selection, allowDuplicate);
                }
                return;
            }
            if (allowDuplicate) {
                selection.concat(this.entries);
            }
            else {
                selection.concatWithNoDuplicate(this.entries);
            }
        }
    };
    /**
     * Test if the current block intersect with the given bounding sphere and if yes, then add its content to the selection array
     * @param sphereCenter defines the bounding sphere center
     * @param sphereRadius defines the bounding sphere radius
     * @param selection defines the array to store current content if selection is positive
     * @param allowDuplicate defines if the selection array can contains duplicated entries
     */
    OctreeBlock.prototype.intersects = function (sphereCenter, sphereRadius, selection, allowDuplicate) {
        if (BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, sphereCenter, sphereRadius)) {
            if (this.blocks) {
                for (var index = 0; index < this.blocks.length; index++) {
                    var block = this.blocks[index];
                    block.intersects(sphereCenter, sphereRadius, selection, allowDuplicate);
                }
                return;
            }
            if (allowDuplicate) {
                selection.concat(this.entries);
            }
            else {
                selection.concatWithNoDuplicate(this.entries);
            }
        }
    };
    /**
     * Test if the current block intersect with the given ray and if yes, then add its content to the selection array
     * @param ray defines the ray to test with
     * @param selection defines the array to store current content if selection is positive
     */
    OctreeBlock.prototype.intersectsRay = function (ray, selection) {
        if (ray.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {
            if (this.blocks) {
                for (var index = 0; index < this.blocks.length; index++) {
                    var block = this.blocks[index];
                    block.intersectsRay(ray, selection);
                }
                return;
            }
            selection.concatWithNoDuplicate(this.entries);
        }
    };
    /**
     * Subdivide the content into child blocks (this block will then be empty)
     */
    OctreeBlock.prototype.createInnerBlocks = function () {
        OctreeBlock._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc);
    };
    /**
     * @hidden
     */
    OctreeBlock._CreateBlocks = function (worldMin, worldMax, entries, maxBlockCapacity, currentDepth, maxDepth, target, creationFunc) {
        target.blocks = new Array();
        var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
        // Segmenting space
        for (var x = 0; x < 2; x++) {
            for (var y = 0; y < 2; y++) {
                for (var z = 0; z < 2; z++) {
                    var localMin = worldMin.add(blockSize.multiplyByFloats(x, y, z));
                    var localMax = worldMin.add(blockSize.multiplyByFloats(x + 1, y + 1, z + 1));
                    var block = new OctreeBlock(localMin, localMax, maxBlockCapacity, currentDepth + 1, maxDepth, creationFunc);
                    block.addEntries(entries);
                    target.blocks.push(block);
                }
            }
        }
    };
    return OctreeBlock;
}());

/**
 * Octrees are a really powerful data structure that can quickly select entities based on space coordinates.
 * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
 */
var Octree = /** @class */ (function () {
    /**
     * Creates a octree
     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
     * @param creationFunc function to be used to instatiate the octree
     * @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)
     * @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)
     */
    function Octree(creationFunc, maxBlockCapacity, 
    /** Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) */
    maxDepth) {
        if (maxDepth === void 0) { maxDepth = 2; }
        this.maxDepth = maxDepth;
        /**
         * Content stored in the octree
         */
        this.dynamicContent = new Array();
        this._maxBlockCapacity = maxBlockCapacity || 64;
        this._selectionContent = new SmartArrayNoDuplicate(1024);
        this._creationFunc = creationFunc;
    }
    // Methods
    /**
     * Updates the octree by adding blocks for the passed in meshes within the min and max world parameters
     * @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
     * @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
     * @param entries meshes to be added to the octree blocks
     */
    Octree.prototype.update = function (worldMin, worldMax, entries) {
        OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);
    };
    /**
     * Adds a mesh to the octree
     * @param entry Mesh to add to the octree
     */
    Octree.prototype.addMesh = function (entry) {
        for (var index = 0; index < this.blocks.length; index++) {
            var block = this.blocks[index];
            block.addEntry(entry);
        }
    };
    /**
     * Remove an element from the octree
     * @param entry defines the element to remove
     */
    Octree.prototype.removeMesh = function (entry) {
        for (var index = 0; index < this.blocks.length; index++) {
            var block = this.blocks[index];
            block.removeEntry(entry);
        }
    };
    /**
     * Selects an array of meshes within the frustum
     * @param frustumPlanes The frustum planes to use which will select all meshes within it
     * @param allowDuplicate If duplicate objects are allowed in the resulting object array
     * @returns array of meshes within the frustum
     */
    Octree.prototype.select = function (frustumPlanes, allowDuplicate) {
        this._selectionContent.reset();
        for (var index = 0; index < this.blocks.length; index++) {
            var block = this.blocks[index];
            block.select(frustumPlanes, this._selectionContent, allowDuplicate);
        }
        if (allowDuplicate) {
            this._selectionContent.concat(this.dynamicContent);
        }
        else {
            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
        }
        return this._selectionContent;
    };
    /**
     * Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array
     * @param sphereCenter defines the bounding sphere center
     * @param sphereRadius defines the bounding sphere radius
     * @param allowDuplicate defines if the selection array can contains duplicated entries
     * @returns an array of objects that intersect the sphere
     */
    Octree.prototype.intersects = function (sphereCenter, sphereRadius, allowDuplicate) {
        this._selectionContent.reset();
        for (var index = 0; index < this.blocks.length; index++) {
            var block = this.blocks[index];
            block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);
        }
        if (allowDuplicate) {
            this._selectionContent.concat(this.dynamicContent);
        }
        else {
            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
        }
        return this._selectionContent;
    };
    /**
    * Test if the octree intersect with the given ray and if yes, then add its content to resulting array
     * @param ray defines the ray to test with
     * @returns array of intersected objects
     */
    Octree.prototype.intersectsRay = function (ray) {
        this._selectionContent.reset();
        for (var index = 0; index < this.blocks.length; index++) {
            var block = this.blocks[index];
            block.intersectsRay(ray, this._selectionContent);
        }
        this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
        return this._selectionContent;
    };
    /**
     * Adds a mesh into the octree block if it intersects the block
     */
    Octree.CreationFuncForMeshes = function (entry, block) {
        var boundingInfo = entry.getBoundingInfo();
        if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {
            block.entries.push(entry);
        }
    };
    /**
     * Adds a submesh into the octree block if it intersects the block
     */
    Octree.CreationFuncForSubMeshes = function (entry, block) {
        var boundingInfo = entry.getBoundingInfo();
        if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {
            block.entries.push(entry);
        }
    };
    return Octree;
}());

Scene.prototype.createOrUpdateSelectionOctree = function (maxCapacity, maxDepth) {
    if (maxCapacity === void 0) { maxCapacity = 64; }
    if (maxDepth === void 0) { maxDepth = 2; }
    var component = this._getComponent(SceneComponentConstants.NAME_OCTREE);
    if (!component) {
        component = new OctreeSceneComponent(this);
        this._addComponent(component);
    }
    if (!this._selectionOctree) {
        this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);
    }
    var worldExtends = this.getWorldExtends();
    // Update octree
    this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);
    return this._selectionOctree;
};
Object.defineProperty(Scene.prototype, "selectionOctree", {
    get: function () {
        return this._selectionOctree;
    },
    enumerable: true,
    configurable: true
});
/**
 * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.
 * Please note that you must have a decent number of submeshes to get performance improvements when using an octree
 * @param maxCapacity defines the maximum size of each block (64 by default)
 * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)
 * @returns the new octree
 * @see https://www.babylonjs-playground.com/#NA4OQ#12
 * @see http://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
 */
AbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity, maxDepth) {
    if (maxCapacity === void 0) { maxCapacity = 64; }
    if (maxDepth === void 0) { maxDepth = 2; }
    var scene = this.getScene();
    var component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);
    if (!component) {
        component = new OctreeSceneComponent(scene);
        scene._addComponent(component);
    }
    if (!this._submeshesOctree) {
        this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);
    }
    this.computeWorldMatrix(true);
    var boundingInfo = this.getBoundingInfo();
    // Update octree
    var bbox = boundingInfo.boundingBox;
    this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);
    return this._submeshesOctree;
};
/**
 * Defines the octree scene component responsible to manage any octrees
 * in a given scene.
 */
var OctreeSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function OctreeSceneComponent(scene) {
        /**
         * The component name help to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_OCTREE;
        /**
         * Indicates if the meshes have been checked to make sure they are isEnabled()
         */
        this.checksIsEnabled = true;
        this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));
        this.scene = scene;
        this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);
        this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);
        this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);
        this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);
    }
    /**
     * Registers the component in a given scene
     */
    OctreeSceneComponent.prototype.register = function () {
        var _this = this;
        this.scene.onMeshRemovedObservable.add(function (mesh) {
            var sceneOctree = _this.scene.selectionOctree;
            if (sceneOctree !== undefined && sceneOctree !== null) {
                var index = sceneOctree.dynamicContent.indexOf(mesh);
                if (index !== -1) {
                    sceneOctree.dynamicContent.splice(index, 1);
                }
            }
        });
        this.scene.onMeshImportedObservable.add(function (mesh) {
            var sceneOctree = _this.scene.selectionOctree;
            if (sceneOctree !== undefined && sceneOctree !== null) {
                sceneOctree.addMesh(mesh);
            }
        });
    };
    /**
     * Return the list of active meshes
     * @returns the list of active meshes
     */
    OctreeSceneComponent.prototype.getActiveMeshCandidates = function () {
        if (this.scene._selectionOctree) {
            var selection = this.scene._selectionOctree.select(this.scene.frustumPlanes);
            return selection;
        }
        return this.scene._getDefaultMeshCandidates();
    };
    /**
     * Return the list of active sub meshes
     * @param mesh The mesh to get the candidates sub meshes from
     * @returns the list of active sub meshes
     */
    OctreeSceneComponent.prototype.getActiveSubMeshCandidates = function (mesh) {
        if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {
            var intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);
            return intersections;
        }
        return this.scene._getDefaultSubMeshCandidates(mesh);
    };
    /**
     * Return the list of sub meshes intersecting with a given local ray
     * @param mesh defines the mesh to find the submesh for
     * @param localRay defines the ray in local space
     * @returns the list of intersecting sub meshes
     */
    OctreeSceneComponent.prototype.getIntersectingSubMeshCandidates = function (mesh, localRay) {
        if (mesh._submeshesOctree && mesh.useOctreeForPicking) {
            Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);
            var intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);
            return intersections;
        }
        return this.scene._getDefaultSubMeshCandidates(mesh);
    };
    /**
     * Return the list of sub meshes colliding with a collider
     * @param mesh defines the mesh to find the submesh for
     * @param collider defines the collider to evaluate the collision against
     * @returns the list of colliding sub meshes
     */
    OctreeSceneComponent.prototype.getCollidingSubMeshCandidates = function (mesh, collider) {
        if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {
            var radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);
            var intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);
            return intersections;
        }
        return this.scene._getDefaultSubMeshCandidates(mesh);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    OctreeSceneComponent.prototype.rebuild = function () {
        // Nothing to do here.
    };
    /**
     * Disposes the component and the associated ressources.
     */
    OctreeSceneComponent.prototype.dispose = function () {
        // Nothing to do here.
    };
    return OctreeSceneComponent;
}());

/**
 * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.
 */
var Gizmo = /** @class */ (function () {
    /**
     * Creates a gizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     */
    function Gizmo(
    /** The utility layer the gizmo will be added to */
    gizmoLayer) {
        var _this = this;
        if (gizmoLayer === void 0) { gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer; }
        this.gizmoLayer = gizmoLayer;
        this._attachedMesh = null;
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        this.scaleRatio = 1;
        /**
         * If a custom mesh has been set (Default: false)
         */
        this._customMeshSet = false;
        /**
         * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
         */
        this.updateGizmoRotationToMatchAttachedMesh = true;
        /**
         * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)
         */
        this.updateGizmoPositionToMatchAttachedMesh = true;
        /**
         * When set, the gizmo will always appear the same size no matter where the camera is (default: false)
         */
        this._updateScale = true;
        this._interactionsEnabled = true;
        this._tempVector = new Vector3();
        this._rootMesh = new Mesh("gizmoRootNode", gizmoLayer.utilityLayerScene);
        this._rootMesh.rotationQuaternion = Quaternion.Identity();
        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(function () {
            _this._update();
        });
    }
    Object.defineProperty(Gizmo.prototype, "attachedMesh", {
        /**
         * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)
         * * When set, interactions will be enabled
         */
        get: function () {
            return this._attachedMesh;
        },
        set: function (value) {
            this._attachedMesh = value;
            this._rootMesh.setEnabled(value ? true : false);
            this._attachedMeshChanged(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes and replaces the current meshes in the gizmo with the specified mesh
     * @param mesh The mesh to replace the default mesh of the gizmo
     */
    Gizmo.prototype.setCustomMesh = function (mesh) {
        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {
            throw "When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";
        }
        this._rootMesh.getChildMeshes().forEach(function (c) {
            c.dispose();
        });
        mesh.parent = this._rootMesh;
        this._customMeshSet = true;
    };
    Gizmo.prototype._attachedMeshChanged = function (value) {
    };
    /**
     * Updates the gizmo to match the attached mesh's position/rotation
     */
    Gizmo.prototype._update = function () {
        if (this.attachedMesh) {
            var effectiveMesh = this.attachedMesh._effectiveMesh || this.attachedMesh;
            // Position
            if (this.updateGizmoPositionToMatchAttachedMesh) {
                this._rootMesh.position.copyFrom(effectiveMesh.absolutePosition);
            }
            // Rotation
            if (this.updateGizmoRotationToMatchAttachedMesh) {
                effectiveMesh.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion);
            }
            else {
                this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);
            }
            // Scale
            if (this._updateScale) {
                var activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;
                var cameraPosition = activeCamera.globalPosition;
                if (activeCamera.devicePosition) {
                    cameraPosition = activeCamera.devicePosition;
                }
                this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);
                var dist = this._tempVector.length() * this.scaleRatio;
                this._rootMesh.scaling.set(dist, dist, dist);
                // Account for handedness, similar to Matrix.decompose
                if (effectiveMesh._getWorldMatrixDeterminant() < 0) {
                    this._rootMesh.scaling.y *= -1;
                }
            }
        }
    };
    /**
     * Disposes of the gizmo
     */
    Gizmo.prototype.dispose = function () {
        this._rootMesh.dispose();
        if (this._beforeRenderObserver) {
            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
        }
    };
    return Gizmo;
}());

/**
 * Single axis drag gizmo
 */
var AxisDragGizmo = /** @class */ (function (_super) {
    __extends(AxisDragGizmo, _super);
    /**
     * Creates an AxisDragGizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     * @param dragAxis The axis which the gizmo will be able to drag on
     * @param color The color of the gizmo
     */
    function AxisDragGizmo(dragAxis, color, gizmoLayer) {
        if (color === void 0) { color = Color3.Gray(); }
        if (gizmoLayer === void 0) { gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer; }
        var _this = _super.call(this, gizmoLayer) || this;
        _this._pointerObserver = null;
        /**
         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        _this.snapDistance = 0;
        /**
         * Event that fires each time the gizmo snaps to a new location.
         * * snapDistance is the the change in distance
         */
        _this.onSnapObservable = new Observable();
        // Create Material
        var coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        coloredMaterial.diffuseColor = color;
        coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
        var hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        hoverMaterial.diffuseColor = color.add(new Color3(0.3, 0.3, 0.3));
        // Build mesh on root node
        var arrow = AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, coloredMaterial);
        arrow.lookAt(_this._rootMesh.position.add(dragAxis));
        arrow.scaling.scaleInPlace(1 / 3);
        arrow.parent = _this._rootMesh;
        var currentSnapDragDistance = 0;
        var tmpVector = new Vector3();
        var tmpSnapEvent = { snapDistance: 0 };
        // Add drag behavior to handle events when the gizmo is dragged
        _this.dragBehavior = new PointerDragBehavior({ dragAxis: dragAxis });
        _this.dragBehavior.moveAttached = false;
        _this._rootMesh.addBehavior(_this.dragBehavior);
        var localDelta = new Vector3();
        var tmpMatrix = new Matrix();
        _this.dragBehavior.onDragObservable.add(function (event) {
            if (_this.attachedMesh) {
                // Convert delta to local translation if it has a parent
                if (_this.attachedMesh.parent) {
                    _this.attachedMesh.parent.computeWorldMatrix().invertToRef(tmpMatrix);
                    tmpMatrix.setTranslationFromFloats(0, 0, 0);
                    Vector3.TransformCoordinatesToRef(event.delta, tmpMatrix, localDelta);
                }
                else {
                    localDelta.copyFrom(event.delta);
                }
                // Snapping logic
                if (_this.snapDistance == 0) {
                    _this.attachedMesh.position.addInPlace(localDelta);
                }
                else {
                    currentSnapDragDistance += event.dragDistance;
                    if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {
                        var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);
                        currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;
                        localDelta.normalizeToRef(tmpVector);
                        tmpVector.scaleInPlace(_this.snapDistance * dragSteps);
                        _this.attachedMesh.position.addInPlace(tmpVector);
                        tmpSnapEvent.snapDistance = _this.snapDistance * dragSteps;
                        _this.onSnapObservable.notifyObservers(tmpSnapEvent);
                    }
                }
            }
        });
        _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {
            if (_this._customMeshSet) {
                return;
            }
            var isHovered = pointerInfo.pickInfo && (_this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);
            var material = isHovered ? hoverMaterial : coloredMaterial;
            _this._rootMesh.getChildMeshes().forEach(function (m) {
                m.material = material;
                if (m.color) {
                    m.color = material.diffuseColor;
                }
            });
        });
        var light = gizmoLayer._getSharedGizmoLight();
        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));
        return _this;
    }
    /** @hidden */
    AxisDragGizmo._CreateArrow = function (scene, material) {
        var arrow = new TransformNode("arrow", scene);
        var cylinder = CylinderBuilder.CreateCylinder("cylinder", { diameterTop: 0, height: 0.075, diameterBottom: 0.0375, tessellation: 96 }, scene);
        var line = CylinderBuilder.CreateCylinder("cylinder", { diameterTop: 0.005, height: 0.275, diameterBottom: 0.005, tessellation: 96 }, scene);
        line.material = material;
        cylinder.parent = arrow;
        line.parent = arrow;
        // Position arrow pointing in its drag axis
        cylinder.material = material;
        cylinder.rotation.x = Math.PI / 2;
        cylinder.position.z += 0.3;
        line.position.z += 0.275 / 2;
        line.rotation.x = Math.PI / 2;
        return arrow;
    };
    /** @hidden */
    AxisDragGizmo._CreateArrowInstance = function (scene, arrow) {
        var instance = new TransformNode("arrow", scene);
        for (var _i = 0, _a = arrow.getChildMeshes(); _i < _a.length; _i++) {
            var mesh = _a[_i];
            var childInstance = mesh.createInstance(mesh.name);
            childInstance.parent = instance;
        }
        return instance;
    };
    AxisDragGizmo.prototype._attachedMeshChanged = function (value) {
        if (this.dragBehavior) {
            this.dragBehavior.enabled = value ? true : false;
        }
    };
    /**
     * Disposes of the gizmo
     */
    AxisDragGizmo.prototype.dispose = function () {
        this.onSnapObservable.clear();
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this.dragBehavior.detach();
        _super.prototype.dispose.call(this);
    };
    return AxisDragGizmo;
}(Gizmo));

/**
     * The Axes viewer will show 3 axes in a specific point in space
     */
var AxesViewer = /** @class */ (function () {
    /**
     * Creates a new AxesViewer
     * @param scene defines the hosting scene
     * @param scaleLines defines a number used to scale line length (1 by default)
     * @param renderingGroupId defines a number used to set the renderingGroupId of the meshes (2 by default)
     * @param xAxis defines the node hierarchy used to render the x-axis
     * @param yAxis defines the node hierarchy used to render the y-axis
     * @param zAxis defines the node hierarchy used to render the z-axis
     */
    function AxesViewer(scene, scaleLines, renderingGroupId, xAxis, yAxis, zAxis) {
        if (scaleLines === void 0) { scaleLines = 1; }
        if (renderingGroupId === void 0) { renderingGroupId = 2; }
        this._scaleLinesFactor = 4;
        this._instanced = false;
        /**
         * Gets or sets a number used to scale line length
         */
        this.scaleLines = 1;
        this.scaleLines = scaleLines;
        if (!xAxis) {
            var redColoredMaterial = new StandardMaterial("", scene);
            redColoredMaterial.disableLighting = true;
            redColoredMaterial.emissiveColor = Color3.Red().scale(0.5);
            xAxis = AxisDragGizmo._CreateArrow(scene, redColoredMaterial);
        }
        if (!yAxis) {
            var greenColoredMaterial = new StandardMaterial("", scene);
            greenColoredMaterial.disableLighting = true;
            greenColoredMaterial.emissiveColor = Color3.Green().scale(0.5);
            yAxis = AxisDragGizmo._CreateArrow(scene, greenColoredMaterial);
        }
        if (!zAxis) {
            var blueColoredMaterial = new StandardMaterial("", scene);
            blueColoredMaterial.disableLighting = true;
            blueColoredMaterial.emissiveColor = Color3.Blue().scale(0.5);
            zAxis = AxisDragGizmo._CreateArrow(scene, blueColoredMaterial);
        }
        this._xAxis = xAxis;
        this._xAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
        this._yAxis = yAxis;
        this._yAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
        this._zAxis = zAxis;
        this._zAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
        if (renderingGroupId != null) {
            AxesViewer._SetRenderingGroupId(this._xAxis, renderingGroupId);
            AxesViewer._SetRenderingGroupId(this._yAxis, renderingGroupId);
            AxesViewer._SetRenderingGroupId(this._zAxis, renderingGroupId);
        }
        this.scene = scene;
        this.update(new Vector3(), Vector3.Right(), Vector3.Up(), Vector3.Forward());
    }
    Object.defineProperty(AxesViewer.prototype, "xAxis", {
        /** Gets the node hierarchy used to render x-axis */
        get: function () {
            return this._xAxis;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxesViewer.prototype, "yAxis", {
        /** Gets the node hierarchy used to render y-axis */
        get: function () {
            return this._yAxis;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxesViewer.prototype, "zAxis", {
        /** Gets the node hierarchy used to render z-axis */
        get: function () {
            return this._zAxis;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Force the viewer to update
     * @param position defines the position of the viewer
     * @param xaxis defines the x axis of the viewer
     * @param yaxis defines the y axis of the viewer
     * @param zaxis defines the z axis of the viewer
     */
    AxesViewer.prototype.update = function (position, xaxis, yaxis, zaxis) {
        this._xAxis.position.copyFrom(position);
        this._xAxis.setDirection(xaxis);
        this._xAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
        this._yAxis.position.copyFrom(position);
        this._yAxis.setDirection(yaxis);
        this._yAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
        this._zAxis.position.copyFrom(position);
        this._zAxis.setDirection(zaxis);
        this._zAxis.scaling.setAll(this.scaleLines * this._scaleLinesFactor);
    };
    /**
     * Creates an instance of this axes viewer.
     * @returns a new axes viewer with instanced meshes
     */
    AxesViewer.prototype.createInstance = function () {
        var xAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._xAxis);
        var yAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._yAxis);
        var zAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._zAxis);
        var axesViewer = new AxesViewer(this.scene, this.scaleLines, null, xAxis, yAxis, zAxis);
        axesViewer._instanced = true;
        return axesViewer;
    };
    /** Releases resources */
    AxesViewer.prototype.dispose = function () {
        if (this._xAxis) {
            this._xAxis.dispose(false, !this._instanced);
            delete this._xAxis;
        }
        if (this._yAxis) {
            this._yAxis.dispose(false, !this._instanced);
            delete this._yAxis;
        }
        if (this._zAxis) {
            this._zAxis.dispose(false, !this._instanced);
            delete this._zAxis;
        }
        delete this.scene;
    };
    AxesViewer._SetRenderingGroupId = function (node, id) {
        node.getChildMeshes().forEach(function (mesh) {
            mesh.renderingGroupId = id;
        });
    };
    return AxesViewer;
}());

/**
     * The BoneAxesViewer will attach 3 axes to a specific bone of a specific mesh
     * @see demo here: https://www.babylonjs-playground.com/#0DE8F4#8
     */
var BoneAxesViewer = /** @class */ (function (_super) {
    __extends(BoneAxesViewer, _super);
    /**
     * Creates a new BoneAxesViewer
     * @param scene defines the hosting scene
     * @param bone defines the target bone
     * @param mesh defines the target mesh
     * @param scaleLines defines a scaling factor for line length (1 by default)
     */
    function BoneAxesViewer(scene, bone, mesh, scaleLines) {
        if (scaleLines === void 0) { scaleLines = 1; }
        var _this = _super.call(this, scene, scaleLines) || this;
        /** Gets current position */
        _this.pos = Vector3.Zero();
        /** Gets direction of X axis */
        _this.xaxis = Vector3.Zero();
        /** Gets direction of Y axis */
        _this.yaxis = Vector3.Zero();
        /** Gets direction of Z axis */
        _this.zaxis = Vector3.Zero();
        _this.mesh = mesh;
        _this.bone = bone;
        return _this;
    }
    /**
     * Force the viewer to update
     */
    BoneAxesViewer.prototype.update = function () {
        if (!this.mesh || !this.bone) {
            return;
        }
        var bone = this.bone;
        bone.getAbsolutePositionToRef(this.mesh, this.pos);
        bone.getDirectionToRef(Axis.X, this.mesh, this.xaxis);
        bone.getDirectionToRef(Axis.Y, this.mesh, this.yaxis);
        bone.getDirectionToRef(Axis.Z, this.mesh, this.zaxis);
        _super.prototype.update.call(this, this.pos, this.xaxis, this.yaxis, this.zaxis);
    };
    /** Releases resources */
    BoneAxesViewer.prototype.dispose = function () {
        if (this.mesh) {
            this.mesh = null;
            this.bone = null;
            _super.prototype.dispose.call(this);
        }
    };
    return BoneAxesViewer;
}(AxesViewer));

Object.defineProperty(Scene.prototype, "debugLayer", {
    get: function () {
        if (!this._debugLayer) {
            this._debugLayer = new DebugLayer(this);
        }
        return this._debugLayer;
    },
    enumerable: true,
    configurable: true
});
/**
 * The debug layer (aka Inspector) is the go to tool in order to better understand
 * what is happening in your scene
 * @see http://doc.babylonjs.com/features/playground_debuglayer
 */
var DebugLayer = /** @class */ (function () {
    /**
     * Instantiates a new debug layer.
     * The debug layer (aka Inspector) is the go to tool in order to better understand
     * what is happening in your scene
     * @see http://doc.babylonjs.com/features/playground_debuglayer
     * @param scene Defines the scene to inspect
     */
    function DebugLayer(scene) {
        var _this = this;
        this.BJSINSPECTOR = this._getGlobalInspector();
        /**
         * Observable triggered when a property is changed through the inspector.
         */
        this.onPropertyChangedObservable = new Observable();
        this._scene = scene;
        this._scene.onDisposeObservable.add(function () {
            // Debug layer
            if (_this._scene._debugLayer) {
                _this._scene._debugLayer.hide();
            }
        });
    }
    /** Creates the inspector window. */
    DebugLayer.prototype._createInspector = function (config) {
        if (this.isVisible()) {
            return;
        }
        var userOptions = __assign({ overlay: false, showExplorer: true, showInspector: true, embedMode: false, handleResize: true, enablePopup: true }, config);
        this.BJSINSPECTOR = this.BJSINSPECTOR || this._getGlobalInspector();
        this.BJSINSPECTOR.Inspector.Show(this._scene, userOptions);
    };
    /**
     * Select a specific entity in the scene explorer and highlight a specific block in that entity property grid
     * @param entity defines the entity to select
     * @param lineContainerTitle defines the specific block to highlight
     */
    DebugLayer.prototype.select = function (entity, lineContainerTitle) {
        if (this.BJSINSPECTOR) {
            this.BJSINSPECTOR.Inspector.MarkLineContainerTitleForHighlighting(lineContainerTitle);
            this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable.notifyObservers(entity);
        }
    };
    /** Get the inspector from bundle or global */
    DebugLayer.prototype._getGlobalInspector = function () {
        // UMD Global name detection from Webpack Bundle UMD Name.
        if (typeof INSPECTOR !== 'undefined') {
            return INSPECTOR;
        }
        // In case of module let s check the global emitted from the Inspector entry point.
        if (typeof BABYLON !== 'undefined' && typeof BABYLON.Inspector !== 'undefined') {
            return BABYLON;
        }
        return undefined;
    };
    /**
     * Get if the inspector is visible or not.
     * @returns true if visible otherwise, false
     */
    DebugLayer.prototype.isVisible = function () {
        return this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector.IsVisible;
    };
    /**
     * Hide the inspector and close its window.
     */
    DebugLayer.prototype.hide = function () {
        if (this.BJSINSPECTOR) {
            this.BJSINSPECTOR.Inspector.Hide();
        }
    };
    /**
      * Launch the debugLayer.
      * @param config Define the configuration of the inspector
      * @return a promise fulfilled when the debug layer is visible
      */
    DebugLayer.prototype.show = function (config) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof _this.BJSINSPECTOR == 'undefined') {
                var inspectorUrl = config && config.inspectorURL ? config.inspectorURL : DebugLayer.InspectorURL;
                // Load inspector and add it to the DOM
                Tools.LoadScript(inspectorUrl, function () {
                    _this._createInspector(config);
                    resolve(_this);
                });
            }
            else {
                // Otherwise creates the inspector
                _this._createInspector(config);
                resolve(_this);
            }
        });
    };
    /**
     * Define the url to get the inspector script from.
     * By default it uses the babylonjs CDN.
     * @ignoreNaming
     */
    DebugLayer.InspectorURL = "https://unpkg.com/babylonjs-inspector@" + Engine.Version + "/babylon.inspector.bundle.js";
    return DebugLayer;
}());

VertexData.CreateSphere = function (options) {
    var segments = options.segments || 32;
    var diameterX = options.diameterX || options.diameter || 1;
    var diameterY = options.diameterY || options.diameter || 1;
    var diameterZ = options.diameterZ || options.diameter || 1;
    var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;
    var slice = options.slice && (options.slice <= 0) ? 1.0 : options.slice || 1.0;
    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
    var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);
    var totalZRotationSteps = 2 + segments;
    var totalYRotationSteps = 2 * totalZRotationSteps;
    var indices = [];
    var positions = [];
    var normals = [];
    var uvs = [];
    for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
        var normalizedZ = zRotationStep / totalZRotationSteps;
        var angleZ = normalizedZ * Math.PI * slice;
        for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
            var normalizedY = yRotationStep / totalYRotationSteps;
            var angleY = normalizedY * Math.PI * 2 * arc;
            var rotationZ = Matrix.RotationZ(-angleZ);
            var rotationY = Matrix.RotationY(angleY);
            var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);
            var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);
            var vertex = complete.multiply(radius);
            var normal = complete.divide(radius).normalize();
            positions.push(vertex.x, vertex.y, vertex.z);
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(normalizedY, normalizedZ);
        }
        if (zRotationStep > 0) {
            var verticesCount = positions.length / 3;
            for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); (firstIndex + totalYRotationSteps + 2) < verticesCount; firstIndex++) {
                indices.push((firstIndex));
                indices.push((firstIndex + 1));
                indices.push(firstIndex + totalYRotationSteps + 1);
                indices.push((firstIndex + totalYRotationSteps + 1));
                indices.push((firstIndex + 1));
                indices.push((firstIndex + totalYRotationSteps + 2));
            }
        }
    }
    // Sides
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
    // Result
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    return vertexData;
};
Mesh.CreateSphere = function (name, segments, diameter, scene, updatable, sideOrientation) {
    var options = {
        segments: segments,
        diameterX: diameter,
        diameterY: diameter,
        diameterZ: diameter,
        sideOrientation: sideOrientation,
        updatable: updatable
    };
    return SphereBuilder.CreateSphere(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var SphereBuilder = /** @class */ (function () {
    function SphereBuilder() {
    }
    /**
     * Creates a sphere mesh
     * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
     * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)
     * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
     * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
     * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the sphere mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#sphere
     */
    SphereBuilder.CreateSphere = function (name, options, scene) {
        var sphere = new Mesh(name, scene);
        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        sphere._originalBuilderSideOrientation = options.sideOrientation;
        var vertexData = VertexData.CreateSphere(options);
        vertexData.applyToMesh(sphere, options.updatable);
        return sphere;
    };
    return SphereBuilder;
}());

/**
 * This is a holder class for the physics joint created by the physics plugin
 * It holds a set of functions to control the underlying joint
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
 */
var PhysicsJoint = /** @class */ (function () {
    /**
     * Initializes the physics joint
     * @param type The type of the physics joint
     * @param jointData The data for the physics joint
     */
    function PhysicsJoint(
    /**
     * The type of the physics joint
     */
    type, 
    /**
     * The data for the physics joint
     */
    jointData) {
        this.type = type;
        this.jointData = jointData;
        jointData.nativeParams = jointData.nativeParams || {};
    }
    Object.defineProperty(PhysicsJoint.prototype, "physicsJoint", {
        /**
         * Gets the physics joint
         */
        get: function () {
            return this._physicsJoint;
        },
        /**
         * Sets the physics joint
         */
        set: function (newJoint) {
            if (this._physicsJoint) ;
            this._physicsJoint = newJoint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsJoint.prototype, "physicsPlugin", {
        /**
         * Sets the physics plugin
         */
        set: function (physicsPlugin) {
            this._physicsPlugin = physicsPlugin;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Execute a function that is physics-plugin specific.
     * @param {Function} func the function that will be executed.
     *                        It accepts two parameters: the physics world and the physics joint
     */
    PhysicsJoint.prototype.executeNativeFunction = function (func) {
        func(this._physicsPlugin.world, this._physicsJoint);
    };
    //TODO check if the native joints are the same
    //Joint Types
    /**
     * Distance-Joint type
     */
    PhysicsJoint.DistanceJoint = 0;
    /**
     * Hinge-Joint type
     */
    PhysicsJoint.HingeJoint = 1;
    /**
     * Ball-and-Socket joint type
     */
    PhysicsJoint.BallAndSocketJoint = 2;
    /**
     * Wheel-Joint type
     */
    PhysicsJoint.WheelJoint = 3;
    /**
     * Slider-Joint type
     */
    PhysicsJoint.SliderJoint = 4;
    //OIMO
    /**
     * Prismatic-Joint type
     */
    PhysicsJoint.PrismaticJoint = 5;
    //
    /**
     * Universal-Joint type
     * ENERGY FTW! (compare with this - @see http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)
     */
    PhysicsJoint.UniversalJoint = 6;
    /**
     * Hinge-Joint 2 type
     */
    PhysicsJoint.Hinge2Joint = PhysicsJoint.WheelJoint;
    //Cannon
    /**
     * Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters
     */
    PhysicsJoint.PointToPointJoint = 8;
    //Cannon only at the moment
    /**
     * Spring-Joint type
     */
    PhysicsJoint.SpringJoint = 9;
    /**
     * Lock-Joint type
     */
    PhysicsJoint.LockJoint = 10;
    return PhysicsJoint;
}());
/**
 * A class representing a physics distance joint
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
 */
var DistanceJoint = /** @class */ (function (_super) {
    __extends(DistanceJoint, _super);
    /**
     *
     * @param jointData The data for the Distance-Joint
     */
    function DistanceJoint(jointData) {
        return _super.call(this, PhysicsJoint.DistanceJoint, jointData) || this;
    }
    /**
     * Update the predefined distance.
     * @param maxDistance The maximum preferred distance
     * @param minDistance The minimum preferred distance
     */
    DistanceJoint.prototype.updateDistance = function (maxDistance, minDistance) {
        this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);
    };
    return DistanceJoint;
}(PhysicsJoint));
/**
 * Represents a Motor-Enabled Joint
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
 */
var MotorEnabledJoint = /** @class */ (function (_super) {
    __extends(MotorEnabledJoint, _super);
    /**
     * Initializes the Motor-Enabled Joint
     * @param type The type of the joint
     * @param jointData The physica joint data for the joint
     */
    function MotorEnabledJoint(type, jointData) {
        return _super.call(this, type, jointData) || this;
    }
    /**
     * Set the motor values.
     * Attention, this function is plugin specific. Engines won't react 100% the same.
     * @param force the force to apply
     * @param maxForce max force for this motor.
     */
    MotorEnabledJoint.prototype.setMotor = function (force, maxForce) {
        this._physicsPlugin.setMotor(this, force || 0, maxForce);
    };
    /**
     * Set the motor's limits.
     * Attention, this function is plugin specific. Engines won't react 100% the same.
     * @param upperLimit The upper limit of the motor
     * @param lowerLimit The lower limit of the motor
     */
    MotorEnabledJoint.prototype.setLimit = function (upperLimit, lowerLimit) {
        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
    };
    return MotorEnabledJoint;
}(PhysicsJoint));
/**
 * This class represents a single physics Hinge-Joint
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
 */
var HingeJoint = /** @class */ (function (_super) {
    __extends(HingeJoint, _super);
    /**
     * Initializes the Hinge-Joint
     * @param jointData The joint data for the Hinge-Joint
     */
    function HingeJoint(jointData) {
        return _super.call(this, PhysicsJoint.HingeJoint, jointData) || this;
    }
    /**
     * Set the motor values.
     * Attention, this function is plugin specific. Engines won't react 100% the same.
     * @param {number} force the force to apply
     * @param {number} maxForce max force for this motor.
     */
    HingeJoint.prototype.setMotor = function (force, maxForce) {
        this._physicsPlugin.setMotor(this, force || 0, maxForce);
    };
    /**
     * Set the motor's limits.
     * Attention, this function is plugin specific. Engines won't react 100% the same.
     * @param upperLimit The upper limit of the motor
     * @param lowerLimit The lower limit of the motor
     */
    HingeJoint.prototype.setLimit = function (upperLimit, lowerLimit) {
        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
    };
    return HingeJoint;
}(MotorEnabledJoint));
/**
 * This class represents a dual hinge physics joint (same as wheel joint)
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
 */
var Hinge2Joint = /** @class */ (function (_super) {
    __extends(Hinge2Joint, _super);
    /**
     * Initializes the Hinge2-Joint
     * @param jointData The joint data for the Hinge2-Joint
     */
    function Hinge2Joint(jointData) {
        return _super.call(this, PhysicsJoint.Hinge2Joint, jointData) || this;
    }
    /**
    * Set the motor values.
    * Attention, this function is plugin specific. Engines won't react 100% the same.
    * @param {number} targetSpeed the speed the motor is to reach
    * @param {number} maxForce max force for this motor.
    * @param {motorIndex} the motor's index, 0 or 1.
    */
    Hinge2Joint.prototype.setMotor = function (targetSpeed, maxForce, motorIndex) {
        if (motorIndex === void 0) { motorIndex = 0; }
        this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);
    };
    /**
     * Set the motor limits.
     * Attention, this function is plugin specific. Engines won't react 100% the same.
     * @param {number} upperLimit the upper limit
     * @param {number} lowerLimit lower limit
     * @param {motorIndex} the motor's index, 0 or 1.
     */
    Hinge2Joint.prototype.setLimit = function (upperLimit, lowerLimit, motorIndex) {
        if (motorIndex === void 0) { motorIndex = 0; }
        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);
    };
    return Hinge2Joint;
}(MotorEnabledJoint));

Mesh._PhysicsImpostorParser = function (scene, physicObject, jsonObject) {
    return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {
        mass: jsonObject.physicsMass,
        friction: jsonObject.physicsFriction,
        restitution: jsonObject.physicsRestitution
    }, scene);
};
/**
 * Represents a physics imposter
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
 */
var PhysicsImpostor = /** @class */ (function () {
    /**
     * Initializes the physics imposter
     * @param object The physics-enabled object used as the physics imposter
     * @param type The type of the physics imposter
     * @param _options The options for the physics imposter
     * @param _scene The Babylon scene
     */
    function PhysicsImpostor(
    /**
     * The physics-enabled object used as the physics imposter
     */
    object, 
    /**
     * The type of the physics imposter
     */
    type, _options, _scene) {
        var _this = this;
        if (_options === void 0) { _options = { mass: 0 }; }
        this.object = object;
        this.type = type;
        this._options = _options;
        this._scene = _scene;
        /** @hidden */
        this._pluginData = {};
        this._bodyUpdateRequired = false;
        this._onBeforePhysicsStepCallbacks = new Array();
        this._onAfterPhysicsStepCallbacks = new Array();
        /** @hidden */
        this._onPhysicsCollideCallbacks = [];
        this._deltaPosition = Vector3.Zero();
        this._isDisposed = false;
        /**
         * @hidden
         */
        this.soft = false;
        /**
         * @hidden
         */
        this.segments = 0;
        //temp variables for parent rotation calculations
        //private _mats: Array<Matrix> = [new Matrix(), new Matrix()];
        this._tmpQuat = new Quaternion();
        this._tmpQuat2 = new Quaternion();
        /**
         * this function is executed by the physics engine.
         */
        this.beforeStep = function () {
            if (!_this._physicsEngine) {
                return;
            }
            _this.object.translate(_this._deltaPosition, -1);
            _this._deltaRotationConjugated && _this.object.rotationQuaternion && _this.object.rotationQuaternion.multiplyToRef(_this._deltaRotationConjugated, _this.object.rotationQuaternion);
            _this.object.computeWorldMatrix(false);
            if (_this.object.parent && _this.object.rotationQuaternion) {
                _this.getParentsRotation();
                _this._tmpQuat.multiplyToRef(_this.object.rotationQuaternion, _this._tmpQuat);
            }
            else {
                _this._tmpQuat.copyFrom(_this.object.rotationQuaternion || new Quaternion());
            }
            if (!_this._options.disableBidirectionalTransformation) {
                _this.object.rotationQuaternion && _this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(_this, /*bInfo.boundingBox.centerWorld*/ _this.object.getAbsolutePosition(), _this._tmpQuat);
            }
            _this._onBeforePhysicsStepCallbacks.forEach(function (func) {
                func(_this);
            });
        };
        /**
         * this function is executed by the physics engine
         */
        this.afterStep = function () {
            if (!_this._physicsEngine) {
                return;
            }
            _this._onAfterPhysicsStepCallbacks.forEach(function (func) {
                func(_this);
            });
            _this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(_this);
            // object has now its world rotation. needs to be converted to local.
            if (_this.object.parent && _this.object.rotationQuaternion) {
                _this.getParentsRotation();
                _this._tmpQuat.conjugateInPlace();
                _this._tmpQuat.multiplyToRef(_this.object.rotationQuaternion, _this.object.rotationQuaternion);
            }
            // take the position set and make it the absolute position of this object.
            _this.object.setAbsolutePosition(_this.object.position);
            _this._deltaRotation && _this.object.rotationQuaternion && _this.object.rotationQuaternion.multiplyToRef(_this._deltaRotation, _this.object.rotationQuaternion);
            _this.object.translate(_this._deltaPosition, 1);
        };
        /**
         * Legacy collision detection event support
         */
        this.onCollideEvent = null;
        /**
         * event and body object due to cannon's event-based architecture.
         */
        this.onCollide = function (e) {
            if (!_this._onPhysicsCollideCallbacks.length && !_this.onCollideEvent) {
                return;
            }
            if (!_this._physicsEngine) {
                return;
            }
            var otherImpostor = _this._physicsEngine.getImpostorWithPhysicsBody(e.body);
            if (otherImpostor) {
                // Legacy collision detection event support
                if (_this.onCollideEvent) {
                    _this.onCollideEvent(_this, otherImpostor);
                }
                _this._onPhysicsCollideCallbacks.filter(function (obj) {
                    return obj.otherImpostors.indexOf(otherImpostor) !== -1;
                }).forEach(function (obj) {
                    obj.callback(_this, otherImpostor);
                });
            }
        };
        //sanity check!
        if (!this.object) {
            Logger.Error("No object was provided. A physics object is obligatory");
            return;
        }
        // Legacy support for old syntax.
        if (!this._scene && object.getScene) {
            this._scene = object.getScene();
        }
        if (!this._scene) {
            return;
        }
        if (this.type > 100) {
            this.soft = true;
        }
        this._physicsEngine = this._scene.getPhysicsEngine();
        if (!this._physicsEngine) {
            Logger.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.");
        }
        else {
            //set the object's quaternion, if not set
            if (!this.object.rotationQuaternion) {
                if (this.object.rotation) {
                    this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);
                }
                else {
                    this.object.rotationQuaternion = new Quaternion();
                }
            }
            //default options params
            this._options.mass = (_options.mass === void 0) ? 0 : _options.mass;
            this._options.friction = (_options.friction === void 0) ? 0.2 : _options.friction;
            this._options.restitution = (_options.restitution === void 0) ? 0.2 : _options.restitution;
            if (this.soft) {
                //softbody mass must be above 0;
                this._options.mass = this._options.mass > 0 ? this._options.mass : 1;
                this._options.pressure = (_options.pressure === void 0) ? 200 : _options.pressure;
                this._options.stiffness = (_options.stiffness === void 0) ? 1 : _options.stiffness;
                this._options.velocityIterations = (_options.velocityIterations === void 0) ? 20 : _options.velocityIterations;
                this._options.positionIterations = (_options.positionIterations === void 0) ? 20 : _options.positionIterations;
                this._options.fixedPoints = (_options.fixedPoints === void 0) ? 0 : _options.fixedPoints;
                this._options.margin = (_options.margin === void 0) ? 0 : _options.margin;
                this._options.damping = (_options.damping === void 0) ? 0 : _options.damping;
                this._options.path = (_options.path === void 0) ? null : _options.path;
                this._options.shape = (_options.shape === void 0) ? null : _options.shape;
            }
            this._joints = [];
            //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.
            if (!this.object.parent || this._options.ignoreParent) {
                this._init();
            }
            else if (this.object.parent.physicsImpostor) {
                Logger.Warn("You must affect impostors to children before affecting impostor to parent.");
            }
        }
    }
    Object.defineProperty(PhysicsImpostor.prototype, "isDisposed", {
        /**
         * Specifies if the physics imposter is disposed
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsImpostor.prototype, "mass", {
        /**
         * Gets the mass of the physics imposter
         */
        get: function () {
            return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;
        },
        set: function (value) {
            this.setMass(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsImpostor.prototype, "friction", {
        /**
         * Gets the coefficient of friction
         */
        get: function () {
            return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;
        },
        /**
         * Sets the coefficient of friction
         */
        set: function (value) {
            if (!this._physicsEngine) {
                return;
            }
            this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsImpostor.prototype, "restitution", {
        /**
         * Gets the coefficient of restitution
         */
        get: function () {
            return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;
        },
        /**
         * Sets the coefficient of restitution
         */
        set: function (value) {
            if (!this._physicsEngine) {
                return;
            }
            this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsImpostor.prototype, "pressure", {
        /**
         * Gets the pressure of a soft body; only supported by the AmmoJSPlugin
         */
        get: function () {
            if (!this._physicsEngine) {
                return 0;
            }
            var plugin = this._physicsEngine.getPhysicsPlugin();
            if (!plugin.setBodyPressure) {
                return 0;
            }
            return plugin.getBodyPressure(this);
        },
        /**
         * Sets the pressure of a soft body; only supported by the AmmoJSPlugin
         */
        set: function (value) {
            if (!this._physicsEngine) {
                return;
            }
            var plugin = this._physicsEngine.getPhysicsPlugin();
            if (!plugin.setBodyPressure) {
                return;
            }
            plugin.setBodyPressure(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsImpostor.prototype, "stiffness", {
        /**
         * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin
         */
        get: function () {
            if (!this._physicsEngine) {
                return 0;
            }
            var plugin = this._physicsEngine.getPhysicsPlugin();
            if (!plugin.getBodyStiffness) {
                return 0;
            }
            return plugin.getBodyStiffness(this);
        },
        /**
         * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin
         */
        set: function (value) {
            if (!this._physicsEngine) {
                return;
            }
            var plugin = this._physicsEngine.getPhysicsPlugin();
            if (!plugin.setBodyStiffness) {
                return;
            }
            plugin.setBodyStiffness(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsImpostor.prototype, "velocityIterations", {
        /**
         * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
         */
        get: function () {
            if (!this._physicsEngine) {
                return 0;
            }
            var plugin = this._physicsEngine.getPhysicsPlugin();
            if (!plugin.getBodyVelocityIterations) {
                return 0;
            }
            return plugin.getBodyVelocityIterations(this);
        },
        /**
         * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
         */
        set: function (value) {
            if (!this._physicsEngine) {
                return;
            }
            var plugin = this._physicsEngine.getPhysicsPlugin();
            if (!plugin.setBodyVelocityIterations) {
                return;
            }
            plugin.setBodyVelocityIterations(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsImpostor.prototype, "positionIterations", {
        /**
         * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin
         */
        get: function () {
            if (!this._physicsEngine) {
                return 0;
            }
            var plugin = this._physicsEngine.getPhysicsPlugin();
            if (!plugin.getBodyPositionIterations) {
                return 0;
            }
            return plugin.getBodyPositionIterations(this);
        },
        /**
         * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin
         */
        set: function (value) {
            if (!this._physicsEngine) {
                return;
            }
            var plugin = this._physicsEngine.getPhysicsPlugin();
            if (!plugin.setBodyPositionIterations) {
                return;
            }
            plugin.setBodyPositionIterations(this, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This function will completly initialize this impostor.
     * It will create a new body - but only if this mesh has no parent.
     * If it has, this impostor will not be used other than to define the impostor
     * of the child mesh.
     * @hidden
     */
    PhysicsImpostor.prototype._init = function () {
        if (!this._physicsEngine) {
            return;
        }
        this._physicsEngine.removeImpostor(this);
        this.physicsBody = null;
        this._parent = this._parent || this._getPhysicsParent();
        if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {
            this._physicsEngine.addImpostor(this);
        }
    };
    PhysicsImpostor.prototype._getPhysicsParent = function () {
        if (this.object.parent instanceof AbstractMesh) {
            var parentMesh = this.object.parent;
            return parentMesh.physicsImpostor;
        }
        return null;
    };
    /**
     * Should a new body be generated.
     * @returns boolean specifying if body initialization is required
     */
    PhysicsImpostor.prototype.isBodyInitRequired = function () {
        return this._bodyUpdateRequired || (!this._physicsBody && !this._parent);
    };
    /**
     * Sets the updated scaling
     * @param updated Specifies if the scaling is updated
     */
    PhysicsImpostor.prototype.setScalingUpdated = function () {
        this.forceUpdate();
    };
    /**
     * Force a regeneration of this or the parent's impostor's body.
     * Use under cautious - This will remove all joints already implemented.
     */
    PhysicsImpostor.prototype.forceUpdate = function () {
        this._init();
        if (this.parent && !this._options.ignoreParent) {
            this.parent.forceUpdate();
        }
    };
    Object.defineProperty(PhysicsImpostor.prototype, "physicsBody", {
        /*public get mesh(): AbstractMesh {
            return this._mesh;
        }*/
        /**
         * Gets the body that holds this impostor. Either its own, or its parent.
         */
        get: function () {
            return (this._parent && !this._options.ignoreParent) ? this._parent.physicsBody : this._physicsBody;
        },
        /**
         * Set the physics body. Used mainly by the physics engine/plugin
         */
        set: function (physicsBody) {
            if (this._physicsBody && this._physicsEngine) {
                this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);
            }
            this._physicsBody = physicsBody;
            this.resetUpdateFlags();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsImpostor.prototype, "parent", {
        /**
         * Get the parent of the physics imposter
         * @returns Physics imposter or null
         */
        get: function () {
            return !this._options.ignoreParent && this._parent ? this._parent : null;
        },
        /**
         * Sets the parent of the physics imposter
         */
        set: function (value) {
            this._parent = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the update flags
     */
    PhysicsImpostor.prototype.resetUpdateFlags = function () {
        this._bodyUpdateRequired = false;
    };
    /**
     * Gets the object extend size
     * @returns the object extend size
     */
    PhysicsImpostor.prototype.getObjectExtendSize = function () {
        if (this.object.getBoundingInfo) {
            var q = this.object.rotationQuaternion;
            //reset rotation
            this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;
            //calculate the world matrix with no rotation
            this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
            var boundingInfo = this.object.getBoundingInfo();
            var size = boundingInfo.boundingBox.extendSizeWorld.scale(2);
            //bring back the rotation
            this.object.rotationQuaternion = q;
            //calculate the world matrix with the new rotation
            this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
            return size;
        }
        else {
            return PhysicsImpostor.DEFAULT_OBJECT_SIZE;
        }
    };
    /**
     * Gets the object center
     * @returns The object center
     */
    PhysicsImpostor.prototype.getObjectCenter = function () {
        if (this.object.getBoundingInfo) {
            var boundingInfo = this.object.getBoundingInfo();
            return boundingInfo.boundingBox.centerWorld;
        }
        else {
            return this.object.position;
        }
    };
    /**
     * Get a specific parametes from the options parameter
     * @param paramName The object parameter name
     * @returns The object parameter
     */
    PhysicsImpostor.prototype.getParam = function (paramName) {
        return this._options[paramName];
    };
    /**
     * Sets a specific parameter in the options given to the physics plugin
     * @param paramName The parameter name
     * @param value The value of the parameter
     */
    PhysicsImpostor.prototype.setParam = function (paramName, value) {
        this._options[paramName] = value;
        this._bodyUpdateRequired = true;
    };
    /**
     * Specifically change the body's mass option. Won't recreate the physics body object
     * @param mass The mass of the physics imposter
     */
    PhysicsImpostor.prototype.setMass = function (mass) {
        if (this.getParam("mass") !== mass) {
            this.setParam("mass", mass);
        }
        if (this._physicsEngine) {
            this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);
        }
    };
    /**
     * Gets the linear velocity
     * @returns  linear velocity or null
     */
    PhysicsImpostor.prototype.getLinearVelocity = function () {
        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();
    };
    /**
     * Sets the linear velocity
     * @param velocity  linear velocity or null
     */
    PhysicsImpostor.prototype.setLinearVelocity = function (velocity) {
        if (this._physicsEngine) {
            this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);
        }
    };
    /**
     * Gets the angular velocity
     * @returns angular velocity or null
     */
    PhysicsImpostor.prototype.getAngularVelocity = function () {
        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();
    };
    /**
     * Sets the angular velocity
     * @param velocity The velocity or null
     */
    PhysicsImpostor.prototype.setAngularVelocity = function (velocity) {
        if (this._physicsEngine) {
            this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);
        }
    };
    /**
     * Execute a function with the physics plugin native code
     * Provide a function the will have two variables - the world object and the physics body object
     * @param func The function to execute with the physics plugin native code
     */
    PhysicsImpostor.prototype.executeNativeFunction = function (func) {
        if (this._physicsEngine) {
            func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);
        }
    };
    /**
     * Register a function that will be executed before the physics world is stepping forward
     * @param func The function to execute before the physics world is stepped forward
     */
    PhysicsImpostor.prototype.registerBeforePhysicsStep = function (func) {
        this._onBeforePhysicsStepCallbacks.push(func);
    };
    /**
     * Unregister a function that will be executed before the physics world is stepping forward
     * @param func The function to execute before the physics world is stepped forward
     */
    PhysicsImpostor.prototype.unregisterBeforePhysicsStep = function (func) {
        var index = this._onBeforePhysicsStepCallbacks.indexOf(func);
        if (index > -1) {
            this._onBeforePhysicsStepCallbacks.splice(index, 1);
        }
        else {
            Logger.Warn("Function to remove was not found");
        }
    };
    /**
     * Register a function that will be executed after the physics step
     * @param func The function to execute after physics step
     */
    PhysicsImpostor.prototype.registerAfterPhysicsStep = function (func) {
        this._onAfterPhysicsStepCallbacks.push(func);
    };
    /**
     * Unregisters a function that will be executed after the physics step
     * @param func The function to execute after physics step
     */
    PhysicsImpostor.prototype.unregisterAfterPhysicsStep = function (func) {
        var index = this._onAfterPhysicsStepCallbacks.indexOf(func);
        if (index > -1) {
            this._onAfterPhysicsStepCallbacks.splice(index, 1);
        }
        else {
            Logger.Warn("Function to remove was not found");
        }
    };
    /**
     * register a function that will be executed when this impostor collides against a different body
     * @param collideAgainst Physics imposter, or array of physics imposters to collide against
     * @param func Callback that is executed on collision
     */
    PhysicsImpostor.prototype.registerOnPhysicsCollide = function (collideAgainst, func) {
        var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
        this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });
    };
    /**
     * Unregisters the physics imposter on contact
     * @param collideAgainst The physics object to collide against
     * @param func Callback to execute on collision
     */
    PhysicsImpostor.prototype.unregisterOnPhysicsCollide = function (collideAgainst, func) {
        var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
        var index = -1;
        var found = this._onPhysicsCollideCallbacks.some(function (cbDef, idx) {
            if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {
                // chcek the arrays match
                var sameList = cbDef.otherImpostors.every(function (impostor) {
                    return collidedAgainstList.indexOf(impostor) > -1;
                });
                if (sameList) {
                    index = idx;
                }
                return sameList;
            }
            return false;
        });
        if (found) {
            this._onPhysicsCollideCallbacks.splice(index, 1);
        }
        else {
            Logger.Warn("Function to remove was not found");
        }
    };
    /**
     * Get the parent rotation
     * @returns The parent rotation
     */
    PhysicsImpostor.prototype.getParentsRotation = function () {
        var parent = this.object.parent;
        this._tmpQuat.copyFromFloats(0, 0, 0, 1);
        while (parent) {
            if (parent.rotationQuaternion) {
                this._tmpQuat2.copyFrom(parent.rotationQuaternion);
            }
            else {
                Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);
            }
            this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);
            parent = parent.parent;
        }
        return this._tmpQuat;
    };
    /**
     * Apply a force
     * @param force The force to apply
     * @param contactPoint The contact point for the force
     * @returns The physics imposter
     */
    PhysicsImpostor.prototype.applyForce = function (force, contactPoint) {
        if (this._physicsEngine) {
            this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);
        }
        return this;
    };
    /**
     * Apply an impulse
     * @param force The impulse force
     * @param contactPoint The contact point for the impulse force
     * @returns The physics imposter
     */
    PhysicsImpostor.prototype.applyImpulse = function (force, contactPoint) {
        if (this._physicsEngine) {
            this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);
        }
        return this;
    };
    /**
     * A help function to create a joint
     * @param otherImpostor A physics imposter used to create a joint
     * @param jointType The type of joint
     * @param jointData The data for the joint
     * @returns The physics imposter
     */
    PhysicsImpostor.prototype.createJoint = function (otherImpostor, jointType, jointData) {
        var joint = new PhysicsJoint(jointType, jointData);
        this.addJoint(otherImpostor, joint);
        return this;
    };
    /**
     * Add a joint to this impostor with a different impostor
     * @param otherImpostor A physics imposter used to add a joint
     * @param joint The joint to add
     * @returns The physics imposter
     */
    PhysicsImpostor.prototype.addJoint = function (otherImpostor, joint) {
        this._joints.push({
            otherImpostor: otherImpostor,
            joint: joint
        });
        if (this._physicsEngine) {
            this._physicsEngine.addJoint(this, otherImpostor, joint);
        }
        return this;
    };
    /**
     * Add an anchor to a cloth impostor
     * @param otherImpostor rigid impostor to anchor to
     * @param width ratio across width from 0 to 1
     * @param height ratio up height from 0 to 1
     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech
     * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false
     * @returns impostor the soft imposter
     */
    PhysicsImpostor.prototype.addAnchor = function (otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {
        if (!this._physicsEngine) {
            return this;
        }
        var plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.appendAnchor) {
            return this;
        }
        if (this._physicsEngine) {
            plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);
        }
        return this;
    };
    /**
     * Add a hook to a rope impostor
     * @param otherImpostor rigid impostor to anchor to
     * @param length ratio across rope from 0 to 1
     * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little strech
     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
     * @returns impostor the rope imposter
     */
    PhysicsImpostor.prototype.addHook = function (otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {
        if (!this._physicsEngine) {
            return this;
        }
        var plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.appendAnchor) {
            return this;
        }
        if (this._physicsEngine) {
            plugin.appendHook(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);
        }
        return this;
    };
    /**
     * Will keep this body still, in a sleep mode.
     * @returns the physics imposter
     */
    PhysicsImpostor.prototype.sleep = function () {
        if (this._physicsEngine) {
            this._physicsEngine.getPhysicsPlugin().sleepBody(this);
        }
        return this;
    };
    /**
     * Wake the body up.
     * @returns The physics imposter
     */
    PhysicsImpostor.prototype.wakeUp = function () {
        if (this._physicsEngine) {
            this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);
        }
        return this;
    };
    /**
     * Clones the physics imposter
     * @param newObject The physics imposter clones to this physics-enabled object
     * @returns A nullable physics imposter
     */
    PhysicsImpostor.prototype.clone = function (newObject) {
        if (!newObject) {
            return null;
        }
        return new PhysicsImpostor(newObject, this.type, this._options, this._scene);
    };
    /**
     * Disposes the physics imposter
     */
    PhysicsImpostor.prototype.dispose = function ( /*disposeChildren: boolean = true*/) {
        var _this = this;
        //no dispose if no physics engine is available.
        if (!this._physicsEngine) {
            return;
        }
        this._joints.forEach(function (j) {
            if (_this._physicsEngine) {
                _this._physicsEngine.removeJoint(_this, j.otherImpostor, j.joint);
            }
        });
        //dispose the physics body
        this._physicsEngine.removeImpostor(this);
        if (this.parent) {
            this.parent.forceUpdate();
        }
        this._isDisposed = true;
    };
    /**
     * Sets the delta position
     * @param position The delta position amount
     */
    PhysicsImpostor.prototype.setDeltaPosition = function (position) {
        this._deltaPosition.copyFrom(position);
    };
    /**
     * Sets the delta rotation
     * @param rotation The delta rotation amount
     */
    PhysicsImpostor.prototype.setDeltaRotation = function (rotation) {
        if (!this._deltaRotation) {
            this._deltaRotation = new Quaternion();
        }
        this._deltaRotation.copyFrom(rotation);
        this._deltaRotationConjugated = this._deltaRotation.conjugate();
    };
    /**
     * Gets the box size of the physics imposter and stores the result in the input parameter
     * @param result Stores the box size
     * @returns The physics imposter
     */
    PhysicsImpostor.prototype.getBoxSizeToRef = function (result) {
        if (this._physicsEngine) {
            this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);
        }
        return this;
    };
    /**
     * Gets the radius of the physics imposter
     * @returns Radius of the physics imposter
     */
    PhysicsImpostor.prototype.getRadius = function () {
        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;
    };
    /**
     * Sync a bone with this impostor
     * @param bone The bone to sync to the impostor.
     * @param boneMesh The mesh that the bone is influencing.
     * @param jointPivot The pivot of the joint / bone in local space.
     * @param distToJoint Optional distance from the impostor to the joint.
     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
     */
    PhysicsImpostor.prototype.syncBoneWithImpostor = function (bone, boneMesh, jointPivot, distToJoint, adjustRotation) {
        var tempVec = PhysicsImpostor._tmpVecs[0];
        var mesh = this.object;
        if (mesh.rotationQuaternion) {
            if (adjustRotation) {
                var tempQuat = PhysicsImpostor._tmpQuat;
                mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);
                bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);
            }
            else {
                bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);
            }
        }
        tempVec.x = 0;
        tempVec.y = 0;
        tempVec.z = 0;
        if (jointPivot) {
            tempVec.x = jointPivot.x;
            tempVec.y = jointPivot.y;
            tempVec.z = jointPivot.z;
            bone.getDirectionToRef(tempVec, boneMesh, tempVec);
            if (distToJoint === undefined || distToJoint === null) {
                distToJoint = jointPivot.length();
            }
            tempVec.x *= distToJoint;
            tempVec.y *= distToJoint;
            tempVec.z *= distToJoint;
        }
        if (bone.getParent()) {
            tempVec.addInPlace(mesh.getAbsolutePosition());
            bone.setAbsolutePosition(tempVec, boneMesh);
        }
        else {
            boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());
            boneMesh.position.x -= tempVec.x;
            boneMesh.position.y -= tempVec.y;
            boneMesh.position.z -= tempVec.z;
        }
    };
    /**
     * Sync impostor to a bone
     * @param bone The bone that the impostor will be synced to.
     * @param boneMesh The mesh that the bone is influencing.
     * @param jointPivot The pivot of the joint / bone in local space.
     * @param distToJoint Optional distance from the impostor to the joint.
     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
     * @param boneAxis Optional vector3 axis the bone is aligned with
     */
    PhysicsImpostor.prototype.syncImpostorWithBone = function (bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {
        var mesh = this.object;
        if (mesh.rotationQuaternion) {
            if (adjustRotation) {
                var tempQuat = PhysicsImpostor._tmpQuat;
                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);
                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);
            }
            else {
                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);
            }
        }
        var pos = PhysicsImpostor._tmpVecs[0];
        var boneDir = PhysicsImpostor._tmpVecs[1];
        if (!boneAxis) {
            boneAxis = PhysicsImpostor._tmpVecs[2];
            boneAxis.x = 0;
            boneAxis.y = 1;
            boneAxis.z = 0;
        }
        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);
        bone.getAbsolutePositionToRef(boneMesh, pos);
        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {
            distToJoint = jointPivot.length();
        }
        if (distToJoint !== undefined && distToJoint !== null) {
            pos.x += boneDir.x * distToJoint;
            pos.y += boneDir.y * distToJoint;
            pos.z += boneDir.z * distToJoint;
        }
        mesh.setAbsolutePosition(pos);
    };
    /**
     * The default object size of the imposter
     */
    PhysicsImpostor.DEFAULT_OBJECT_SIZE = new Vector3(1, 1, 1);
    /**
     * The identity quaternion of the imposter
     */
    PhysicsImpostor.IDENTITY_QUATERNION = Quaternion.Identity();
    PhysicsImpostor._tmpVecs = ArrayTools.BuildArray(3, Vector3.Zero);
    PhysicsImpostor._tmpQuat = Quaternion.Identity();
    //Impostor types
    /**
     * No-Imposter type
     */
    PhysicsImpostor.NoImpostor = 0;
    /**
     * Sphere-Imposter type
     */
    PhysicsImpostor.SphereImpostor = 1;
    /**
     * Box-Imposter type
     */
    PhysicsImpostor.BoxImpostor = 2;
    /**
     * Plane-Imposter type
     */
    PhysicsImpostor.PlaneImpostor = 3;
    /**
     * Mesh-imposter type
     */
    PhysicsImpostor.MeshImpostor = 4;
    /**
     * Cylinder-Imposter type
     */
    PhysicsImpostor.CylinderImpostor = 7;
    /**
     * Particle-Imposter type
     */
    PhysicsImpostor.ParticleImpostor = 8;
    /**
     * Heightmap-Imposter type
     */
    PhysicsImpostor.HeightmapImpostor = 9;
    /**
     * ConvexHull-Impostor type (Ammo.js plugin only)
     */
    PhysicsImpostor.ConvexHullImpostor = 10;
    /**
     * Rope-Imposter type
     */
    PhysicsImpostor.RopeImpostor = 101;
    /**
     * Cloth-Imposter type
     */
    PhysicsImpostor.ClothImpostor = 102;
    /**
     * Softbody-Imposter type
     */
    PhysicsImpostor.SoftbodyImpostor = 103;
    return PhysicsImpostor;
}());

/**
     * Used to show the physics impostor around the specific mesh
     */
var PhysicsViewer = /** @class */ (function () {
    /**
     * Creates a new PhysicsViewer
     * @param scene defines the hosting scene
     */
    function PhysicsViewer(scene) {
        /** @hidden */
        this._impostors = [];
        /** @hidden */
        this._meshes = [];
        /** @hidden */
        this._numMeshes = 0;
        this._debugMeshMeshes = new Array();
        this._scene = scene || EngineStore.LastCreatedScene;
        var physicEngine = this._scene.getPhysicsEngine();
        if (physicEngine) {
            this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();
        }
        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);
        this._utilityLayer.pickUtilitySceneFirst = false;
        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;
    }
    /** @hidden */
    PhysicsViewer.prototype._updateDebugMeshes = function () {
        var plugin = this._physicsEnginePlugin;
        for (var i = 0; i < this._numMeshes; i++) {
            var impostor = this._impostors[i];
            if (!impostor) {
                continue;
            }
            if (impostor.isDisposed) {
                this.hideImpostor(this._impostors[i--]);
            }
            else {
                if (impostor.type === PhysicsImpostor.MeshImpostor) {
                    continue;
                }
                var mesh = this._meshes[i];
                if (mesh && plugin) {
                    plugin.syncMeshWithImpostor(mesh, impostor);
                }
            }
        }
    };
    /**
     * Renders a specified physic impostor
     * @param impostor defines the impostor to render
     * @param targetMesh defines the mesh represented by the impostor
     * @returns the new debug mesh used to render the impostor
     */
    PhysicsViewer.prototype.showImpostor = function (impostor, targetMesh) {
        if (!this._scene) {
            return null;
        }
        for (var i = 0; i < this._numMeshes; i++) {
            if (this._impostors[i] == impostor) {
                return null;
            }
        }
        var debugMesh = this._getDebugMesh(impostor, targetMesh);
        if (debugMesh) {
            this._impostors[this._numMeshes] = impostor;
            this._meshes[this._numMeshes] = debugMesh;
            if (this._numMeshes === 0) {
                this._renderFunction = this._updateDebugMeshes.bind(this);
                this._scene.registerBeforeRender(this._renderFunction);
            }
            this._numMeshes++;
        }
        return debugMesh;
    };
    /**
     * Hides a specified physic impostor
     * @param impostor defines the impostor to hide
     */
    PhysicsViewer.prototype.hideImpostor = function (impostor) {
        if (!impostor || !this._scene || !this._utilityLayer) {
            return;
        }
        var removed = false;
        var utilityLayerScene = this._utilityLayer.utilityLayerScene;
        for (var i = 0; i < this._numMeshes; i++) {
            if (this._impostors[i] == impostor) {
                var mesh = this._meshes[i];
                if (!mesh) {
                    continue;
                }
                utilityLayerScene.removeMesh(mesh);
                mesh.dispose();
                var index = this._debugMeshMeshes.indexOf(mesh);
                if (index > -1) {
                    this._debugMeshMeshes.splice(index, 1);
                }
                this._numMeshes--;
                if (this._numMeshes > 0) {
                    this._meshes[i] = this._meshes[this._numMeshes];
                    this._impostors[i] = this._impostors[this._numMeshes];
                    this._meshes[this._numMeshes] = null;
                    this._impostors[this._numMeshes] = null;
                }
                else {
                    this._meshes[0] = null;
                    this._impostors[0] = null;
                }
                removed = true;
                break;
            }
        }
        if (removed && this._numMeshes === 0) {
            this._scene.unregisterBeforeRender(this._renderFunction);
        }
    };
    PhysicsViewer.prototype._getDebugMaterial = function (scene) {
        if (!this._debugMaterial) {
            this._debugMaterial = new StandardMaterial('', scene);
            this._debugMaterial.wireframe = true;
            this._debugMaterial.emissiveColor = Color3.White();
            this._debugMaterial.disableLighting = true;
        }
        return this._debugMaterial;
    };
    PhysicsViewer.prototype._getDebugBoxMesh = function (scene) {
        if (!this._debugBoxMesh) {
            this._debugBoxMesh = BoxBuilder.CreateBox('physicsBodyBoxViewMesh', { size: 1 }, scene);
            this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();
            this._debugBoxMesh.material = this._getDebugMaterial(scene);
            this._debugBoxMesh.setEnabled(false);
        }
        return this._debugBoxMesh.createInstance('physicsBodyBoxViewInstance');
    };
    PhysicsViewer.prototype._getDebugSphereMesh = function (scene) {
        if (!this._debugSphereMesh) {
            this._debugSphereMesh = SphereBuilder.CreateSphere('physicsBodySphereViewMesh', { diameter: 1 }, scene);
            this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();
            this._debugSphereMesh.material = this._getDebugMaterial(scene);
            this._debugSphereMesh.setEnabled(false);
        }
        return this._debugSphereMesh.createInstance('physicsBodyBoxViewInstance');
    };
    PhysicsViewer.prototype._getDebugCylinderMesh = function (scene) {
        if (!this._debugCylinderMesh) {
            this._debugCylinderMesh = CylinderBuilder.CreateCylinder('physicsBodyCylinderViewMesh', { diameterTop: 1, diameterBottom: 1, height: 1 }, scene);
            this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();
            this._debugCylinderMesh.material = this._getDebugMaterial(scene);
            this._debugCylinderMesh.setEnabled(false);
        }
        return this._debugCylinderMesh.createInstance('physicsBodyBoxViewInstance');
    };
    PhysicsViewer.prototype._getDebugMeshMesh = function (mesh, scene) {
        var wireframeOver = new Mesh(mesh.name, scene, null, mesh);
        wireframeOver.position = Vector3.Zero();
        wireframeOver.setParent(mesh);
        wireframeOver.material = this._getDebugMaterial(scene);
        this._debugMeshMeshes.push(wireframeOver);
        return wireframeOver;
    };
    PhysicsViewer.prototype._getDebugMesh = function (impostor, targetMesh) {
        var _this = this;
        if (!this._utilityLayer) {
            return null;
        }
        // Only create child impostor debug meshes when evaluating the parent
        if (targetMesh && targetMesh.parent && targetMesh.parent.physicsImpostor) {
            return null;
        }
        var mesh = null;
        var utilityLayerScene = this._utilityLayer.utilityLayerScene;
        switch (impostor.type) {
            case PhysicsImpostor.BoxImpostor:
                mesh = this._getDebugBoxMesh(utilityLayerScene);
                impostor.getBoxSizeToRef(mesh.scaling);
                break;
            case PhysicsImpostor.SphereImpostor:
                mesh = this._getDebugSphereMesh(utilityLayerScene);
                var radius = impostor.getRadius();
                mesh.scaling.x = radius * 2;
                mesh.scaling.y = radius * 2;
                mesh.scaling.z = radius * 2;
                break;
            case PhysicsImpostor.MeshImpostor:
                if (targetMesh) {
                    mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);
                }
                break;
            case PhysicsImpostor.NoImpostor:
                if (targetMesh) {
                    // Handle compound impostors
                    var childMeshes = targetMesh.getChildMeshes().filter(function (c) { return c.physicsImpostor ? 1 : 0; });
                    childMeshes.forEach(function (m) {
                        var a = _this._getDebugBoxMesh(utilityLayerScene);
                        a.parent = m;
                    });
                }
                break;
            case PhysicsImpostor.CylinderImpostor:
                mesh = this._getDebugCylinderMesh(utilityLayerScene);
                var bi = impostor.object.getBoundingInfo();
                mesh.scaling.x = bi.boundingBox.maximum.x - bi.boundingBox.minimum.x;
                mesh.scaling.y = bi.boundingBox.maximum.y - bi.boundingBox.minimum.y;
                mesh.scaling.z = bi.boundingBox.maximum.z - bi.boundingBox.minimum.z;
                break;
        }
        return mesh;
    };
    /** Releases all resources */
    PhysicsViewer.prototype.dispose = function () {
        var count = this._numMeshes;
        for (var index = 0; index < count; index++) {
            this.hideImpostor(this._impostors[0]);
        }
        if (this._debugBoxMesh) {
            this._debugBoxMesh.dispose();
        }
        if (this._debugSphereMesh) {
            this._debugSphereMesh.dispose();
        }
        if (this._debugCylinderMesh) {
            this._debugCylinderMesh.dispose();
        }
        if (this._debugMaterial) {
            this._debugMaterial.dispose();
        }
        this._impostors.length = 0;
        this._scene = null;
        this._physicsEnginePlugin = null;
        if (this._utilityLayer) {
            this._utilityLayer.dispose();
            this._utilityLayer = null;
        }
    };
    return PhysicsViewer;
}());

Mesh._instancedMeshFactory = function (name, mesh) {
    return new InstancedMesh(name, mesh);
};
/**
 * Creates an instance based on a source mesh.
 */
var InstancedMesh = /** @class */ (function (_super) {
    __extends(InstancedMesh, _super);
    function InstancedMesh(name, source) {
        var _this = _super.call(this, name, source.getScene()) || this;
        /** @hidden */
        _this._indexInSourceMeshInstanceArray = -1;
        source.addInstance(_this);
        _this._sourceMesh = source;
        _this.position.copyFrom(source.position);
        _this.rotation.copyFrom(source.rotation);
        _this.scaling.copyFrom(source.scaling);
        if (source.rotationQuaternion) {
            _this.rotationQuaternion = source.rotationQuaternion.clone();
        }
        _this.infiniteDistance = source.infiniteDistance;
        _this.setPivotMatrix(source.getPivotMatrix());
        _this.refreshBoundingInfo();
        _this._syncSubMeshes();
        return _this;
    }
    /**
     * Returns the string "InstancedMesh".
     */
    InstancedMesh.prototype.getClassName = function () {
        return "InstancedMesh";
    };
    Object.defineProperty(InstancedMesh.prototype, "lightSources", {
        /** Gets the list of lights affecting that mesh */
        get: function () {
            return this._sourceMesh._lightSources;
        },
        enumerable: true,
        configurable: true
    });
    InstancedMesh.prototype._resyncLightSources = function () {
        // Do nothing as all the work will be done by source mesh
    };
    InstancedMesh.prototype._resyncLighSource = function (light) {
        // Do nothing as all the work will be done by source mesh
    };
    InstancedMesh.prototype._removeLightSource = function (light) {
        // Do nothing as all the work will be done by source mesh
    };
    Object.defineProperty(InstancedMesh.prototype, "receiveShadows", {
        // Methods
        /**
         * If the source mesh receives shadows
         */
        get: function () {
            return this._sourceMesh.receiveShadows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstancedMesh.prototype, "material", {
        /**
         * The material of the source mesh
         */
        get: function () {
            return this._sourceMesh.material;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstancedMesh.prototype, "visibility", {
        /**
         * Visibility of the source mesh
         */
        get: function () {
            return this._sourceMesh.visibility;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstancedMesh.prototype, "skeleton", {
        /**
         * Skeleton of the source mesh
         */
        get: function () {
            return this._sourceMesh.skeleton;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstancedMesh.prototype, "renderingGroupId", {
        /**
         * Rendering ground id of the source mesh
         */
        get: function () {
            return this._sourceMesh.renderingGroupId;
        },
        set: function (value) {
            if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
                return;
            }
            //no-op with warning
            Logger.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the total number of vertices (integer).
     */
    InstancedMesh.prototype.getTotalVertices = function () {
        return this._sourceMesh.getTotalVertices();
    };
    /**
     * Returns a positive integer : the total number of indices in this mesh geometry.
     * @returns the numner of indices or zero if the mesh has no geometry.
     */
    InstancedMesh.prototype.getTotalIndices = function () {
        return this._sourceMesh.getTotalIndices();
    };
    Object.defineProperty(InstancedMesh.prototype, "sourceMesh", {
        /**
         * The source mesh of the instance
         */
        get: function () {
            return this._sourceMesh;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Is this node ready to be used/rendered
     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
     * @return {boolean} is it ready
     */
    InstancedMesh.prototype.isReady = function (completeCheck) {
        if (completeCheck === void 0) { completeCheck = false; }
        return this._sourceMesh.isReady(completeCheck, true);
    };
    /**
     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
     * @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)
     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
     * @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.
     */
    InstancedMesh.prototype.getVerticesData = function (kind, copyWhenShared) {
        return this._sourceMesh.getVerticesData(kind, copyWhenShared);
    };
    /**
     * Sets the vertex data of the mesh geometry for the requested `kind`.
     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
     * The `data` are either a numeric array either a Float32Array.
     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.
     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
     * Note that a new underlying VertexBuffer object is created each call.
     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
     *
     * Possible `kind` values :
     * - VertexBuffer.PositionKind
     * - VertexBuffer.UVKind
     * - VertexBuffer.UV2Kind
     * - VertexBuffer.UV3Kind
     * - VertexBuffer.UV4Kind
     * - VertexBuffer.UV5Kind
     * - VertexBuffer.UV6Kind
     * - VertexBuffer.ColorKind
     * - VertexBuffer.MatricesIndicesKind
     * - VertexBuffer.MatricesIndicesExtraKind
     * - VertexBuffer.MatricesWeightsKind
     * - VertexBuffer.MatricesWeightsExtraKind
     *
     * Returns the Mesh.
     */
    InstancedMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {
        if (this.sourceMesh) {
            this.sourceMesh.setVerticesData(kind, data, updatable, stride);
        }
        return this.sourceMesh;
    };
    /**
     * Updates the existing vertex data of the mesh geometry for the requested `kind`.
     * If the mesh has no geometry, it is simply returned as it is.
     * The `data` are either a numeric array either a Float32Array.
     * No new underlying VertexBuffer object is created.
     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
     *
     * Possible `kind` values :
     * - VertexBuffer.PositionKind
     * - VertexBuffer.UVKind
     * - VertexBuffer.UV2Kind
     * - VertexBuffer.UV3Kind
     * - VertexBuffer.UV4Kind
     * - VertexBuffer.UV5Kind
     * - VertexBuffer.UV6Kind
     * - VertexBuffer.ColorKind
     * - VertexBuffer.MatricesIndicesKind
     * - VertexBuffer.MatricesIndicesExtraKind
     * - VertexBuffer.MatricesWeightsKind
     * - VertexBuffer.MatricesWeightsExtraKind
     *
     * Returns the Mesh.
     */
    InstancedMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {
        if (this.sourceMesh) {
            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
        }
        return this.sourceMesh;
    };
    /**
     * Sets the mesh indices.
     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
     * This method creates a new index buffer each call.
     * Returns the Mesh.
     */
    InstancedMesh.prototype.setIndices = function (indices, totalVertices) {
        if (totalVertices === void 0) { totalVertices = null; }
        if (this.sourceMesh) {
            this.sourceMesh.setIndices(indices, totalVertices);
        }
        return this.sourceMesh;
    };
    /**
     * Boolean : True if the mesh owns the requested kind of data.
     */
    InstancedMesh.prototype.isVerticesDataPresent = function (kind) {
        return this._sourceMesh.isVerticesDataPresent(kind);
    };
    /**
     * Returns an array of indices (IndicesArray).
     */
    InstancedMesh.prototype.getIndices = function () {
        return this._sourceMesh.getIndices();
    };
    Object.defineProperty(InstancedMesh.prototype, "_positions", {
        get: function () {
            return this._sourceMesh._positions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
     * This means the mesh underlying bounding box and sphere are recomputed.
     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info
     * @returns the current mesh
     */
    InstancedMesh.prototype.refreshBoundingInfo = function (applySkeleton) {
        if (applySkeleton === void 0) { applySkeleton = false; }
        if (this._boundingInfo && this._boundingInfo.isLocked) {
            return this;
        }
        var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton), bias);
        return this;
    };
    /** @hidden */
    InstancedMesh.prototype._preActivate = function () {
        if (this._currentLOD) {
            this._currentLOD._preActivate();
        }
        return this;
    };
    /** @hidden */
    InstancedMesh.prototype._activate = function (renderId, intermediateRendering) {
        if (this._currentLOD) {
            this._currentLOD._registerInstanceForRenderId(this, renderId);
        }
        if (intermediateRendering) {
            if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
                this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
                return true;
            }
        }
        else {
            if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
                this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
                return true;
            }
        }
        return false;
    };
    /** @hidden */
    InstancedMesh.prototype._postActivate = function () {
        if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
        }
    };
    InstancedMesh.prototype.getWorldMatrix = function () {
        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
            var tempMaster = this._currentLOD._masterMesh;
            this._currentLOD._masterMesh = this;
            Tmp.Matrix[0].copyFrom(this._currentLOD.computeWorldMatrix(true));
            this._currentLOD._masterMesh = tempMaster;
            return Tmp.Matrix[0];
        }
        return _super.prototype.getWorldMatrix.call(this);
    };
    Object.defineProperty(InstancedMesh.prototype, "isAnInstance", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the current associated LOD AbstractMesh.
     */
    InstancedMesh.prototype.getLOD = function (camera) {
        if (!camera) {
            return this;
        }
        var boundingInfo = this.getBoundingInfo();
        this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
        if (this._currentLOD === this.sourceMesh) {
            return this.sourceMesh;
        }
        return this._currentLOD;
    };
    /** @hidden */
    InstancedMesh.prototype._syncSubMeshes = function () {
        this.releaseSubMeshes();
        if (this._sourceMesh.subMeshes) {
            for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {
                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
            }
        }
        return this;
    };
    /** @hidden */
    InstancedMesh.prototype._generatePointsArray = function () {
        return this._sourceMesh._generatePointsArray();
    };
    /**
     * Creates a new InstancedMesh from the current mesh.
     * - name (string) : the cloned mesh name
     * - newParent (optional Node) : the optional Node to parent the clone to.
     * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.
     *
     * Returns the clone.
     */
    InstancedMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {
        var result = this._sourceMesh.createInstance(name);
        // Deep copy
        DeepCopier.DeepCopy(this, result, ["name", "subMeshes", "uniqueId"], []);
        // Bounding info
        this.refreshBoundingInfo();
        // Parent
        if (newParent) {
            result.parent = newParent;
        }
        if (!doNotCloneChildren) {
            // Children
            for (var index = 0; index < this.getScene().meshes.length; index++) {
                var mesh = this.getScene().meshes[index];
                if (mesh.parent === this) {
                    mesh.clone(mesh.name, result);
                }
            }
        }
        result.computeWorldMatrix(true);
        return result;
    };
    /**
     * Disposes the InstancedMesh.
     * Returns nothing.
     */
    InstancedMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {
        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }
        // Remove from mesh
        this._sourceMesh.removeInstance(this);
        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
    };
    return InstancedMesh;
}(AbstractMesh));

var name$7 = 'colorPixelShader';
var shader$7 = "#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvoid main(void) {\n#include<clipPlaneFragment>\n#ifdef VERTEXCOLOR\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n}";
Effect.ShadersStore[name$7] = shader$7;

var name$8 = 'colorVertexShader';
var shader$8 = "\nattribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<clipPlaneVertexDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\n#include<clipPlaneVertex>\n#ifdef VERTEXCOLOR\n\nvColor=color;\n#endif\n}";
Effect.ShadersStore[name$8] = shader$8;

/**
 * Line mesh
 * @see https://doc.babylonjs.com/babylon101/parametric_shapes
 */
var LinesMesh = /** @class */ (function (_super) {
    __extends(LinesMesh, _super);
    /**
     * Creates a new LinesMesh
     * @param name defines the name
     * @param scene defines the hosting scene
     * @param parent defines the parent mesh if any
     * @param source defines the optional source LinesMesh used to clone data from
     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
     * When false, achieved by calling a clone(), also passing False.
     * This will make creation of children, recursive.
     * @param useVertexColor defines if this LinesMesh supports vertex color
     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha
     */
    function LinesMesh(name, scene, parent, source, doNotCloneChildren, 
    /**
     * If vertex color should be applied to the mesh
     */
    useVertexColor, 
    /**
     * If vertex alpha should be applied to the mesh
     */
    useVertexAlpha) {
        if (scene === void 0) { scene = null; }
        if (parent === void 0) { parent = null; }
        var _this = _super.call(this, name, scene, parent, source, doNotCloneChildren) || this;
        _this.useVertexColor = useVertexColor;
        _this.useVertexAlpha = useVertexAlpha;
        /**
         * Color of the line (Default: White)
         */
        _this.color = new Color3(1, 1, 1);
        /**
         * Alpha of the line (Default: 1)
         */
        _this.alpha = 1;
        if (source) {
            _this.color = source.color.clone();
            _this.alpha = source.alpha;
            _this.useVertexColor = source.useVertexColor;
            _this.useVertexAlpha = source.useVertexAlpha;
        }
        _this.intersectionThreshold = 0.1;
        var defines = [];
        var options = {
            attributes: [VertexBuffer.PositionKind, "world0", "world1", "world2", "world3"],
            uniforms: ["vClipPlane", "vClipPlane2", "vClipPlane3", "vClipPlane4", "world", "viewProjection"],
            needAlphaBlending: true,
            defines: defines
        };
        if (useVertexAlpha === false) {
            options.needAlphaBlending = false;
        }
        if (!useVertexColor) {
            options.uniforms.push("color");
        }
        else {
            options.defines.push("#define VERTEXCOLOR");
            options.attributes.push(VertexBuffer.ColorKind);
        }
        _this._colorShader = new ShaderMaterial("colorShader", _this.getScene(), "color", options);
        return _this;
    }
    LinesMesh.prototype._addClipPlaneDefine = function (label) {
        var define = "#define " + label;
        var index = this._colorShader.options.defines.indexOf(define);
        if (index !== -1) {
            return;
        }
        this._colorShader.options.defines.push(define);
    };
    LinesMesh.prototype._removeClipPlaneDefine = function (label) {
        var define = "#define " + label;
        var index = this._colorShader.options.defines.indexOf(define);
        if (index === -1) {
            return;
        }
        this._colorShader.options.defines.splice(index, 1);
    };
    LinesMesh.prototype.isReady = function () {
        var scene = this.getScene();
        // Clip planes
        scene.clipPlane ? this._addClipPlaneDefine("CLIPPLANE") : this._removeClipPlaneDefine("CLIPPLANE");
        scene.clipPlane2 ? this._addClipPlaneDefine("CLIPPLANE2") : this._removeClipPlaneDefine("CLIPPLANE2");
        scene.clipPlane3 ? this._addClipPlaneDefine("CLIPPLANE3") : this._removeClipPlaneDefine("CLIPPLANE3");
        scene.clipPlane4 ? this._addClipPlaneDefine("CLIPPLANE4") : this._removeClipPlaneDefine("CLIPPLANE4");
        if (!this._colorShader.isReady()) {
            return false;
        }
        return _super.prototype.isReady.call(this);
    };
    /**
     * Returns the string "LineMesh"
     */
    LinesMesh.prototype.getClassName = function () {
        return "LinesMesh";
    };
    Object.defineProperty(LinesMesh.prototype, "material", {
        /**
         * @hidden
         */
        get: function () {
            return this._colorShader;
        },
        /**
         * @hidden
         */
        set: function (value) {
            // Do nothing
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinesMesh.prototype, "checkCollisions", {
        /**
         * @hidden
         */
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden */
    LinesMesh.prototype._bind = function (subMesh, effect, fillMode) {
        if (!this._geometry) {
            return this;
        }
        var colorEffect = this._colorShader.getEffect();
        // VBOs
        var indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
        this._geometry._bind(colorEffect, indexToBind);
        // Color
        if (!this.useVertexColor) {
            this._colorShader.setColor4("color", this.color.toColor4(this.alpha));
        }
        // Clip planes
        MaterialHelper.BindClipPlane(colorEffect, this.getScene());
        return this;
    };
    /** @hidden */
    LinesMesh.prototype._draw = function (subMesh, fillMode, instancesCount) {
        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {
            return this;
        }
        var engine = this.getScene().getEngine();
        // Draw order
        if (this._unIndexed) {
            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
        }
        else {
            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
        }
        return this;
    };
    /**
     * Disposes of the line mesh
     * @param doNotRecurse If children should be disposed
     */
    LinesMesh.prototype.dispose = function (doNotRecurse) {
        this._colorShader.dispose(false, false, true);
        _super.prototype.dispose.call(this, doNotRecurse);
    };
    /**
     * Returns a new LineMesh object cloned from the current one.
     */
    LinesMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {
        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);
    };
    /**
     * Creates a new InstancedLinesMesh object from the mesh model.
     * @see http://doc.babylonjs.com/how_to/how_to_use_instances
     * @param name defines the name of the new instance
     * @returns a new InstancedLinesMesh
     */
    LinesMesh.prototype.createInstance = function (name) {
        return new InstancedLinesMesh(name, this);
    };
    return LinesMesh;
}(Mesh));
/**
 * Creates an instance based on a source LinesMesh
 */
var InstancedLinesMesh = /** @class */ (function (_super) {
    __extends(InstancedLinesMesh, _super);
    function InstancedLinesMesh(name, source) {
        var _this = _super.call(this, name, source) || this;
        _this.intersectionThreshold = source.intersectionThreshold;
        return _this;
    }
    /**
     * Returns the string "InstancedLinesMesh".
     */
    InstancedLinesMesh.prototype.getClassName = function () {
        return "InstancedLinesMesh";
    };
    return InstancedLinesMesh;
}(InstancedMesh));

VertexData.CreateLineSystem = function (options) {
    var indices = [];
    var positions = [];
    var lines = options.lines;
    var colors = options.colors;
    var vertexColors = [];
    var idx = 0;
    for (var l = 0; l < lines.length; l++) {
        var points = lines[l];
        for (var index = 0; index < points.length; index++) {
            positions.push(points[index].x, points[index].y, points[index].z);
            if (colors) {
                var color = colors[l];
                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);
            }
            if (index > 0) {
                indices.push(idx - 1);
                indices.push(idx);
            }
            idx++;
        }
    }
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    if (colors) {
        vertexData.colors = vertexColors;
    }
    return vertexData;
};
VertexData.CreateDashedLines = function (options) {
    var dashSize = options.dashSize || 3;
    var gapSize = options.gapSize || 1;
    var dashNb = options.dashNb || 200;
    var points = options.points;
    var positions = new Array();
    var indices = new Array();
    var curvect = Vector3.Zero();
    var lg = 0;
    var nb = 0;
    var shft = 0;
    var dashshft = 0;
    var curshft = 0;
    var idx = 0;
    var i = 0;
    for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        lg += curvect.length();
    }
    shft = lg / dashNb;
    dashshft = dashSize * shft / (dashSize + gapSize);
    for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        nb = Math.floor(curvect.length() / shft);
        curvect.normalize();
        for (var j = 0; j < nb; j++) {
            curshft = shft * j;
            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);
            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);
            indices.push(idx, idx + 1);
            idx += 2;
        }
    }
    // Result
    var vertexData = new VertexData();
    vertexData.positions = positions;
    vertexData.indices = indices;
    return vertexData;
};
Mesh.CreateLines = function (name, points, scene, updatable, instance) {
    if (scene === void 0) { scene = null; }
    if (updatable === void 0) { updatable = false; }
    if (instance === void 0) { instance = null; }
    var options = {
        points: points,
        updatable: updatable,
        instance: instance
    };
    return LinesBuilder.CreateLines(name, options, scene);
};
Mesh.CreateDashedLines = function (name, points, dashSize, gapSize, dashNb, scene, updatable, instance) {
    if (scene === void 0) { scene = null; }
    var options = {
        points: points,
        dashSize: dashSize,
        gapSize: gapSize,
        dashNb: dashNb,
        updatable: updatable,
        instance: instance
    };
    return LinesBuilder.CreateDashedLines(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var LinesBuilder = /** @class */ (function () {
    function LinesBuilder() {
    }
    /**
     * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
     * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
     * * The parameter `lines` is an array of lines, each line being an array of successive Vector3
     * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
     * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
     * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
     * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system
     * @param name defines the name of the new line system
     * @param options defines the options used to create the line system
     * @param scene defines the hosting scene
     * @returns a new line system mesh
     */
    LinesBuilder.CreateLineSystem = function (name, options, scene) {
        var instance = options.instance;
        var lines = options.lines;
        var colors = options.colors;
        if (instance) { // lines update
            var positions = instance.getVerticesData(VertexBuffer.PositionKind);
            var vertexColor;
            var lineColors;
            if (colors) {
                vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);
            }
            var i = 0;
            var c = 0;
            for (var l = 0; l < lines.length; l++) {
                var points = lines[l];
                for (var p = 0; p < points.length; p++) {
                    positions[i] = points[p].x;
                    positions[i + 1] = points[p].y;
                    positions[i + 2] = points[p].z;
                    if (colors && vertexColor) {
                        lineColors = colors[l];
                        vertexColor[c] = lineColors[p].r;
                        vertexColor[c + 1] = lineColors[p].g;
                        vertexColor[c + 2] = lineColors[p].b;
                        vertexColor[c + 3] = lineColors[p].a;
                        c += 4;
                    }
                    i += 3;
                }
            }
            instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
            if (colors && vertexColor) {
                instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);
            }
            return instance;
        }
        // line system creation
        var useVertexColor = (colors) ? true : false;
        var lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha);
        var vertexData = VertexData.CreateLineSystem(options);
        vertexData.applyToMesh(lineSystem, options.updatable);
        return lineSystem;
    };
    /**
     * Creates a line mesh
     * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
     * * The parameter `points` is an array successive Vector3
     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
     * * The optional parameter `colors` is an array of successive Color4, one per line point
     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
     * * When updating an instance, remember that only point positions can change, not the number of points
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines
     * @param name defines the name of the new line system
     * @param options defines the options used to create the line system
     * @param scene defines the hosting scene
     * @returns a new line mesh
     */
    LinesBuilder.CreateLines = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var colors = (options.colors) ? [options.colors] : null;
        var lines = LinesBuilder.CreateLineSystem(name, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha }, scene);
        return lines;
    };
    /**
     * Creates a dashed line mesh
     * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
     * * The parameter `points` is an array successive Vector3
     * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
     * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
     * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
     * * When updating an instance, remember that only point positions can change, not the number of points
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the dashed line mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines
     */
    LinesBuilder.CreateDashedLines = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var points = options.points;
        var instance = options.instance;
        var gapSize = options.gapSize || 1;
        var dashSize = options.dashSize || 3;
        if (instance) { //  dashed lines update
            var positionFunction = function (positions) {
                var curvect = Vector3.Zero();
                var nbSeg = positions.length / 6;
                var lg = 0;
                var nb = 0;
                var shft = 0;
                var dashshft = 0;
                var curshft = 0;
                var p = 0;
                var i = 0;
                var j = 0;
                for (i = 0; i < points.length - 1; i++) {
                    points[i + 1].subtractToRef(points[i], curvect);
                    lg += curvect.length();
                }
                shft = lg / nbSeg;
                var dashSize = instance._creationDataStorage.dashSize;
                var gapSize = instance._creationDataStorage.gapSize;
                dashshft = dashSize * shft / (dashSize + gapSize);
                for (i = 0; i < points.length - 1; i++) {
                    points[i + 1].subtractToRef(points[i], curvect);
                    nb = Math.floor(curvect.length() / shft);
                    curvect.normalize();
                    j = 0;
                    while (j < nb && p < positions.length) {
                        curshft = shft * j;
                        positions[p] = points[i].x + curshft * curvect.x;
                        positions[p + 1] = points[i].y + curshft * curvect.y;
                        positions[p + 2] = points[i].z + curshft * curvect.z;
                        positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;
                        positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;
                        positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;
                        p += 6;
                        j++;
                    }
                }
                while (p < positions.length) {
                    positions[p] = points[i].x;
                    positions[p + 1] = points[i].y;
                    positions[p + 2] = points[i].z;
                    p += 3;
                }
            };
            instance.updateMeshPositions(positionFunction, false);
            return instance;
        }
        // dashed lines creation
        var dashedLines = new LinesMesh(name, scene);
        var vertexData = VertexData.CreateDashedLines(options);
        vertexData.applyToMesh(dashedLines, options.updatable);
        dashedLines._creationDataStorage = new _CreationDataStorage();
        dashedLines._creationDataStorage.dashSize = dashSize;
        dashedLines._creationDataStorage.gapSize = gapSize;
        return dashedLines;
    };
    return LinesBuilder;
}());

/**
 * As raycast might be hard to debug, the RayHelper can help rendering the different rays
 * in order to better appreciate the issue one might have.
 * @see http://doc.babylonjs.com/babylon101/raycasts#debugging
 */
var RayHelper = /** @class */ (function () {
    /**
     * Instantiate a new ray helper.
     * As raycast might be hard to debug, the RayHelper can help rendering the different rays
     * in order to better appreciate the issue one might have.
     * @see http://doc.babylonjs.com/babylon101/raycasts#debugging
     * @param ray Defines the ray we are currently tryin to visualize
     */
    function RayHelper(ray) {
        this.ray = ray;
    }
    /**
     * Helper function to create a colored helper in a scene in one line.
     * @param ray Defines the ray we are currently tryin to visualize
     * @param scene Defines the scene the ray is used in
     * @param color Defines the color we want to see the ray in
     * @returns The newly created ray helper.
     */
    RayHelper.CreateAndShow = function (ray, scene, color) {
        var helper = new RayHelper(ray);
        helper.show(scene, color);
        return helper;
    };
    /**
     * Shows the ray we are willing to debug.
     * @param scene Defines the scene the ray needs to be rendered in
     * @param color Defines the color the ray needs to be rendered in
     */
    RayHelper.prototype.show = function (scene, color) {
        if (!this._renderFunction && this.ray) {
            var ray = this.ray;
            this._renderFunction = this._render.bind(this);
            this._scene = scene;
            this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];
            this._renderLine = Mesh.CreateLines("ray", this._renderPoints, scene, true);
            if (this._renderFunction) {
                this._scene.registerBeforeRender(this._renderFunction);
            }
        }
        if (color && this._renderLine) {
            this._renderLine.color.copyFrom(color);
        }
    };
    /**
     * Hides the ray we are debugging.
     */
    RayHelper.prototype.hide = function () {
        if (this._renderFunction && this._scene) {
            this._scene.unregisterBeforeRender(this._renderFunction);
            this._scene = null;
            this._renderFunction = null;
            if (this._renderLine) {
                this._renderLine.dispose();
                this._renderLine = null;
            }
            this._renderPoints = [];
        }
    };
    RayHelper.prototype._render = function () {
        var ray = this.ray;
        if (!ray) {
            return;
        }
        var point = this._renderPoints[1];
        var len = Math.min(ray.length, 1000000);
        point.copyFrom(ray.direction);
        point.scaleInPlace(len);
        point.addInPlace(ray.origin);
        Mesh.CreateLines("ray", this._renderPoints, this._scene, true, this._renderLine);
    };
    /**
     * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.
     * @param mesh Defines the mesh we want the helper attached to
     * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)
     * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)
     * @param length Defines the length of the ray
     */
    RayHelper.prototype.attachToMesh = function (mesh, meshSpaceDirection, meshSpaceOrigin, length) {
        this._attachedToMesh = mesh;
        var ray = this.ray;
        if (!ray) {
            return;
        }
        if (!ray.direction) {
            ray.direction = Vector3.Zero();
        }
        if (!ray.origin) {
            ray.origin = Vector3.Zero();
        }
        if (length) {
            ray.length = length;
        }
        if (!meshSpaceOrigin) {
            meshSpaceOrigin = Vector3.Zero();
        }
        if (!meshSpaceDirection) {
            // -1 so that this will work with Mesh.lookAt
            meshSpaceDirection = new Vector3(0, 0, -1);
        }
        if (!this._meshSpaceDirection) {
            this._meshSpaceDirection = meshSpaceDirection.clone();
            this._meshSpaceOrigin = meshSpaceOrigin.clone();
        }
        else {
            this._meshSpaceDirection.copyFrom(meshSpaceDirection);
            this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);
        }
        if (!this._updateToMeshFunction) {
            this._updateToMeshFunction = this._updateToMesh.bind(this);
            this._attachedToMesh.getScene().registerBeforeRender(this._updateToMeshFunction);
        }
        this._updateToMesh();
    };
    /**
     * Detach the ray helper from the mesh it has previously been attached to.
     */
    RayHelper.prototype.detachFromMesh = function () {
        if (this._attachedToMesh) {
            if (this._updateToMeshFunction) {
                this._attachedToMesh.getScene().unregisterBeforeRender(this._updateToMeshFunction);
            }
            this._attachedToMesh = null;
            this._updateToMeshFunction = null;
        }
    };
    RayHelper.prototype._updateToMesh = function () {
        var ray = this.ray;
        if (!this._attachedToMesh || !ray) {
            return;
        }
        if (this._attachedToMesh._isDisposed) {
            this.detachFromMesh();
            return;
        }
        this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);
        Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);
    };
    /**
     * Dispose the helper and release its associated resources.
     */
    RayHelper.prototype.dispose = function () {
        this.hide();
        this.detachFromMesh();
        this.ray = null;
    };
    return RayHelper;
}());

/**
     * Class used to render a debug view of a given skeleton
     * @see http://www.babylonjs-playground.com/#1BZJVJ#8
     */
var SkeletonViewer = /** @class */ (function () {
    /**
     * Creates a new SkeletonViewer
     * @param skeleton defines the skeleton to render
     * @param mesh defines the mesh attached to the skeleton
     * @param scene defines the hosting scene
     * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)
     * @param renderingGroupId defines the rendering group id to use with the viewer
     */
    function SkeletonViewer(
    /** defines the skeleton to render */
    skeleton, 
    /** defines the mesh attached to the skeleton */
    mesh, scene, 
    /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */
    autoUpdateBonesMatrices, 
    /** defines the rendering group id to use with the viewer */
    renderingGroupId) {
        if (autoUpdateBonesMatrices === void 0) { autoUpdateBonesMatrices = true; }
        if (renderingGroupId === void 0) { renderingGroupId = 1; }
        this.skeleton = skeleton;
        this.mesh = mesh;
        this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;
        this.renderingGroupId = renderingGroupId;
        /** Gets or sets the color used to render the skeleton */
        this.color = Color3.White();
        this._debugLines = new Array();
        this._isEnabled = false;
        this._scene = scene;
        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);
        this._utilityLayer.pickUtilitySceneFirst = false;
        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;
        this.update();
        this._renderFunction = this.update.bind(this);
    }
    Object.defineProperty(SkeletonViewer.prototype, "debugMesh", {
        /**
         * Returns the mesh used to render the bones
         */
        get: function () {
            return this._debugMesh;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkeletonViewer.prototype, "isEnabled", {
        get: function () {
            return this._isEnabled;
        },
        /** Gets or sets a boolean indicating if the viewer is enabled */
        set: function (value) {
            if (this._isEnabled === value) {
                return;
            }
            this._isEnabled = value;
            if (value) {
                this._scene.registerBeforeRender(this._renderFunction);
            }
            else {
                this._scene.unregisterBeforeRender(this._renderFunction);
            }
        },
        enumerable: true,
        configurable: true
    });
    SkeletonViewer.prototype._getBonePosition = function (position, bone, meshMat, x, y, z) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        var tmat = Tmp.Matrix[0];
        var parentBone = bone.getParent();
        tmat.copyFrom(bone.getLocalMatrix());
        if (x !== 0 || y !== 0 || z !== 0) {
            var tmat2 = Tmp.Matrix[1];
            Matrix.IdentityToRef(tmat2);
            tmat2.setTranslationFromFloats(x, y, z);
            tmat2.multiplyToRef(tmat, tmat);
        }
        if (parentBone) {
            tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);
        }
        tmat.multiplyToRef(meshMat, tmat);
        position.x = tmat.m[12];
        position.y = tmat.m[13];
        position.z = tmat.m[14];
    };
    SkeletonViewer.prototype._getLinesForBonesWithLength = function (bones, meshMat) {
        var len = bones.length;
        var mesh = this.mesh._effectiveMesh;
        var meshPos = mesh.position;
        for (var i = 0; i < len; i++) {
            var bone = bones[i];
            var points = this._debugLines[i];
            if (!points) {
                points = [Vector3.Zero(), Vector3.Zero()];
                this._debugLines[i] = points;
            }
            this._getBonePosition(points[0], bone, meshMat);
            this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);
            points[0].subtractInPlace(meshPos);
            points[1].subtractInPlace(meshPos);
        }
    };
    SkeletonViewer.prototype._getLinesForBonesNoLength = function (bones, meshMat) {
        var len = bones.length;
        var boneNum = 0;
        var mesh = this.mesh._effectiveMesh;
        var meshPos = mesh.position;
        for (var i = len - 1; i >= 0; i--) {
            var childBone = bones[i];
            var parentBone = childBone.getParent();
            if (!parentBone) {
                continue;
            }
            var points = this._debugLines[boneNum];
            if (!points) {
                points = [Vector3.Zero(), Vector3.Zero()];
                this._debugLines[boneNum] = points;
            }
            childBone.getAbsolutePositionToRef(mesh, points[0]);
            parentBone.getAbsolutePositionToRef(mesh, points[1]);
            points[0].subtractInPlace(meshPos);
            points[1].subtractInPlace(meshPos);
            boneNum++;
        }
    };
    /** Update the viewer to sync with current skeleton state */
    SkeletonViewer.prototype.update = function () {
        if (!this._utilityLayer) {
            return;
        }
        if (this.autoUpdateBonesMatrices) {
            this.skeleton.computeAbsoluteTransforms();
        }
        var mesh = this.mesh._effectiveMesh;
        if (this.skeleton.bones[0].length === undefined) {
            this._getLinesForBonesNoLength(this.skeleton.bones, mesh.getWorldMatrix());
        }
        else {
            this._getLinesForBonesWithLength(this.skeleton.bones, mesh.getWorldMatrix());
        }
        var targetScene = this._utilityLayer.utilityLayerScene;
        if (!this._debugMesh) {
            this._debugMesh = LinesBuilder.CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: null }, targetScene);
            this._debugMesh.renderingGroupId = this.renderingGroupId;
        }
        else {
            LinesBuilder.CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: this._debugMesh }, targetScene);
        }
        this._debugMesh.position.copyFrom(this.mesh.position);
        this._debugMesh.color = this.color;
    };
    /** Release associated resources */
    SkeletonViewer.prototype.dispose = function () {
        this.isEnabled = false;
        if (this._debugMesh) {
            this.isEnabled = false;
            this._debugMesh.dispose();
            this._debugMesh = null;
        }
        if (this._utilityLayer) {
            this._utilityLayer.dispose();
            this._utilityLayer = null;
        }
    };
    return SkeletonViewer;
}());

/**
 * Options to create the null engine
 */
var NullEngineOptions = /** @class */ (function () {
    function NullEngineOptions() {
        /**
         * Render width (Default: 512)
         */
        this.renderWidth = 512;
        /**
         * Render height (Default: 256)
         */
        this.renderHeight = 256;
        /**
         * Texture size (Default: 512)
         */
        this.textureSize = 512;
        /**
         * If delta time between frames should be constant
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        this.deterministicLockstep = false;
        /**
         * Maximum about of steps between frames (Default: 4)
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        this.lockstepMaxSteps = 4;
    }
    return NullEngineOptions;
}());
/**
 * The null engine class provides support for headless version of babylon.js.
 * This can be used in server side scenario or for testing purposes
 */
var NullEngine = /** @class */ (function (_super) {
    __extends(NullEngine, _super);
    function NullEngine(options) {
        if (options === void 0) { options = new NullEngineOptions(); }
        var _this = _super.call(this, null) || this;
        if (options.deterministicLockstep === undefined) {
            options.deterministicLockstep = false;
        }
        if (options.lockstepMaxSteps === undefined) {
            options.lockstepMaxSteps = 4;
        }
        _this._options = options;
        // Init caps
        // We consider we are on a webgl1 capable device
        _this._caps = new EngineCapabilities();
        _this._caps.maxTexturesImageUnits = 16;
        _this._caps.maxVertexTextureImageUnits = 16;
        _this._caps.maxTextureSize = 512;
        _this._caps.maxCubemapTextureSize = 512;
        _this._caps.maxRenderTextureSize = 512;
        _this._caps.maxVertexAttribs = 16;
        _this._caps.maxVaryingVectors = 16;
        _this._caps.maxFragmentUniformVectors = 16;
        _this._caps.maxVertexUniformVectors = 16;
        // Extensions
        _this._caps.standardDerivatives = false;
        _this._caps.astc = null;
        _this._caps.s3tc = null;
        _this._caps.pvrtc = null;
        _this._caps.etc1 = null;
        _this._caps.etc2 = null;
        _this._caps.textureAnisotropicFilterExtension = null;
        _this._caps.maxAnisotropy = 0;
        _this._caps.uintIndices = false;
        _this._caps.fragmentDepthSupported = false;
        _this._caps.highPrecisionShaderSupported = true;
        _this._caps.colorBufferFloat = false;
        _this._caps.textureFloat = false;
        _this._caps.textureFloatLinearFiltering = false;
        _this._caps.textureFloatRender = false;
        _this._caps.textureHalfFloat = false;
        _this._caps.textureHalfFloatLinearFiltering = false;
        _this._caps.textureHalfFloatRender = false;
        _this._caps.textureLOD = false;
        _this._caps.drawBuffersExtension = false;
        _this._caps.depthTextureExtension = false;
        _this._caps.vertexArrayObject = false;
        _this._caps.instancedArrays = false;
        Logger.Log("Babylon.js v" + Engine.Version + " - Null engine");
        // Wrappers
        var theCurrentGlobal = (typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : window);
        if (typeof URL === "undefined") {
            theCurrentGlobal.URL = {
                createObjectURL: function () { },
                revokeObjectURL: function () { }
            };
        }
        if (typeof Blob === "undefined") {
            theCurrentGlobal.Blob = function () { };
        }
        return _this;
    }
    /**
     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
     */
    NullEngine.prototype.isDeterministicLockStep = function () {
        return this._options.deterministicLockstep;
    };
    /** @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep */
    NullEngine.prototype.getLockstepMaxSteps = function () {
        return this._options.lockstepMaxSteps;
    };
    /**
     * Sets hardware scaling, used to save performance if needed
     * @see https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    NullEngine.prototype.getHardwareScalingLevel = function () {
        return 1.0;
    };
    NullEngine.prototype.createVertexBuffer = function (vertices) {
        var buffer = new DataBuffer();
        buffer.references = 1;
        return buffer;
    };
    NullEngine.prototype.createIndexBuffer = function (indices) {
        var buffer = new DataBuffer();
        buffer.references = 1;
        return buffer;
    };
    NullEngine.prototype.clear = function (color, backBuffer, depth, stencil) {
    };
    NullEngine.prototype.getRenderWidth = function (useScreen) {
        if (useScreen === void 0) { useScreen = false; }
        if (!useScreen && this._currentRenderTarget) {
            return this._currentRenderTarget.width;
        }
        return this._options.renderWidth;
    };
    NullEngine.prototype.getRenderHeight = function (useScreen) {
        if (useScreen === void 0) { useScreen = false; }
        if (!useScreen && this._currentRenderTarget) {
            return this._currentRenderTarget.height;
        }
        return this._options.renderHeight;
    };
    NullEngine.prototype.setViewport = function (viewport, requiredWidth, requiredHeight) {
        this._cachedViewport = viewport;
    };
    NullEngine.prototype.createShaderProgram = function (pipelineContext, vertexCode, fragmentCode, defines, context) {
        return {
            __SPECTOR_rebuildProgram: null,
        };
    };
    NullEngine.prototype.getUniforms = function (pipelineContext, uniformsNames) {
        return [];
    };
    NullEngine.prototype.getAttributes = function (pipelineContext, attributesNames) {
        return [];
    };
    NullEngine.prototype.bindSamplers = function (effect) {
        this._currentEffect = null;
    };
    NullEngine.prototype.enableEffect = function (effect) {
        this._currentEffect = effect;
        if (effect.onBind) {
            effect.onBind(effect);
        }
        if (effect._onBindObservable) {
            effect._onBindObservable.notifyObservers(effect);
        }
    };
    NullEngine.prototype.setState = function (culling, zOffset, force, reverseSide) {
    };
    NullEngine.prototype.setIntArray = function (uniform, array) {
    };
    NullEngine.prototype.setIntArray2 = function (uniform, array) {
    };
    NullEngine.prototype.setIntArray3 = function (uniform, array) {
    };
    NullEngine.prototype.setIntArray4 = function (uniform, array) {
    };
    NullEngine.prototype.setFloatArray = function (uniform, array) {
    };
    NullEngine.prototype.setFloatArray2 = function (uniform, array) {
    };
    NullEngine.prototype.setFloatArray3 = function (uniform, array) {
    };
    NullEngine.prototype.setFloatArray4 = function (uniform, array) {
    };
    NullEngine.prototype.setArray = function (uniform, array) {
    };
    NullEngine.prototype.setArray2 = function (uniform, array) {
    };
    NullEngine.prototype.setArray3 = function (uniform, array) {
    };
    NullEngine.prototype.setArray4 = function (uniform, array) {
    };
    NullEngine.prototype.setMatrices = function (uniform, matrices) {
    };
    NullEngine.prototype.setMatrix = function (uniform, matrix) {
    };
    NullEngine.prototype.setMatrix3x3 = function (uniform, matrix) {
    };
    NullEngine.prototype.setMatrix2x2 = function (uniform, matrix) {
    };
    NullEngine.prototype.setFloat = function (uniform, value) {
    };
    NullEngine.prototype.setFloat2 = function (uniform, x, y) {
    };
    NullEngine.prototype.setFloat3 = function (uniform, x, y, z) {
    };
    NullEngine.prototype.setBool = function (uniform, bool) {
    };
    NullEngine.prototype.setFloat4 = function (uniform, x, y, z, w) {
    };
    NullEngine.prototype.setColor3 = function (uniform, color3) {
    };
    NullEngine.prototype.setColor4 = function (uniform, color3, alpha) {
    };
    NullEngine.prototype.setAlphaMode = function (mode, noDepthWriteChange) {
        if (noDepthWriteChange === void 0) { noDepthWriteChange = false; }
        if (this._alphaMode === mode) {
            return;
        }
        this._alphaState.alphaBlend = (mode !== Constants.ALPHA_DISABLE);
        if (!noDepthWriteChange) {
            this.setDepthWrite(mode === Constants.ALPHA_DISABLE);
        }
        this._alphaMode = mode;
    };
    NullEngine.prototype.bindBuffers = function (vertexBuffers, indexBuffer, effect) {
    };
    NullEngine.prototype.wipeCaches = function (bruteForce) {
        if (this.preventCacheWipeBetweenFrames) {
            return;
        }
        this.resetTextureCache();
        this._currentEffect = null;
        if (bruteForce) {
            this._currentProgram = null;
            this._stencilState.reset();
            this._depthCullingState.reset();
            this._alphaState.reset();
        }
        this._cachedVertexBuffers = null;
        this._cachedIndexBuffer = null;
        this._cachedEffectForVertexBuffers = null;
    };
    NullEngine.prototype.draw = function (useTriangles, indexStart, indexCount, instancesCount) {
    };
    NullEngine.prototype.drawElementsType = function (fillMode, indexStart, indexCount, instancesCount) {
    };
    NullEngine.prototype.drawArraysType = function (fillMode, verticesStart, verticesCount, instancesCount) {
    };
    /** @hidden */
    NullEngine.prototype._createTexture = function () {
        return {};
    };
    /** @hidden */
    NullEngine.prototype._releaseTexture = function (texture) {
    };
    NullEngine.prototype.createTexture = function (urlArg, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallBack, format) {
        if (samplingMode === void 0) { samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE; }
        if (onLoad === void 0) { onLoad = null; }
        var texture = new InternalTexture(this, InternalTexture.DATASOURCE_URL);
        var url = String(urlArg);
        texture.url = url;
        texture.generateMipMaps = !noMipmap;
        texture.samplingMode = samplingMode;
        texture.invertY = invertY;
        texture.baseWidth = this._options.textureSize;
        texture.baseHeight = this._options.textureSize;
        texture.width = this._options.textureSize;
        texture.height = this._options.textureSize;
        if (format) {
            texture.format = format;
        }
        texture.isReady = true;
        if (onLoad) {
            onLoad();
        }
        this._internalTexturesCache.push(texture);
        return texture;
    };
    NullEngine.prototype.createRenderTargetTexture = function (size, options) {
        var fullOptions = new RenderTargetCreationOptions();
        if (options !== undefined && typeof options === "object") {
            fullOptions.generateMipMaps = options.generateMipMaps;
            fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;
            fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
            fullOptions.type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;
            fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;
        }
        else {
            fullOptions.generateMipMaps = options;
            fullOptions.generateDepthBuffer = true;
            fullOptions.generateStencilBuffer = false;
            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;
            fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;
        }
        var texture = new InternalTexture(this, InternalTexture.DATASOURCE_RENDERTARGET);
        var width = size.width || size;
        var height = size.height || size;
        texture._depthStencilBuffer = {};
        texture._framebuffer = {};
        texture.baseWidth = width;
        texture.baseHeight = height;
        texture.width = width;
        texture.height = height;
        texture.isReady = true;
        texture.samples = 1;
        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
        texture.samplingMode = fullOptions.samplingMode;
        texture.type = fullOptions.type;
        texture._generateDepthBuffer = fullOptions.generateDepthBuffer;
        texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
        this._internalTexturesCache.push(texture);
        return texture;
    };
    NullEngine.prototype.updateTextureSamplingMode = function (samplingMode, texture) {
        texture.samplingMode = samplingMode;
    };
    NullEngine.prototype.bindFramebuffer = function (texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {
        if (this._currentRenderTarget) {
            this.unBindFramebuffer(this._currentRenderTarget);
        }
        this._currentRenderTarget = texture;
        this._currentFramebuffer = texture._MSAAFramebuffer ? texture._MSAAFramebuffer : texture._framebuffer;
        if (this._cachedViewport && !forceFullscreenViewport) {
            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
        }
    };
    NullEngine.prototype.unBindFramebuffer = function (texture, disableGenerateMipMaps, onBeforeUnbind) {
        this._currentRenderTarget = null;
        if (onBeforeUnbind) {
            if (texture._MSAAFramebuffer) {
                this._currentFramebuffer = texture._framebuffer;
            }
            onBeforeUnbind();
        }
        this._currentFramebuffer = null;
    };
    NullEngine.prototype.createDynamicVertexBuffer = function (vertices) {
        var buffer = new DataBuffer();
        buffer.references = 1;
        buffer.capacity = 1;
        return buffer;
    };
    NullEngine.prototype.updateDynamicTexture = function (texture, canvas, invertY, premulAlpha, format) {
    };
    NullEngine.prototype.areAllEffectsReady = function () {
        return true;
    };
    /**
     * @hidden
     * Get the current error code of the webGL context
     * @returns the error code
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
     */
    NullEngine.prototype.getError = function () {
        return 0;
    };
    /** @hidden */
    NullEngine.prototype._getUnpackAlignement = function () {
        return 1;
    };
    /** @hidden */
    NullEngine.prototype._unpackFlipY = function (value) {
    };
    NullEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset) {
    };
    /**
     * Updates a dynamic vertex buffer.
     * @param vertexBuffer the vertex buffer to update
     * @param data the data used to update the vertex buffer
     * @param byteOffset the byte offset of the data (optional)
     * @param byteLength the byte length of the data (optional)
     */
    NullEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, vertices, byteOffset, byteLength) {
    };
    NullEngine.prototype._bindTextureDirectly = function (target, texture) {
        if (this._boundTexturesCache[this._activeChannel] !== texture) {
            this._boundTexturesCache[this._activeChannel] = texture;
            return true;
        }
        return false;
    };
    /** @hidden */
    NullEngine.prototype._bindTexture = function (channel, texture) {
        if (channel < 0) {
            return;
        }
        this._bindTextureDirectly(0, texture);
    };
    /** @hidden */
    NullEngine.prototype._releaseBuffer = function (buffer) {
        buffer.references--;
        if (buffer.references === 0) {
            return true;
        }
        return false;
    };
    NullEngine.prototype.releaseEffects = function () {
    };
    NullEngine.prototype.displayLoadingUI = function () {
    };
    NullEngine.prototype.hideLoadingUI = function () {
    };
    /** @hidden */
    NullEngine.prototype._uploadCompressedDataToTextureDirectly = function (texture, internalFormat, width, height, data, faceIndex, lod) {
    };
    /** @hidden */
    NullEngine.prototype._uploadDataToTextureDirectly = function (texture, imageData, faceIndex, lod) {
    };
    /** @hidden */
    NullEngine.prototype._uploadArrayBufferViewToTexture = function (texture, imageData, faceIndex, lod) {
    };
    /** @hidden */
    NullEngine.prototype._uploadImageToTexture = function (texture, image, faceIndex, lod) {
    };
    return NullEngine;
}(Engine));

/**
 * @hidden
 **/
var _TimeToken = /** @class */ (function () {
    function _TimeToken() {
        this._timeElapsedQueryEnded = false;
    }
    return _TimeToken;
}());

/** @hidden */
var _OcclusionDataStorage = /** @class */ (function () {
    function _OcclusionDataStorage() {
        /** @hidden */
        this.occlusionInternalRetryCounter = 0;
        /** @hidden */
        this.isOcclusionQueryInProgress = false;
        /** @hidden */
        this.isOccluded = false;
        /** @hidden */
        this.occlusionRetryCount = -1;
        /** @hidden */
        this.occlusionType = AbstractMesh.OCCLUSION_TYPE_NONE;
        /** @hidden */
        this.occlusionQueryAlgorithmType = AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;
    }
    return _OcclusionDataStorage;
}());
Engine.prototype.createQuery = function () {
    return this._gl.createQuery();
};
Engine.prototype.deleteQuery = function (query) {
    this._gl.deleteQuery(query);
    return this;
};
Engine.prototype.isQueryResultAvailable = function (query) {
    return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT_AVAILABLE);
};
Engine.prototype.getQueryResult = function (query) {
    return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT);
};
Engine.prototype.beginOcclusionQuery = function (algorithmType, query) {
    var glAlgorithm = this._getGlAlgorithmType(algorithmType);
    this._gl.beginQuery(glAlgorithm, query);
    return this;
};
Engine.prototype.endOcclusionQuery = function (algorithmType) {
    var glAlgorithm = this._getGlAlgorithmType(algorithmType);
    this._gl.endQuery(glAlgorithm);
    return this;
};
Engine.prototype._createTimeQuery = function () {
    var timerQuery = this.getCaps().timerQuery;
    if (timerQuery.createQueryEXT) {
        return timerQuery.createQueryEXT();
    }
    return this.createQuery();
};
Engine.prototype._deleteTimeQuery = function (query) {
    var timerQuery = this.getCaps().timerQuery;
    if (timerQuery.deleteQueryEXT) {
        timerQuery.deleteQueryEXT(query);
        return;
    }
    this.deleteQuery(query);
};
Engine.prototype._getTimeQueryResult = function (query) {
    var timerQuery = this.getCaps().timerQuery;
    if (timerQuery.getQueryObjectEXT) {
        return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_EXT);
    }
    return this.getQueryResult(query);
};
Engine.prototype._getTimeQueryAvailability = function (query) {
    var timerQuery = this.getCaps().timerQuery;
    if (timerQuery.getQueryObjectEXT) {
        return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_AVAILABLE_EXT);
    }
    return this.isQueryResultAvailable(query);
};
Engine.prototype.startTimeQuery = function () {
    var caps = this.getCaps();
    var timerQuery = caps.timerQuery;
    if (!timerQuery) {
        return null;
    }
    var token = new _TimeToken();
    this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);
    if (caps.canUseTimestampForTimerQuery) {
        token._startTimeQuery = this._createTimeQuery();
        timerQuery.queryCounterEXT(token._startTimeQuery, timerQuery.TIMESTAMP_EXT);
    }
    else {
        if (this._currentNonTimestampToken) {
            return this._currentNonTimestampToken;
        }
        token._timeElapsedQuery = this._createTimeQuery();
        if (timerQuery.beginQueryEXT) {
            timerQuery.beginQueryEXT(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);
        }
        else {
            this._gl.beginQuery(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);
        }
        this._currentNonTimestampToken = token;
    }
    return token;
};
Engine.prototype.endTimeQuery = function (token) {
    var caps = this.getCaps();
    var timerQuery = caps.timerQuery;
    if (!timerQuery || !token) {
        return -1;
    }
    if (caps.canUseTimestampForTimerQuery) {
        if (!token._startTimeQuery) {
            return -1;
        }
        if (!token._endTimeQuery) {
            token._endTimeQuery = this._createTimeQuery();
            timerQuery.queryCounterEXT(token._endTimeQuery, timerQuery.TIMESTAMP_EXT);
        }
    }
    else if (!token._timeElapsedQueryEnded) {
        if (!token._timeElapsedQuery) {
            return -1;
        }
        if (timerQuery.endQueryEXT) {
            timerQuery.endQueryEXT(timerQuery.TIME_ELAPSED_EXT);
        }
        else {
            this._gl.endQuery(timerQuery.TIME_ELAPSED_EXT);
        }
        token._timeElapsedQueryEnded = true;
    }
    var disjoint = this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);
    var available = false;
    if (token._endTimeQuery) {
        available = this._getTimeQueryAvailability(token._endTimeQuery);
    }
    else if (token._timeElapsedQuery) {
        available = this._getTimeQueryAvailability(token._timeElapsedQuery);
    }
    if (available && !disjoint) {
        var result = 0;
        if (caps.canUseTimestampForTimerQuery) {
            if (!token._startTimeQuery || !token._endTimeQuery) {
                return -1;
            }
            var timeStart = this._getTimeQueryResult(token._startTimeQuery);
            var timeEnd = this._getTimeQueryResult(token._endTimeQuery);
            result = timeEnd - timeStart;
            this._deleteTimeQuery(token._startTimeQuery);
            this._deleteTimeQuery(token._endTimeQuery);
            token._startTimeQuery = null;
            token._endTimeQuery = null;
        }
        else {
            if (!token._timeElapsedQuery) {
                return -1;
            }
            result = this._getTimeQueryResult(token._timeElapsedQuery);
            this._deleteTimeQuery(token._timeElapsedQuery);
            token._timeElapsedQuery = null;
            token._timeElapsedQueryEnded = false;
            this._currentNonTimestampToken = null;
        }
        return result;
    }
    return -1;
};
Engine.prototype._getGlAlgorithmType = function (algorithmType) {
    return algorithmType === AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE ? this._gl.ANY_SAMPLES_PASSED_CONSERVATIVE : this._gl.ANY_SAMPLES_PASSED;
};
Object.defineProperty(AbstractMesh.prototype, "isOcclusionQueryInProgress", {
    get: function () {
        return this._occlusionDataStorage.isOcclusionQueryInProgress;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "_occlusionDataStorage", {
    get: function () {
        if (!this.__occlusionDataStorage) {
            this.__occlusionDataStorage = new _OcclusionDataStorage();
        }
        return this.__occlusionDataStorage;
    },
    enumerable: false,
    configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "isOccluded", {
    get: function () {
        return this._occlusionDataStorage.isOccluded;
    },
    set: function (value) {
        this._occlusionDataStorage.isOccluded = value;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionQueryAlgorithmType", {
    get: function () {
        return this._occlusionDataStorage.occlusionQueryAlgorithmType;
    },
    set: function (value) {
        this._occlusionDataStorage.occlusionQueryAlgorithmType = value;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionType", {
    get: function () {
        return this._occlusionDataStorage.occlusionType;
    },
    set: function (value) {
        this._occlusionDataStorage.occlusionType = value;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "occlusionRetryCount", {
    get: function () {
        return this._occlusionDataStorage.occlusionRetryCount;
    },
    set: function (value) {
        this._occlusionDataStorage.occlusionRetryCount = value;
    },
    enumerable: true,
    configurable: true
});
// We also need to update AbstractMesh as there is a portion of the code there
AbstractMesh.prototype._checkOcclusionQuery = function () {
    var dataStorage = this._occlusionDataStorage;
    if (dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_NONE) {
        dataStorage.isOccluded = false;
        return false;
    }
    var engine = this.getEngine();
    if (engine.webGLVersion < 2) {
        dataStorage.isOccluded = false;
        return false;
    }
    if (!engine.isQueryResultAvailable) { // Occlusion query where not referenced
        dataStorage.isOccluded = false;
        return false;
    }
    if (this.isOcclusionQueryInProgress && this._occlusionQuery) {
        var isOcclusionQueryAvailable = engine.isQueryResultAvailable(this._occlusionQuery);
        if (isOcclusionQueryAvailable) {
            var occlusionQueryResult = engine.getQueryResult(this._occlusionQuery);
            dataStorage.isOcclusionQueryInProgress = false;
            dataStorage.occlusionInternalRetryCounter = 0;
            dataStorage.isOccluded = occlusionQueryResult === 1 ? false : true;
        }
        else {
            dataStorage.occlusionInternalRetryCounter++;
            if (dataStorage.occlusionRetryCount !== -1 && dataStorage.occlusionInternalRetryCounter > dataStorage.occlusionRetryCount) {
                dataStorage.isOcclusionQueryInProgress = false;
                dataStorage.occlusionInternalRetryCounter = 0;
                // if optimistic set isOccluded to false regardless of the status of isOccluded. (Render in the current render loop)
                // if strict continue the last state of the object.
                dataStorage.isOccluded = dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;
            }
            else {
                return false;
            }
        }
    }
    var scene = this.getScene();
    if (scene.getBoundingBoxRenderer) {
        var occlusionBoundingBoxRenderer = scene.getBoundingBoxRenderer();
        if (!this._occlusionQuery) {
            this._occlusionQuery = engine.createQuery();
        }
        engine.beginOcclusionQuery(dataStorage.occlusionQueryAlgorithmType, this._occlusionQuery);
        occlusionBoundingBoxRenderer.renderOcclusionBoundingBox(this);
        engine.endOcclusionQuery(dataStorage.occlusionQueryAlgorithmType);
        this._occlusionDataStorage.isOcclusionQueryInProgress = true;
    }
    return dataStorage.isOccluded;
};

/** @hidden */
var _forceTransformFeedbackToBundle = true;
Engine.prototype.createTransformFeedback = function () {
    return this._gl.createTransformFeedback();
};
Engine.prototype.deleteTransformFeedback = function (value) {
    this._gl.deleteTransformFeedback(value);
};
Engine.prototype.bindTransformFeedback = function (value) {
    this._gl.bindTransformFeedback(this._gl.TRANSFORM_FEEDBACK, value);
};
Engine.prototype.beginTransformFeedback = function (usePoints) {
    if (usePoints === void 0) { usePoints = true; }
    this._gl.beginTransformFeedback(usePoints ? this._gl.POINTS : this._gl.TRIANGLES);
};
Engine.prototype.endTransformFeedback = function () {
    this._gl.endTransformFeedback();
};
Engine.prototype.setTranformFeedbackVaryings = function (program, value) {
    this._gl.transformFeedbackVaryings(program, value, this._gl.INTERLEAVED_ATTRIBS);
};
Engine.prototype.bindTransformFeedbackBuffer = function (value) {
    this._gl.bindBufferBase(this._gl.TRANSFORM_FEEDBACK_BUFFER, 0, value ? value.underlyingResource : null);
};

/**
 * Google Daydream controller
 */
var DaydreamController = /** @class */ (function (_super) {
    __extends(DaydreamController, _super);
    /**
     * Creates a new DaydreamController from a gamepad
     * @param vrGamepad the gamepad that the controller should be created from
     */
    function DaydreamController(vrGamepad) {
        var _this = _super.call(this, vrGamepad) || this;
        _this.controllerType = PoseEnabledControllerType.DAYDREAM;
        return _this;
    }
    /**
     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
     * @param scene scene in which to add meshes
     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
     */
    DaydreamController.prototype.initControllerMesh = function (scene, meshLoaded) {
        var _this = this;
        SceneLoader.ImportMesh("", DaydreamController.MODEL_BASE_URL, DaydreamController.MODEL_FILENAME, scene, function (newMeshes) {
            _this._defaultModel = newMeshes[1];
            _this.attachToMesh(_this._defaultModel);
            if (meshLoaded) {
                meshLoaded(_this._defaultModel);
            }
        });
    };
    /**
     * Called once for each button that changed state since the last frame
     * @param buttonIdx Which button index changed
     * @param state New state of the button
     * @param changes Which properties on the state changed since last frame
     */
    DaydreamController.prototype._handleButtonChange = function (buttonIdx, state, changes) {
        // Daydream controller only has 1 GamepadButton (on the trackpad).
        if (buttonIdx === 0) {
            var observable = this.onTriggerStateChangedObservable;
            if (observable) {
                observable.notifyObservers(state);
            }
        }
        else {
            // If the app or home buttons are ever made available
            Logger.Warn("Unrecognized Daydream button index: " + buttonIdx);
        }
    };
    /**
     * Base Url for the controller model.
     */
    DaydreamController.MODEL_BASE_URL = 'https://controllers.babylonjs.com/generic/';
    /**
     * File name for the controller model.
     */
    DaydreamController.MODEL_FILENAME = 'generic.babylon';
    /**
     * Gamepad Id prefix used to identify Daydream Controller.
     */
    DaydreamController.GAMEPAD_ID_PREFIX = 'Daydream'; // id is 'Daydream Controller'
    return DaydreamController;
}(WebVRController));
PoseEnabledControllerHelper._ControllerFactories.push({
    canCreate: function (gamepadInfo) {
        return gamepadInfo.id.indexOf(DaydreamController.GAMEPAD_ID_PREFIX) === 0;
    },
    create: function (gamepadInfo) {
        return new DaydreamController(gamepadInfo);
    }
});

/**
     * Gear VR Controller
     */
var GearVRController = /** @class */ (function (_super) {
    __extends(GearVRController, _super);
    /**
     * Creates a new GearVRController from a gamepad
     * @param vrGamepad the gamepad that the controller should be created from
     */
    function GearVRController(vrGamepad) {
        var _this = _super.call(this, vrGamepad) || this;
        _this._buttonIndexToObservableNameMap = [
            'onPadStateChangedObservable',
            'onTriggerStateChangedObservable' // Trigger
        ];
        _this.controllerType = PoseEnabledControllerType.GEAR_VR;
        // Initial starting position defaults to where hand would be (incase of only 3dof controller)
        _this._calculatedPosition = new Vector3(_this.hand == "left" ? -0.15 : 0.15, -0.5, 0.25);
        _this._disableTrackPosition(_this._calculatedPosition);
        return _this;
    }
    /**
     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
     * @param scene scene in which to add meshes
     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
     */
    GearVRController.prototype.initControllerMesh = function (scene, meshLoaded) {
        var _this = this;
        SceneLoader.ImportMesh("", GearVRController.MODEL_BASE_URL, GearVRController.MODEL_FILENAME, scene, function (newMeshes) {
            // Offset the controller so it will rotate around the users wrist
            var mesh = new Mesh("", scene);
            newMeshes[1].parent = mesh;
            newMeshes[1].position.z = -0.15;
            _this._defaultModel = mesh;
            _this.attachToMesh(_this._defaultModel);
            if (meshLoaded) {
                meshLoaded(_this._defaultModel);
            }
        });
    };
    /**
     * Called once for each button that changed state since the last frame
     * @param buttonIdx Which button index changed
     * @param state New state of the button
     * @param changes Which properties on the state changed since last frame
     */
    GearVRController.prototype._handleButtonChange = function (buttonIdx, state, changes) {
        if (buttonIdx < this._buttonIndexToObservableNameMap.length) {
            var observableName = this._buttonIndexToObservableNameMap[buttonIdx];
            // Only emit events for buttons that we know how to map from index to observable
            var observable = this[observableName];
            if (observable) {
                observable.notifyObservers(state);
            }
        }
    };
    /**
     * Base Url for the controller model.
     */
    GearVRController.MODEL_BASE_URL = 'https://controllers.babylonjs.com/generic/';
    /**
     * File name for the controller model.
     */
    GearVRController.MODEL_FILENAME = 'generic.babylon';
    /**
     * Gamepad Id prefix used to identify this controller.
     */
    GearVRController.GAMEPAD_ID_PREFIX = 'Gear VR'; // id is 'Gear VR Controller'
    return GearVRController;
}(WebVRController));
PoseEnabledControllerHelper._ControllerFactories.push({
    canCreate: function (gamepadInfo) {
        return gamepadInfo.id.indexOf(GearVRController.GAMEPAD_ID_PREFIX) === 0 ||
            gamepadInfo.id.indexOf('Oculus Go') !== -1;
    },
    create: function (gamepadInfo) {
        return new GearVRController(gamepadInfo);
    }
});

/**
 * Generic Controller
 */
var GenericController = /** @class */ (function (_super) {
    __extends(GenericController, _super);
    /**
     * Creates a new GenericController from a gamepad
     * @param vrGamepad the gamepad that the controller should be created from
     */
    function GenericController(vrGamepad) {
        return _super.call(this, vrGamepad) || this;
    }
    /**
     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
     * @param scene scene in which to add meshes
     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
     */
    GenericController.prototype.initControllerMesh = function (scene, meshLoaded) {
        var _this = this;
        SceneLoader.ImportMesh("", GenericController.MODEL_BASE_URL, GenericController.MODEL_FILENAME, scene, function (newMeshes) {
            _this._defaultModel = newMeshes[1];
            _this.attachToMesh(_this._defaultModel);
            if (meshLoaded) {
                meshLoaded(_this._defaultModel);
            }
        });
    };
    /**
     * Called once for each button that changed state since the last frame
     * @param buttonIdx Which button index changed
     * @param state New state of the button
     * @param changes Which properties on the state changed since last frame
     */
    GenericController.prototype._handleButtonChange = function (buttonIdx, state, changes) {
        console.log("Button id: " + buttonIdx + "state: ");
        console.dir(state);
    };
    /**
     * Base Url for the controller model.
     */
    GenericController.MODEL_BASE_URL = 'https://controllers.babylonjs.com/generic/';
    /**
     * File name for the controller model.
     */
    GenericController.MODEL_FILENAME = 'generic.babylon';
    return GenericController;
}(WebVRController));
PoseEnabledControllerHelper._DefaultControllerFactory = function (gamepadInfo) { return new GenericController(gamepadInfo); };

/**
 * Oculus Touch Controller
 */
var OculusTouchController = /** @class */ (function (_super) {
    __extends(OculusTouchController, _super);
    /**
     * Creates a new OculusTouchController from a gamepad
     * @param vrGamepad the gamepad that the controller should be created from
     */
    function OculusTouchController(vrGamepad) {
        var _this = _super.call(this, vrGamepad) || this;
        /**
         * Fired when the secondary trigger on this controller is modified
         */
        _this.onSecondaryTriggerStateChangedObservable = new Observable();
        /**
         * Fired when the thumb rest on this controller is modified
         */
        _this.onThumbRestChangedObservable = new Observable();
        _this.controllerType = PoseEnabledControllerType.OCULUS;
        return _this;
    }
    /**
     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
     * @param scene scene in which to add meshes
     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
     */
    OculusTouchController.prototype.initControllerMesh = function (scene, meshLoaded) {
        var _this = this;
        var meshName;
        // Hand
        if (this.hand === 'left') {
            meshName = OculusTouchController.MODEL_LEFT_FILENAME;
        }
        else { // Right is the default if no hand is specified
            meshName = OculusTouchController.MODEL_RIGHT_FILENAME;
        }
        SceneLoader.ImportMesh("", OculusTouchController.MODEL_BASE_URL, meshName, scene, function (newMeshes) {
            /*
            Parent Mesh name: oculus_touch_left
            - body
            - trigger
            - thumbstick
            - grip
            - button_y
            - button_x
            - button_enter
            */
            _this._defaultModel = newMeshes[1];
            _this.attachToMesh(_this._defaultModel);
            if (meshLoaded) {
                meshLoaded(_this._defaultModel);
            }
        });
    };
    Object.defineProperty(OculusTouchController.prototype, "onAButtonStateChangedObservable", {
        /**
         * Fired when the A button on this controller is modified
         */
        get: function () {
            if (this.hand === 'right') {
                return this.onMainButtonStateChangedObservable;
            }
            else {
                throw new Error('No A button on left hand');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OculusTouchController.prototype, "onBButtonStateChangedObservable", {
        /**
         * Fired when the B button on this controller is modified
         */
        get: function () {
            if (this.hand === 'right') {
                return this.onSecondaryButtonStateChangedObservable;
            }
            else {
                throw new Error('No B button on left hand');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OculusTouchController.prototype, "onXButtonStateChangedObservable", {
        /**
         * Fired when the X button on this controller is modified
         */
        get: function () {
            if (this.hand === 'left') {
                return this.onMainButtonStateChangedObservable;
            }
            else {
                throw new Error('No X button on right hand');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OculusTouchController.prototype, "onYButtonStateChangedObservable", {
        /**
         * Fired when the Y button on this controller is modified
         */
        get: function () {
            if (this.hand === 'left') {
                return this.onSecondaryButtonStateChangedObservable;
            }
            else {
                throw new Error('No Y button on right hand');
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
      * Called once for each button that changed state since the last frame
      * 0) thumb stick (touch, press, value = pressed (0,1)). value is in this.leftStick
      * 1) index trigger (touch (?), press (only when value > 0.1), value 0 to 1)
      * 2) secondary trigger (same)
      * 3) A (right) X (left), touch, pressed = value
      * 4) B / Y
      * 5) thumb rest
      * @param buttonIdx Which button index changed
      * @param state New state of the button
      * @param changes Which properties on the state changed since last frame
      */
    OculusTouchController.prototype._handleButtonChange = function (buttonIdx, state, changes) {
        var notifyObject = state; //{ state: state, changes: changes };
        var triggerDirection = this.hand === 'right' ? -1 : 1;
        switch (buttonIdx) {
            case 0:
                this.onPadStateChangedObservable.notifyObservers(notifyObject);
                return;
            case 1: // index trigger
                if (this._defaultModel) {
                    (this._defaultModel.getChildren()[3]).rotation.x = -notifyObject.value * 0.20;
                    (this._defaultModel.getChildren()[3]).position.y = -notifyObject.value * 0.005;
                    (this._defaultModel.getChildren()[3]).position.z = -notifyObject.value * 0.005;
                }
                this.onTriggerStateChangedObservable.notifyObservers(notifyObject);
                return;
            case 2: // secondary trigger
                if (this._defaultModel) {
                    (this._defaultModel.getChildren()[4]).position.x = triggerDirection * notifyObject.value * 0.0035;
                }
                this.onSecondaryTriggerStateChangedObservable.notifyObservers(notifyObject);
                return;
            case 3:
                if (this._defaultModel) {
                    if (notifyObject.pressed) {
                        (this._defaultModel.getChildren()[1]).position.y = -0.001;
                    }
                    else {
                        (this._defaultModel.getChildren()[1]).position.y = 0;
                    }
                }
                this.onMainButtonStateChangedObservable.notifyObservers(notifyObject);
                return;
            case 4:
                if (this._defaultModel) {
                    if (notifyObject.pressed) {
                        (this._defaultModel.getChildren()[2]).position.y = -0.001;
                    }
                    else {
                        (this._defaultModel.getChildren()[2]).position.y = 0;
                    }
                }
                this.onSecondaryButtonStateChangedObservable.notifyObservers(notifyObject);
                return;
            case 5:
                this.onThumbRestChangedObservable.notifyObservers(notifyObject);
                return;
        }
    };
    /**
     * Base Url for the controller model.
     */
    OculusTouchController.MODEL_BASE_URL = 'https://controllers.babylonjs.com/oculus/';
    /**
     * File name for the left controller model.
     */
    OculusTouchController.MODEL_LEFT_FILENAME = 'left.babylon';
    /**
     * File name for the right controller model.
     */
    OculusTouchController.MODEL_RIGHT_FILENAME = 'right.babylon';
    return OculusTouchController;
}(WebVRController));
PoseEnabledControllerHelper._ControllerFactories.push({
    canCreate: function (gamepadInfo) {
        return gamepadInfo.id.indexOf('Oculus Touch') !== -1;
    },
    create: function (gamepadInfo) {
        return new OculusTouchController(gamepadInfo);
    }
});

/**
 * Vive Controller
 */
var ViveController = /** @class */ (function (_super) {
    __extends(ViveController, _super);
    /**
     * Creates a new ViveController from a gamepad
     * @param vrGamepad the gamepad that the controller should be created from
     */
    function ViveController(vrGamepad) {
        var _this = _super.call(this, vrGamepad) || this;
        _this.controllerType = PoseEnabledControllerType.VIVE;
        _this._invertLeftStickY = true;
        return _this;
    }
    /**
     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
     * @param scene scene in which to add meshes
     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
     */
    ViveController.prototype.initControllerMesh = function (scene, meshLoaded) {
        var _this = this;
        SceneLoader.ImportMesh("", ViveController.MODEL_BASE_URL, ViveController.MODEL_FILENAME, scene, function (newMeshes) {
            /*
            Parent Mesh name: ViveWand
            - body
            - r_gripper
            - l_gripper
            - menu_button
            - system_button
            - trackpad
            - trigger
            - LED
            */
            _this._defaultModel = newMeshes[1];
            _this.attachToMesh(_this._defaultModel);
            if (meshLoaded) {
                meshLoaded(_this._defaultModel);
            }
        });
    };
    Object.defineProperty(ViveController.prototype, "onLeftButtonStateChangedObservable", {
        /**
         * Fired when the left button on this controller is modified
         */
        get: function () {
            return this.onMainButtonStateChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViveController.prototype, "onRightButtonStateChangedObservable", {
        /**
         * Fired when the right button on this controller is modified
         */
        get: function () {
            return this.onMainButtonStateChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViveController.prototype, "onMenuButtonStateChangedObservable", {
        /**
         * Fired when the menu button on this controller is modified
         */
        get: function () {
            return this.onSecondaryButtonStateChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called once for each button that changed state since the last frame
     * Vive mapping:
     * 0: touchpad
     * 1: trigger
     * 2: left AND right buttons
     * 3: menu button
     * @param buttonIdx Which button index changed
     * @param state New state of the button
     * @param changes Which properties on the state changed since last frame
     */
    ViveController.prototype._handleButtonChange = function (buttonIdx, state, changes) {
        var notifyObject = state; //{ state: state, changes: changes };
        switch (buttonIdx) {
            case 0:
                this.onPadStateChangedObservable.notifyObservers(notifyObject);
                return;
            case 1: // index trigger
                if (this._defaultModel) {
                    (this._defaultModel.getChildren()[6]).rotation.x = -notifyObject.value * 0.15;
                }
                this.onTriggerStateChangedObservable.notifyObservers(notifyObject);
                return;
            case 2: // left AND right button
                this.onMainButtonStateChangedObservable.notifyObservers(notifyObject);
                return;
            case 3:
                if (this._defaultModel) {
                    if (notifyObject.pressed) {
                        (this._defaultModel.getChildren()[2]).position.y = -0.001;
                    }
                    else {
                        (this._defaultModel.getChildren()[2]).position.y = 0;
                    }
                }
                this.onSecondaryButtonStateChangedObservable.notifyObservers(notifyObject);
                return;
        }
    };
    /**
     * Base Url for the controller model.
     */
    ViveController.MODEL_BASE_URL = 'https://controllers.babylonjs.com/vive/';
    /**
     * File name for the controller model.
     */
    ViveController.MODEL_FILENAME = 'wand.babylon';
    return ViveController;
}(WebVRController));
PoseEnabledControllerHelper._ControllerFactories.push({
    canCreate: function (gamepadInfo) {
        return gamepadInfo.id.toLowerCase().indexOf('openvr') !== -1;
    },
    create: function (gamepadInfo) {
        return new ViveController(gamepadInfo);
    }
});

/**
 * Defines the LoadedMeshInfo object that describes information about the loaded webVR controller mesh
 */
var LoadedMeshInfo = /** @class */ (function () {
    function LoadedMeshInfo() {
        /**
         * Map of the button meshes contained in the controller
         */
        this.buttonMeshes = {};
        /**
         * Map of the axis meshes contained in the controller
         */
        this.axisMeshes = {};
    }
    return LoadedMeshInfo;
}());
/**
 * Defines the WindowsMotionController object that the state of the windows motion controller
 */
var WindowsMotionController = /** @class */ (function (_super) {
    __extends(WindowsMotionController, _super);
    /**
     * Creates a new WindowsMotionController from a gamepad
     * @param vrGamepad the gamepad that the controller should be created from
     */
    function WindowsMotionController(vrGamepad) {
        var _this = _super.call(this, vrGamepad) || this;
        _this._mapping = {
            // Semantic button names
            buttons: ['thumbstick', 'trigger', 'grip', 'menu', 'trackpad'],
            // A mapping of the button name to glTF model node name
            // that should be transformed by button value.
            buttonMeshNames: {
                'trigger': 'SELECT',
                'menu': 'MENU',
                'grip': 'GRASP',
                'thumbstick': 'THUMBSTICK_PRESS',
                'trackpad': 'TOUCHPAD_PRESS'
            },
            // This mapping is used to translate from the Motion Controller to Babylon semantics
            buttonObservableNames: {
                'trigger': 'onTriggerStateChangedObservable',
                'menu': 'onSecondaryButtonStateChangedObservable',
                'grip': 'onMainButtonStateChangedObservable',
                'thumbstick': 'onPadStateChangedObservable',
                'trackpad': 'onTrackpadChangedObservable'
            },
            // A mapping of the axis name to glTF model node name
            // that should be transformed by axis value.
            // This array mirrors the browserGamepad.axes array, such that
            // the mesh corresponding to axis 0 is in this array index 0.
            axisMeshNames: [
                'THUMBSTICK_X',
                'THUMBSTICK_Y',
                'TOUCHPAD_TOUCH_X',
                'TOUCHPAD_TOUCH_Y'
            ],
            pointingPoseMeshName: PoseEnabledController.POINTING_POSE
        };
        /**
         * Fired when the trackpad on this controller is clicked
         */
        _this.onTrackpadChangedObservable = new Observable();
        /**
         * Fired when the trackpad on this controller is modified
         */
        _this.onTrackpadValuesChangedObservable = new Observable();
        /**
         * The current x and y values of this controller's trackpad
         */
        _this.trackpad = { x: 0, y: 0 };
        _this.controllerType = PoseEnabledControllerType.WINDOWS;
        _this._loadedMeshInfo = null;
        return _this;
    }
    Object.defineProperty(WindowsMotionController.prototype, "onTriggerButtonStateChangedObservable", {
        /**
         * Fired when the trigger on this controller is modified
         */
        get: function () {
            return this.onTriggerStateChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowsMotionController.prototype, "onMenuButtonStateChangedObservable", {
        /**
         * Fired when the menu button on this controller is modified
         */
        get: function () {
            return this.onSecondaryButtonStateChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowsMotionController.prototype, "onGripButtonStateChangedObservable", {
        /**
         * Fired when the grip button on this controller is modified
         */
        get: function () {
            return this.onMainButtonStateChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowsMotionController.prototype, "onThumbstickButtonStateChangedObservable", {
        /**
         * Fired when the thumbstick button on this controller is modified
         */
        get: function () {
            return this.onPadStateChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowsMotionController.prototype, "onTouchpadButtonStateChangedObservable", {
        /**
         * Fired when the touchpad button on this controller is modified
         */
        get: function () {
            return this.onTrackpadChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowsMotionController.prototype, "onTouchpadValuesChangedObservable", {
        /**
         * Fired when the touchpad values on this controller are modified
         */
        get: function () {
            return this.onTrackpadValuesChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    WindowsMotionController.prototype._updateTrackpad = function () {
        if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {
            this.trackpad.x = this.browserGamepad["axes"][2];
            this.trackpad.y = this.browserGamepad["axes"][3];
            this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);
        }
    };
    /**
     * Called once per frame by the engine.
     */
    WindowsMotionController.prototype.update = function () {
        _super.prototype.update.call(this);
        if (this.browserGamepad.axes) {
            this._updateTrackpad();
            // Only need to animate axes if there is a loaded mesh
            if (this._loadedMeshInfo) {
                for (var axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {
                    this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);
                }
            }
        }
    };
    /**
     * Called once for each button that changed state since the last frame
     * @param buttonIdx Which button index changed
     * @param state New state of the button
     * @param changes Which properties on the state changed since last frame
     */
    WindowsMotionController.prototype._handleButtonChange = function (buttonIdx, state, changes) {
        var buttonName = this._mapping.buttons[buttonIdx];
        if (!buttonName) {
            return;
        }
        // Update the trackpad to ensure trackpad.x/y are accurate during button events between frames
        this._updateTrackpad();
        // Only emit events for buttons that we know how to map from index to name
        var observable = this[(this._mapping.buttonObservableNames)[buttonName]];
        if (observable) {
            observable.notifyObservers(state);
        }
        this._lerpButtonTransform(buttonName, state.value);
    };
    /**
     * Moves the buttons on the controller mesh based on their current state
     * @param buttonName the name of the button to move
     * @param buttonValue the value of the button which determines the buttons new position
     */
    WindowsMotionController.prototype._lerpButtonTransform = function (buttonName, buttonValue) {
        // If there is no loaded mesh, there is nothing to transform.
        if (!this._loadedMeshInfo) {
            return;
        }
        var meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];
        if (!meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {
            return;
        }
        Quaternion.SlerpToRef(meshInfo.unpressed.rotationQuaternion, meshInfo.pressed.rotationQuaternion, buttonValue, meshInfo.value.rotationQuaternion);
        Vector3.LerpToRef(meshInfo.unpressed.position, meshInfo.pressed.position, buttonValue, meshInfo.value.position);
    };
    /**
     * Moves the axis on the controller mesh based on its current state
     * @param axis the index of the axis
     * @param axisValue the value of the axis which determines the meshes new position
     * @hidden
     */
    WindowsMotionController.prototype._lerpAxisTransform = function (axis, axisValue) {
        if (!this._loadedMeshInfo) {
            return;
        }
        var meshInfo = this._loadedMeshInfo.axisMeshes[axis];
        if (!meshInfo) {
            return;
        }
        if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {
            return;
        }
        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)
        var lerpValue = axisValue * 0.5 + 0.5;
        Quaternion.SlerpToRef(meshInfo.min.rotationQuaternion, meshInfo.max.rotationQuaternion, lerpValue, meshInfo.value.rotationQuaternion);
        Vector3.LerpToRef(meshInfo.min.position, meshInfo.max.position, lerpValue, meshInfo.value.position);
    };
    /**
     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
     * @param scene scene in which to add meshes
     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
     */
    WindowsMotionController.prototype.initControllerMesh = function (scene, meshLoaded, forceDefault) {
        var _this = this;
        if (forceDefault === void 0) { forceDefault = false; }
        var path;
        var filename;
        // Checking if GLB loader is present
        if (SceneLoader.IsPluginForExtensionAvailable(".glb")) {
            // Determine the device specific folder based on the ID suffix
            var device = 'default';
            if (this.id && !forceDefault) {
                var match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);
                device = ((match && match[0]) || device);
            }
            // Hand
            if (this.hand === 'left') {
                filename = WindowsMotionController.MODEL_LEFT_FILENAME;
            }
            else { // Right is the default if no hand is specified
                filename = WindowsMotionController.MODEL_RIGHT_FILENAME;
            }
            path = WindowsMotionController.MODEL_BASE_URL + device + '/';
        }
        else {
            Logger.Warn("You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models");
            path = GenericController.MODEL_BASE_URL;
            filename = GenericController.MODEL_FILENAME;
        }
        SceneLoader.ImportMesh("", path, filename, scene, function (meshes) {
            // glTF files successfully loaded from the remote server, now process them to ensure they are in the right format.
            _this._loadedMeshInfo = _this.processModel(scene, meshes);
            if (!_this._loadedMeshInfo) {
                return;
            }
            _this._defaultModel = _this._loadedMeshInfo.rootNode;
            _this.attachToMesh(_this._defaultModel);
            if (meshLoaded) {
                meshLoaded(_this._defaultModel);
            }
        }, null, function (scene, message) {
            Logger.Log(message);
            Logger.Warn('Failed to retrieve controller model from the remote server: ' + path + filename);
            if (!forceDefault) {
                _this.initControllerMesh(scene, meshLoaded, true);
            }
        });
    };
    /**
     * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that
     * can be transformed by button presses and axes values, based on this._mapping.
     *
     * @param scene scene in which the meshes exist
     * @param meshes list of meshes that make up the controller model to process
     * @return structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.
     */
    WindowsMotionController.prototype.processModel = function (scene, meshes) {
        var loadedMeshInfo = null;
        // Create a new mesh to contain the glTF hierarchy
        var parentMesh = new Mesh(this.id + " " + this.hand, scene);
        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'
        var childMesh = null;
        for (var i = 0; i < meshes.length; i++) {
            var mesh = meshes[i];
            if (!mesh.parent) {
                // Exclude controller meshes from picking results
                mesh.isPickable = false;
                // Handle root node, attach to the new parentMesh
                childMesh = mesh;
                break;
            }
        }
        if (childMesh) {
            childMesh.setParent(parentMesh);
            // Create our mesh info. Note that this method will always return non-null.
            loadedMeshInfo = this.createMeshInfo(parentMesh);
        }
        else {
            Logger.Warn('Could not find root node in model file.');
        }
        return loadedMeshInfo;
    };
    WindowsMotionController.prototype.createMeshInfo = function (rootNode) {
        var loadedMeshInfo = new LoadedMeshInfo();
        var i;
        loadedMeshInfo.rootNode = rootNode;
        // Reset the caches
        loadedMeshInfo.buttonMeshes = {};
        loadedMeshInfo.axisMeshes = {};
        // Button Meshes
        for (i = 0; i < this._mapping.buttons.length; i++) {
            var buttonMeshName = this._mapping.buttonMeshNames[this._mapping.buttons[i]];
            if (!buttonMeshName) {
                Logger.Log('Skipping unknown button at index: ' + i + ' with mapped name: ' + this._mapping.buttons[i]);
                continue;
            }
            var buttonMesh = getChildByName(rootNode, buttonMeshName);
            if (!buttonMesh) {
                Logger.Warn('Missing button mesh with name: ' + buttonMeshName);
                continue;
            }
            var buttonMeshInfo = {
                index: i,
                value: getImmediateChildByName(buttonMesh, 'VALUE'),
                pressed: getImmediateChildByName(buttonMesh, 'PRESSED'),
                unpressed: getImmediateChildByName(buttonMesh, 'UNPRESSED')
            };
            if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {
                loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;
            }
            else {
                // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.
                Logger.Warn('Missing button submesh under mesh with name: ' + buttonMeshName +
                    '(VALUE: ' + !!buttonMeshInfo.value +
                    ', PRESSED: ' + !!buttonMeshInfo.pressed +
                    ', UNPRESSED:' + !!buttonMeshInfo.unpressed +
                    ')');
            }
        }
        // Axis Meshes
        for (i = 0; i < this._mapping.axisMeshNames.length; i++) {
            var axisMeshName = this._mapping.axisMeshNames[i];
            if (!axisMeshName) {
                Logger.Log('Skipping unknown axis at index: ' + i);
                continue;
            }
            var axisMesh = getChildByName(rootNode, axisMeshName);
            if (!axisMesh) {
                Logger.Warn('Missing axis mesh with name: ' + axisMeshName);
                continue;
            }
            var axisMeshInfo = {
                index: i,
                value: getImmediateChildByName(axisMesh, 'VALUE'),
                min: getImmediateChildByName(axisMesh, 'MIN'),
                max: getImmediateChildByName(axisMesh, 'MAX')
            };
            if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {
                loadedMeshInfo.axisMeshes[i] = axisMeshInfo;
            }
            else {
                // If we didn't find the mesh, it simply means thit axis won't have transforms applied as mapped axis values change.
                Logger.Warn('Missing axis submesh under mesh with name: ' + axisMeshName +
                    '(VALUE: ' + !!axisMeshInfo.value +
                    ', MIN: ' + !!axisMeshInfo.min +
                    ', MAX:' + !!axisMeshInfo.max +
                    ')');
            }
        }
        // Pointing Ray
        loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);
        if (!loadedMeshInfo.pointingPoseNode) {
            Logger.Warn('Missing pointing pose mesh with name: ' + this._mapping.pointingPoseMeshName);
        }
        else {
            this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;
        }
        return loadedMeshInfo;
        // Look through all children recursively. This will return null if no mesh exists with the given name.
        function getChildByName(node, name) {
            return node.getChildren(function (n) { return n.name === name; }, false)[0];
        }
        // Look through only immediate children. This will return null if no mesh exists with the given name.
        function getImmediateChildByName(node, name) {
            return node.getChildren(function (n) { return n.name == name; }, true)[0];
        }
    };
    /**
     * Gets the ray of the controller in the direction the controller is pointing
     * @param length the length the resulting ray should be
     * @returns a ray in the direction the controller is pointing
     */
    WindowsMotionController.prototype.getForwardRay = function (length) {
        if (length === void 0) { length = 100; }
        if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {
            return _super.prototype.getForwardRay.call(this, length);
        }
        var m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();
        var origin = m.getTranslation();
        var forward = new Vector3(0, 0, -1);
        var forwardWorld = Vector3.TransformNormal(forward, m);
        var direction = Vector3.Normalize(forwardWorld);
        return new Ray(origin, direction, length);
    };
    /**
    * Disposes of the controller
    */
    WindowsMotionController.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.onTrackpadChangedObservable.clear();
    };
    /**
     * The base url used to load the left and right controller models
     */
    WindowsMotionController.MODEL_BASE_URL = 'https://controllers.babylonjs.com/microsoft/';
    /**
     * The name of the left controller model file
     */
    WindowsMotionController.MODEL_LEFT_FILENAME = 'left.glb';
    /**
     * The name of the right controller model file
     */
    WindowsMotionController.MODEL_RIGHT_FILENAME = 'right.glb';
    /**
     * The controller name prefix for this controller type
     */
    WindowsMotionController.GAMEPAD_ID_PREFIX = 'Spatial Controller (Spatial Interaction Source) ';
    /**
     * The controller id pattern for this controller type
     */
    WindowsMotionController.GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;
    return WindowsMotionController;
}(WebVRController));
PoseEnabledControllerHelper._ControllerFactories.push({
    canCreate: function (gamepadInfo) {
        return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;
    },
    create: function (gamepadInfo) {
        return new WindowsMotionController(gamepadInfo);
    }
});

/**
 * Single axis scale gizmo
 */
var AxisScaleGizmo = /** @class */ (function (_super) {
    __extends(AxisScaleGizmo, _super);
    /**
     * Creates an AxisScaleGizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     * @param dragAxis The axis which the gizmo will be able to scale on
     * @param color The color of the gizmo
     */
    function AxisScaleGizmo(dragAxis, color, gizmoLayer) {
        if (color === void 0) { color = Color3.Gray(); }
        if (gizmoLayer === void 0) { gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer; }
        var _this = _super.call(this, gizmoLayer) || this;
        _this._pointerObserver = null;
        /**
         * Scale distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        _this.snapDistance = 0;
        /**
         * Event that fires each time the gizmo snaps to a new location.
         * * snapDistance is the the change in distance
         */
        _this.onSnapObservable = new Observable();
        /**
         * If the scaling operation should be done on all axis (default: false)
         */
        _this.uniformScaling = false;
        // Create Material
        _this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        _this._coloredMaterial.diffuseColor = color;
        _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
        var hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        hoverMaterial.diffuseColor = color.add(new Color3(0.3, 0.3, 0.3));
        // Build mesh on root node
        var arrow = new AbstractMesh("", gizmoLayer.utilityLayerScene);
        var arrowMesh = BoxBuilder.CreateBox("yPosMesh", { size: 0.4 }, gizmoLayer.utilityLayerScene);
        var arrowTail = CylinderBuilder.CreateCylinder("cylinder", { diameterTop: 0.005, height: 0.275, diameterBottom: 0.005, tessellation: 96 }, gizmoLayer.utilityLayerScene);
        arrowTail.material = _this._coloredMaterial;
        arrow.addChild(arrowMesh);
        arrow.addChild(arrowTail);
        // Position arrow pointing in its drag axis
        arrowMesh.scaling.scaleInPlace(0.1);
        arrowMesh.material = _this._coloredMaterial;
        arrowMesh.rotation.x = Math.PI / 2;
        arrowMesh.position.z += 0.3;
        arrowTail.position.z += 0.275 / 2;
        arrowTail.rotation.x = Math.PI / 2;
        arrow.lookAt(_this._rootMesh.position.add(dragAxis));
        _this._rootMesh.addChild(arrow);
        arrow.scaling.scaleInPlace(1 / 3);
        // Add drag behavior to handle events when the gizmo is dragged
        _this.dragBehavior = new PointerDragBehavior({ dragAxis: dragAxis });
        _this.dragBehavior.moveAttached = false;
        _this._rootMesh.addBehavior(_this.dragBehavior);
        var currentSnapDragDistance = 0;
        var tmpVector = new Vector3();
        var tmpSnapEvent = { snapDistance: 0 };
        _this.dragBehavior.onDragObservable.add(function (event) {
            if (_this.attachedMesh) {
                // Drag strength is modified by the scale of the gizmo (eg. for small objects like boombox the strength will be increased to match the behavior of larger objects)
                var dragStrength = event.dragDistance * ((_this.scaleRatio * 3) / _this._rootMesh.scaling.length());
                // Snapping logic
                var snapped = false;
                var dragSteps = 0;
                if (_this.uniformScaling) {
                    _this.attachedMesh.scaling.normalizeToRef(tmpVector);
                    if (tmpVector.y < 0) {
                        tmpVector.scaleInPlace(-1);
                    }
                }
                else {
                    tmpVector.copyFrom(dragAxis);
                }
                if (_this.snapDistance == 0) {
                    tmpVector.scaleToRef(dragStrength, tmpVector);
                }
                else {
                    currentSnapDragDistance += dragStrength;
                    if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {
                        dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);
                        if (currentSnapDragDistance < 0) {
                            dragSteps *= -1;
                        }
                        currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;
                        tmpVector.scaleToRef(_this.snapDistance * dragSteps, tmpVector);
                        snapped = true;
                    }
                    else {
                        tmpVector.scaleInPlace(0);
                    }
                }
                _this.attachedMesh.scaling.addInPlace(tmpVector);
                if (snapped) {
                    tmpSnapEvent.snapDistance = _this.snapDistance * dragSteps;
                    _this.onSnapObservable.notifyObservers(tmpSnapEvent);
                }
            }
        });
        _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {
            if (_this._customMeshSet) {
                return;
            }
            var isHovered = pointerInfo.pickInfo && (_this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);
            var material = isHovered ? hoverMaterial : _this._coloredMaterial;
            _this._rootMesh.getChildMeshes().forEach(function (m) {
                m.material = material;
                if (m.color) {
                    m.color = material.diffuseColor;
                }
            });
        });
        var light = gizmoLayer._getSharedGizmoLight();
        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes());
        return _this;
    }
    AxisScaleGizmo.prototype._attachedMeshChanged = function (value) {
        if (this.dragBehavior) {
            this.dragBehavior.enabled = value ? true : false;
        }
    };
    /**
     * Disposes of the gizmo
     */
    AxisScaleGizmo.prototype.dispose = function () {
        this.onSnapObservable.clear();
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this.dragBehavior.detach();
        _super.prototype.dispose.call(this);
    };
    /**
     * Disposes and replaces the current meshes in the gizmo with the specified mesh
     * @param mesh The mesh to replace the default mesh of the gizmo
     * @param useGizmoMaterial If the gizmo's default material should be used (default: false)
     */
    AxisScaleGizmo.prototype.setCustomMesh = function (mesh, useGizmoMaterial) {
        var _this = this;
        if (useGizmoMaterial === void 0) { useGizmoMaterial = false; }
        _super.prototype.setCustomMesh.call(this, mesh);
        if (useGizmoMaterial) {
            this._rootMesh.getChildMeshes().forEach(function (m) {
                m.material = _this._coloredMaterial;
                if (m.color) {
                    m.color = _this._coloredMaterial.diffuseColor;
                }
            });
            this._customMeshSet = false;
        }
    };
    return AxisScaleGizmo;
}(Gizmo));

/**
 * Bounding box gizmo
 */
var BoundingBoxGizmo = /** @class */ (function (_super) {
    __extends(BoundingBoxGizmo, _super);
    /**
     * Creates an BoundingBoxGizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     * @param color The color of the gizmo
     */
    function BoundingBoxGizmo(color, gizmoLayer) {
        if (color === void 0) { color = Color3.Gray(); }
        if (gizmoLayer === void 0) { gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer; }
        var _this = _super.call(this, gizmoLayer) || this;
        _this._boundingDimensions = new Vector3(1, 1, 1);
        _this._renderObserver = null;
        _this._pointerObserver = null;
        _this._scaleDragSpeed = 0.2;
        _this._tmpQuaternion = new Quaternion();
        _this._tmpVector = new Vector3(0, 0, 0);
        _this._tmpRotationMatrix = new Matrix();
        /**
         * If child meshes should be ignored when calculating the boudning box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)
         */
        _this.ignoreChildren = false;
        /**
         * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)
         */
        _this.includeChildPredicate = null;
        /**
         * The size of the rotation spheres attached to the bounding box (Default: 0.1)
         */
        _this.rotationSphereSize = 0.1;
        /**
         * The size of the scale boxes attached to the bounding box (Default: 0.1)
         */
        _this.scaleBoxSize = 0.1;
        /**
         * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)
         */
        _this.fixedDragMeshScreenSize = false;
        /**
         * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)
         */
        _this.fixedDragMeshScreenSizeDistanceFactor = 10;
        /**
         * Fired when a rotation sphere or scale box is dragged
         */
        _this.onDragStartObservable = new Observable();
        /**
         * Fired when a scale box is dragged
         */
        _this.onScaleBoxDragObservable = new Observable();
        /**
          * Fired when a scale box drag is ended
         */
        _this.onScaleBoxDragEndObservable = new Observable();
        /**
         * Fired when a rotation sphere is dragged
         */
        _this.onRotationSphereDragObservable = new Observable();
        /**
         * Fired when a rotation sphere drag is ended
         */
        _this.onRotationSphereDragEndObservable = new Observable();
        /**
         * Relative bounding box pivot used when scaling the attached mesh. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)
         */
        _this.scalePivot = null;
        _this._existingMeshScale = new Vector3();
        // Dragging
        _this._dragMesh = null;
        _this.pointerDragBehavior = new PointerDragBehavior();
        // Do not update the gizmo's scale so it has a fixed size to the object its attached to
        _this._updateScale = false;
        _this._anchorMesh = new AbstractMesh("anchor", gizmoLayer.utilityLayerScene);
        // Create Materials
        _this.coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        _this.coloredMaterial.disableLighting = true;
        _this.hoverColoredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        _this.hoverColoredMaterial.disableLighting = true;
        // Build bounding box out of lines
        _this._lineBoundingBox = new AbstractMesh("", gizmoLayer.utilityLayerScene);
        _this._lineBoundingBox.rotationQuaternion = new Quaternion();
        var lines = [];
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, 0), new Vector3(_this._boundingDimensions.x, 0, 0)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, 0), new Vector3(0, _this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, 0), new Vector3(0, 0, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));
        lines.push(LinesBuilder.CreateLines("lines", { points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));
        lines.forEach(function (l) {
            l.color = color;
            l.position.addInPlace(new Vector3(-_this._boundingDimensions.x / 2, -_this._boundingDimensions.y / 2, -_this._boundingDimensions.z / 2));
            l.isPickable = false;
            _this._lineBoundingBox.addChild(l);
        });
        _this._rootMesh.addChild(_this._lineBoundingBox);
        _this.setColor(color);
        // Create rotation spheres
        _this._rotateSpheresParent = new AbstractMesh("", gizmoLayer.utilityLayerScene);
        _this._rotateSpheresParent.rotationQuaternion = new Quaternion();
        var _loop_1 = function (i_1) {
            var sphere = SphereBuilder.CreateSphere("", { diameter: 1 }, gizmoLayer.utilityLayerScene);
            sphere.rotationQuaternion = new Quaternion();
            sphere.material = this_1.coloredMaterial;
            // Drag behavior
            _dragBehavior = new PointerDragBehavior({});
            _dragBehavior.moveAttached = false;
            _dragBehavior.updateDragPlane = false;
            sphere.addBehavior(_dragBehavior);
            var startingTurnDirection = new Vector3(1, 0, 0);
            var totalTurnAmountOfDrag = 0;
            _dragBehavior.onDragStartObservable.add(function () {
                startingTurnDirection.copyFrom(sphere.forward);
                totalTurnAmountOfDrag = 0;
            });
            _dragBehavior.onDragObservable.add(function (event) {
                _this.onRotationSphereDragObservable.notifyObservers({});
                if (_this.attachedMesh) {
                    var originalParent = _this.attachedMesh.parent;
                    if (originalParent && (originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001))) {
                        Logger.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");
                        return;
                    }
                    PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);
                    var worldDragDirection = startingTurnDirection;
                    // Project the world right on to the drag plane
                    var toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));
                    var dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();
                    // project drag delta on to the resulting drag axis and rotate based on that
                    var projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());
                    // Make rotation relative to size of mesh.
                    projectDist = (projectDist / _this._boundingDimensions.length()) * _this._anchorMesh.scaling.length();
                    // Rotate based on axis
                    if (!_this.attachedMesh.rotationQuaternion) {
                        _this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.attachedMesh.rotation.y, _this.attachedMesh.rotation.x, _this.attachedMesh.rotation.z);
                    }
                    if (!_this._anchorMesh.rotationQuaternion) {
                        _this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._anchorMesh.rotation.y, _this._anchorMesh.rotation.x, _this._anchorMesh.rotation.z);
                    }
                    // Do not allow the object to turn more than a full circle
                    totalTurnAmountOfDrag += projectDist;
                    if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {
                        if (i_1 >= 8) {
                            Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, _this._tmpQuaternion);
                        }
                        else if (i_1 >= 4) {
                            Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, _this._tmpQuaternion);
                        }
                        else {
                            Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, _this._tmpQuaternion);
                        }
                        // Rotate around center of bounding box
                        _this._anchorMesh.addChild(_this.attachedMesh);
                        _this._anchorMesh.rotationQuaternion.multiplyToRef(_this._tmpQuaternion, _this._anchorMesh.rotationQuaternion);
                        _this._anchorMesh.removeChild(_this.attachedMesh);
                        _this.attachedMesh.setParent(originalParent);
                    }
                    _this.updateBoundingBox();
                    PivotTools._RestorePivotPoint(_this.attachedMesh);
                }
                _this._updateDummy();
            });
            // Selection/deselection
            _dragBehavior.onDragStartObservable.add(function () {
                _this.onDragStartObservable.notifyObservers({});
                _this._selectNode(sphere);
            });
            _dragBehavior.onDragEndObservable.add(function () {
                _this.onRotationSphereDragEndObservable.notifyObservers({});
                _this._selectNode(null);
                _this._updateDummy();
            });
            this_1._rotateSpheresParent.addChild(sphere);
        };
        var this_1 = this, _dragBehavior;
        for (var i_1 = 0; i_1 < 12; i_1++) {
            _loop_1(i_1);
        }
        _this._rootMesh.addChild(_this._rotateSpheresParent);
        // Create scale cubes
        _this._scaleBoxesParent = new AbstractMesh("", gizmoLayer.utilityLayerScene);
        _this._scaleBoxesParent.rotationQuaternion = new Quaternion();
        for (var i = 0; i < 2; i++) {
            for (var j = 0; j < 2; j++) {
                var _loop_2 = function () {
                    var box = BoxBuilder.CreateBox("", { size: 1 }, gizmoLayer.utilityLayerScene);
                    box.material = this_2.coloredMaterial;
                    // Dragging logic
                    var dragAxis = new Vector3(i == 0 ? -1 : 1, j == 0 ? -1 : 1, k == 0 ? -1 : 1);
                    _dragBehavior = new PointerDragBehavior({ dragAxis: dragAxis });
                    _dragBehavior.moveAttached = false;
                    box.addBehavior(_dragBehavior);
                    _dragBehavior.onDragObservable.add(function (event) {
                        _this.onScaleBoxDragObservable.notifyObservers({});
                        if (_this.attachedMesh) {
                            var originalParent = _this.attachedMesh.parent;
                            if (originalParent && (originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001))) {
                                Logger.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");
                                return;
                            }
                            PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);
                            var relativeDragDistance = (event.dragDistance / _this._boundingDimensions.length()) * _this._anchorMesh.scaling.length();
                            var deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);
                            deltaScale.scaleInPlace(_this._scaleDragSpeed);
                            _this.updateBoundingBox();
                            if (_this.scalePivot) {
                                _this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(_this._tmpRotationMatrix);
                                // Move anchor to desired pivot point (Bottom left corner + dimension/2)
                                _this._boundingDimensions.scaleToRef(0.5, _this._tmpVector);
                                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);
                                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);
                                _this._boundingDimensions.multiplyToRef(_this.scalePivot, _this._tmpVector);
                                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);
                                _this._anchorMesh.position.addInPlace(_this._tmpVector);
                            }
                            else {
                                // Scale from the position of the opposite corner
                                box.absolutePosition.subtractToRef(_this._anchorMesh.position, _this._tmpVector);
                                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);
                            }
                            _this._anchorMesh.addChild(_this.attachedMesh);
                            _this._anchorMesh.scaling.addInPlace(deltaScale);
                            if (_this._anchorMesh.scaling.x < 0 || _this._anchorMesh.scaling.y < 0 || _this._anchorMesh.scaling.z < 0) {
                                _this._anchorMesh.scaling.subtractInPlace(deltaScale);
                            }
                            _this._anchorMesh.removeChild(_this.attachedMesh);
                            _this.attachedMesh.setParent(originalParent);
                            PivotTools._RestorePivotPoint(_this.attachedMesh);
                        }
                        _this._updateDummy();
                    });
                    // Selection/deselection
                    _dragBehavior.onDragStartObservable.add(function () {
                        _this.onDragStartObservable.notifyObservers({});
                        _this._selectNode(box);
                    });
                    _dragBehavior.onDragEndObservable.add(function () {
                        _this.onScaleBoxDragEndObservable.notifyObservers({});
                        _this._selectNode(null);
                        _this._updateDummy();
                    });
                    this_2._scaleBoxesParent.addChild(box);
                };
                var this_2 = this, _dragBehavior;
                for (var k = 0; k < 2; k++) {
                    _loop_2();
                }
            }
        }
        _this._rootMesh.addChild(_this._scaleBoxesParent);
        // Hover color change
        var pointerIds = new Array();
        _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {
            if (!pointerIds[pointerInfo.event.pointerId]) {
                _this._rotateSpheresParent.getChildMeshes().concat(_this._scaleBoxesParent.getChildMeshes()).forEach(function (mesh) {
                    if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {
                        pointerIds[pointerInfo.event.pointerId] = mesh;
                        mesh.material = _this.hoverColoredMaterial;
                    }
                });
            }
            else {
                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {
                    pointerIds[pointerInfo.event.pointerId].material = _this.coloredMaterial;
                    delete pointerIds[pointerInfo.event.pointerId];
                }
            }
        });
        // Update bounding box positions
        _this._renderObserver = _this.gizmoLayer.originalScene.onBeforeRenderObservable.add(function () {
            // Only update the bouding box if scaling has changed
            if (_this.attachedMesh && !_this._existingMeshScale.equals(_this.attachedMesh.scaling)) {
                _this.updateBoundingBox();
            }
            else if (_this.fixedDragMeshScreenSize) {
                _this._updateRotationSpheres();
                _this._updateScaleBoxes();
            }
            // If dragg mesh is enabled and dragging, update the attached mesh pose to match the drag mesh
            if (_this._dragMesh && _this.attachedMesh && _this.pointerDragBehavior.dragging) {
                _this._lineBoundingBox.position.rotateByQuaternionToRef(_this._rootMesh.rotationQuaternion, _this._tmpVector);
                _this.attachedMesh.setAbsolutePosition(_this._dragMesh.position.add(_this._tmpVector.scale(-1)));
            }
        });
        _this.updateBoundingBox();
        return _this;
    }
    /**
     * Sets the color of the bounding box gizmo
     * @param color the color to set
     */
    BoundingBoxGizmo.prototype.setColor = function (color) {
        this.coloredMaterial.emissiveColor = color;
        this.hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));
        this._lineBoundingBox.getChildren().forEach(function (l) {
            if (l.color) {
                l.color = color;
            }
        });
    };
    BoundingBoxGizmo.prototype._attachedMeshChanged = function (value) {
        var _this = this;
        if (value) {
            // Reset anchor mesh to match attached mesh's scale
            // This is needed to avoid invalid box/sphere position on first drag
            PivotTools._RemoveAndStorePivotPoint(value);
            var originalParent = value.parent;
            this._anchorMesh.addChild(value);
            this._anchorMesh.removeChild(value);
            value.setParent(originalParent);
            PivotTools._RestorePivotPoint(value);
            this.updateBoundingBox();
            value.getChildMeshes(false).forEach(function (m) {
                m.markAsDirty("scaling");
            });
            this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(function () {
                _this._updateDummy();
            });
        }
    };
    BoundingBoxGizmo.prototype._selectNode = function (selectedMesh) {
        this._rotateSpheresParent.getChildMeshes()
            .concat(this._scaleBoxesParent.getChildMeshes()).forEach(function (m) {
            m.isVisible = (!selectedMesh || m == selectedMesh);
        });
    };
    /**
     * Updates the bounding box information for the Gizmo
     */
    BoundingBoxGizmo.prototype.updateBoundingBox = function () {
        if (this.attachedMesh) {
            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
            // Store original parent
            var originalParent = this.attachedMesh.parent;
            this.attachedMesh.setParent(null);
            // Store original skelton override mesh
            var originalSkeletonOverrideMesh = null;
            if (this.attachedMesh.skeleton) {
                originalSkeletonOverrideMesh = this.attachedMesh.skeleton.overrideMesh;
                this.attachedMesh.skeleton.overrideMesh = null;
            }
            this._update();
            // Rotate based on axis
            if (!this.attachedMesh.rotationQuaternion) {
                this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);
            }
            if (!this._anchorMesh.rotationQuaternion) {
                this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);
            }
            this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
            // Store original position and reset mesh to origin before computing the bounding box
            this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
            this._tmpVector.copyFrom(this.attachedMesh.position);
            this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);
            this.attachedMesh.position.set(0, 0, 0);
            // Update bounding dimensions/positions
            var boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);
            boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);
            // Update gizmo to match bounding box scaling and rotation
            // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin
            // The position of the gizmo is then set to the attachedMesh in gizmo._update
            this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);
            this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);
            this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);
            this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);
            this._lineBoundingBox.computeWorldMatrix();
            this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);
            // Restore position/rotation values
            this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);
            this.attachedMesh.position.copyFrom(this._tmpVector);
            // Restore original parent
            this.attachedMesh.setParent(originalParent);
            // Restore original skeleton override mesh
            if (this.attachedMesh.skeleton) {
                this.attachedMesh.skeleton.overrideMesh = originalSkeletonOverrideMesh;
            }
        }
        this._updateRotationSpheres();
        this._updateScaleBoxes();
        if (this.attachedMesh) {
            this._existingMeshScale.copyFrom(this.attachedMesh.scaling);
            PivotTools._RestorePivotPoint(this.attachedMesh);
        }
    };
    BoundingBoxGizmo.prototype._updateRotationSpheres = function () {
        var rotateSpheres = this._rotateSpheresParent.getChildMeshes();
        for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 2; j++) {
                for (var k = 0; k < 2; k++) {
                    var index = ((i * 4) + (j * 2)) + k;
                    if (i == 0) {
                        rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);
                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
                        rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));
                    }
                    if (i == 1) {
                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);
                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
                        rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));
                    }
                    if (i == 2) {
                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);
                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
                        rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));
                    }
                    if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {
                        rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
                        var distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;
                        rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
                    }
                    else {
                        rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);
                    }
                }
            }
        }
    };
    BoundingBoxGizmo.prototype._updateScaleBoxes = function () {
        var scaleBoxes = this._scaleBoxesParent.getChildMeshes();
        for (var i = 0; i < 2; i++) {
            for (var j = 0; j < 2; j++) {
                for (var k = 0; k < 2; k++) {
                    var index = ((i * 4) + (j * 2)) + k;
                    if (scaleBoxes[index]) {
                        scaleBoxes[index].position.set(this._boundingDimensions.x * i, this._boundingDimensions.y * j, this._boundingDimensions.z * k);
                        scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
                        if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {
                            scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
                            var distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;
                            scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
                        }
                        else {
                            scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);
                        }
                    }
                }
            }
        }
    };
    /**
     * Enables rotation on the specified axis and disables rotation on the others
     * @param axis The list of axis that should be enabled (eg. "xy" or "xyz")
     */
    BoundingBoxGizmo.prototype.setEnabledRotationAxis = function (axis) {
        this._rotateSpheresParent.getChildMeshes().forEach(function (m, i) {
            if (i < 4) {
                m.setEnabled(axis.indexOf("x") != -1);
            }
            else if (i < 8) {
                m.setEnabled(axis.indexOf("y") != -1);
            }
            else {
                m.setEnabled(axis.indexOf("z") != -1);
            }
        });
    };
    /**
     * Enables/disables scaling
     * @param enable if scaling should be enabled
     */
    BoundingBoxGizmo.prototype.setEnabledScaling = function (enable) {
        this._scaleBoxesParent.getChildMeshes().forEach(function (m, i) {
            m.setEnabled(enable);
        });
    };
    BoundingBoxGizmo.prototype._updateDummy = function () {
        if (this._dragMesh) {
            this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());
            this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);
            this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);
        }
    };
    /**
     * Enables a pointer drag behavior on the bounding box of the gizmo
     */
    BoundingBoxGizmo.prototype.enableDragBehavior = function () {
        this._dragMesh = Mesh.CreateBox("dummy", 1, this.gizmoLayer.utilityLayerScene);
        this._dragMesh.visibility = 0;
        this._dragMesh.rotationQuaternion = new Quaternion();
        this.pointerDragBehavior.useObjectOrienationForDragging = false;
        this._dragMesh.addBehavior(this.pointerDragBehavior);
    };
    /**
     * Disposes of the gizmo
     */
    BoundingBoxGizmo.prototype.dispose = function () {
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);
        this._lineBoundingBox.dispose();
        this._rotateSpheresParent.dispose();
        this._scaleBoxesParent.dispose();
        if (this._dragMesh) {
            this._dragMesh.dispose();
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)
     * @param mesh the mesh to wrap in the bounding box mesh and make not pickable
     * @returns the bounding box mesh with the passed in mesh as a child
     */
    BoundingBoxGizmo.MakeNotPickableAndWrapInBoundingBox = function (mesh) {
        var makeNotPickable = function (root) {
            root.isPickable = false;
            root.getChildMeshes().forEach(function (c) {
                makeNotPickable(c);
            });
        };
        makeNotPickable(mesh);
        // Reset position to get boudning box from origin with no rotation
        if (!mesh.rotationQuaternion) {
            mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);
        }
        var oldPos = mesh.position.clone();
        var oldRot = mesh.rotationQuaternion.clone();
        mesh.rotationQuaternion.set(0, 0, 0, 1);
        mesh.position.set(0, 0, 0);
        // Update bounding dimensions/positions
        var box = BoxBuilder.CreateBox("box", { size: 1 }, mesh.getScene());
        var boundingMinMax = mesh.getHierarchyBoundingVectors();
        boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);
        // Adjust scale to avoid undefined behavior when adding child
        if (box.scaling.y === 0) {
            box.scaling.y = Epsilon;
        }
        if (box.scaling.x === 0) {
            box.scaling.x = Epsilon;
        }
        if (box.scaling.z === 0) {
            box.scaling.z = Epsilon;
        }
        box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);
        // Restore original positions
        mesh.addChild(box);
        mesh.rotationQuaternion.copyFrom(oldRot);
        mesh.position.copyFrom(oldPos);
        // Reverse parenting
        mesh.removeChild(box);
        box.addChild(mesh);
        box.visibility = 0;
        return box;
    };
    /**
     * CustomMeshes are not supported by this gizmo
     * @param mesh The mesh to replace the default mesh of the gizmo
     */
    BoundingBoxGizmo.prototype.setCustomMesh = function (mesh) {
        Logger.Error("Custom meshes are not supported on this gizmo");
    };
    return BoundingBoxGizmo;
}(Gizmo));

/**
 * Single plane rotation gizmo
 */
var PlaneRotationGizmo = /** @class */ (function (_super) {
    __extends(PlaneRotationGizmo, _super);
    /**
     * Creates a PlaneRotationGizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     * @param planeNormal The normal of the plane which the gizmo will be able to rotate on
     * @param color The color of the gizmo
     * @param tessellation Amount of tessellation to be used when creating rotation circles
     */
    function PlaneRotationGizmo(planeNormal, color, gizmoLayer, tessellation) {
        if (color === void 0) { color = Color3.Gray(); }
        if (gizmoLayer === void 0) { gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer; }
        if (tessellation === void 0) { tessellation = 32; }
        var _this = _super.call(this, gizmoLayer) || this;
        _this._pointerObserver = null;
        /**
         * Rotation distance in radians that the gizmo will snap to (Default: 0)
         */
        _this.snapDistance = 0;
        /**
         * Event that fires each time the gizmo snaps to a new location.
         * * snapDistance is the the change in distance
         */
        _this.onSnapObservable = new Observable();
        // Create Material
        var coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        coloredMaterial.diffuseColor = color;
        coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
        var hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        hoverMaterial.diffuseColor = color.add(new Color3(0.3, 0.3, 0.3));
        // Build mesh on root node
        var parentMesh = new AbstractMesh("", gizmoLayer.utilityLayerScene);
        var drag = Mesh.CreateTorus("", 0.6, 0.03, tessellation, gizmoLayer.utilityLayerScene);
        drag.visibility = 0;
        var rotationMesh = Mesh.CreateTorus("", 0.6, 0.005, tessellation, gizmoLayer.utilityLayerScene);
        rotationMesh.material = coloredMaterial;
        // Position arrow pointing in its drag axis
        rotationMesh.rotation.x = Math.PI / 2;
        drag.rotation.x = Math.PI / 2;
        parentMesh.addChild(rotationMesh);
        parentMesh.addChild(drag);
        parentMesh.lookAt(_this._rootMesh.position.add(planeNormal));
        _this._rootMesh.addChild(parentMesh);
        parentMesh.scaling.scaleInPlace(1 / 3);
        // Add drag behavior to handle events when the gizmo is dragged
        _this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });
        _this.dragBehavior.moveAttached = false;
        _this.dragBehavior.maxDragAngle = Math.PI * 9 / 20;
        _this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;
        _this._rootMesh.addBehavior(_this.dragBehavior);
        var lastDragPosition = new Vector3();
        _this.dragBehavior.onDragStartObservable.add(function (e) {
            if (_this.attachedMesh) {
                lastDragPosition.copyFrom(e.dragPlanePoint);
            }
        });
        var rotationMatrix = new Matrix();
        var planeNormalTowardsCamera = new Vector3();
        var localPlaneNormalTowardsCamera = new Vector3();
        var tmpSnapEvent = { snapDistance: 0 };
        var currentSnapDragDistance = 0;
        var tmpMatrix = new Matrix();
        var tmpVector = new Vector3();
        var amountToRotate = new Quaternion();
        _this.dragBehavior.onDragObservable.add(function (event) {
            if (_this.attachedMesh) {
                if (!_this.attachedMesh.rotationQuaternion) {
                    _this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.attachedMesh.rotation.y, _this.attachedMesh.rotation.x, _this.attachedMesh.rotation.z);
                }
                // Remove parent priort to rotating
                var attachedMeshParent = _this.attachedMesh.parent;
                if (attachedMeshParent) {
                    _this.attachedMesh.setParent(null);
                }
                // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)
                var newVector = event.dragPlanePoint.subtract(_this.attachedMesh.absolutePosition).normalize();
                var originalVector = lastDragPosition.subtract(_this.attachedMesh.absolutePosition).normalize();
                var cross = Vector3.Cross(newVector, originalVector);
                var dot = Vector3.Dot(newVector, originalVector);
                var angle = Math.atan2(cross.length(), dot);
                planeNormalTowardsCamera.copyFrom(planeNormal);
                localPlaneNormalTowardsCamera.copyFrom(planeNormal);
                if (_this.updateGizmoRotationToMatchAttachedMesh) {
                    _this.attachedMesh.rotationQuaternion.toRotationMatrix(rotationMatrix);
                    localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);
                }
                // Flip up vector depending on which side the camera is on
                if (gizmoLayer.utilityLayerScene.activeCamera) {
                    var camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(_this.attachedMesh.position);
                    if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {
                        planeNormalTowardsCamera.scaleInPlace(-1);
                        localPlaneNormalTowardsCamera.scaleInPlace(-1);
                    }
                }
                var halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;
                if (halfCircleSide) {
                    angle = -angle;
                }
                // Snapping logic
                var snapped = false;
                if (_this.snapDistance != 0) {
                    currentSnapDragDistance += angle;
                    if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {
                        var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);
                        if (currentSnapDragDistance < 0) {
                            dragSteps *= -1;
                        }
                        currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;
                        angle = _this.snapDistance * dragSteps;
                        snapped = true;
                    }
                    else {
                        angle = 0;
                    }
                }
                // If the mesh has a parent, convert needed world rotation to local rotation
                tmpMatrix.reset();
                if (_this.attachedMesh.parent) {
                    _this.attachedMesh.parent.computeWorldMatrix().invertToRef(tmpMatrix);
                    tmpMatrix.getRotationMatrixToRef(tmpMatrix);
                    Vector3.TransformCoordinatesToRef(planeNormalTowardsCamera, tmpMatrix, planeNormalTowardsCamera);
                }
                // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)
                var quaternionCoefficient = Math.sin(angle / 2);
                amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2));
                // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis
                if (tmpMatrix.determinant() > 0) {
                    amountToRotate.toEulerAnglesToRef(tmpVector);
                    Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);
                }
                if (_this.updateGizmoRotationToMatchAttachedMesh) {
                    // Rotate selected mesh quaternion over fixed axis
                    _this.attachedMesh.rotationQuaternion.multiplyToRef(amountToRotate, _this.attachedMesh.rotationQuaternion);
                }
                else {
                    // Rotate selected mesh quaternion over rotated axis
                    amountToRotate.multiplyToRef(_this.attachedMesh.rotationQuaternion, _this.attachedMesh.rotationQuaternion);
                }
                lastDragPosition.copyFrom(event.dragPlanePoint);
                if (snapped) {
                    tmpSnapEvent.snapDistance = angle;
                    _this.onSnapObservable.notifyObservers(tmpSnapEvent);
                }
                // Restore parent
                if (attachedMeshParent) {
                    _this.attachedMesh.setParent(attachedMeshParent);
                }
            }
        });
        _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {
            if (_this._customMeshSet) {
                return;
            }
            var isHovered = pointerInfo.pickInfo && (_this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);
            var material = isHovered ? hoverMaterial : coloredMaterial;
            _this._rootMesh.getChildMeshes().forEach(function (m) {
                m.material = material;
                if (m.color) {
                    m.color = material.diffuseColor;
                }
            });
        });
        var light = gizmoLayer._getSharedGizmoLight();
        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));
        return _this;
    }
    PlaneRotationGizmo.prototype._attachedMeshChanged = function (value) {
        if (this.dragBehavior) {
            this.dragBehavior.enabled = value ? true : false;
        }
    };
    /**
     * Disposes of the gizmo
     */
    PlaneRotationGizmo.prototype.dispose = function () {
        this.onSnapObservable.clear();
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this.dragBehavior.detach();
        _super.prototype.dispose.call(this);
    };
    return PlaneRotationGizmo;
}(Gizmo));

/**
 * Gizmo that enables rotating a mesh along 3 axis
 */
var RotationGizmo = /** @class */ (function (_super) {
    __extends(RotationGizmo, _super);
    /**
     * Creates a RotationGizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     * @param tessellation Amount of tessellation to be used when creating rotation circles
     */
    function RotationGizmo(gizmoLayer, tessellation) {
        if (gizmoLayer === void 0) { gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer; }
        if (tessellation === void 0) { tessellation = 32; }
        var _this = _super.call(this, gizmoLayer) || this;
        /** Fires an event when any of it's sub gizmos are dragged */
        _this.onDragStartObservable = new Observable();
        /** Fires an event when any of it's sub gizmos are released from dragging */
        _this.onDragEndObservable = new Observable();
        _this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, tessellation);
        _this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, tessellation);
        _this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, tessellation);
        // Relay drag events
        [_this.xGizmo, _this.yGizmo, _this.zGizmo].forEach(function (gizmo) {
            gizmo.dragBehavior.onDragStartObservable.add(function () {
                _this.onDragStartObservable.notifyObservers({});
            });
            gizmo.dragBehavior.onDragEndObservable.add(function () {
                _this.onDragEndObservable.notifyObservers({});
            });
        });
        _this.attachedMesh = null;
        return _this;
    }
    Object.defineProperty(RotationGizmo.prototype, "attachedMesh", {
        get: function () {
            return this.xGizmo.attachedMesh;
        },
        set: function (mesh) {
            if (this.xGizmo) {
                this.xGizmo.attachedMesh = mesh;
                this.yGizmo.attachedMesh = mesh;
                this.zGizmo.attachedMesh = mesh;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RotationGizmo.prototype, "updateGizmoRotationToMatchAttachedMesh", {
        get: function () {
            return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;
        },
        set: function (value) {
            if (this.xGizmo) {
                this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;
                this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;
                this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RotationGizmo.prototype, "snapDistance", {
        get: function () {
            return this.xGizmo.snapDistance;
        },
        /**
         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        set: function (value) {
            if (this.xGizmo) {
                this.xGizmo.snapDistance = value;
                this.yGizmo.snapDistance = value;
                this.zGizmo.snapDistance = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RotationGizmo.prototype, "scaleRatio", {
        get: function () {
            return this.xGizmo.scaleRatio;
        },
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        set: function (value) {
            if (this.xGizmo) {
                this.xGizmo.scaleRatio = value;
                this.yGizmo.scaleRatio = value;
                this.zGizmo.scaleRatio = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes of the gizmo
     */
    RotationGizmo.prototype.dispose = function () {
        this.xGizmo.dispose();
        this.yGizmo.dispose();
        this.zGizmo.dispose();
        this.onDragStartObservable.clear();
        this.onDragEndObservable.clear();
    };
    /**
     * CustomMeshes are not supported by this gizmo
     * @param mesh The mesh to replace the default mesh of the gizmo
     */
    RotationGizmo.prototype.setCustomMesh = function (mesh) {
        Logger.Error("Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)");
    };
    return RotationGizmo;
}(Gizmo));

/**
 * Gizmo that enables dragging a mesh along 3 axis
 */
var PositionGizmo = /** @class */ (function (_super) {
    __extends(PositionGizmo, _super);
    /**
     * Creates a PositionGizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     */
    function PositionGizmo(gizmoLayer) {
        if (gizmoLayer === void 0) { gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer; }
        var _this = _super.call(this, gizmoLayer) || this;
        /** Fires an event when any of it's sub gizmos are dragged */
        _this.onDragStartObservable = new Observable();
        /** Fires an event when any of it's sub gizmos are released from dragging */
        _this.onDragEndObservable = new Observable();
        _this.xGizmo = new AxisDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer);
        _this.yGizmo = new AxisDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer);
        _this.zGizmo = new AxisDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer);
        // Relay drag events
        [_this.xGizmo, _this.yGizmo, _this.zGizmo].forEach(function (gizmo) {
            gizmo.dragBehavior.onDragStartObservable.add(function () {
                _this.onDragStartObservable.notifyObservers({});
            });
            gizmo.dragBehavior.onDragEndObservable.add(function () {
                _this.onDragEndObservable.notifyObservers({});
            });
        });
        _this.attachedMesh = null;
        return _this;
    }
    Object.defineProperty(PositionGizmo.prototype, "attachedMesh", {
        get: function () {
            return this.xGizmo.attachedMesh;
        },
        set: function (mesh) {
            if (this.xGizmo) {
                this.xGizmo.attachedMesh = mesh;
                this.yGizmo.attachedMesh = mesh;
                this.zGizmo.attachedMesh = mesh;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PositionGizmo.prototype, "updateGizmoRotationToMatchAttachedMesh", {
        get: function () {
            return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;
        },
        set: function (value) {
            if (this.xGizmo) {
                this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;
                this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;
                this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PositionGizmo.prototype, "snapDistance", {
        get: function () {
            return this.xGizmo.snapDistance;
        },
        /**
         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        set: function (value) {
            if (this.xGizmo) {
                this.xGizmo.snapDistance = value;
                this.yGizmo.snapDistance = value;
                this.zGizmo.snapDistance = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PositionGizmo.prototype, "scaleRatio", {
        get: function () {
            return this.xGizmo.scaleRatio;
        },
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        set: function (value) {
            if (this.xGizmo) {
                this.xGizmo.scaleRatio = value;
                this.yGizmo.scaleRatio = value;
                this.zGizmo.scaleRatio = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes of the gizmo
     */
    PositionGizmo.prototype.dispose = function () {
        this.xGizmo.dispose();
        this.yGizmo.dispose();
        this.zGizmo.dispose();
        this.onDragStartObservable.clear();
        this.onDragEndObservable.clear();
    };
    /**
     * CustomMeshes are not supported by this gizmo
     * @param mesh The mesh to replace the default mesh of the gizmo
     */
    PositionGizmo.prototype.setCustomMesh = function (mesh) {
        Logger.Error("Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)");
    };
    return PositionGizmo;
}(Gizmo));

VertexData.CreatePolyhedron = function (options) {
    // provided polyhedron types :
    // 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)
    // 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)
    var polyhedra = [];
    polyhedra[0] = { vertex: [[0, 0, 1.732051], [1.632993, 0, -0.5773503], [-0.8164966, 1.414214, -0.5773503], [-0.8164966, -1.414214, -0.5773503]], face: [[0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]] };
    polyhedra[1] = { vertex: [[0, 0, 1.414214], [1.414214, 0, 0], [0, 1.414214, 0], [-1.414214, 0, 0], [0, -1.414214, 0], [0, 0, -1.414214]], face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1], [1, 4, 5], [1, 5, 2], [2, 5, 3], [3, 5, 4]] };
    polyhedra[2] = {
        vertex: [[0, 0, 1.070466], [0.7136442, 0, 0.7978784], [-0.3568221, 0.618034, 0.7978784], [-0.3568221, -0.618034, 0.7978784], [0.7978784, 0.618034, 0.3568221], [0.7978784, -0.618034, 0.3568221], [-0.9341724, 0.381966, 0.3568221], [0.1362939, 1, 0.3568221], [0.1362939, -1, 0.3568221], [-0.9341724, -0.381966, 0.3568221], [0.9341724, 0.381966, -0.3568221], [0.9341724, -0.381966, -0.3568221], [-0.7978784, 0.618034, -0.3568221], [-0.1362939, 1, -0.3568221], [-0.1362939, -1, -0.3568221], [-0.7978784, -0.618034, -0.3568221], [0.3568221, 0.618034, -0.7978784], [0.3568221, -0.618034, -0.7978784], [-0.7136442, 0, -0.7978784], [0, 0, -1.070466]],
        face: [[0, 1, 4, 7, 2], [0, 2, 6, 9, 3], [0, 3, 8, 5, 1], [1, 5, 11, 10, 4], [2, 7, 13, 12, 6], [3, 9, 15, 14, 8], [4, 10, 16, 13, 7], [5, 8, 14, 17, 11], [6, 12, 18, 15, 9], [10, 11, 17, 19, 16], [12, 13, 16, 19, 18], [14, 15, 18, 19, 17]]
    };
    polyhedra[3] = {
        vertex: [[0, 0, 1.175571], [1.051462, 0, 0.5257311], [0.3249197, 1, 0.5257311], [-0.8506508, 0.618034, 0.5257311], [-0.8506508, -0.618034, 0.5257311], [0.3249197, -1, 0.5257311], [0.8506508, 0.618034, -0.5257311], [0.8506508, -0.618034, -0.5257311], [-0.3249197, 1, -0.5257311], [-1.051462, 0, -0.5257311], [-0.3249197, -1, -0.5257311], [0, 0, -1.175571]],
        face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 5], [0, 5, 1], [1, 5, 7], [1, 7, 6], [1, 6, 2], [2, 6, 8], [2, 8, 3], [3, 8, 9], [3, 9, 4], [4, 9, 10], [4, 10, 5], [5, 10, 7], [6, 7, 11], [6, 11, 8], [7, 10, 11], [8, 11, 9], [9, 11, 10]]
    };
    polyhedra[4] = {
        vertex: [[0, 0, 1.070722], [0.7148135, 0, 0.7971752], [-0.104682, 0.7071068, 0.7971752], [-0.6841528, 0.2071068, 0.7971752], [-0.104682, -0.7071068, 0.7971752], [0.6101315, 0.7071068, 0.5236279], [1.04156, 0.2071068, 0.1367736], [0.6101315, -0.7071068, 0.5236279], [-0.3574067, 1, 0.1367736], [-0.7888348, -0.5, 0.5236279], [-0.9368776, 0.5, 0.1367736], [-0.3574067, -1, 0.1367736], [0.3574067, 1, -0.1367736], [0.9368776, -0.5, -0.1367736], [0.7888348, 0.5, -0.5236279], [0.3574067, -1, -0.1367736], [-0.6101315, 0.7071068, -0.5236279], [-1.04156, -0.2071068, -0.1367736], [-0.6101315, -0.7071068, -0.5236279], [0.104682, 0.7071068, -0.7971752], [0.6841528, -0.2071068, -0.7971752], [0.104682, -0.7071068, -0.7971752], [-0.7148135, 0, -0.7971752], [0, 0, -1.070722]],
        face: [[0, 2, 3], [1, 6, 5], [4, 9, 11], [7, 15, 13], [8, 16, 10], [12, 14, 19], [17, 22, 18], [20, 21, 23], [0, 1, 5, 2], [0, 3, 9, 4], [0, 4, 7, 1], [1, 7, 13, 6], [2, 5, 12, 8], [2, 8, 10, 3], [3, 10, 17, 9], [4, 11, 15, 7], [5, 6, 14, 12], [6, 13, 20, 14], [8, 12, 19, 16], [9, 17, 18, 11], [10, 16, 22, 17], [11, 18, 21, 15], [13, 15, 21, 20], [14, 20, 23, 19], [16, 19, 23, 22], [18, 22, 23, 21]]
    };
    polyhedra[5] = { vertex: [[0, 0, 1.322876], [1.309307, 0, 0.1889822], [-0.9819805, 0.8660254, 0.1889822], [0.1636634, -1.299038, 0.1889822], [0.3273268, 0.8660254, -0.9449112], [-0.8183171, -0.4330127, -0.9449112]], face: [[0, 3, 1], [2, 4, 5], [0, 1, 4, 2], [0, 2, 5, 3], [1, 3, 5, 4]] };
    polyhedra[6] = { vertex: [[0, 0, 1.159953], [1.013464, 0, 0.5642542], [-0.3501431, 0.9510565, 0.5642542], [-0.7715208, -0.6571639, 0.5642542], [0.6633206, 0.9510565, -0.03144481], [0.8682979, -0.6571639, -0.3996071], [-1.121664, 0.2938926, -0.03144481], [-0.2348831, -1.063314, -0.3996071], [0.5181548, 0.2938926, -0.9953061], [-0.5850262, -0.112257, -0.9953061]], face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 9, 7], [5, 7, 9, 8], [0, 3, 7, 5, 1], [2, 4, 8, 9, 6]] };
    polyhedra[7] = { vertex: [[0, 0, 1.118034], [0.8944272, 0, 0.6708204], [-0.2236068, 0.8660254, 0.6708204], [-0.7826238, -0.4330127, 0.6708204], [0.6708204, 0.8660254, 0.2236068], [1.006231, -0.4330127, -0.2236068], [-1.006231, 0.4330127, 0.2236068], [-0.6708204, -0.8660254, -0.2236068], [0.7826238, 0.4330127, -0.6708204], [0.2236068, -0.8660254, -0.6708204], [-0.8944272, 0, -0.6708204], [0, 0, -1.118034]], face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 10, 7], [5, 9, 11, 8], [7, 10, 11, 9], [0, 3, 7, 9, 5, 1], [2, 4, 8, 11, 10, 6]] };
    polyhedra[8] = { vertex: [[-0.729665, 0.670121, 0.319155], [-0.655235, -0.29213, -0.754096], [-0.093922, -0.607123, 0.537818], [0.702196, 0.595691, 0.485187], [0.776626, -0.36656, -0.588064]], face: [[1, 4, 2], [0, 1, 2], [3, 0, 2], [4, 3, 2], [4, 1, 0, 3]] };
    polyhedra[9] = { vertex: [[-0.868849, -0.100041, 0.61257], [-0.329458, 0.976099, 0.28078], [-0.26629, -0.013796, -0.477654], [-0.13392, -1.034115, 0.229829], [0.738834, 0.707117, -0.307018], [0.859683, -0.535264, -0.338508]], face: [[3, 0, 2], [5, 3, 2], [4, 5, 2], [1, 4, 2], [0, 1, 2], [0, 3, 5, 4, 1]] };
    polyhedra[10] = { vertex: [[-0.610389, 0.243975, 0.531213], [-0.187812, -0.48795, -0.664016], [-0.187812, 0.9759, -0.664016], [0.187812, -0.9759, 0.664016], [0.798201, 0.243975, 0.132803]], face: [[1, 3, 0], [3, 4, 0], [3, 1, 4], [0, 2, 1], [0, 4, 2], [2, 4, 1]] };
    polyhedra[11] = { vertex: [[-1.028778, 0.392027, -0.048786], [-0.640503, -0.646161, 0.621837], [-0.125162, -0.395663, -0.540059], [0.004683, 0.888447, -0.651988], [0.125161, 0.395663, 0.540059], [0.632925, -0.791376, 0.433102], [1.031672, 0.157063, -0.354165]], face: [[3, 2, 0], [2, 1, 0], [2, 5, 1], [0, 4, 3], [0, 1, 4], [4, 1, 5], [2, 3, 6], [3, 4, 6], [5, 2, 6], [4, 5, 6]] };
    polyhedra[12] = { vertex: [[-0.669867, 0.334933, -0.529576], [-0.669867, 0.334933, 0.529577], [-0.4043, 1.212901, 0], [-0.334933, -0.669867, -0.529576], [-0.334933, -0.669867, 0.529577], [0.334933, 0.669867, -0.529576], [0.334933, 0.669867, 0.529577], [0.4043, -1.212901, 0], [0.669867, -0.334933, -0.529576], [0.669867, -0.334933, 0.529577]], face: [[8, 9, 7], [6, 5, 2], [3, 8, 7], [5, 0, 2], [4, 3, 7], [0, 1, 2], [9, 4, 7], [1, 6, 2], [9, 8, 5, 6], [8, 3, 0, 5], [3, 4, 1, 0], [4, 9, 6, 1]] };
    polyhedra[13] = { vertex: [[-0.931836, 0.219976, -0.264632], [-0.636706, 0.318353, 0.692816], [-0.613483, -0.735083, -0.264632], [-0.326545, 0.979634, 0], [-0.318353, -0.636706, 0.692816], [-0.159176, 0.477529, -0.856368], [0.159176, -0.477529, -0.856368], [0.318353, 0.636706, 0.692816], [0.326545, -0.979634, 0], [0.613482, 0.735082, -0.264632], [0.636706, -0.318353, 0.692816], [0.931835, -0.219977, -0.264632]], face: [[11, 10, 8], [7, 9, 3], [6, 11, 8], [9, 5, 3], [2, 6, 8], [5, 0, 3], [4, 2, 8], [0, 1, 3], [10, 4, 8], [1, 7, 3], [10, 11, 9, 7], [11, 6, 5, 9], [6, 2, 0, 5], [2, 4, 1, 0], [4, 10, 7, 1]] };
    polyhedra[14] = {
        vertex: [[-0.93465, 0.300459, -0.271185], [-0.838689, -0.260219, -0.516017], [-0.711319, 0.717591, 0.128359], [-0.710334, -0.156922, 0.080946], [-0.599799, 0.556003, -0.725148], [-0.503838, -0.004675, -0.969981], [-0.487004, 0.26021, 0.48049], [-0.460089, -0.750282, -0.512622], [-0.376468, 0.973135, -0.325605], [-0.331735, -0.646985, 0.084342], [-0.254001, 0.831847, 0.530001], [-0.125239, -0.494738, -0.966586], [0.029622, 0.027949, 0.730817], [0.056536, -0.982543, -0.262295], [0.08085, 1.087391, 0.076037], [0.125583, -0.532729, 0.485984], [0.262625, 0.599586, 0.780328], [0.391387, -0.726999, -0.716259], [0.513854, -0.868287, 0.139347], [0.597475, 0.85513, 0.326364], [0.641224, 0.109523, 0.783723], [0.737185, -0.451155, 0.538891], [0.848705, -0.612742, -0.314616], [0.976075, 0.365067, 0.32976], [1.072036, -0.19561, 0.084927]],
        face: [[15, 18, 21], [12, 20, 16], [6, 10, 2], [3, 0, 1], [9, 7, 13], [2, 8, 4, 0], [0, 4, 5, 1], [1, 5, 11, 7], [7, 11, 17, 13], [13, 17, 22, 18], [18, 22, 24, 21], [21, 24, 23, 20], [20, 23, 19, 16], [16, 19, 14, 10], [10, 14, 8, 2], [15, 9, 13, 18], [12, 15, 21, 20], [6, 12, 16, 10], [3, 6, 2, 0], [9, 3, 1, 7], [9, 15, 12, 6, 3], [22, 17, 11, 5, 4, 8, 14, 19, 23, 24]]
    };
    var type = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;
    var size = options.size;
    var sizeX = options.sizeX || size || 1;
    var sizeY = options.sizeY || size || 1;
    var sizeZ = options.sizeZ || size || 1;
    var data = options.custom || polyhedra[type];
    var nbfaces = data.face.length;
    var faceUV = options.faceUV || new Array(nbfaces);
    var faceColors = options.faceColors;
    var flat = (options.flat === undefined) ? true : options.flat;
    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
    var positions = new Array();
    var indices = new Array();
    var normals = new Array();
    var uvs = new Array();
    var colors = new Array();
    var index = 0;
    var faceIdx = 0; // face cursor in the array "indexes"
    var indexes = new Array();
    var i = 0;
    var f = 0;
    var u, v, ang, x, y, tmp;
    // default face colors and UV if undefined
    if (flat) {
        for (f = 0; f < nbfaces; f++) {
            if (faceColors && faceColors[f] === undefined) {
                faceColors[f] = new Color4(1, 1, 1, 1);
            }
            if (faceUV && faceUV[f] === undefined) {
                faceUV[f] = new Vector4(0, 0, 1, 1);
            }
        }
    }
    if (!flat) {
        for (i = 0; i < data.vertex.length; i++) {
            positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);
            uvs.push(0, 0);
        }
        for (f = 0; f < nbfaces; f++) {
            for (i = 0; i < data.face[f].length - 2; i++) {
                indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);
            }
        }
    }
    else {
        for (f = 0; f < nbfaces; f++) {
            var fl = data.face[f].length; // number of vertices of the current face
            ang = 2 * Math.PI / fl;
            x = 0.5 * Math.tan(ang / 2);
            y = 0.5;
            // positions, uvs, colors
            for (i = 0; i < fl; i++) {
                // positions
                positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);
                indexes.push(index);
                index++;
                // uvs
                u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);
                v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);
                uvs.push(u, v);
                tmp = x * Math.cos(ang) - y * Math.sin(ang);
                y = x * Math.sin(ang) + y * Math.cos(ang);
                x = tmp;
                // colors
                if (faceColors) {
                    colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);
                }
            }
            // indices from indexes
            for (i = 0; i < fl - 2; i++) {
                indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);
            }
            faceIdx += fl;
        }
    }
    VertexData.ComputeNormals(positions, indices, normals);
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
    var vertexData = new VertexData();
    vertexData.positions = positions;
    vertexData.indices = indices;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    if (faceColors && flat) {
        vertexData.colors = colors;
    }
    return vertexData;
};
Mesh.CreatePolyhedron = function (name, options, scene) {
    return PolyhedronBuilder.CreatePolyhedron(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var PolyhedronBuilder = /** @class */ (function () {
    function PolyhedronBuilder() {
    }
    /**
     * Creates a polyhedron mesh
     * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
     * * The parameter `size` (positive float, default 1) sets the polygon size
     * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
     * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
     * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
     * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
     * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
     * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the polyhedron mesh
     * @see https://doc.babylonjs.com/how_to/polyhedra_shapes
     */
    PolyhedronBuilder.CreatePolyhedron = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var polyhedron = new Mesh(name, scene);
        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        polyhedron._originalBuilderSideOrientation = options.sideOrientation;
        var vertexData = VertexData.CreatePolyhedron(options);
        vertexData.applyToMesh(polyhedron, options.updatable);
        return polyhedron;
    };
    return PolyhedronBuilder;
}());

/**
 * Gizmo that enables scaling a mesh along 3 axis
 */
var ScaleGizmo = /** @class */ (function (_super) {
    __extends(ScaleGizmo, _super);
    /**
     * Creates a ScaleGizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     */
    function ScaleGizmo(gizmoLayer) {
        if (gizmoLayer === void 0) { gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer; }
        var _this = _super.call(this, gizmoLayer) || this;
        /** Fires an event when any of it's sub gizmos are dragged */
        _this.onDragStartObservable = new Observable();
        /** Fires an event when any of it's sub gizmos are released from dragging */
        _this.onDragEndObservable = new Observable();
        _this.xGizmo = new AxisScaleGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer);
        _this.yGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer);
        _this.zGizmo = new AxisScaleGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer);
        // Create uniform scale gizmo
        _this.uniformScaleGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Yellow().scale(0.5), gizmoLayer);
        _this.uniformScaleGizmo.updateGizmoRotationToMatchAttachedMesh = false;
        _this.uniformScaleGizmo.uniformScaling = true;
        var uniformScalingMesh = PolyhedronBuilder.CreatePolyhedron("", { type: 1 }, _this.uniformScaleGizmo.gizmoLayer.utilityLayerScene);
        uniformScalingMesh.scaling.scaleInPlace(0.02);
        uniformScalingMesh.visibility = 0;
        var octahedron = PolyhedronBuilder.CreatePolyhedron("", { type: 1 }, _this.uniformScaleGizmo.gizmoLayer.utilityLayerScene);
        octahedron.scaling.scaleInPlace(0.007);
        uniformScalingMesh.addChild(octahedron);
        _this.uniformScaleGizmo.setCustomMesh(uniformScalingMesh, true);
        var light = gizmoLayer._getSharedGizmoLight();
        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(octahedron);
        // Relay drag events
        [_this.xGizmo, _this.yGizmo, _this.zGizmo, _this.uniformScaleGizmo].forEach(function (gizmo) {
            gizmo.dragBehavior.onDragStartObservable.add(function () {
                _this.onDragStartObservable.notifyObservers({});
            });
            gizmo.dragBehavior.onDragEndObservable.add(function () {
                _this.onDragEndObservable.notifyObservers({});
            });
        });
        _this.attachedMesh = null;
        return _this;
    }
    Object.defineProperty(ScaleGizmo.prototype, "attachedMesh", {
        get: function () {
            return this.xGizmo.attachedMesh;
        },
        set: function (mesh) {
            if (this.xGizmo) {
                this.xGizmo.attachedMesh = mesh;
                this.yGizmo.attachedMesh = mesh;
                this.zGizmo.attachedMesh = mesh;
                this.uniformScaleGizmo.attachedMesh = mesh;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleGizmo.prototype, "updateGizmoRotationToMatchAttachedMesh", {
        get: function () {
            return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;
        },
        set: function (value) {
            if (!value) {
                Logger.Warn("Setting updateGizmoRotationToMatchAttachedMesh = false on scaling gizmo is not supported.");
            }
            if (this.xGizmo) {
                this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;
                this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;
                this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleGizmo.prototype, "snapDistance", {
        get: function () {
            return this.xGizmo.snapDistance;
        },
        /**
         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        set: function (value) {
            if (this.xGizmo) {
                this.xGizmo.snapDistance = value;
                this.yGizmo.snapDistance = value;
                this.zGizmo.snapDistance = value;
                this.uniformScaleGizmo.snapDistance = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleGizmo.prototype, "scaleRatio", {
        get: function () {
            return this.xGizmo.scaleRatio;
        },
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        set: function (value) {
            if (this.xGizmo) {
                this.xGizmo.scaleRatio = value;
                this.yGizmo.scaleRatio = value;
                this.zGizmo.scaleRatio = value;
                this.uniformScaleGizmo.scaleRatio = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes of the gizmo
     */
    ScaleGizmo.prototype.dispose = function () {
        this.xGizmo.dispose();
        this.yGizmo.dispose();
        this.zGizmo.dispose();
        this.uniformScaleGizmo.dispose();
        this.onDragStartObservable.clear();
        this.onDragEndObservable.clear();
    };
    return ScaleGizmo;
}(Gizmo));

/**
 * Helps setup gizmo's in the scene to rotate/scale/position meshes
 */
var GizmoManager = /** @class */ (function () {
    /**
     * Instatiates a gizmo manager
     * @param scene the scene to overlay the gizmos on top of
     */
    function GizmoManager(scene) {
        var _this = this;
        this.scene = scene;
        /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */
        this.clearGizmoOnEmptyPointerEvent = false;
        /** Fires an event when the manager is attached to a mesh */
        this.onAttachedToMeshObservable = new Observable();
        this._gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };
        this._pointerObserver = null;
        this._attachedMesh = null;
        this._boundingBoxColor = Color3.FromHexString("#0984e3");
        /**
         * When bounding box gizmo is enabled, this can be used to track drag/end events
         */
        this.boundingBoxDragBehavior = new SixDofDragBehavior();
        /**
         * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)
         */
        this.attachableMeshes = null;
        /**
         * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh. (Default: true)
         */
        this.usePointerToAttachGizmos = true;
        this._defaultKeepDepthUtilityLayer = new UtilityLayerRenderer(scene);
        this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
        this._defaultUtilityLayer = UtilityLayerRenderer.DefaultUtilityLayer;
        this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };
        // Instatiate/dispose gizmos based on pointer actions
        this._pointerObserver = scene.onPointerObservable.add(function (pointerInfo) {
            if (!_this.usePointerToAttachGizmos) {
                return;
            }
            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {
                    var node = pointerInfo.pickInfo.pickedMesh;
                    if (_this.attachableMeshes == null) {
                        // Attach to the most parent node
                        while (node && node.parent != null) {
                            node = node.parent;
                        }
                    }
                    else {
                        // Attach to the parent node that is an attachableMesh
                        var found = false;
                        _this.attachableMeshes.forEach(function (mesh) {
                            if (node && (node == mesh || node.isDescendantOf(mesh))) {
                                node = mesh;
                                found = true;
                            }
                        });
                        if (!found) {
                            node = null;
                        }
                    }
                    if (node instanceof AbstractMesh) {
                        if (_this._attachedMesh != node) {
                            _this.attachToMesh(node);
                        }
                    }
                    else {
                        if (_this.clearGizmoOnEmptyPointerEvent) {
                            _this.attachToMesh(null);
                        }
                    }
                }
                else {
                    if (_this.clearGizmoOnEmptyPointerEvent) {
                        _this.attachToMesh(null);
                    }
                }
            }
        });
    }
    /**
     * Attaches a set of gizmos to the specified mesh
     * @param mesh The mesh the gizmo's should be attached to
     */
    GizmoManager.prototype.attachToMesh = function (mesh) {
        if (this._attachedMesh) {
            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
        }
        this._attachedMesh = mesh;
        for (var key in this.gizmos) {
            var gizmo = (this.gizmos[key]);
            if (gizmo && this._gizmosEnabled[key]) {
                gizmo.attachedMesh = mesh;
            }
        }
        if (this.boundingBoxGizmoEnabled && this._attachedMesh) {
            this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);
        }
        this.onAttachedToMeshObservable.notifyObservers(mesh);
    };
    Object.defineProperty(GizmoManager.prototype, "positionGizmoEnabled", {
        get: function () {
            return this._gizmosEnabled.positionGizmo;
        },
        /**
         * If the position gizmo is enabled
         */
        set: function (value) {
            if (value) {
                if (!this.gizmos.positionGizmo) {
                    this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer);
                }
                this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;
            }
            else if (this.gizmos.positionGizmo) {
                this.gizmos.positionGizmo.attachedMesh = null;
            }
            this._gizmosEnabled.positionGizmo = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GizmoManager.prototype, "rotationGizmoEnabled", {
        get: function () {
            return this._gizmosEnabled.rotationGizmo;
        },
        /**
         * If the rotation gizmo is enabled
         */
        set: function (value) {
            if (value) {
                if (!this.gizmos.rotationGizmo) {
                    this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer);
                }
                this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;
            }
            else if (this.gizmos.rotationGizmo) {
                this.gizmos.rotationGizmo.attachedMesh = null;
            }
            this._gizmosEnabled.rotationGizmo = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GizmoManager.prototype, "scaleGizmoEnabled", {
        get: function () {
            return this._gizmosEnabled.scaleGizmo;
        },
        /**
         * If the scale gizmo is enabled
         */
        set: function (value) {
            if (value) {
                this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer);
                this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;
            }
            else if (this.gizmos.scaleGizmo) {
                this.gizmos.scaleGizmo.attachedMesh = null;
            }
            this._gizmosEnabled.scaleGizmo = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GizmoManager.prototype, "boundingBoxGizmoEnabled", {
        get: function () {
            return this._gizmosEnabled.boundingBoxGizmo;
        },
        /**
         * If the boundingBox gizmo is enabled
         */
        set: function (value) {
            if (value) {
                this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);
                this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;
                if (this._attachedMesh) {
                    this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
                    this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);
                }
            }
            else if (this.gizmos.boundingBoxGizmo) {
                if (this._attachedMesh) {
                    this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
                }
                this.gizmos.boundingBoxGizmo.attachedMesh = null;
            }
            this._gizmosEnabled.boundingBoxGizmo = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes of the gizmo manager
     */
    GizmoManager.prototype.dispose = function () {
        this.scene.onPointerObservable.remove(this._pointerObserver);
        for (var key in this.gizmos) {
            var gizmo = (this.gizmos[key]);
            if (gizmo) {
                gizmo.dispose();
            }
        }
        this._defaultKeepDepthUtilityLayer.dispose();
        this.boundingBoxDragBehavior.detach();
        this.onAttachedToMeshObservable.clear();
    };
    return GizmoManager;
}());

/**
 * Creates a hemispheric light
 */
Mesh.CreateHemisphere = function (name, segments, diameter, scene) {
    var options = {
        segments: segments,
        diameter: diameter
    };
    return HemisphereBuilder.CreateHemisphere(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var HemisphereBuilder = /** @class */ (function () {
    function HemisphereBuilder() {
    }
    /**
     * Creates a hemisphere mesh
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the hemisphere mesh
     */
    HemisphereBuilder.CreateHemisphere = function (name, options, scene) {
        if (!options.diameter) {
            options.diameter = 1;
        }
        if (!options.segments) {
            options.segments = 16;
        }
        var halfSphere = SphereBuilder.CreateSphere("", { slice: 0.5, diameter: options.diameter, segments: options.segments }, scene);
        var disc = Mesh.CreateDisc("", options.diameter / 2, (options.segments * 3) + (4 - options.segments), scene);
        disc.rotation.x = -Math.PI / 2;
        disc.parent = halfSphere;
        var merged = Mesh.MergeMeshes([disc, halfSphere], true);
        merged.name = name;
        return merged;
    };
    return HemisphereBuilder;
}());

/**
 * Gizmo that enables viewing a light
 */
var LightGizmo = /** @class */ (function (_super) {
    __extends(LightGizmo, _super);
    /**
     * Creates a LightGizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     */
    function LightGizmo(gizmoLayer) {
        var _this = _super.call(this, gizmoLayer) || this;
        _this.cachedPosition = new Vector3();
        _this.cachedForward = new Vector3(0, 0, 1);
        _this._light = null;
        _this.attachedMesh = new AbstractMesh("", _this.gizmoLayer.utilityLayerScene);
        _this._material = new StandardMaterial("light", _this.gizmoLayer.originalScene);
        _this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);
        _this._material.specularColor = new Color3(0.1, 0.1, 0.1);
        return _this;
    }
    Object.defineProperty(LightGizmo.prototype, "light", {
        get: function () {
            return this._light;
        },
        /**
         * The light that the gizmo is attached to
         */
        set: function (light) {
            var _this = this;
            this._light = light;
            if (light) {
                // Create the mesh for the given light type
                if (this._lightMesh) {
                    this._lightMesh.dispose();
                }
                if (light instanceof HemisphericLight) {
                    this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);
                }
                else if (light instanceof DirectionalLight) {
                    this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);
                }
                else if (light instanceof SpotLight) {
                    this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);
                }
                else {
                    this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);
                }
                this._lightMesh.getChildMeshes(false).forEach(function (m) {
                    m.material = _this._material;
                });
                this._lightMesh.parent = this._rootMesh;
                // Add lighting to the light gizmo
                var gizmoLight = this.gizmoLayer._getSharedGizmoLight();
                gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));
                this._lightMesh.rotationQuaternion = new Quaternion();
                // Get update position and direction if the light has it
                if (light.position) {
                    this.attachedMesh.position.copyFrom(light.position);
                }
                if (light.direction) {
                    this.attachedMesh.setDirection(light.direction);
                }
                this._update();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Updates the gizmo to match the attached mesh's position/rotation
     */
    LightGizmo.prototype._update = function () {
        _super.prototype._update.call(this);
        if (!this._light) {
            return;
        }
        if (this._light.position) {
            // If the gizmo is moved update the light otherwise update the gizmo to match the light
            if (!this.attachedMesh.position.equals(this.cachedPosition)) {
                // update light to match gizmo
                this._light.position.copyFrom(this.attachedMesh.position);
                this.cachedPosition.copyFrom(this.attachedMesh.position);
            }
            else {
                // update gizmo to match light
                this.attachedMesh.position.copyFrom(this._light.position);
            }
        }
        if (this._light.direction) {
            // If the gizmo is moved update the light otherwise update the gizmo to match the light
            if (Vector3.DistanceSquared(this.attachedMesh.forward, this.cachedForward) > 0.0001) {
                // update light to match gizmo
                this._light.direction.copyFrom(this.attachedMesh.forward);
                this.cachedForward.copyFrom(this.attachedMesh.forward);
            }
            else if (Vector3.DistanceSquared(this.attachedMesh.forward, this._light.direction) > 0.0001) {
                // update gizmo to match light
                this.attachedMesh.setDirection(this._light.direction);
                this.cachedForward.copyFrom(this._lightMesh.forward);
            }
        }
        if (!this._light.isEnabled()) {
            this._material.diffuseColor.set(0, 0, 0);
        }
        else {
            this._material.diffuseColor.set(this._light.diffuse.r / 3, this._light.diffuse.g / 3, this._light.diffuse.b / 3);
        }
    };
    /**
     * Disposes of the light gizmo
     */
    LightGizmo.prototype.dispose = function () {
        this._material.dispose();
        _super.prototype.dispose.call(this);
    };
    LightGizmo._CreateHemisphericLightMesh = function (scene) {
        var root = new Mesh("hemisphereLight", scene);
        var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, { segments: 10, diameter: 1 }, scene);
        hemisphere.position.z = -0.15;
        hemisphere.rotation.x = Math.PI / 2;
        hemisphere.parent = root;
        var lines = this._createLightLines(3, scene);
        lines.parent = root;
        lines.position.z - 0.15;
        root.scaling.scaleInPlace(LightGizmo._Scale);
        root.rotation.x = Math.PI / 2;
        return root;
    };
    LightGizmo._CreatePointLightMesh = function (scene) {
        var root = new Mesh("pointLight", scene);
        var sphere = SphereBuilder.CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);
        sphere.rotation.x = Math.PI / 2;
        sphere.parent = root;
        var lines = this._createLightLines(5, scene);
        lines.parent = root;
        root.scaling.scaleInPlace(LightGizmo._Scale);
        root.rotation.x = Math.PI / 2;
        return root;
    };
    LightGizmo._CreateSpotLightMesh = function (scene) {
        var root = new Mesh("spotLight", scene);
        var sphere = SphereBuilder.CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);
        sphere.parent = root;
        var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, { segments: 10, diameter: 2 }, scene);
        hemisphere.parent = root;
        hemisphere.rotation.x = -Math.PI / 2;
        var lines = this._createLightLines(2, scene);
        lines.parent = root;
        root.scaling.scaleInPlace(LightGizmo._Scale);
        root.rotation.x = Math.PI / 2;
        return root;
    };
    LightGizmo._CreateDirectionalLightMesh = function (scene) {
        var root = new Mesh("directionalLight", scene);
        var mesh = new Mesh(root.name, scene);
        mesh.parent = root;
        var sphere = SphereBuilder.CreateSphere(root.name, { diameter: 1.2, segments: 10 }, scene);
        sphere.parent = mesh;
        var line = Mesh.CreateCylinder(root.name, 6, 0.3, 0.3, 6, 1, scene);
        line.parent = mesh;
        var left = line.clone(root.name);
        left.scaling.y = 0.5;
        left.position.x += 1.25;
        var right = line.clone(root.name);
        right.scaling.y = 0.5;
        right.position.x += -1.25;
        var arrowHead = Mesh.CreateCylinder(root.name, 1, 0, 0.6, 6, 1, scene);
        arrowHead.position.y += 3;
        arrowHead.parent = mesh;
        var left = arrowHead.clone(root.name);
        left.position.y = 1.5;
        left.position.x += 1.25;
        var right = arrowHead.clone(root.name);
        right.position.y = 1.5;
        right.position.x += -1.25;
        mesh.scaling.scaleInPlace(LightGizmo._Scale);
        mesh.rotation.z = Math.PI / 2;
        mesh.rotation.y = Math.PI / 2;
        return root;
    };
    // Static helper methods
    LightGizmo._Scale = 0.007;
    /**
     * Creates the lines for a light mesh
     */
    LightGizmo._createLightLines = function (levels, scene) {
        var distFromSphere = 1.2;
        var root = new Mesh("root", scene);
        root.rotation.x = Math.PI / 2;
        // Create the top line, this will be cloned for all other lines
        var linePivot = new Mesh("linePivot", scene);
        linePivot.parent = root;
        var line = Mesh.CreateCylinder("line", 2, 0.2, 0.3, 6, 1, scene);
        line.position.y = line.scaling.y / 2 + distFromSphere;
        line.parent = linePivot;
        if (levels < 2) {
            return linePivot;
        }
        for (var i = 0; i < 4; i++) {
            var l = linePivot.clone("lineParentClone");
            l.rotation.z = Math.PI / 4;
            l.rotation.y = (Math.PI / 2) + (Math.PI / 2 * i);
            l.getChildMeshes()[0].scaling.y = 0.5;
            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;
            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;
        }
        if (levels < 3) {
            return root;
        }
        for (var i = 0; i < 4; i++) {
            var l = linePivot.clone("linePivotClone");
            l.rotation.z = Math.PI / 2;
            l.rotation.y = (Math.PI / 2 * i);
        }
        if (levels < 4) {
            return root;
        }
        for (var i = 0; i < 4; i++) {
            var l = linePivot.clone("linePivotClone");
            l.rotation.z = Math.PI + (Math.PI / 4);
            l.rotation.y = (Math.PI / 2) + (Math.PI / 2 * i);
            l.getChildMeshes()[0].scaling.y = 0.5;
            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;
            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;
        }
        if (levels < 5) {
            return root;
        }
        var l = linePivot.clone("linePivotClone");
        l.rotation.z = Math.PI;
        return root;
    };
    return LightGizmo;
}(Gizmo));

var name$9 = 'kernelBlurVaryingDeclaration';
var shader$9 = "varying vec2 sampleCoord{X};";
Effect.IncludesShadersStore[name$9] = shader$9;

var name$a = 'kernelBlurFragment';
var shader$a = "#ifdef DOF\nfactor=sampleCoC(sampleCoord{X});\ncomputedWeight=KERNEL_WEIGHT{X}*factor;\nsumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;\n#endif";
Effect.IncludesShadersStore[name$a] = shader$a;

var name$b = 'kernelBlurFragment2';
var shader$b = "#ifdef DOF\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});\ncomputedWeight=KERNEL_DEP_WEIGHT{X}*factor;\nsumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\n#endif";
Effect.IncludesShadersStore[name$b] = shader$b;

var name$c = 'kernelBlurPixelShader';
var shader$c = "\nuniform sampler2D textureSampler;\nuniform vec2 delta;\n\nvarying vec2 sampleCenter;\n#ifdef DOF\nuniform sampler2D circleOfConfusionSampler;\nuniform vec2 cameraMinMaxZ;\nfloat sampleDistance(const in vec2 offset) {\nfloat depth=texture2D(circleOfConfusionSampler,offset).g;\nreturn cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth;\n}\nfloat sampleCoC(const in vec2 offset) {\nfloat coc=texture2D(circleOfConfusionSampler,offset).r;\nreturn coc;\n}\n#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\nvec4 pack(float depth)\n{\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\nvec4 res=fract(depth*bit_shift);\nres-=res.xxyz*bit_mask;\nreturn res;\n}\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}\n#endif\nvoid main(void)\n{\nfloat computedWeight=0.0;\n#ifdef PACKEDFLOAT\nfloat blend=0.;\n#else\nvec4 blend=vec4(0.);\n#endif\n#ifdef DOF\nfloat sumOfWeights=CENTER_WEIGHT;\nfloat factor=0.0;\n\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\n#else\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\n#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\ngl_FragColor=pack(blend);\n#else\ngl_FragColor=blend;\n#endif\n#ifdef DOF\ngl_FragColor/=sumOfWeights;\n#endif\n}";
Effect.ShadersStore[name$c] = shader$c;

var name$d = 'kernelBlurVertex';
var shader$d = "sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";
Effect.IncludesShadersStore[name$d] = shader$d;

var name$e = 'kernelBlurVertexShader';
var shader$e = "\nattribute vec2 position;\n\nuniform vec2 delta;\n\nvarying vec2 sampleCenter;\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nsampleCenter=(position*madd+madd);\n#include<kernelBlurVertex>[0..varyingCount]\ngl_Position=vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name$e] = shader$e;

/**
 * The Blur Post Process which blurs an image based on a kernel and direction.
 * Can be used twice in x and y directions to perform a guassian blur in two passes.
 */
var BlurPostProcess = /** @class */ (function (_super) {
    __extends(BlurPostProcess, _super);
    /**
     * Creates a new instance BlurPostProcess
     * @param name The name of the effect.
     * @param direction The direction in which to blur the image.
     * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.
     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function BlurPostProcess(name, 
    /** The direction in which to blur the image. */
    direction, kernel, options, camera, samplingMode, engine, reusable, textureType, defines, blockCompilation) {
        if (samplingMode === void 0) { samplingMode = Texture.BILINEAR_SAMPLINGMODE; }
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (defines === void 0) { defines = ""; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "kernelBlur", ["delta", "direction", "cameraMinMaxZ"], ["circleOfConfusionSampler"], options, camera, samplingMode, engine, reusable, null, textureType, "kernelBlur", { varyingCount: 0, depCount: 0 }, true) || this;
        _this.direction = direction;
        _this.blockCompilation = blockCompilation;
        _this._packedFloat = false;
        _this._staticDefines = "";
        _this._staticDefines = defines;
        _this.onApplyObservable.add(function (effect) {
            if (_this._outputTexture) {
                effect.setFloat2('delta', (1 / _this._outputTexture.width) * _this.direction.x, (1 / _this._outputTexture.height) * _this.direction.y);
            }
            else {
                effect.setFloat2('delta', (1 / _this.width) * _this.direction.x, (1 / _this.height) * _this.direction.y);
            }
        });
        _this.kernel = kernel;
        return _this;
    }
    Object.defineProperty(BlurPostProcess.prototype, "kernel", {
        /**
         * Gets the length in pixels of the blur sample region
         */
        get: function () {
            return this._idealKernel;
        },
        /**
         * Sets the length in pixels of the blur sample region
         */
        set: function (v) {
            if (this._idealKernel === v) {
                return;
            }
            v = Math.max(v, 1);
            this._idealKernel = v;
            this._kernel = this._nearestBestKernel(v);
            if (!this.blockCompilation) {
                this._updateParameters();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlurPostProcess.prototype, "packedFloat", {
        /**
         * Gets wether or not the blur is unpacking/repacking floats
         */
        get: function () {
            return this._packedFloat;
        },
        /**
         * Sets wether or not the blur needs to unpack/repack floats
         */
        set: function (v) {
            if (this._packedFloat === v) {
                return;
            }
            this._packedFloat = v;
            if (!this.blockCompilation) {
                this._updateParameters();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the effect with the current post process compile time values and recompiles the shader.
     * @param defines Define statements that should be added at the beginning of the shader. (default: null)
     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
     * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
     * @param onCompiled Called when the shader has been compiled.
     * @param onError Called if there is an error when compiling a shader.
     */
    BlurPostProcess.prototype.updateEffect = function (defines, uniforms, samplers, indexParameters, onCompiled, onError) {
        this._updateParameters(onCompiled, onError);
    };
    BlurPostProcess.prototype._updateParameters = function (onCompiled, onError) {
        // Generate sampling offsets and weights
        var N = this._kernel;
        var centerIndex = (N - 1) / 2;
        // Generate Gaussian sampling weights over kernel
        var offsets = [];
        var weights = [];
        var totalWeight = 0;
        for (var i = 0; i < N; i++) {
            var u = i / (N - 1);
            var w = this._gaussianWeight(u * 2.0 - 1);
            offsets[i] = (i - centerIndex);
            weights[i] = w;
            totalWeight += w;
        }
        // Normalize weights
        for (var i = 0; i < weights.length; i++) {
            weights[i] /= totalWeight;
        }
        // Optimize: combine samples to take advantage of hardware linear sampling
        // Walk from left to center, combining pairs (symmetrically)
        var linearSamplingWeights = [];
        var linearSamplingOffsets = [];
        var linearSamplingMap = [];
        for (var i = 0; i <= centerIndex; i += 2) {
            var j = Math.min(i + 1, Math.floor(centerIndex));
            var singleCenterSample = i === j;
            if (singleCenterSample) {
                linearSamplingMap.push({ o: offsets[i], w: weights[i] });
            }
            else {
                var sharedCell = j === centerIndex;
                var weightLinear = (weights[i] + weights[j] * (sharedCell ? .5 : 1.));
                var offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);
                if (offsetLinear === 0) {
                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });
                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });
                }
                else {
                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });
                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });
                }
            }
        }
        for (var i = 0; i < linearSamplingMap.length; i++) {
            linearSamplingOffsets[i] = linearSamplingMap[i].o;
            linearSamplingWeights[i] = linearSamplingMap[i].w;
        }
        // Replace with optimized
        offsets = linearSamplingOffsets;
        weights = linearSamplingWeights;
        // Generate shaders
        var maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;
        var freeVaryingVec2 = Math.max(maxVaryingRows, 0.) - 1; // Because of sampleCenter
        var varyingCount = Math.min(offsets.length, freeVaryingVec2);
        var defines = "";
        defines += this._staticDefines;
        // The DOF fragment should ignore the center pixel when looping as it is handled manualy in the fragment shader.
        if (this._staticDefines.indexOf("DOF") != -1) {
            defines += "#define CENTER_WEIGHT " + this._glslFloat(weights[varyingCount - 1]) + "\r\n";
            varyingCount--;
        }
        for (var i = 0; i < varyingCount; i++) {
            defines += "#define KERNEL_OFFSET" + i + " " + this._glslFloat(offsets[i]) + "\r\n";
            defines += "#define KERNEL_WEIGHT" + i + " " + this._glslFloat(weights[i]) + "\r\n";
        }
        var depCount = 0;
        for (var i = freeVaryingVec2; i < offsets.length; i++) {
            defines += "#define KERNEL_DEP_OFFSET" + depCount + " " + this._glslFloat(offsets[i]) + "\r\n";
            defines += "#define KERNEL_DEP_WEIGHT" + depCount + " " + this._glslFloat(weights[i]) + "\r\n";
            depCount++;
        }
        if (this.packedFloat) {
            defines += "#define PACKEDFLOAT 1";
        }
        this.blockCompilation = false;
        _super.prototype.updateEffect.call(this, defines, null, null, {
            varyingCount: varyingCount,
            depCount: depCount
        }, onCompiled, onError);
    };
    /**
     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are
     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
     * The gaps between physical kernels are compensated for in the weighting of the samples
     * @param idealKernel Ideal blur kernel.
     * @return Nearest best kernel.
     */
    BlurPostProcess.prototype._nearestBestKernel = function (idealKernel) {
        var v = Math.round(idealKernel);
        for (var _i = 0, _a = [v, v - 1, v + 1, v - 2, v + 2]; _i < _a.length; _i++) {
            var k = _a[_i];
            if (((k % 2) !== 0) && ((Math.floor(k / 2) % 2) === 0) && k > 0) {
                return Math.max(k, 3);
            }
        }
        return Math.max(v, 3);
    };
    /**
     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.
     * @param x The point on the Gaussian distribution to sample.
     * @return the value of the Gaussian function at x.
     */
    BlurPostProcess.prototype._gaussianWeight = function (x) {
        //reference: Engines/ImageProcessingBlur.cpp #dcc760
        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],
        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.
        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is
        // truncated at around 1.3% of peak strength.
        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size
        var sigma = (1 / 3);
        var denominator = Math.sqrt(2.0 * Math.PI) * sigma;
        var exponent = -((x * x) / (2.0 * sigma * sigma));
        var weight = (1.0 / denominator) * Math.exp(exponent);
        return weight;
    };
    /**
      * Generates a string that can be used as a floating point number in GLSL.
      * @param x Value to print.
      * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).
      * @return GLSL float string.
      */
    BlurPostProcess.prototype._glslFloat = function (x, decimalFigures) {
        if (decimalFigures === void 0) { decimalFigures = 8; }
        return x.toFixed(decimalFigures).replace(/0+$/, '');
    };
    return BlurPostProcess;
}(PostProcess));

/**
 * Mirror texture can be used to simulate the view from a mirror in a scene.
 * It will dynamically be rendered every frame to adapt to the camera point of view.
 * You can then easily use it as a reflectionTexture on a flat surface.
 * In case the surface is not a plane, please consider relying on reflection probes.
 * @see https://doc.babylonjs.com/how_to/reflect#mirrors
 */
var MirrorTexture = /** @class */ (function (_super) {
    __extends(MirrorTexture, _super);
    /**
     * Instantiates a Mirror Texture.
     * Mirror texture can be used to simulate the view from a mirror in a scene.
     * It will dynamically be rendered every frame to adapt to the camera point of view.
     * You can then easily use it as a reflectionTexture on a flat surface.
     * In case the surface is not a plane, please consider relying on reflection probes.
     * @see https://doc.babylonjs.com/how_to/reflect#mirrors
     * @param name
     * @param size
     * @param scene
     * @param generateMipMaps
     * @param type
     * @param samplingMode
     * @param generateDepthBuffer
     */
    function MirrorTexture(name, size, scene, generateMipMaps, type, samplingMode, generateDepthBuffer) {
        if (type === void 0) { type = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (samplingMode === void 0) { samplingMode = Texture.BILINEAR_SAMPLINGMODE; }
        if (generateDepthBuffer === void 0) { generateDepthBuffer = true; }
        var _this = _super.call(this, name, size, scene, generateMipMaps, true, type, false, samplingMode, generateDepthBuffer) || this;
        _this.scene = scene;
        /**
         * Define the reflection plane we want to use. The mirrorPlane is usually set to the constructed reflector.
         * It is possible to directly set the mirrorPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the mirrorPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the reflector as stated in the doc.
         * @see https://doc.babylonjs.com/how_to/reflect#mirrors
         */
        _this.mirrorPlane = new Plane$1(0, 1, 0, 1);
        _this._transformMatrix = Matrix.Zero();
        _this._mirrorMatrix = Matrix.Zero();
        _this._adaptiveBlurKernel = 0;
        _this._blurKernelX = 0;
        _this._blurKernelY = 0;
        _this._blurRatio = 1.0;
        _this.ignoreCameraViewport = true;
        _this._updateGammaSpace();
        _this._imageProcessingConfigChangeObserver = scene.imageProcessingConfiguration.onUpdateParameters.add(function () {
            _this._updateGammaSpace;
        });
        _this.onBeforeRenderObservable.add(function () {
            Matrix.ReflectionToRef(_this.mirrorPlane, _this._mirrorMatrix);
            _this._savedViewMatrix = scene.getViewMatrix();
            _this._mirrorMatrix.multiplyToRef(_this._savedViewMatrix, _this._transformMatrix);
            scene.setTransformMatrix(_this._transformMatrix, scene.getProjectionMatrix());
            scene.clipPlane = _this.mirrorPlane;
            scene.getEngine().cullBackFaces = false;
            scene._mirroredCameraPosition = Vector3.TransformCoordinates(scene.activeCamera.globalPosition, _this._mirrorMatrix);
        });
        _this.onAfterRenderObservable.add(function () {
            scene.setTransformMatrix(_this._savedViewMatrix, scene.getProjectionMatrix());
            scene.getEngine().cullBackFaces = true;
            scene._mirroredCameraPosition = null;
            scene.clipPlane = null;
        });
        return _this;
    }
    Object.defineProperty(MirrorTexture.prototype, "blurRatio", {
        get: function () {
            return this._blurRatio;
        },
        /**
         * Define the blur ratio used to blur the reflection if needed.
         */
        set: function (value) {
            if (this._blurRatio === value) {
                return;
            }
            this._blurRatio = value;
            this._preparePostProcesses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MirrorTexture.prototype, "adaptiveBlurKernel", {
        /**
         * Define the adaptive blur kernel used to blur the reflection if needed.
         * This will autocompute the closest best match for the `blurKernel`
         */
        set: function (value) {
            this._adaptiveBlurKernel = value;
            this._autoComputeBlurKernel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MirrorTexture.prototype, "blurKernel", {
        /**
         * Define the blur kernel used to blur the reflection if needed.
         * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
         */
        set: function (value) {
            this.blurKernelX = value;
            this.blurKernelY = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MirrorTexture.prototype, "blurKernelX", {
        get: function () {
            return this._blurKernelX;
        },
        /**
         * Define the blur kernel on the X Axis used to blur the reflection if needed.
         * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
         */
        set: function (value) {
            if (this._blurKernelX === value) {
                return;
            }
            this._blurKernelX = value;
            this._preparePostProcesses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MirrorTexture.prototype, "blurKernelY", {
        get: function () {
            return this._blurKernelY;
        },
        /**
         * Define the blur kernel on the Y Axis used to blur the reflection if needed.
         * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
         */
        set: function (value) {
            if (this._blurKernelY === value) {
                return;
            }
            this._blurKernelY = value;
            this._preparePostProcesses();
        },
        enumerable: true,
        configurable: true
    });
    MirrorTexture.prototype._autoComputeBlurKernel = function () {
        var engine = this.getScene().getEngine();
        var dw = this.getRenderWidth() / engine.getRenderWidth();
        var dh = this.getRenderHeight() / engine.getRenderHeight();
        this.blurKernelX = this._adaptiveBlurKernel * dw;
        this.blurKernelY = this._adaptiveBlurKernel * dh;
    };
    MirrorTexture.prototype._onRatioRescale = function () {
        if (this._sizeRatio) {
            this.resize(this._initialSizeParameter);
            if (!this._adaptiveBlurKernel) {
                this._preparePostProcesses();
            }
        }
        if (this._adaptiveBlurKernel) {
            this._autoComputeBlurKernel();
        }
    };
    MirrorTexture.prototype._updateGammaSpace = function () {
        this.gammaSpace = !this.scene.imageProcessingConfiguration.isEnabled || !this.scene.imageProcessingConfiguration.applyByPostProcess;
    };
    MirrorTexture.prototype._preparePostProcesses = function () {
        this.clearPostProcesses(true);
        if (this._blurKernelX && this._blurKernelY) {
            var engine = this.getScene().getEngine();
            var textureType = engine.getCaps().textureFloatRender ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_HALF_FLOAT;
            this._blurX = new BlurPostProcess("horizontal blur", new Vector2(1.0, 0), this._blurKernelX, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);
            this._blurX.autoClear = false;
            if (this._blurRatio === 1 && this.samples < 2 && this._texture) {
                this._blurX.inputTexture = this._texture;
            }
            else {
                this._blurX.alwaysForcePOT = true;
            }
            this._blurY = new BlurPostProcess("vertical blur", new Vector2(0, 1.0), this._blurKernelY, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);
            this._blurY.autoClear = false;
            this._blurY.alwaysForcePOT = this._blurRatio !== 1;
            this.addPostProcess(this._blurX);
            this.addPostProcess(this._blurY);
        }
        else {
            if (this._blurY) {
                this.removePostProcess(this._blurY);
                this._blurY.dispose();
                this._blurY = null;
            }
            if (this._blurX) {
                this.removePostProcess(this._blurX);
                this._blurX.dispose();
                this._blurX = null;
            }
        }
    };
    /**
     * Clone the mirror texture.
     * @returns the cloned texture
     */
    MirrorTexture.prototype.clone = function () {
        var scene = this.getScene();
        if (!scene) {
            return this;
        }
        var textureSize = this.getSize();
        var newTexture = new MirrorTexture(this.name, textureSize.width, scene, this._renderTargetOptions.generateMipMaps, this._renderTargetOptions.type, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer);
        // Base texture
        newTexture.hasAlpha = this.hasAlpha;
        newTexture.level = this.level;
        // Mirror Texture
        newTexture.mirrorPlane = this.mirrorPlane.clone();
        if (this.renderList) {
            newTexture.renderList = this.renderList.slice(0);
        }
        return newTexture;
    };
    /**
     * Serialize the texture to a JSON representation you could use in Parse later on
     * @returns the serialized JSON representation
     */
    MirrorTexture.prototype.serialize = function () {
        if (!this.name) {
            return null;
        }
        var serializationObject = _super.prototype.serialize.call(this);
        serializationObject.mirrorPlane = this.mirrorPlane.asArray();
        return serializationObject;
    };
    /**
     * Dispose the texture and release its associated resources.
     */
    MirrorTexture.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigChangeObserver);
    };
    return MirrorTexture;
}(RenderTargetTexture));
Texture._CreateMirror = function (name, renderTargetSize, scene, generateMipMaps) {
    return new MirrorTexture(name, renderTargetSize, scene, generateMipMaps);
};

var name$f = 'backgroundFragmentDeclaration';
var shader$f = " uniform vec4 vPrimaryColor;\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\nuniform vec4 vPrimaryColorShadow;\n#endif\nuniform float shadowLevel;\nuniform float alpha;\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\nuniform mat4 reflectionMatrix;\nuniform vec3 vReflectionMicrosurfaceInfos;\n#endif\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\nuniform vec3 vBackgroundCenter;\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 vReflectionControl;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\nuniform mat4 view;\n#endif";
Effect.IncludesShadersStore[name$f] = shader$f;

var name$g = 'backgroundUboDeclaration';
var shader$g = "layout(std140,column_major) uniform;\nuniform Material\n{\nuniform vec4 vPrimaryColor;\nuniform vec4 vPrimaryColorShadow;\nuniform vec2 vDiffuseInfos;\nuniform vec2 vReflectionInfos;\nuniform mat4 diffuseMatrix;\nuniform mat4 reflectionMatrix;\nuniform vec3 vReflectionMicrosurfaceInfos;\nuniform float fFovMultiplier;\nuniform float pointSize;\nuniform float shadowLevel;\nuniform float alpha;\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\nuniform vec3 vBackgroundCenter;\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 vReflectionControl;\n#endif\n};\nuniform Scene {\nmat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif\nmat4 view;\n};";
Effect.IncludesShadersStore[name$g] = shader$g;

var name$h = 'backgroundPixelShader';
var shader$h = "#ifdef TEXTURELODSUPPORT\n#extension GL_EXT_shader_texture_lod : enable\n#endif\nprecision highp float;\n#include<__decl__backgroundFragment>\n#define RECIPROCAL_PI2 0.15915494\n\nuniform vec3 vEyePosition;\n\nvarying vec3 vPositionW;\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef DIFFUSE\n#if DIFFUSEDIRECTUV == 1\n#define vDiffuseUV vMainUV1\n#elif DIFFUSEDIRECTUV == 2\n#define vDiffuseUV vMainUV2\n#else\nvarying vec2 vDiffuseUV;\n#endif\nuniform sampler2D diffuseSampler;\n#endif\n\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\n#ifdef TEXTURELODSUPPORT\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;\nuniform samplerCube reflectionSamplerHigh;\n#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\n#ifdef TEXTURELODSUPPORT\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;\nuniform samplerCube reflectionSamplerHigh;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE;\n#endif\n\n#ifndef SHADOWONLY\n#define SHADOWONLY;\n#endif\n#include<imageProcessingDeclaration>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<helperFunctions>\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<imageProcessingFunctions>\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\n#ifdef REFLECTIONFRESNEL\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\nvec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{\n\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));\n}\n#endif\nvoid main(void) {\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(0.0,1.0,0.0);\n#endif\n\nfloat shadow=1.;\nfloat globalShadow=0.;\nfloat shadowLightCount=0.;\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef SHADOWINUSE\nglobalShadow/=shadowLightCount;\n#else\nglobalShadow=1.0;\n#endif\n\nvec4 reflectionColor=vec4(1.,1.,1.,1.);\n#ifdef REFLECTION\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=reflectionVector;\n#else\nvec2 reflectionCoords=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\n#ifdef REFLECTIONBLUR\nfloat reflectionLOD=vReflectionInfos.y;\n#ifdef TEXTURELODSUPPORT\n\nreflectionLOD=reflectionLOD*log2(vReflectionMicrosurfaceInfos.x)*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\nreflectionColor=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\n#else\nfloat lodReflectionNormalized=saturate(reflectionLOD);\nfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\nvec4 reflectionSpecularMid=sampleReflection(reflectionSampler,reflectionCoords);\nif(lodReflectionNormalizedDoubled<1.0){\nreflectionColor=mix(\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\nreflectionSpecularMid,\nlodReflectionNormalizedDoubled\n);\n} else {\nreflectionColor=mix(\nreflectionSpecularMid,\nsampleReflection(reflectionSamplerLow,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);\n}\n#endif\n#else\nvec4 reflectionSample=sampleReflection(reflectionSampler,reflectionCoords);\nreflectionColor=reflectionSample;\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef GAMMAREFLECTION\nreflectionColor.rgb=toLinearSpace(reflectionColor.rgb);\n#endif\n#ifdef REFLECTIONBGR\nreflectionColor.rgb=reflectionColor.bgr;\n#endif\n\nreflectionColor.rgb*=vReflectionInfos.x;\n#endif\n\nvec3 diffuseColor=vec3(1.,1.,1.);\nfloat finalAlpha=alpha;\n#ifdef DIFFUSE\nvec4 diffuseMap=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef GAMMADIFFUSE\ndiffuseMap.rgb=toLinearSpace(diffuseMap.rgb);\n#endif\n\ndiffuseMap.rgb*=vDiffuseInfos.y;\n#ifdef DIFFUSEHASALPHA\nfinalAlpha*=diffuseMap.a;\n#endif\ndiffuseColor=diffuseMap.rgb;\n#endif\n\n#ifdef REFLECTIONFRESNEL\nvec3 colorBase=diffuseColor;\n#else\nvec3 colorBase=reflectionColor.rgb*diffuseColor;\n#endif\ncolorBase=max(colorBase,0.0);\n\n#ifdef USERGBCOLOR\nvec3 finalColor=colorBase;\n#else\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\nvec3 mainColor=mix(vPrimaryColorShadow.rgb,vPrimaryColor.rgb,colorBase);\n#else\nvec3 mainColor=vPrimaryColor.rgb;\n#endif\nvec3 finalColor=colorBase*mainColor;\n#endif\n\n#ifdef REFLECTIONFRESNEL\nvec3 reflectionAmount=vReflectionControl.xxx;\nvec3 reflectionReflectance0=vReflectionControl.yyy;\nvec3 reflectionReflectance90=vReflectionControl.zzz;\nfloat VdotN=dot(normalize(vEyePosition),normalW);\nvec3 planarReflectionFresnel=fresnelSchlickEnvironmentGGX(saturate(VdotN),reflectionReflectance0,reflectionReflectance90,1.0);\nreflectionAmount*=planarReflectionFresnel;\n#ifdef REFLECTIONFALLOFF\nfloat reflectionDistanceFalloff=1.0-saturate(length(vPositionW.xyz-vBackgroundCenter)*vReflectionControl.w);\nreflectionDistanceFalloff*=reflectionDistanceFalloff;\nreflectionAmount*=reflectionDistanceFalloff;\n#endif\nfinalColor=mix(finalColor,reflectionColor.rgb,saturate(reflectionAmount));\n#endif\n#ifdef OPACITYFRESNEL\nfloat viewAngleToFloor=dot(normalW,normalize(vEyePosition-vBackgroundCenter));\n\nconst float startAngle=0.1;\nfloat fadeFactor=saturate(viewAngleToFloor/startAngle);\nfinalAlpha*=fadeFactor*fadeFactor;\n#endif\n\n#ifdef SHADOWINUSE\nfinalColor=mix(finalColor*shadowLevel,finalColor,globalShadow);\n#endif\n\nvec4 color=vec4(finalColor,finalAlpha);\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n\n\ncolor.rgb=clamp(color.rgb,0.,30.0);\n#else\n\ncolor=applyImageProcessing(color);\n#endif\n#ifdef PREMULTIPLYALPHA\n\ncolor.rgb*=color.a;\n#endif\n#ifdef NOISE\ncolor.rgb+=dither(vPositionW.xy,0.5);\ncolor=max(color,0.0);\n#endif\ngl_FragColor=color;\n}\n";
Effect.ShadersStore[name$h] = shader$h;

var name$i = 'backgroundVertexDeclaration';
var shader$i = "uniform mat4 view;\nuniform mat4 viewProjection;\nuniform float shadowLevel;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\nuniform mat4 reflectionMatrix;\nuniform vec3 vReflectionMicrosurfaceInfos;\nuniform float fFovMultiplier;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif";
Effect.IncludesShadersStore[name$i] = shader$i;

var name$j = 'backgroundVertexShader';
var shader$j = "precision highp float;\n#include<__decl__backgroundVertex>\n#include<helperFunctions>\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\nvarying vec2 vDiffuseUV;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\nvoid main(void) {\n#ifdef REFLECTIONMAP_SKYBOX\n#ifdef REFLECTIONMAP_SKYBOX_TRANSFORMED\nvPositionUVW=(reflectionMatrix*vec4(position,1.0)).xyz;\n#else\nvPositionUVW=position;\n#endif\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR == 0u) {\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n} else {\ngl_Position=viewProjectionR*finalWorld*vec4(position,1.0);\n}\n#else\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#endif\nvec4 worldPos=finalWorld*vec4(position,1.0);\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normal);\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\n#ifdef EQUIRECTANGULAR_RELFECTION_FOV\nmat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));\nvec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));\nif (fFovMultiplier<=1.0) {\nvDirectionW=normalize(segment);\n} else {\nvDirectionW=normalize(vDirectionW+(vDirectionW-segment));\n}\n#endif\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uv;\n#endif\n#ifdef MAINUV2\nvMainUV2=uv2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n";
Effect.ShadersStore[name$j] = shader$j;

/**
 * Background material defines definition.
 * @hidden Mainly internal Use
 */
var BackgroundMaterialDefines = /** @class */ (function (_super) {
    __extends(BackgroundMaterialDefines, _super);
    /**
     * Constructor of the defines.
     */
    function BackgroundMaterialDefines() {
        var _this = _super.call(this) || this;
        /**
         * True if the diffuse texture is in use.
         */
        _this.DIFFUSE = false;
        /**
         * The direct UV channel to use.
         */
        _this.DIFFUSEDIRECTUV = 0;
        /**
         * True if the diffuse texture is in gamma space.
         */
        _this.GAMMADIFFUSE = false;
        /**
         * True if the diffuse texture has opacity in the alpha channel.
         */
        _this.DIFFUSEHASALPHA = false;
        /**
         * True if you want the material to fade to transparent at grazing angle.
         */
        _this.OPACITYFRESNEL = false;
        /**
         * True if an extra blur needs to be added in the reflection.
         */
        _this.REFLECTIONBLUR = false;
        /**
         * True if you want the material to fade to reflection at grazing angle.
         */
        _this.REFLECTIONFRESNEL = false;
        /**
         * True if you want the material to falloff as far as you move away from the scene center.
         */
        _this.REFLECTIONFALLOFF = false;
        /**
         * False if the current Webgl implementation does not support the texture lod extension.
         */
        _this.TEXTURELODSUPPORT = false;
        /**
         * True to ensure the data are premultiplied.
         */
        _this.PREMULTIPLYALPHA = false;
        /**
         * True if the texture contains cooked RGB values and not gray scaled multipliers.
         */
        _this.USERGBCOLOR = false;
        /**
         * True if highlight and shadow levels have been specified. It can help ensuring the main perceived color
         * stays aligned with the desired configuration.
         */
        _this.USEHIGHLIGHTANDSHADOWCOLORS = false;
        /**
         * True to add noise in order to reduce the banding effect.
         */
        _this.NOISE = false;
        /**
         * is the reflection texture in BGR color scheme?
         * Mainly used to solve a bug in ios10 video tag
         */
        _this.REFLECTIONBGR = false;
        _this.IMAGEPROCESSING = false;
        _this.VIGNETTE = false;
        _this.VIGNETTEBLENDMODEMULTIPLY = false;
        _this.VIGNETTEBLENDMODEOPAQUE = false;
        _this.TONEMAPPING = false;
        _this.TONEMAPPING_ACES = false;
        _this.CONTRAST = false;
        _this.COLORCURVES = false;
        _this.COLORGRADING = false;
        _this.COLORGRADING3D = false;
        _this.SAMPLER3DGREENDEPTH = false;
        _this.SAMPLER3DBGRMAP = false;
        _this.IMAGEPROCESSINGPOSTPROCESS = false;
        _this.EXPOSURE = false;
        _this.MULTIVIEW = false;
        // Reflection.
        _this.REFLECTION = false;
        _this.REFLECTIONMAP_3D = false;
        _this.REFLECTIONMAP_SPHERICAL = false;
        _this.REFLECTIONMAP_PLANAR = false;
        _this.REFLECTIONMAP_CUBIC = false;
        _this.REFLECTIONMAP_PROJECTION = false;
        _this.REFLECTIONMAP_SKYBOX = false;
        _this.REFLECTIONMAP_SKYBOX_TRANSFORMED = false;
        _this.REFLECTIONMAP_EXPLICIT = false;
        _this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        _this.INVERTCUBICMAP = false;
        _this.REFLECTIONMAP_OPPOSITEZ = false;
        _this.LODINREFLECTIONALPHA = false;
        _this.GAMMAREFLECTION = false;
        _this.RGBDREFLECTION = false;
        _this.EQUIRECTANGULAR_RELFECTION_FOV = false;
        // Default BJS.
        _this.MAINUV1 = false;
        _this.MAINUV2 = false;
        _this.UV1 = false;
        _this.UV2 = false;
        _this.CLIPPLANE = false;
        _this.CLIPPLANE2 = false;
        _this.CLIPPLANE3 = false;
        _this.CLIPPLANE4 = false;
        _this.POINTSIZE = false;
        _this.FOG = false;
        _this.NORMAL = false;
        _this.NUM_BONE_INFLUENCERS = 0;
        _this.BonesPerMesh = 0;
        _this.INSTANCES = false;
        _this.SHADOWFLOAT = false;
        _this.rebuild();
        return _this;
    }
    return BackgroundMaterialDefines;
}(MaterialDefines));
/**
 * Background material used to create an efficient environement around your scene.
 */
var BackgroundMaterial = /** @class */ (function (_super) {
    __extends(BackgroundMaterial, _super);
    /**
     * Instantiates a Background Material in the given scene
     * @param name The friendly name of the material
     * @param scene The scene to add the material to
     */
    function BackgroundMaterial(name, scene) {
        var _this = _super.call(this, name, scene) || this;
        /**
         * Key light Color (multiply against the environement texture)
         */
        _this.primaryColor = Color3.White();
        _this._primaryColorShadowLevel = 0;
        _this._primaryColorHighlightLevel = 0;
        /**
         * Reflection Texture used in the material.
         * Should be author in a specific way for the best result (refer to the documentation).
         */
        _this.reflectionTexture = null;
        /**
         * Reflection Texture level of blur.
         *
         * Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the
         * texture twice.
         */
        _this.reflectionBlur = 0;
        /**
         * Diffuse Texture used in the material.
         * Should be author in a specific way for the best result (refer to the documentation).
         */
        _this.diffuseTexture = null;
        _this._shadowLights = null;
        /**
         * Specify the list of lights casting shadow on the material.
         * All scene shadow lights will be included if null.
         */
        _this.shadowLights = null;
        /**
         * Helps adjusting the shadow to a softer level if required.
         * 0 means black shadows and 1 means no shadows.
         */
        _this.shadowLevel = 0;
        /**
         * In case of opacity Fresnel or reflection falloff, this is use as a scene center.
         * It is usually zero but might be interesting to modify according to your setup.
         */
        _this.sceneCenter = Vector3.Zero();
        /**
         * This helps specifying that the material is falling off to the sky box at grazing angle.
         * This helps ensuring a nice transition when the camera goes under the ground.
         */
        _this.opacityFresnel = true;
        /**
         * This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.
         * This helps adding a mirror texture on the ground.
         */
        _this.reflectionFresnel = false;
        /**
         * This helps specifying the falloff radius off the reflection texture from the sceneCenter.
         * This helps adding a nice falloff effect to the reflection if used as a mirror for instance.
         */
        _this.reflectionFalloffDistance = 0.0;
        /**
         * This specifies the weight of the reflection against the background in case of reflection Fresnel.
         */
        _this.reflectionAmount = 1.0;
        /**
         * This specifies the weight of the reflection at grazing angle.
         */
        _this.reflectionReflectance0 = 0.05;
        /**
         * This specifies the weight of the reflection at a perpendicular point of view.
         */
        _this.reflectionReflectance90 = 0.5;
        /**
         * Helps to directly use the maps channels instead of their level.
         */
        _this.useRGBColor = true;
        /**
         * This helps reducing the banding effect that could occur on the background.
         */
        _this.enableNoise = false;
        _this._fovMultiplier = 1.0;
        /**
         * Enable the FOV adjustment feature controlled by fovMultiplier.
         */
        _this.useEquirectangularFOV = false;
        _this._maxSimultaneousLights = 4;
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        _this.maxSimultaneousLights = 4;
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        _this._imageProcessingObserver = null;
        /**
         * Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.
         * Setting this flag to true (not done automatically!) will convert it back to RGB.
         */
        _this.switchToBGR = false;
        // Temp values kept as cache in the material.
        _this._renderTargets = new SmartArray(16);
        _this._reflectionControls = Vector4.Zero();
        _this._white = Color3.White();
        _this._primaryShadowColor = Color3.Black();
        _this._primaryHighlightColor = Color3.Black();
        // Setup the default processing configuration to the scene.
        _this._attachImageProcessingConfiguration(null);
        _this.getRenderTargetTextures = function () {
            _this._renderTargets.reset();
            if (_this._diffuseTexture && _this._diffuseTexture.isRenderTarget) {
                _this._renderTargets.push(_this._diffuseTexture);
            }
            if (_this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {
                _this._renderTargets.push(_this._reflectionTexture);
            }
            return _this._renderTargets;
        };
        return _this;
    }
    Object.defineProperty(BackgroundMaterial.prototype, "_perceptualColor", {
        /**
         * Experimental Internal Use Only.
         *
         * Key light Color in "perceptual value" meaning the color you would like to see on screen.
         * This acts as a helper to set the primary color to a more "human friendly" value.
         * Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the
         * output color as close as possible from the chosen value.
         * (This does not account for contrast color grading and color curves as they are considered post effect and not directly
         * part of lighting setup.)
         */
        get: function () {
            return this.__perceptualColor;
        },
        set: function (value) {
            this.__perceptualColor = value;
            this._computePrimaryColorFromPerceptualColor();
            this._markAllSubMeshesAsLightsDirty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "primaryColorShadowLevel", {
        /**
         * Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.
         * The color opposite to the primary color is used at the level chosen to define what the black area would look.
         */
        get: function () {
            return this._primaryColorShadowLevel;
        },
        set: function (value) {
            this._primaryColorShadowLevel = value;
            this._computePrimaryColors();
            this._markAllSubMeshesAsLightsDirty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "primaryColorHighlightLevel", {
        /**
         * Defines the level of the highliights (highlight area of the reflection map) in order to help scaling the colors.
         * The primary color is used at the level chosen to define what the white area would look.
         */
        get: function () {
            return this._primaryColorHighlightLevel;
        },
        set: function (value) {
            this._primaryColorHighlightLevel = value;
            this._computePrimaryColors();
            this._markAllSubMeshesAsLightsDirty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "reflectionStandardFresnelWeight", {
        /**
         * Sets the reflection reflectance fresnel values according to the default standard
         * empirically know to work well :-)
         */
        set: function (value) {
            var reflectionWeight = value;
            if (reflectionWeight < 0.5) {
                reflectionWeight = reflectionWeight * 2.0;
                this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 * reflectionWeight;
                this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 * reflectionWeight;
            }
            else {
                reflectionWeight = reflectionWeight * 2.0 - 1.0;
                this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 + (1.0 - BackgroundMaterial.StandardReflectance0) * reflectionWeight;
                this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 + (1.0 - BackgroundMaterial.StandardReflectance90) * reflectionWeight;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "fovMultiplier", {
        /**
         * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
         * Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.
         * Recommended to be keep at 1.0 except for special cases.
         */
        get: function () {
            return this._fovMultiplier;
        },
        set: function (value) {
            if (isNaN(value)) {
                value = 1.0;
            }
            this._fovMultiplier = Math.max(0.0, Math.min(2.0, value));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attaches a new image processing configuration to the PBR Material.
     * @param configuration (if null the scene configuration will be use)
     */
    BackgroundMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {
        var _this = this;
        if (configuration === this._imageProcessingConfiguration) {
            return;
        }
        // Detaches observer.
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        // Pick the scene configuration if needed.
        if (!configuration) {
            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
        }
        else {
            this._imageProcessingConfiguration = configuration;
        }
        // Attaches observer.
        if (this._imageProcessingConfiguration) {
            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {
                _this._computePrimaryColorFromPerceptualColor();
                _this._markAllSubMeshesAsImageProcessingDirty();
            });
        }
    };
    Object.defineProperty(BackgroundMaterial.prototype, "imageProcessingConfiguration", {
        /**
         * Gets the image processing configuration used either in this material.
         */
        get: function () {
            return this._imageProcessingConfiguration;
        },
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        set: function (value) {
            this._attachImageProcessingConfiguration(value);
            // Ensure the effect will be rebuilt.
            this._markAllSubMeshesAsTexturesDirty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "cameraColorCurvesEnabled", {
        /**
         * Gets wether the color curves effect is enabled.
         */
        get: function () {
            return this.imageProcessingConfiguration.colorCurvesEnabled;
        },
        /**
         * Sets wether the color curves effect is enabled.
         */
        set: function (value) {
            this.imageProcessingConfiguration.colorCurvesEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "cameraColorGradingEnabled", {
        /**
         * Gets wether the color grading effect is enabled.
         */
        get: function () {
            return this.imageProcessingConfiguration.colorGradingEnabled;
        },
        /**
         * Gets wether the color grading effect is enabled.
         */
        set: function (value) {
            this.imageProcessingConfiguration.colorGradingEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "cameraToneMappingEnabled", {
        /**
         * Gets wether tonemapping is enabled or not.
         */
        get: function () {
            return this._imageProcessingConfiguration.toneMappingEnabled;
        },
        /**
         * Sets wether tonemapping is enabled or not
         */
        set: function (value) {
            this._imageProcessingConfiguration.toneMappingEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "cameraExposure", {
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        get: function () {
            return this._imageProcessingConfiguration.exposure;
        },
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        set: function (value) {
            this._imageProcessingConfiguration.exposure = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "cameraContrast", {
        /**
         * Gets The camera contrast used on this material.
         */
        get: function () {
            return this._imageProcessingConfiguration.contrast;
        },
        /**
         * Sets The camera contrast used on this material.
         */
        set: function (value) {
            this._imageProcessingConfiguration.contrast = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "cameraColorGradingTexture", {
        /**
         * Gets the Color Grading 2D Lookup Texture.
         */
        get: function () {
            return this._imageProcessingConfiguration.colorGradingTexture;
        },
        /**
         * Sets the Color Grading 2D Lookup Texture.
         */
        set: function (value) {
            this.imageProcessingConfiguration.colorGradingTexture = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "cameraColorCurves", {
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        get: function () {
            return this.imageProcessingConfiguration.colorCurves;
        },
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        set: function (value) {
            this.imageProcessingConfiguration.colorCurves = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BackgroundMaterial.prototype, "hasRenderTargetTextures", {
        /**
         * Gets a boolean indicating that current material needs to register RTT
         */
        get: function () {
            if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
                return true;
            }
            if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * The entire material has been created in order to prevent overdraw.
     * @returns false
     */
    BackgroundMaterial.prototype.needAlphaTesting = function () {
        return true;
    };
    /**
     * The entire material has been created in order to prevent overdraw.
     * @returns true if blending is enable
     */
    BackgroundMaterial.prototype.needAlphaBlending = function () {
        return ((this.alpha < 0) || (this._diffuseTexture != null && this._diffuseTexture.hasAlpha));
    };
    /**
     * Checks wether the material is ready to be rendered for a given mesh.
     * @param mesh The mesh to render
     * @param subMesh The submesh to check against
     * @param useInstances Specify wether or not the material is used with instances
     * @returns true if all the dependencies are ready (Textures, Effects...)
     */
    BackgroundMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {
        var _this = this;
        if (useInstances === void 0) { useInstances = false; }
        if (subMesh.effect && this.isFrozen) {
            if (this._wasPreviouslyReady) {
                return true;
            }
        }
        if (!subMesh._materialDefines) {
            subMesh._materialDefines = new BackgroundMaterialDefines();
        }
        var scene = this.getScene();
        var defines = subMesh._materialDefines;
        if (!this.checkReadyOnEveryCall && subMesh.effect) {
            if (defines._renderId === scene.getRenderId()) {
                return true;
            }
        }
        var engine = scene.getEngine();
        // Lights
        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights);
        defines._needNormals = true;
        // Multiview
        MaterialHelper.PrepareDefinesForMultiview(scene, defines);
        // Textures
        if (defines._areTexturesDirty) {
            defines._needUVs = false;
            if (scene.texturesEnabled) {
                if (scene.getEngine().getCaps().textureLOD) {
                    defines.TEXTURELODSUPPORT = true;
                }
                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {
                        return false;
                    }
                    MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
                    defines.DIFFUSEHASALPHA = this._diffuseTexture.hasAlpha;
                    defines.GAMMADIFFUSE = this._diffuseTexture.gammaSpace;
                    defines.OPACITYFRESNEL = this._opacityFresnel;
                }
                else {
                    defines.DIFFUSE = false;
                    defines.DIFFUSEHASALPHA = false;
                    defines.GAMMADIFFUSE = false;
                    defines.OPACITYFRESNEL = false;
                }
                var reflectionTexture = this._reflectionTexture;
                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
                    if (!reflectionTexture.isReadyOrNotBlocking()) {
                        return false;
                    }
                    defines.REFLECTION = true;
                    defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
                    defines.RGBDREFLECTION = reflectionTexture.isRGBD;
                    defines.REFLECTIONBLUR = this._reflectionBlur > 0;
                    defines.REFLECTIONMAP_OPPOSITEZ = this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
                    defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
                    defines.EQUIRECTANGULAR_RELFECTION_FOV = this.useEquirectangularFOV;
                    defines.REFLECTIONBGR = this.switchToBGR;
                    if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {
                        defines.INVERTCUBICMAP = true;
                    }
                    defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
                    switch (reflectionTexture.coordinatesMode) {
                        case Texture.EXPLICIT_MODE:
                            defines.REFLECTIONMAP_EXPLICIT = true;
                            break;
                        case Texture.PLANAR_MODE:
                            defines.REFLECTIONMAP_PLANAR = true;
                            break;
                        case Texture.PROJECTION_MODE:
                            defines.REFLECTIONMAP_PROJECTION = true;
                            break;
                        case Texture.SKYBOX_MODE:
                            defines.REFLECTIONMAP_SKYBOX = true;
                            defines.REFLECTIONMAP_SKYBOX_TRANSFORMED = !reflectionTexture.getReflectionTextureMatrix().isIdentity();
                            break;
                        case Texture.SPHERICAL_MODE:
                            defines.REFLECTIONMAP_SPHERICAL = true;
                            break;
                        case Texture.EQUIRECTANGULAR_MODE:
                            defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
                            break;
                        case Texture.FIXED_EQUIRECTANGULAR_MODE:
                            defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
                            break;
                        case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                            defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
                            break;
                        case Texture.CUBIC_MODE:
                        case Texture.INVCUBIC_MODE:
                        default:
                            defines.REFLECTIONMAP_CUBIC = true;
                            break;
                    }
                    if (this.reflectionFresnel) {
                        defines.REFLECTIONFRESNEL = true;
                        defines.REFLECTIONFALLOFF = this.reflectionFalloffDistance > 0;
                        this._reflectionControls.x = this.reflectionAmount;
                        this._reflectionControls.y = this.reflectionReflectance0;
                        this._reflectionControls.z = this.reflectionReflectance90;
                        this._reflectionControls.w = 1 / this.reflectionFalloffDistance;
                    }
                    else {
                        defines.REFLECTIONFRESNEL = false;
                        defines.REFLECTIONFALLOFF = false;
                    }
                }
                else {
                    defines.REFLECTION = false;
                    defines.REFLECTIONFRESNEL = false;
                    defines.REFLECTIONFALLOFF = false;
                    defines.REFLECTIONBLUR = false;
                    defines.REFLECTIONMAP_3D = false;
                    defines.REFLECTIONMAP_SPHERICAL = false;
                    defines.REFLECTIONMAP_PLANAR = false;
                    defines.REFLECTIONMAP_CUBIC = false;
                    defines.REFLECTIONMAP_PROJECTION = false;
                    defines.REFLECTIONMAP_SKYBOX = false;
                    defines.REFLECTIONMAP_SKYBOX_TRANSFORMED = false;
                    defines.REFLECTIONMAP_EXPLICIT = false;
                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
                    defines.INVERTCUBICMAP = false;
                    defines.REFLECTIONMAP_OPPOSITEZ = false;
                    defines.LODINREFLECTIONALPHA = false;
                    defines.GAMMAREFLECTION = false;
                    defines.RGBDREFLECTION = false;
                }
            }
            defines.PREMULTIPLYALPHA = (this.alphaMode === Constants.ALPHA_PREMULTIPLIED || this.alphaMode === Constants.ALPHA_PREMULTIPLIED_PORTERDUFF);
            defines.USERGBCOLOR = this._useRGBColor;
            defines.NOISE = this._enableNoise;
        }
        if (defines._areLightsDirty) {
            defines.USEHIGHLIGHTANDSHADOWCOLORS = !this._useRGBColor && (this._primaryColorShadowLevel !== 0 || this._primaryColorHighlightLevel !== 0);
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
            if (!this._imageProcessingConfiguration.isReady()) {
                return false;
            }
            this._imageProcessingConfiguration.prepareDefines(defines);
        }
        // Misc.
        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
        // Values that need to be evaluated on every frame
        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances);
        // Attribs
        if (MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true, false)) {
            if (mesh) {
                if (!scene.getEngine().getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
                    mesh.createNormals(true);
                    Logger.Warn("BackgroundMaterial: Normals have been created for the mesh: " + mesh.name);
                }
            }
        }
        // Get correct effect
        if (defines.isDirty) {
            defines.markAsProcessed();
            scene.resetCachedMaterial();
            // Fallbacks
            var fallbacks = new EffectFallbacks();
            if (defines.FOG) {
                fallbacks.addFallback(0, "FOG");
            }
            if (defines.POINTSIZE) {
                fallbacks.addFallback(1, "POINTSIZE");
            }
            if (defines.MULTIVIEW) {
                fallbacks.addFallback(0, "MULTIVIEW");
            }
            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
            if (defines.NUM_BONE_INFLUENCERS > 0) {
                fallbacks.addCPUSkinningFallback(0, mesh);
            }
            //Attributes
            var attribs = [VertexBuffer.PositionKind];
            if (defines.NORMAL) {
                attribs.push(VertexBuffer.NormalKind);
            }
            if (defines.UV1) {
                attribs.push(VertexBuffer.UVKind);
            }
            if (defines.UV2) {
                attribs.push(VertexBuffer.UV2Kind);
            }
            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
            MaterialHelper.PrepareAttributesForInstances(attribs, defines);
            var uniforms = ["world", "view", "viewProjection", "vEyePosition", "vLightsType",
                "vFogInfos", "vFogColor", "pointSize",
                "vClipPlane", "vClipPlane2", "vClipPlane3", "vClipPlane4", "mBones",
                "vPrimaryColor", "vPrimaryColorShadow",
                "vReflectionInfos", "reflectionMatrix", "vReflectionMicrosurfaceInfos", "fFovMultiplier",
                "shadowLevel", "alpha",
                "vBackgroundCenter", "vReflectionControl",
                "vDiffuseInfos", "diffuseMatrix",
            ];
            var samplers = ["diffuseSampler", "reflectionSampler", "reflectionSamplerLow", "reflectionSamplerHigh"];
            var uniformBuffers = ["Material", "Scene"];
            if (ImageProcessingConfiguration) {
                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
            }
            MaterialHelper.PrepareUniformsAndSamplersList({
                uniformsNames: uniforms,
                uniformBuffersNames: uniformBuffers,
                samplers: samplers,
                defines: defines,
                maxSimultaneousLights: this._maxSimultaneousLights
            });
            var onCompiled = function (effect) {
                if (_this.onCompiled) {
                    _this.onCompiled(effect);
                }
                _this.bindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());
            };
            var join = defines.toString();
            subMesh.setEffect(scene.getEngine().createEffect("background", {
                attributes: attribs,
                uniformsNames: uniforms,
                uniformBuffersNames: uniformBuffers,
                samplers: samplers,
                defines: join,
                fallbacks: fallbacks,
                onCompiled: onCompiled,
                onError: this.onError,
                indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights }
            }, engine), defines);
            this.buildUniformLayout();
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
            return false;
        }
        defines._renderId = scene.getRenderId();
        this._wasPreviouslyReady = true;
        return true;
    };
    /**
     * Compute the primary color according to the chosen perceptual color.
     */
    BackgroundMaterial.prototype._computePrimaryColorFromPerceptualColor = function () {
        if (!this.__perceptualColor) {
            return;
        }
        this._primaryColor.copyFrom(this.__perceptualColor);
        // Revert gamma space.
        this._primaryColor.toLinearSpaceToRef(this._primaryColor);
        // Revert image processing configuration.
        if (this._imageProcessingConfiguration) {
            // Revert Exposure.
            this._primaryColor.scaleToRef(1 / this._imageProcessingConfiguration.exposure, this._primaryColor);
        }
        this._computePrimaryColors();
    };
    /**
     * Compute the highlights and shadow colors according to their chosen levels.
     */
    BackgroundMaterial.prototype._computePrimaryColors = function () {
        if (this._primaryColorShadowLevel === 0 && this._primaryColorHighlightLevel === 0) {
            return;
        }
        // Find the highlight color based on the configuration.
        this._primaryColor.scaleToRef(this._primaryColorShadowLevel, this._primaryShadowColor);
        this._primaryColor.subtractToRef(this._primaryShadowColor, this._primaryShadowColor);
        // Find the shadow color based on the configuration.
        this._white.subtractToRef(this._primaryColor, this._primaryHighlightColor);
        this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel, this._primaryHighlightColor);
        this._primaryColor.addToRef(this._primaryHighlightColor, this._primaryHighlightColor);
    };
    /**
     * Build the uniform buffer used in the material.
     */
    BackgroundMaterial.prototype.buildUniformLayout = function () {
        // Order is important !
        this._uniformBuffer.addUniform("vPrimaryColor", 4);
        this._uniformBuffer.addUniform("vPrimaryColorShadow", 4);
        this._uniformBuffer.addUniform("vDiffuseInfos", 2);
        this._uniformBuffer.addUniform("vReflectionInfos", 2);
        this._uniformBuffer.addUniform("diffuseMatrix", 16);
        this._uniformBuffer.addUniform("reflectionMatrix", 16);
        this._uniformBuffer.addUniform("vReflectionMicrosurfaceInfos", 3);
        this._uniformBuffer.addUniform("fFovMultiplier", 1);
        this._uniformBuffer.addUniform("pointSize", 1);
        this._uniformBuffer.addUniform("shadowLevel", 1);
        this._uniformBuffer.addUniform("alpha", 1);
        this._uniformBuffer.addUniform("vBackgroundCenter", 3);
        this._uniformBuffer.addUniform("vReflectionControl", 4);
        this._uniformBuffer.create();
    };
    /**
     * Unbind the material.
     */
    BackgroundMaterial.prototype.unbind = function () {
        if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
            this._uniformBuffer.setTexture("diffuseSampler", null);
        }
        if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
            this._uniformBuffer.setTexture("reflectionSampler", null);
        }
        _super.prototype.unbind.call(this);
    };
    /**
     * Bind only the world matrix to the material.
     * @param world The world matrix to bind.
     */
    BackgroundMaterial.prototype.bindOnlyWorldMatrix = function (world) {
        this._activeEffect.setMatrix("world", world);
    };
    /**
     * Bind the material for a dedicated submeh (every used meshes will be considered opaque).
     * @param world The world matrix to bind.
     * @param subMesh The submesh to bind for.
     */
    BackgroundMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {
        var scene = this.getScene();
        var defines = subMesh._materialDefines;
        if (!defines) {
            return;
        }
        var effect = subMesh.effect;
        if (!effect) {
            return;
        }
        this._activeEffect = effect;
        // Matrices
        this.bindOnlyWorldMatrix(world);
        // Bones
        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);
        var mustRebind = this._mustRebind(scene, effect, mesh.visibility);
        if (mustRebind) {
            this._uniformBuffer.bindToEffect(effect, "Material");
            this.bindViewProjection(effect);
            var reflectionTexture = this._reflectionTexture;
            if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {
                // Texture uniforms
                if (scene.texturesEnabled) {
                    if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
                        this._uniformBuffer.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
                        MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, "diffuse");
                    }
                    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
                        this._uniformBuffer.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
                        this._uniformBuffer.updateFloat2("vReflectionInfos", reflectionTexture.level, this._reflectionBlur);
                        this._uniformBuffer.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
                    }
                }
                if (this.shadowLevel > 0) {
                    this._uniformBuffer.updateFloat("shadowLevel", this.shadowLevel);
                }
                this._uniformBuffer.updateFloat("alpha", this.alpha);
                // Point size
                if (this.pointsCloud) {
                    this._uniformBuffer.updateFloat("pointSize", this.pointSize);
                }
                if (defines.USEHIGHLIGHTANDSHADOWCOLORS) {
                    this._uniformBuffer.updateColor4("vPrimaryColor", this._primaryHighlightColor, 1.0);
                    this._uniformBuffer.updateColor4("vPrimaryColorShadow", this._primaryShadowColor, 1.0);
                }
                else {
                    this._uniformBuffer.updateColor4("vPrimaryColor", this._primaryColor, 1.0);
                }
            }
            this._uniformBuffer.updateFloat("fFovMultiplier", this._fovMultiplier);
            // Textures
            if (scene.texturesEnabled) {
                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
                    this._uniformBuffer.setTexture("diffuseSampler", this._diffuseTexture);
                }
                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
                    if (defines.REFLECTIONBLUR && defines.TEXTURELODSUPPORT) {
                        this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture);
                    }
                    else if (!defines.REFLECTIONBLUR) {
                        this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture);
                    }
                    else {
                        this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
                        this._uniformBuffer.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
                        this._uniformBuffer.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
                    }
                    if (defines.REFLECTIONFRESNEL) {
                        this._uniformBuffer.updateFloat3("vBackgroundCenter", this.sceneCenter.x, this.sceneCenter.y, this.sceneCenter.z);
                        this._uniformBuffer.updateFloat4("vReflectionControl", this._reflectionControls.x, this._reflectionControls.y, this._reflectionControls.z, this._reflectionControls.w);
                    }
                }
            }
            // Clip plane
            MaterialHelper.BindClipPlane(this._activeEffect, scene);
            MaterialHelper.BindEyePosition(effect, scene);
        }
        if (mustRebind || !this.isFrozen) {
            if (scene.lightsEnabled) {
                MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights, false);
            }
            // View
            this.bindView(effect);
            // Fog
            MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);
            // image processing
            if (this._imageProcessingConfiguration) {
                this._imageProcessingConfiguration.bind(this._activeEffect);
            }
        }
        this._uniformBuffer.update();
        this._afterBind(mesh, this._activeEffect);
    };
    /**
     * Dispose the material.
     * @param forceDisposeEffect Force disposal of the associated effect.
     * @param forceDisposeTextures Force disposal of the associated textures.
     */
    BackgroundMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures) {
        if (forceDisposeEffect === void 0) { forceDisposeEffect = false; }
        if (forceDisposeTextures === void 0) { forceDisposeTextures = false; }
        if (forceDisposeTextures) {
            if (this.diffuseTexture) {
                this.diffuseTexture.dispose();
            }
            if (this.reflectionTexture) {
                this.reflectionTexture.dispose();
            }
        }
        this._renderTargets.dispose();
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        _super.prototype.dispose.call(this, forceDisposeEffect);
    };
    /**
     * Clones the material.
     * @param name The cloned name.
     * @returns The cloned material.
     */
    BackgroundMaterial.prototype.clone = function (name) {
        var _this = this;
        return SerializationHelper.Clone(function () { return new BackgroundMaterial(name, _this.getScene()); }, this);
    };
    /**
     * Serializes the current material to its JSON representation.
     * @returns The JSON representation.
     */
    BackgroundMaterial.prototype.serialize = function () {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "BABYLON.BackgroundMaterial";
        return serializationObject;
    };
    /**
     * Gets the class name of the material
     * @returns "BackgroundMaterial"
     */
    BackgroundMaterial.prototype.getClassName = function () {
        return "BackgroundMaterial";
    };
    /**
     * Parse a JSON input to create back a background material.
     * @param source The JSON data to parse
     * @param scene The scene to create the parsed material in
     * @param rootUrl The root url of the assets the material depends upon
     * @returns the instantiated BackgroundMaterial.
     */
    BackgroundMaterial.Parse = function (source, scene, rootUrl) {
        return SerializationHelper.Parse(function () { return new BackgroundMaterial(source.name, scene); }, source, scene, rootUrl);
    };
    /**
     * Standard reflectance value at parallel view angle.
     */
    BackgroundMaterial.StandardReflectance0 = 0.05;
    /**
     * Standard reflectance value at grazing angle.
     */
    BackgroundMaterial.StandardReflectance90 = 0.5;
    __decorate([
        serializeAsColor3()
    ], BackgroundMaterial.prototype, "_primaryColor", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], BackgroundMaterial.prototype, "primaryColor", void 0);
    __decorate([
        serializeAsColor3()
    ], BackgroundMaterial.prototype, "__perceptualColor", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_primaryColorShadowLevel", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_primaryColorHighlightLevel", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], BackgroundMaterial.prototype, "primaryColorHighlightLevel", null);
    __decorate([
        serializeAsTexture()
    ], BackgroundMaterial.prototype, "_reflectionTexture", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionTexture", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_reflectionBlur", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionBlur", void 0);
    __decorate([
        serializeAsTexture()
    ], BackgroundMaterial.prototype, "_diffuseTexture", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "diffuseTexture", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "shadowLights", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_shadowLevel", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "shadowLevel", void 0);
    __decorate([
        serializeAsVector3()
    ], BackgroundMaterial.prototype, "_sceneCenter", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "sceneCenter", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_opacityFresnel", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "opacityFresnel", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_reflectionFresnel", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionFresnel", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_reflectionFalloffDistance", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionFalloffDistance", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_reflectionAmount", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionAmount", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_reflectionReflectance0", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionReflectance0", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_reflectionReflectance90", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionReflectance90", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_useRGBColor", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "useRGBColor", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_enableNoise", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "enableNoise", void 0);
    __decorate([
        serialize()
    ], BackgroundMaterial.prototype, "_maxSimultaneousLights", void 0);
    __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
        serializeAsImageProcessingConfiguration()
    ], BackgroundMaterial.prototype, "_imageProcessingConfiguration", void 0);
    return BackgroundMaterial;
}(PushMaterial));
_TypeStore.RegisteredTypes["BABYLON.BackgroundMaterial"] = BackgroundMaterial;

/**
 * The Environment helper class can be used to add a fully featuread none expensive background to your scene.
 * It includes by default a skybox and a ground relying on the BackgroundMaterial.
 * It also helps with the default setup of your imageProcessing configuration.
 */
var EnvironmentHelper = /** @class */ (function () {
    /**
     * constructor
     * @param options Defines the options we want to customize the helper
     * @param scene The scene to add the material to
     */
    function EnvironmentHelper(options, scene) {
        var _this = this;
        this._errorHandler = function (message, exception) {
            _this.onErrorObservable.notifyObservers({ message: message, exception: exception });
        };
        this._options = __assign({}, EnvironmentHelper._getDefaultOptions(), options);
        this._scene = scene;
        this.onErrorObservable = new Observable();
        this._setupBackground();
        this._setupImageProcessing();
    }
    /**
     * Creates the default options for the helper.
     */
    EnvironmentHelper._getDefaultOptions = function () {
        return {
            createGround: true,
            groundSize: 15,
            groundTexture: this._groundTextureCDNUrl,
            groundColor: new Color3(0.2, 0.2, 0.3).toLinearSpace().scale(3),
            groundOpacity: 0.9,
            enableGroundShadow: true,
            groundShadowLevel: 0.5,
            enableGroundMirror: false,
            groundMirrorSizeRatio: 0.3,
            groundMirrorBlurKernel: 64,
            groundMirrorAmount: 1,
            groundMirrorFresnelWeight: 1,
            groundMirrorFallOffDistance: 0,
            groundMirrorTextureType: Constants.TEXTURETYPE_UNSIGNED_INT,
            groundYBias: 0.00001,
            createSkybox: true,
            skyboxSize: 20,
            skyboxTexture: this._skyboxTextureCDNUrl,
            skyboxColor: new Color3(0.2, 0.2, 0.3).toLinearSpace().scale(3),
            backgroundYRotation: 0,
            sizeAuto: true,
            rootPosition: Vector3.Zero(),
            setupImageProcessing: true,
            environmentTexture: this._environmentTextureCDNUrl,
            cameraExposure: 0.8,
            cameraContrast: 1.2,
            toneMappingEnabled: true,
        };
    };
    Object.defineProperty(EnvironmentHelper.prototype, "rootMesh", {
        /**
         * Gets the root mesh created by the helper.
         */
        get: function () {
            return this._rootMesh;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnvironmentHelper.prototype, "skybox", {
        /**
         * Gets the skybox created by the helper.
         */
        get: function () {
            return this._skybox;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnvironmentHelper.prototype, "skyboxTexture", {
        /**
         * Gets the skybox texture created by the helper.
         */
        get: function () {
            return this._skyboxTexture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnvironmentHelper.prototype, "skyboxMaterial", {
        /**
         * Gets the skybox material created by the helper.
         */
        get: function () {
            return this._skyboxMaterial;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnvironmentHelper.prototype, "ground", {
        /**
         * Gets the ground mesh created by the helper.
         */
        get: function () {
            return this._ground;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnvironmentHelper.prototype, "groundTexture", {
        /**
         * Gets the ground texture created by the helper.
         */
        get: function () {
            return this._groundTexture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnvironmentHelper.prototype, "groundMirror", {
        /**
         * Gets the ground mirror created by the helper.
         */
        get: function () {
            return this._groundMirror;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnvironmentHelper.prototype, "groundMirrorRenderList", {
        /**
         * Gets the ground mirror render list to helps pushing the meshes
         * you wish in the ground reflection.
         */
        get: function () {
            if (this._groundMirror) {
                return this._groundMirror.renderList;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnvironmentHelper.prototype, "groundMaterial", {
        /**
         * Gets the ground material created by the helper.
         */
        get: function () {
            return this._groundMaterial;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the background according to the new options
     * @param options
     */
    EnvironmentHelper.prototype.updateOptions = function (options) {
        var newOptions = __assign({}, this._options, options);
        if (this._ground && !newOptions.createGround) {
            this._ground.dispose();
            this._ground = null;
        }
        if (this._groundMaterial && !newOptions.createGround) {
            this._groundMaterial.dispose();
            this._groundMaterial = null;
        }
        if (this._groundTexture) {
            if (this._options.groundTexture != newOptions.groundTexture) {
                this._groundTexture.dispose();
                this._groundTexture = null;
            }
        }
        if (this._skybox && !newOptions.createSkybox) {
            this._skybox.dispose();
            this._skybox = null;
        }
        if (this._skyboxMaterial && !newOptions.createSkybox) {
            this._skyboxMaterial.dispose();
            this._skyboxMaterial = null;
        }
        if (this._skyboxTexture) {
            if (this._options.skyboxTexture != newOptions.skyboxTexture) {
                this._skyboxTexture.dispose();
                this._skyboxTexture = null;
            }
        }
        if (this._groundMirror && !newOptions.enableGroundMirror) {
            this._groundMirror.dispose();
            this._groundMirror = null;
        }
        if (this._scene.environmentTexture) {
            if (this._options.environmentTexture != newOptions.environmentTexture) {
                this._scene.environmentTexture.dispose();
            }
        }
        this._options = newOptions;
        this._setupBackground();
        this._setupImageProcessing();
    };
    /**
     * Sets the primary color of all the available elements.
     * @param color the main color to affect to the ground and the background
     */
    EnvironmentHelper.prototype.setMainColor = function (color) {
        if (this.groundMaterial) {
            this.groundMaterial.primaryColor = color;
        }
        if (this.skyboxMaterial) {
            this.skyboxMaterial.primaryColor = color;
        }
        if (this.groundMirror) {
            this.groundMirror.clearColor = new Color4(color.r, color.g, color.b, 1.0);
        }
    };
    /**
     * Setup the image processing according to the specified options.
     */
    EnvironmentHelper.prototype._setupImageProcessing = function () {
        if (this._options.setupImageProcessing) {
            this._scene.imageProcessingConfiguration.contrast = this._options.cameraContrast;
            this._scene.imageProcessingConfiguration.exposure = this._options.cameraExposure;
            this._scene.imageProcessingConfiguration.toneMappingEnabled = this._options.toneMappingEnabled;
            this._setupEnvironmentTexture();
        }
    };
    /**
     * Setup the environment texture according to the specified options.
     */
    EnvironmentHelper.prototype._setupEnvironmentTexture = function () {
        if (this._scene.environmentTexture) {
            return;
        }
        if (this._options.environmentTexture instanceof BaseTexture) {
            this._scene.environmentTexture = this._options.environmentTexture;
            return;
        }
        var environmentTexture = CubeTexture.CreateFromPrefilteredData(this._options.environmentTexture, this._scene);
        this._scene.environmentTexture = environmentTexture;
    };
    /**
     * Setup the background according to the specified options.
     */
    EnvironmentHelper.prototype._setupBackground = function () {
        if (!this._rootMesh) {
            this._rootMesh = new Mesh("BackgroundHelper", this._scene);
        }
        this._rootMesh.rotation.y = this._options.backgroundYRotation;
        var sceneSize = this._getSceneSize();
        if (this._options.createGround) {
            this._setupGround(sceneSize);
            this._setupGroundMaterial();
            this._setupGroundDiffuseTexture();
            if (this._options.enableGroundMirror) {
                this._setupGroundMirrorTexture(sceneSize);
            }
            this._setupMirrorInGroundMaterial();
        }
        if (this._options.createSkybox) {
            this._setupSkybox(sceneSize);
            this._setupSkyboxMaterial();
            this._setupSkyboxReflectionTexture();
        }
        this._rootMesh.position.x = sceneSize.rootPosition.x;
        this._rootMesh.position.z = sceneSize.rootPosition.z;
        this._rootMesh.position.y = sceneSize.rootPosition.y;
    };
    /**
     * Get the scene sizes according to the setup.
     */
    EnvironmentHelper.prototype._getSceneSize = function () {
        var _this = this;
        var groundSize = this._options.groundSize;
        var skyboxSize = this._options.skyboxSize;
        var rootPosition = this._options.rootPosition;
        if (!this._scene.meshes || this._scene.meshes.length === 1) { // 1 only means the root of the helper.
            return { groundSize: groundSize, skyboxSize: skyboxSize, rootPosition: rootPosition };
        }
        var sceneExtends = this._scene.getWorldExtends(function (mesh) {
            return (mesh !== _this._ground && mesh !== _this._rootMesh && mesh !== _this._skybox);
        });
        var sceneDiagonal = sceneExtends.max.subtract(sceneExtends.min);
        if (this._options.sizeAuto) {
            if (this._scene.activeCamera instanceof ArcRotateCamera &&
                this._scene.activeCamera.upperRadiusLimit) {
                groundSize = this._scene.activeCamera.upperRadiusLimit * 2;
                skyboxSize = groundSize;
            }
            var sceneDiagonalLenght = sceneDiagonal.length();
            if (sceneDiagonalLenght > groundSize) {
                groundSize = sceneDiagonalLenght * 2;
                skyboxSize = groundSize;
            }
            // 10 % bigger.
            groundSize *= 1.1;
            skyboxSize *= 1.5;
            rootPosition = sceneExtends.min.add(sceneDiagonal.scale(0.5));
            rootPosition.y = sceneExtends.min.y - this._options.groundYBias;
        }
        return { groundSize: groundSize, skyboxSize: skyboxSize, rootPosition: rootPosition };
    };
    /**
     * Setup the ground according to the specified options.
     */
    EnvironmentHelper.prototype._setupGround = function (sceneSize) {
        var _this = this;
        if (!this._ground || this._ground.isDisposed()) {
            this._ground = Mesh.CreatePlane("BackgroundPlane", sceneSize.groundSize, this._scene);
            this._ground.rotation.x = Math.PI / 2; // Face up by default.
            this._ground.parent = this._rootMesh;
            this._ground.onDisposeObservable.add(function () { _this._ground = null; });
        }
        this._ground.receiveShadows = this._options.enableGroundShadow;
    };
    /**
     * Setup the ground material according to the specified options.
     */
    EnvironmentHelper.prototype._setupGroundMaterial = function () {
        if (!this._groundMaterial) {
            this._groundMaterial = new BackgroundMaterial("BackgroundPlaneMaterial", this._scene);
        }
        this._groundMaterial.alpha = this._options.groundOpacity;
        this._groundMaterial.alphaMode = Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;
        this._groundMaterial.shadowLevel = this._options.groundShadowLevel;
        this._groundMaterial.primaryColor = this._options.groundColor;
        this._groundMaterial.useRGBColor = false;
        this._groundMaterial.enableNoise = true;
        if (this._ground) {
            this._ground.material = this._groundMaterial;
        }
    };
    /**
     * Setup the ground diffuse texture according to the specified options.
     */
    EnvironmentHelper.prototype._setupGroundDiffuseTexture = function () {
        if (!this._groundMaterial) {
            return;
        }
        if (this._groundTexture) {
            return;
        }
        if (this._options.groundTexture instanceof BaseTexture) {
            this._groundMaterial.diffuseTexture = this._options.groundTexture;
            return;
        }
        var diffuseTexture = new Texture(this._options.groundTexture, this._scene, undefined, undefined, undefined, undefined, this._errorHandler);
        diffuseTexture.gammaSpace = false;
        diffuseTexture.hasAlpha = true;
        this._groundMaterial.diffuseTexture = diffuseTexture;
    };
    /**
     * Setup the ground mirror texture according to the specified options.
     */
    EnvironmentHelper.prototype._setupGroundMirrorTexture = function (sceneSize) {
        var wrapping = Texture.CLAMP_ADDRESSMODE;
        if (!this._groundMirror) {
            this._groundMirror = new MirrorTexture("BackgroundPlaneMirrorTexture", { ratio: this._options.groundMirrorSizeRatio }, this._scene, false, this._options.groundMirrorTextureType, Texture.BILINEAR_SAMPLINGMODE, true);
            this._groundMirror.mirrorPlane = new Plane$1(0, -1, 0, sceneSize.rootPosition.y);
            this._groundMirror.anisotropicFilteringLevel = 1;
            this._groundMirror.wrapU = wrapping;
            this._groundMirror.wrapV = wrapping;
            this._groundMirror.gammaSpace = false;
            if (this._groundMirror.renderList) {
                for (var i = 0; i < this._scene.meshes.length; i++) {
                    var mesh = this._scene.meshes[i];
                    if (mesh !== this._ground &&
                        mesh !== this._skybox &&
                        mesh !== this._rootMesh) {
                        this._groundMirror.renderList.push(mesh);
                    }
                }
            }
        }
        this._groundMirror.clearColor = new Color4(this._options.groundColor.r, this._options.groundColor.g, this._options.groundColor.b, 1);
        this._groundMirror.adaptiveBlurKernel = this._options.groundMirrorBlurKernel;
    };
    /**
     * Setup the ground to receive the mirror texture.
     */
    EnvironmentHelper.prototype._setupMirrorInGroundMaterial = function () {
        if (this._groundMaterial) {
            this._groundMaterial.reflectionTexture = this._groundMirror;
            this._groundMaterial.reflectionFresnel = true;
            this._groundMaterial.reflectionAmount = this._options.groundMirrorAmount;
            this._groundMaterial.reflectionStandardFresnelWeight = this._options.groundMirrorFresnelWeight;
            this._groundMaterial.reflectionFalloffDistance = this._options.groundMirrorFallOffDistance;
        }
    };
    /**
     * Setup the skybox according to the specified options.
     */
    EnvironmentHelper.prototype._setupSkybox = function (sceneSize) {
        var _this = this;
        if (!this._skybox || this._skybox.isDisposed()) {
            this._skybox = Mesh.CreateBox("BackgroundSkybox", sceneSize.skyboxSize, this._scene, undefined, Mesh.BACKSIDE);
            this._skybox.onDisposeObservable.add(function () { _this._skybox = null; });
        }
        this._skybox.parent = this._rootMesh;
    };
    /**
     * Setup the skybox material according to the specified options.
     */
    EnvironmentHelper.prototype._setupSkyboxMaterial = function () {
        if (!this._skybox) {
            return;
        }
        if (!this._skyboxMaterial) {
            this._skyboxMaterial = new BackgroundMaterial("BackgroundSkyboxMaterial", this._scene);
        }
        this._skyboxMaterial.useRGBColor = false;
        this._skyboxMaterial.primaryColor = this._options.skyboxColor;
        this._skyboxMaterial.enableNoise = true;
        this._skybox.material = this._skyboxMaterial;
    };
    /**
     * Setup the skybox reflection texture according to the specified options.
     */
    EnvironmentHelper.prototype._setupSkyboxReflectionTexture = function () {
        if (!this._skyboxMaterial) {
            return;
        }
        if (this._skyboxTexture) {
            return;
        }
        if (this._options.skyboxTexture instanceof BaseTexture) {
            this._skyboxMaterial.reflectionTexture = this._options.skyboxTexture;
            return;
        }
        this._skyboxTexture = new CubeTexture(this._options.skyboxTexture, this._scene, undefined, undefined, undefined, undefined, this._errorHandler);
        this._skyboxTexture.coordinatesMode = Texture.SKYBOX_MODE;
        this._skyboxTexture.gammaSpace = false;
        this._skyboxMaterial.reflectionTexture = this._skyboxTexture;
    };
    /**
     * Dispose all the elements created by the Helper.
     */
    EnvironmentHelper.prototype.dispose = function () {
        if (this._groundMaterial) {
            this._groundMaterial.dispose(true, true);
        }
        if (this._skyboxMaterial) {
            this._skyboxMaterial.dispose(true, true);
        }
        this._rootMesh.dispose(false);
    };
    /**
     * Default ground texture URL.
     */
    EnvironmentHelper._groundTextureCDNUrl = "https://assets.babylonjs.com/environments/backgroundGround.png";
    /**
     * Default skybox texture URL.
     */
    EnvironmentHelper._skyboxTextureCDNUrl = "https://assets.babylonjs.com/environments/backgroundSkybox.dds";
    /**
     * Default environment texture URL.
     */
    EnvironmentHelper._environmentTextureCDNUrl = "https://assets.babylonjs.com/environments/environmentSpecular.env";
    return EnvironmentHelper;
}());

/**
 * Display a 360 degree photo on an approximately spherical surface, useful for VR applications or skyboxes.
 * As a subclass of TransformNode, this allow parenting to the camera with different locations in the scene.
 * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.
 * Potential additions to this helper include zoom and and non-infinite distance rendering effects.
 */
var PhotoDome = /** @class */ (function (_super) {
    __extends(PhotoDome, _super);
    /**
     * Create an instance of this class and pass through the parameters to the relevant classes, Texture, StandardMaterial, and Mesh.
     * @param name Element's name, child elements will append suffixes for their own names.
     * @param urlsOfPhoto defines the url of the photo to display
     * @param options defines an object containing optional or exposed sub element properties
     * @param onError defines a callback called when an error occured while loading the texture
     */
    function PhotoDome(name, urlOfPhoto, options, scene, onError) {
        if (onError === void 0) { onError = null; }
        var _this = _super.call(this, name, scene) || this;
        _this._useDirectMapping = false;
        /**
         * Observable raised when an error occured while loading the 360 image
         */
        _this.onLoadErrorObservable = new Observable();
        // set defaults and manage values
        name = name || "photoDome";
        options.resolution = (Math.abs(options.resolution) | 0) || 32;
        options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);
        if (options.useDirectMapping === undefined) {
            _this._useDirectMapping = true;
        }
        else {
            _this._useDirectMapping = options.useDirectMapping;
        }
        if (options.faceForward === undefined) {
            options.faceForward = true;
        }
        _this._setReady(false);
        // create
        var material = _this._material = new BackgroundMaterial(name + "_material", scene);
        _this._mesh = Mesh.CreateSphere(name + "_mesh", options.resolution, options.size, scene, false, Mesh.BACKSIDE);
        // configure material
        material.opacityFresnel = false;
        material.useEquirectangularFOV = true;
        material.fovMultiplier = 1.0;
        _this.photoTexture = new Texture(urlOfPhoto, scene, true, !_this._useDirectMapping, undefined, undefined, function (message, exception) {
            _this.onLoadErrorObservable.notifyObservers(message || "Unknown error occured");
            if (onError) {
                onError(message, exception);
            }
        });
        _this.photoTexture.onLoadObservable.addOnce(function () {
            _this._setReady(true);
        });
        // configure mesh
        _this._mesh.material = material;
        _this._mesh.parent = _this;
        // Initial rotation
        if (options.faceForward && scene.activeCamera) {
            var camera = scene.activeCamera;
            var forward = Vector3.Forward();
            var direction = Vector3.TransformNormal(forward, camera.getViewMatrix());
            direction.normalize();
            _this.rotation.y = Math.acos(Vector3.Dot(forward, direction));
        }
        return _this;
    }
    Object.defineProperty(PhotoDome.prototype, "photoTexture", {
        /**
         * Gets or sets the texture being displayed on the sphere
         */
        get: function () {
            return this._photoTexture;
        },
        set: function (value) {
            if (this._photoTexture === value) {
                return;
            }
            this._photoTexture = value;
            if (this._useDirectMapping) {
                this._photoTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
                this._photoTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
                this._material.diffuseTexture = this._photoTexture;
            }
            else {
                this._photoTexture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation
                this._photoTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
                this._material.reflectionTexture = this._photoTexture;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhotoDome.prototype, "fovMultiplier", {
        /**
         * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
         * Also see the options.resolution property.
         */
        get: function () {
            return this._material.fovMultiplier;
        },
        set: function (value) {
            this._material.fovMultiplier = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Releases resources associated with this node.
     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
     */
    PhotoDome.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {
        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }
        this._photoTexture.dispose();
        this._mesh.dispose();
        this._material.dispose();
        this.onLoadErrorObservable.clear();
        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
    };
    return PhotoDome;
}(TransformNode));

// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html
// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
var DDS_MAGIC = 0x20534444;
var 
//DDSD_CAPS = 0x1,
//DDSD_HEIGHT = 0x2,
//DDSD_WIDTH = 0x4,
//DDSD_PITCH = 0x8,
//DDSD_PIXELFORMAT = 0x1000,
DDSD_MIPMAPCOUNT = 0x20000;
//DDSD_LINEARSIZE = 0x80000,
//DDSD_DEPTH = 0x800000;
// var DDSCAPS_COMPLEX = 0x8,
//     DDSCAPS_MIPMAP = 0x400000,
//     DDSCAPS_TEXTURE = 0x1000;
var DDSCAPS2_CUBEMAP = 0x200;
// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
// DDSCAPS2_VOLUME = 0x200000;
var 
//DDPF_ALPHAPIXELS = 0x1,
//DDPF_ALPHA = 0x2,
DDPF_FOURCC = 0x4, DDPF_RGB = 0x40, 
//DDPF_YUV = 0x200,
DDPF_LUMINANCE = 0x20000;
function FourCCToInt32(value) {
    return value.charCodeAt(0) +
        (value.charCodeAt(1) << 8) +
        (value.charCodeAt(2) << 16) +
        (value.charCodeAt(3) << 24);
}
function Int32ToFourCC(value) {
    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);
}
var FOURCC_DXT1 = FourCCToInt32("DXT1");
var FOURCC_DXT3 = FourCCToInt32("DXT3");
var FOURCC_DXT5 = FourCCToInt32("DXT5");
var FOURCC_DX10 = FourCCToInt32("DX10");
var FOURCC_D3DFMT_R16G16B16A16F = 113;
var FOURCC_D3DFMT_R32G32B32A32F = 116;
var DXGI_FORMAT_R16G16B16A16_FLOAT = 10;
var DXGI_FORMAT_B8G8R8X8_UNORM = 88;
var headerLengthInt = 31; // The header length in 32 bit ints
// Offsets into the header array
var off_magic = 0;
var off_size = 1;
var off_flags = 2;
var off_height = 3;
var off_width = 4;
var off_mipmapCount = 7;
var off_pfFlags = 20;
var off_pfFourCC = 21;
var off_RGBbpp = 22;
var off_RMask = 23;
var off_GMask = 24;
var off_BMask = 25;
var off_AMask = 26;
// var off_caps1 = 27;
var off_caps2 = 28;
// var off_caps3 = 29;
// var off_caps4 = 30;
var off_dxgiFormat = 32;
/**
 * Class used to provide DDS decompression tools
 */
var DDSTools = /** @class */ (function () {
    function DDSTools() {
    }
    /**
     * Gets DDS information from an array buffer
     * @param arrayBuffer defines the array buffer to read data from
     * @returns the DDS information
     */
    DDSTools.GetDDSInfo = function (arrayBuffer) {
        var header = new Int32Array(arrayBuffer, 0, headerLengthInt);
        var extendedHeader = new Int32Array(arrayBuffer, 0, headerLengthInt + 4);
        var mipmapCount = 1;
        if (header[off_flags] & DDSD_MIPMAPCOUNT) {
            mipmapCount = Math.max(1, header[off_mipmapCount]);
        }
        var fourCC = header[off_pfFourCC];
        var dxgiFormat = (fourCC === FOURCC_DX10) ? extendedHeader[off_dxgiFormat] : 0;
        var textureType = Constants.TEXTURETYPE_UNSIGNED_INT;
        switch (fourCC) {
            case FOURCC_D3DFMT_R16G16B16A16F:
                textureType = Constants.TEXTURETYPE_HALF_FLOAT;
                break;
            case FOURCC_D3DFMT_R32G32B32A32F:
                textureType = Constants.TEXTURETYPE_FLOAT;
                break;
            case FOURCC_DX10:
                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {
                    textureType = Constants.TEXTURETYPE_HALF_FLOAT;
                    break;
                }
        }
        return {
            width: header[off_width],
            height: header[off_height],
            mipmapCount: mipmapCount,
            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,
            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,
            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,
            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,
            isCompressed: (fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5),
            dxgiFormat: dxgiFormat,
            textureType: textureType
        };
    };
    DDSTools._ToHalfFloat = function (value) {
        if (!DDSTools._FloatView) {
            DDSTools._FloatView = new Float32Array(1);
            DDSTools._Int32View = new Int32Array(DDSTools._FloatView.buffer);
        }
        DDSTools._FloatView[0] = value;
        var x = DDSTools._Int32View[0];
        var bits = (x >> 16) & 0x8000; /* Get the sign */
        var m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
        var e = (x >> 23) & 0xff; /* Using int is faster here */
        /* If zero, or denormal, or exponent underflows too much for a denormal
        * half, return signed zero. */
        if (e < 103) {
            return bits;
        }
        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
        if (e > 142) {
            bits |= 0x7c00;
            /* If exponent was 0xff and one mantissa bit was set, it means NaN,
            * not Inf, so make sure we set one mantissa bit too. */
            bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);
            return bits;
        }
        /* If exponent underflows but not too much, return a denormal */
        if (e < 113) {
            m |= 0x0800;
            /* Extra rounding may overflow and set mantissa to 0 and exponent
            * to 1, which is OK. */
            bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
            return bits;
        }
        bits |= ((e - 112) << 10) | (m >> 1);
        bits += m & 1;
        return bits;
    };
    DDSTools._FromHalfFloat = function (value) {
        var s = (value & 0x8000) >> 15;
        var e = (value & 0x7C00) >> 10;
        var f = value & 0x03FF;
        if (e === 0) {
            return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
        }
        else if (e == 0x1F) {
            return f ? NaN : ((s ? -1 : 1) * Infinity);
        }
        return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + (f / Math.pow(2, 10)));
    };
    DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {
        var destArray = new Float32Array(dataLength);
        var srcData = new Uint16Array(arrayBuffer, dataOffset);
        var index = 0;
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var srcPos = (x + y * width) * 4;
                destArray[index] = DDSTools._FromHalfFloat(srcData[srcPos]);
                destArray[index + 1] = DDSTools._FromHalfFloat(srcData[srcPos + 1]);
                destArray[index + 2] = DDSTools._FromHalfFloat(srcData[srcPos + 2]);
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = lod;
                }
                else {
                    destArray[index + 3] = DDSTools._FromHalfFloat(srcData[srcPos + 3]);
                }
                index += 4;
            }
        }
        return destArray;
    };
    DDSTools._GetHalfFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {
        if (DDSTools.StoreLODInAlphaChannel) {
            var destArray = new Uint16Array(dataLength);
            var srcData = new Uint16Array(arrayBuffer, dataOffset);
            var index = 0;
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var srcPos = (x + y * width) * 4;
                    destArray[index] = srcData[srcPos];
                    destArray[index + 1] = srcData[srcPos + 1];
                    destArray[index + 2] = srcData[srcPos + 2];
                    destArray[index + 3] = DDSTools._ToHalfFloat(lod);
                    index += 4;
                }
            }
            return destArray;
        }
        return new Uint16Array(arrayBuffer, dataOffset, dataLength);
    };
    DDSTools._GetFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {
        if (DDSTools.StoreLODInAlphaChannel) {
            var destArray = new Float32Array(dataLength);
            var srcData = new Float32Array(arrayBuffer, dataOffset);
            var index = 0;
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var srcPos = (x + y * width) * 4;
                    destArray[index] = srcData[srcPos];
                    destArray[index + 1] = srcData[srcPos + 1];
                    destArray[index + 2] = srcData[srcPos + 2];
                    destArray[index + 3] = lod;
                    index += 4;
                }
            }
            return destArray;
        }
        return new Float32Array(arrayBuffer, dataOffset, dataLength);
    };
    DDSTools._GetFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {
        var destArray = new Uint8Array(dataLength);
        var srcData = new Float32Array(arrayBuffer, dataOffset);
        var index = 0;
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var srcPos = (x + y * width) * 4;
                destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;
                destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;
                destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = lod;
                }
                else {
                    destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;
                }
                index += 4;
            }
        }
        return destArray;
    };
    DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {
        var destArray = new Uint8Array(dataLength);
        var srcData = new Uint16Array(arrayBuffer, dataOffset);
        var index = 0;
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var srcPos = (x + y * width) * 4;
                destArray[index] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos])) * 255;
                destArray[index + 1] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 1])) * 255;
                destArray[index + 2] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 2])) * 255;
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = lod;
                }
                else {
                    destArray[index + 3] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 3])) * 255;
                }
                index += 4;
            }
        }
        return destArray;
    };
    DDSTools._GetRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {
        var byteArray = new Uint8Array(dataLength);
        var srcData = new Uint8Array(arrayBuffer, dataOffset);
        var index = 0;
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var srcPos = (x + y * width) * 4;
                byteArray[index] = srcData[srcPos + rOffset];
                byteArray[index + 1] = srcData[srcPos + gOffset];
                byteArray[index + 2] = srcData[srcPos + bOffset];
                byteArray[index + 3] = srcData[srcPos + aOffset];
                index += 4;
            }
        }
        return byteArray;
    };
    DDSTools._ExtractLongWordOrder = function (value) {
        if (value === 0 || value === 255 || value === -16777216) {
            return 0;
        }
        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);
    };
    DDSTools._GetRGBArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {
        var byteArray = new Uint8Array(dataLength);
        var srcData = new Uint8Array(arrayBuffer, dataOffset);
        var index = 0;
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var srcPos = (x + y * width) * 3;
                byteArray[index] = srcData[srcPos + rOffset];
                byteArray[index + 1] = srcData[srcPos + gOffset];
                byteArray[index + 2] = srcData[srcPos + bOffset];
                index += 3;
            }
        }
        return byteArray;
    };
    DDSTools._GetLuminanceArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer) {
        var byteArray = new Uint8Array(dataLength);
        var srcData = new Uint8Array(arrayBuffer, dataOffset);
        var index = 0;
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var srcPos = (x + y * width);
                byteArray[index] = srcData[srcPos];
                index++;
            }
        }
        return byteArray;
    };
    /**
     * Uploads DDS Levels to a Babylon Texture
     * @hidden
     */
    DDSTools.UploadDDSLevels = function (engine, texture, arrayBuffer, info, loadMipmaps, faces, lodIndex, currentFace) {
        if (lodIndex === void 0) { lodIndex = -1; }
        var sphericalPolynomialFaces = null;
        if (info.sphericalPolynomial) {
            sphericalPolynomialFaces = new Array();
        }
        var ext = engine.getCaps().s3tc;
        var header = new Int32Array(arrayBuffer, 0, headerLengthInt);
        var fourCC, width, height, dataLength = 0, dataOffset;
        var byteArray, mipmapCount, mip;
        var internalCompressedFormat = 0;
        var blockBytes = 1;
        if (header[off_magic] !== DDS_MAGIC) {
            Logger.Error("Invalid magic number in DDS header");
            return;
        }
        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {
            Logger.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");
            return;
        }
        if (info.isCompressed && !ext) {
            Logger.Error("Compressed textures are not supported on this platform.");
            return;
        }
        var bpp = header[off_RGBbpp];
        dataOffset = header[off_size] + 4;
        var computeFormats = false;
        if (info.isFourCC) {
            fourCC = header[off_pfFourCC];
            switch (fourCC) {
                case FOURCC_DXT1:
                    blockBytes = 8;
                    internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    break;
                case FOURCC_DXT3:
                    blockBytes = 16;
                    internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    break;
                case FOURCC_DXT5:
                    blockBytes = 16;
                    internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    break;
                case FOURCC_D3DFMT_R16G16B16A16F:
                    computeFormats = true;
                    break;
                case FOURCC_D3DFMT_R32G32B32A32F:
                    computeFormats = true;
                    break;
                case FOURCC_DX10:
                    // There is an additionnal header so dataOffset need to be changed
                    dataOffset += 5 * 4; // 5 uints
                    var supported = false;
                    switch (info.dxgiFormat) {
                        case DXGI_FORMAT_R16G16B16A16_FLOAT:
                            computeFormats = true;
                            supported = true;
                            break;
                        case DXGI_FORMAT_B8G8R8X8_UNORM:
                            info.isRGB = true;
                            info.isFourCC = false;
                            bpp = 32;
                            supported = true;
                            break;
                    }
                    if (supported) {
                        break;
                    }
                default:
                    console.error("Unsupported FourCC code:", Int32ToFourCC(fourCC));
                    return;
            }
        }
        var rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);
        var gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);
        var bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);
        var aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);
        if (computeFormats) {
            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);
        }
        mipmapCount = 1;
        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
            mipmapCount = Math.max(1, header[off_mipmapCount]);
        }
        var startFace = currentFace || 0;
        for (var face = startFace; face < faces; face++) {
            width = header[off_width];
            height = header[off_height];
            for (mip = 0; mip < mipmapCount; ++mip) {
                if (lodIndex === -1 || lodIndex === mip) {
                    // In case of fixed LOD, if the lod has just been uploaded, early exit.
                    var i = (lodIndex === -1) ? mip : 0;
                    if (!info.isCompressed && info.isFourCC) {
                        texture.format = Constants.TEXTUREFORMAT_RGBA;
                        dataLength = width * height * 4;
                        var floatArray = null;
                        if (engine._badOS || engine._badDesktopOS || (!engine.getCaps().textureHalfFloat && !engine.getCaps().textureFloat)) { // Required because iOS has many issues with float and half float generation
                            if (bpp === 128) {
                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);
                                if (sphericalPolynomialFaces && i == 0) {
                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i));
                                }
                            }
                            else if (bpp === 64) {
                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);
                                if (sphericalPolynomialFaces && i == 0) {
                                    sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i));
                                }
                            }
                            texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;
                        }
                        else {
                            if (bpp === 128) {
                                texture.type = Constants.TEXTURETYPE_FLOAT;
                                floatArray = DDSTools._GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);
                                if (sphericalPolynomialFaces && i == 0) {
                                    sphericalPolynomialFaces.push(floatArray);
                                }
                            }
                            else if (bpp === 64 && !engine.getCaps().textureHalfFloat) {
                                texture.type = Constants.TEXTURETYPE_FLOAT;
                                floatArray = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);
                                if (sphericalPolynomialFaces && i == 0) {
                                    sphericalPolynomialFaces.push(floatArray);
                                }
                            }
                            else { // 64
                                texture.type = Constants.TEXTURETYPE_HALF_FLOAT;
                                floatArray = DDSTools._GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);
                                if (sphericalPolynomialFaces && i == 0) {
                                    sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i));
                                }
                            }
                        }
                        if (floatArray) {
                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);
                        }
                    }
                    else if (info.isRGB) {
                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;
                        if (bpp === 24) {
                            texture.format = Constants.TEXTUREFORMAT_RGB;
                            dataLength = width * height * 3;
                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset);
                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
                        }
                        else { // 32
                            texture.format = Constants.TEXTUREFORMAT_RGBA;
                            dataLength = width * height * 4;
                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset);
                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
                        }
                    }
                    else if (info.isLuminance) {
                        var unpackAlignment = engine._getUnpackAlignement();
                        var unpaddedRowSize = width;
                        var paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;
                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;
                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer);
                        texture.format = Constants.TEXTUREFORMAT_LUMINANCE;
                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;
                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
                    }
                    else {
                        dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                        byteArray = new Uint8Array(arrayBuffer, dataOffset, dataLength);
                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;
                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);
                    }
                }
                dataOffset += bpp ? (width * height * (bpp / 8)) : dataLength;
                width *= 0.5;
                height *= 0.5;
                width = Math.max(1.0, width);
                height = Math.max(1.0, height);
            }
            if (currentFace !== undefined) {
                // Loading a single face
                break;
            }
        }
        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {
            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({
                size: header[off_width],
                right: sphericalPolynomialFaces[0],
                left: sphericalPolynomialFaces[1],
                up: sphericalPolynomialFaces[2],
                down: sphericalPolynomialFaces[3],
                front: sphericalPolynomialFaces[4],
                back: sphericalPolynomialFaces[5],
                format: Constants.TEXTUREFORMAT_RGBA,
                type: Constants.TEXTURETYPE_FLOAT,
                gammaSpace: false,
            });
        }
        else {
            info.sphericalPolynomial = undefined;
        }
    };
    /**
     * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)
     */
    DDSTools.StoreLODInAlphaChannel = false;
    return DDSTools;
}());
/**
 * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)
 * @param rootUrl defines the url where the file to load is located
 * @param scene defines the current scene
 * @param lodScale defines scale to apply to the mip map selection
 * @param lodOffset defines offset to apply to the mip map selection
 * @param onLoad defines an optional callback raised when the texture is loaded
 * @param onError defines an optional callback raised if there is an issue to load the texture
 * @param format defines the format of the data
 * @param forcedExtension defines the extension to use to pick the right loader
 * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture
 * @returns the cube texture as an InternalTexture
 */
Engine.prototype.createPrefilteredCubeTexture = function (rootUrl, scene, lodScale, lodOffset, onLoad, onError, format, forcedExtension, createPolynomials) {
    var _this = this;
    if (onLoad === void 0) { onLoad = null; }
    if (onError === void 0) { onError = null; }
    if (forcedExtension === void 0) { forcedExtension = null; }
    if (createPolynomials === void 0) { createPolynomials = true; }
    var callback = function (loadData) {
        if (!loadData) {
            if (onLoad) {
                onLoad(null);
            }
            return;
        }
        var texture = loadData.texture;
        if (!createPolynomials) {
            texture._sphericalPolynomial = new SphericalPolynomial();
        }
        else if (loadData.info.sphericalPolynomial) {
            texture._sphericalPolynomial = loadData.info.sphericalPolynomial;
        }
        texture._dataSource = InternalTexture.DATASOURCE_CUBEPREFILTERED;
        if (_this.getCaps().textureLOD) {
            // Do not add extra process if texture lod is supported.
            if (onLoad) {
                onLoad(texture);
            }
            return;
        }
        var mipSlices = 3;
        var gl = _this._gl;
        var width = loadData.width;
        if (!width) {
            return;
        }
        var textures = [];
        for (var i = 0; i < mipSlices; i++) {
            //compute LOD from even spacing in smoothness (matching shader calculation)
            var smoothness = i / (mipSlices - 1);
            var roughness = 1 - smoothness;
            var minLODIndex = lodOffset; // roughness = 0
            var maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1
            var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
            var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
            var glTextureFromLod = new InternalTexture(_this, InternalTexture.DATASOURCE_TEMP);
            glTextureFromLod.type = texture.type;
            glTextureFromLod.format = texture.format;
            glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));
            glTextureFromLod.height = glTextureFromLod.width;
            glTextureFromLod.isCube = true;
            _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            if (loadData.isDDS) {
                var info = loadData.info;
                var data = loadData.data;
                _this._unpackFlipY(info.isCompressed);
                DDSTools.UploadDDSLevels(_this, glTextureFromLod, data, info, true, 6, mipmapIndex);
            }
            else {
                Logger.Warn("DDS is the only prefiltered cube map supported so far.");
            }
            _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
            // Wrap in a base texture for easy binding.
            var lodTexture = new BaseTexture(scene);
            lodTexture.isCube = true;
            lodTexture._texture = glTextureFromLod;
            glTextureFromLod.isReady = true;
            textures.push(lodTexture);
        }
        texture._lodTextureHigh = textures[2];
        texture._lodTextureMid = textures[1];
        texture._lodTextureLow = textures[0];
        if (onLoad) {
            onLoad(texture);
        }
    };
    return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);
};

/**
 * Implementation of the DDS Texture Loader.
 * @hidden
 */
var _DDSTextureLoader = /** @class */ (function () {
    function _DDSTextureLoader() {
        /**
         * Defines wether the loader supports cascade loading the different faces.
         */
        this.supportCascades = true;
    }
    /**
     * This returns if the loader support the current file information.
     * @param extension defines the file extension of the file being loaded
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @param fallback defines the fallback internal texture if any
     * @param isBase64 defines whether the texture is encoded as a base64
     * @param isBuffer defines whether the texture data are stored as a buffer
     * @returns true if the loader can load the specified file
     */
    _DDSTextureLoader.prototype.canLoad = function (extension, textureFormatInUse, fallback, isBase64, isBuffer) {
        return extension.indexOf(".dds") === 0;
    };
    /**
     * Transform the url before loading if required.
     * @param rootUrl the url of the texture
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @returns the transformed texture
     */
    _DDSTextureLoader.prototype.transformUrl = function (rootUrl, textureFormatInUse) {
        return rootUrl;
    };
    /**
     * Gets the fallback url in case the load fail. This can return null to allow the default fallback mecanism to work
     * @param rootUrl the url of the texture
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @returns the fallback texture
     */
    _DDSTextureLoader.prototype.getFallbackTextureUrl = function (rootUrl, textureFormatInUse) {
        return null;
    };
    /**
     * Uploads the cube texture data to the WebGl Texture. It has alreday been bound.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param createPolynomials will be true if polynomials have been requested
     * @param onLoad defines the callback to trigger once the texture is ready
     * @param onError defines the callback to trigger in case of error
     */
    _DDSTextureLoader.prototype.loadCubeData = function (imgs, texture, createPolynomials, onLoad, onError) {
        var engine = texture.getEngine();
        var info;
        var loadMipmap = false;
        if (Array.isArray(imgs)) {
            for (var index = 0; index < imgs.length; index++) {
                var data_1 = imgs[index];
                info = DDSTools.GetDDSInfo(data_1);
                texture.width = info.width;
                texture.height = info.height;
                loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;
                engine._unpackFlipY(info.isCompressed);
                DDSTools.UploadDDSLevels(engine, texture, data_1, info, loadMipmap, 6, -1, index);
                if (!info.isFourCC && info.mipmapCount === 1) {
                    engine.generateMipMapsForCubemap(texture);
                }
            }
        }
        else {
            var data = imgs;
            info = DDSTools.GetDDSInfo(data);
            texture.width = info.width;
            texture.height = info.height;
            if (createPolynomials) {
                info.sphericalPolynomial = new SphericalPolynomial();
            }
            loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;
            engine._unpackFlipY(info.isCompressed);
            DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);
            if (!info.isFourCC && info.mipmapCount === 1) {
                engine.generateMipMapsForCubemap(texture);
            }
        }
        engine._setCubeMapTextureParams(loadMipmap);
        texture.isReady = true;
        if (onLoad) {
            onLoad({ isDDS: true, width: texture.width, info: info, data: imgs, texture: texture });
        }
    };
    /**
     * Uploads the 2D texture data to the WebGl Texture. It has alreday been bound once in the callback.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param callback defines the method to call once ready to upload
     */
    _DDSTextureLoader.prototype.loadData = function (data, texture, callback) {
        var info = DDSTools.GetDDSInfo(data);
        var loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && ((info.width >> (info.mipmapCount - 1)) === 1);
        callback(info.width, info.height, loadMipmap, info.isFourCC, function () {
            DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);
        });
    };
    return _DDSTextureLoader;
}());
// Register the loader.
Engine._TextureLoaders.push(new _DDSTextureLoader());

/**
 * Implementation of the ENV Texture Loader.
 * @hidden
 */
var _ENVTextureLoader = /** @class */ (function () {
    function _ENVTextureLoader() {
        /**
         * Defines wether the loader supports cascade loading the different faces.
         */
        this.supportCascades = false;
    }
    /**
     * This returns if the loader support the current file information.
     * @param extension defines the file extension of the file being loaded
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @param fallback defines the fallback internal texture if any
     * @param isBase64 defines whether the texture is encoded as a base64
     * @param isBuffer defines whether the texture data are stored as a buffer
     * @returns true if the loader can load the specified file
     */
    _ENVTextureLoader.prototype.canLoad = function (extension, textureFormatInUse, fallback, isBase64, isBuffer) {
        return extension.indexOf(".env") === 0;
    };
    /**
     * Transform the url before loading if required.
     * @param rootUrl the url of the texture
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @returns the transformed texture
     */
    _ENVTextureLoader.prototype.transformUrl = function (rootUrl, textureFormatInUse) {
        return rootUrl;
    };
    /**
     * Gets the fallback url in case the load fail. This can return null to allow the default fallback mecanism to work
     * @param rootUrl the url of the texture
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @returns the fallback texture
     */
    _ENVTextureLoader.prototype.getFallbackTextureUrl = function (rootUrl, textureFormatInUse) {
        return null;
    };
    /**
     * Uploads the cube texture data to the WebGl Texture. It has alreday been bound.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param createPolynomials will be true if polynomials have been requested
     * @param onLoad defines the callback to trigger once the texture is ready
     * @param onError defines the callback to trigger in case of error
     */
    _ENVTextureLoader.prototype.loadCubeData = function (data, texture, createPolynomials, onLoad, onError) {
        if (Array.isArray(data)) {
            return;
        }
        data = data;
        var info = EnvironmentTextureTools.GetEnvInfo(data);
        if (info) {
            texture.width = info.width;
            texture.height = info.width;
            EnvironmentTextureTools.UploadEnvSpherical(texture, info);
            EnvironmentTextureTools.UploadEnvLevelsAsync(texture, data, info).then(function () {
                texture.isReady = true;
                if (onLoad) {
                    onLoad();
                }
            });
        }
        else if (onError) {
            onError("Can not parse the environment file", null);
        }
    };
    /**
     * Uploads the 2D texture data to the WebGl Texture. It has alreday been bound once in the callback.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param callback defines the method to call once ready to upload
     */
    _ENVTextureLoader.prototype.loadData = function (data, texture, callback) {
        throw ".env not supported in 2d.";
    };
    return _ENVTextureLoader;
}());
// Register the loader.
Engine._TextureLoaders.push(new _ENVTextureLoader());

/**
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 */
var KhronosTextureContainer = /** @class */ (function () {
    /**
     * Creates a new KhronosTextureContainer
     * @param arrayBuffer contents of the KTX container file
     * @param facesExpected should be either 1 or 6, based whether a cube texture or or
     * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
     * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
     */
    function KhronosTextureContainer(
    /** contents of the KTX container file */
    arrayBuffer, facesExpected, threeDExpected, textureArrayExpected) {
        this.arrayBuffer = arrayBuffer;
        /**
         * If the container has been made invalid (eg. constructor failed to correctly load array buffer)
         */
        this.isInvalid = false;
        // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:
        // '', 'K', 'T', 'X', ' ', '1', '1', '', '\r', '\n', '\x1A', '\n'
        // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
        var identifier = new Uint8Array(this.arrayBuffer, 0, 12);
        if (identifier[0] !== 0xAB || identifier[1] !== 0x4B || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 ||
            identifier[6] !== 0x31 || identifier[7] !== 0xBB || identifier[8] !== 0x0D || identifier[9] !== 0x0A || identifier[10] !== 0x1A || identifier[11] !== 0x0A) {
            this.isInvalid = true;
            Logger.Error("texture missing KTX identifier");
            return;
        }
        // load the reset of the header in native 32 bit uint
        var dataSize = Uint32Array.BYTES_PER_ELEMENT;
        var headerDataView = new DataView(this.arrayBuffer, 12, 13 * dataSize);
        var endianness = headerDataView.getUint32(0, true);
        var littleEndian = endianness === 0x04030201;
        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures
        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays
        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6
        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures
        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data
        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
        if (this.glType !== 0) {
            Logger.Error("only compressed formats currently supported");
            return;
        }
        else {
            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
        }
        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
            Logger.Error("only 2D textures currently supported");
            return;
        }
        if (this.numberOfArrayElements !== 0) {
            Logger.Error("texture arrays not currently supported");
            return;
        }
        if (this.numberOfFaces !== facesExpected) {
            Logger.Error("number of faces expected" + facesExpected + ", but found " + this.numberOfFaces);
            return;
        }
        // we now have a completely validated file, so could use existence of loadType as success
        // would need to make this more elaborate & adjust checks above to support more than one load type
        this.loadType = KhronosTextureContainer.COMPRESSED_2D;
    }
    /**
     * Uploads KTX content to a Babylon Texture.
     * It is assumed that the texture has already been created & is currently bound
     * @hidden
     */
    KhronosTextureContainer.prototype.uploadLevels = function (texture, loadMipmaps) {
        switch (this.loadType) {
            case KhronosTextureContainer.COMPRESSED_2D:
                this._upload2DCompressedLevels(texture, loadMipmaps);
                break;
        }
    };
    KhronosTextureContainer.prototype._upload2DCompressedLevels = function (texture, loadMipmaps) {
        // initialize width & height for level 1
        var dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;
        var width = this.pixelWidth;
        var height = this.pixelHeight;
        var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
        for (var level = 0; level < mipmapCount; level++) {
            var imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
            dataOffset += 4; //image data starts from next multiple of 4 offset. Each face refers to same imagesize field above.
            for (var face = 0; face < this.numberOfFaces; face++) {
                var byteArray = new Uint8Array(this.arrayBuffer, dataOffset, imageSize);
                var engine = texture.getEngine();
                engine._uploadCompressedDataToTextureDirectly(texture, this.glInternalFormat, width, height, byteArray, face, level);
                dataOffset += imageSize; // add size of the image for the next face/mipmap
                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image
            }
            width = Math.max(1.0, width * 0.5);
            height = Math.max(1.0, height * 0.5);
        }
    };
    KhronosTextureContainer.HEADER_LEN = 12 + (13 * 4); // identifier + header elements (not including key value meta-data pairs)
    // load types
    KhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
    KhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()
    KhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()
    KhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()
    return KhronosTextureContainer;
}());

/**
 * Implementation of the KTX Texture Loader.
 * @hidden
 */
var _KTXTextureLoader = /** @class */ (function () {
    function _KTXTextureLoader() {
        /**
         * Defines wether the loader supports cascade loading the different faces.
         */
        this.supportCascades = false;
    }
    /**
     * This returns if the loader support the current file information.
     * @param extension defines the file extension of the file being loaded
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @param fallback defines the fallback internal texture if any
     * @param isBase64 defines whether the texture is encoded as a base64
     * @param isBuffer defines whether the texture data are stored as a buffer
     * @returns true if the loader can load the specified file
     */
    _KTXTextureLoader.prototype.canLoad = function (extension, textureFormatInUse, fallback, isBase64, isBuffer) {
        if (textureFormatInUse && !isBase64 && !fallback && !isBuffer) {
            return true;
        }
        return false;
    };
    /**
     * Transform the url before loading if required.
     * @param rootUrl the url of the texture
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @returns the transformed texture
     */
    _KTXTextureLoader.prototype.transformUrl = function (rootUrl, textureFormatInUse) {
        var lastDot = rootUrl.lastIndexOf('.');
        if (lastDot != -1 && rootUrl.substring(lastDot + 1) == "ktx") {
            // Already transformed
            return rootUrl;
        }
        return (lastDot > -1 ? rootUrl.substring(0, lastDot) : rootUrl) + textureFormatInUse;
    };
    /**
     * Gets the fallback url in case the load fail. This can return null to allow the default fallback mecanism to work
     * @param rootUrl the url of the texture
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @returns the fallback texture
     */
    _KTXTextureLoader.prototype.getFallbackTextureUrl = function (rootUrl, textureFormatInUse) {
        // remove the format appended to the rootUrl in the original createCubeTexture call.
        var exp = new RegExp("" + textureFormatInUse + "$");
        return rootUrl.replace(exp, "");
    };
    /**
     * Uploads the cube texture data to the WebGl Texture. It has alreday been bound.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param createPolynomials will be true if polynomials have been requested
     * @param onLoad defines the callback to trigger once the texture is ready
     * @param onError defines the callback to trigger in case of error
     */
    _KTXTextureLoader.prototype.loadCubeData = function (data, texture, createPolynomials, onLoad, onError) {
        if (Array.isArray(data)) {
            return;
        }
        // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture
        texture._invertVScale = !texture.invertY;
        var engine = texture.getEngine();
        var ktx = new KhronosTextureContainer(data, 6);
        var loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;
        engine._unpackFlipY(true);
        ktx.uploadLevels(texture, texture.generateMipMaps);
        texture.width = ktx.pixelWidth;
        texture.height = ktx.pixelHeight;
        engine._setCubeMapTextureParams(loadMipmap);
        texture.isReady = true;
    };
    /**
     * Uploads the 2D texture data to the WebGl Texture. It has alreday been bound once in the callback.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param callback defines the method to call once ready to upload
     */
    _KTXTextureLoader.prototype.loadData = function (data, texture, callback) {
        // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture
        texture._invertVScale = !texture.invertY;
        var ktx = new KhronosTextureContainer(data, 1);
        callback(ktx.pixelWidth, ktx.pixelHeight, false, true, function () {
            ktx.uploadLevels(texture, texture.generateMipMaps);
        }, ktx.isInvalid);
    };
    return _KTXTextureLoader;
}());
// Register the loader.
Engine._TextureLoaders.unshift(new _KTXTextureLoader());

/** @hidden */
var _forceSceneHelpersToBundle = true;
Scene.prototype.createDefaultLight = function (replace) {
    if (replace === void 0) { replace = false; }
    // Dispose existing light in replace mode.
    if (replace) {
        if (this.lights) {
            for (var i = 0; i < this.lights.length; i++) {
                this.lights[i].dispose();
            }
        }
    }
    // Light
    if (this.lights.length === 0) {
        new HemisphericLight("default light", Vector3.Up(), this);
    }
};
Scene.prototype.createDefaultCamera = function (createArcRotateCamera, replace, attachCameraControls) {
    if (createArcRotateCamera === void 0) { createArcRotateCamera = false; }
    if (replace === void 0) { replace = false; }
    if (attachCameraControls === void 0) { attachCameraControls = false; }
    // Dispose existing camera in replace mode.
    if (replace) {
        if (this.activeCamera) {
            this.activeCamera.dispose();
            this.activeCamera = null;
        }
    }
    // Camera
    if (!this.activeCamera) {
        var worldExtends = this.getWorldExtends();
        var worldSize = worldExtends.max.subtract(worldExtends.min);
        var worldCenter = worldExtends.min.add(worldSize.scale(0.5));
        var camera;
        var radius = worldSize.length() * 1.5;
        // empty scene scenario!
        if (!isFinite(radius)) {
            radius = 1;
            worldCenter.copyFromFloats(0, 0, 0);
        }
        if (createArcRotateCamera) {
            var arcRotateCamera = new ArcRotateCamera("default camera", -(Math.PI / 2), Math.PI / 2, radius, worldCenter, this);
            arcRotateCamera.lowerRadiusLimit = radius * 0.01;
            arcRotateCamera.wheelPrecision = 100 / radius;
            camera = arcRotateCamera;
        }
        else {
            var freeCamera = new FreeCamera("default camera", new Vector3(worldCenter.x, worldCenter.y, -radius), this);
            freeCamera.setTarget(worldCenter);
            camera = freeCamera;
        }
        camera.minZ = radius * 0.01;
        camera.maxZ = radius * 1000;
        camera.speed = radius * 0.2;
        this.activeCamera = camera;
        var canvas = this.getEngine().getRenderingCanvas();
        if (attachCameraControls && canvas) {
            camera.attachControl(canvas);
        }
    }
};
Scene.prototype.createDefaultCameraOrLight = function (createArcRotateCamera, replace, attachCameraControls) {
    if (createArcRotateCamera === void 0) { createArcRotateCamera = false; }
    if (replace === void 0) { replace = false; }
    if (attachCameraControls === void 0) { attachCameraControls = false; }
    this.createDefaultLight(replace);
    this.createDefaultCamera(createArcRotateCamera, replace, attachCameraControls);
};
Scene.prototype.createDefaultSkybox = function (environmentTexture, pbr, scale, blur, setGlobalEnvTexture) {
    if (pbr === void 0) { pbr = false; }
    if (scale === void 0) { scale = 1000; }
    if (blur === void 0) { blur = 0; }
    if (setGlobalEnvTexture === void 0) { setGlobalEnvTexture = true; }
    if (!environmentTexture) {
        Logger.Warn("Can not create default skybox without environment texture.");
        return null;
    }
    if (setGlobalEnvTexture) {
        if (environmentTexture) {
            this.environmentTexture = environmentTexture;
        }
    }
    // Skybox
    var hdrSkybox = Mesh.CreateBox("hdrSkyBox", scale, this);
    if (pbr) {
        var hdrSkyboxMaterial = new PBRMaterial("skyBox", this);
        hdrSkyboxMaterial.backFaceCulling = false;
        hdrSkyboxMaterial.reflectionTexture = environmentTexture.clone();
        if (hdrSkyboxMaterial.reflectionTexture) {
            hdrSkyboxMaterial.reflectionTexture.coordinatesMode = Texture.SKYBOX_MODE;
        }
        hdrSkyboxMaterial.microSurface = 1.0 - blur;
        hdrSkyboxMaterial.disableLighting = true;
        hdrSkyboxMaterial.twoSidedLighting = true;
        hdrSkybox.infiniteDistance = true;
        hdrSkybox.material = hdrSkyboxMaterial;
    }
    else {
        var skyboxMaterial = new StandardMaterial("skyBox", this);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = environmentTexture.clone();
        if (skyboxMaterial.reflectionTexture) {
            skyboxMaterial.reflectionTexture.coordinatesMode = Texture.SKYBOX_MODE;
        }
        skyboxMaterial.disableLighting = true;
        hdrSkybox.infiniteDistance = true;
        hdrSkybox.material = skyboxMaterial;
    }
    hdrSkybox.isPickable = false;
    return hdrSkybox;
};
Scene.prototype.createDefaultEnvironment = function (options) {
    if (EnvironmentHelper) {
        return new EnvironmentHelper(options, this);
    }
    return null;
};
Scene.prototype.createDefaultVRExperience = function (webVROptions) {
    if (webVROptions === void 0) { webVROptions = {}; }
    return new VRExperienceHelper(this, webVROptions);
};
Scene.prototype.createDefaultXRExperienceAsync = function () {
    var _this = this;
    return WebXRExperienceHelper.CreateAsync(this).then(function (helper) {
        var outputCanvas = new WebXRManagedOutputCanvas(helper);
        return WebXREnterExitUI.CreateAsync(_this, helper, { outputCanvasContext: outputCanvas.canvasContext })
            .then(function (ui) {
            new WebXRInput(helper);
            return helper;
        });
    });
};

/**
 * If you want to display a video in your scene, this is the special texture for that.
 * This special texture works similar to other textures, with the exception of a few parameters.
 * @see https://doc.babylonjs.com/how_to/video_texture
 */
var VideoTexture = /** @class */ (function (_super) {
    __extends(VideoTexture, _super);
    /**
     * Creates a video texture.
     * If you want to display a video in your scene, this is the special texture for that.
     * This special texture works similar to other textures, with the exception of a few parameters.
     * @see https://doc.babylonjs.com/how_to/video_texture
     * @param name optional name, will detect from video source, if not defined
     * @param src can be used to provide an url, array of urls or an already setup HTML video element.
     * @param scene is obviously the current scene.
     * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).
     * @param invertY is false by default but can be used to invert video on Y axis
     * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default
     * @param settings allows finer control over video usage
     */
    function VideoTexture(name, src, scene, generateMipMaps, invertY, samplingMode, settings) {
        if (generateMipMaps === void 0) { generateMipMaps = false; }
        if (invertY === void 0) { invertY = false; }
        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }
        if (settings === void 0) { settings = {
            autoPlay: true,
            loop: true,
            autoUpdateTexture: true,
        }; }
        var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;
        _this._onUserActionRequestedObservable = null;
        _this._stillImageCaptured = false;
        _this._displayingPosterTexture = false;
        _this._createInternalTexture = function () {
            if (_this._texture != null) {
                if (_this._displayingPosterTexture) {
                    _this._texture.dispose();
                    _this._displayingPosterTexture = false;
                }
                else {
                    return;
                }
            }
            if (!_this._engine.needPOTTextures ||
                (Tools.IsExponentOfTwo(_this.video.videoWidth) && Tools.IsExponentOfTwo(_this.video.videoHeight))) {
                _this.wrapU = Texture.WRAP_ADDRESSMODE;
                _this.wrapV = Texture.WRAP_ADDRESSMODE;
            }
            else {
                _this.wrapU = Texture.CLAMP_ADDRESSMODE;
                _this.wrapV = Texture.CLAMP_ADDRESSMODE;
                _this._generateMipMaps = false;
            }
            _this._texture = _this._engine.createDynamicTexture(_this.video.videoWidth, _this.video.videoHeight, _this._generateMipMaps, _this.samplingMode);
            if (!_this.video.autoplay && !_this._settings.poster) {
                var oldHandler_1 = _this.video.onplaying;
                var error_1 = false;
                var oldMuted_1 = _this.video.muted;
                _this.video.muted = true;
                _this.video.onplaying = function () {
                    _this.video.muted = oldMuted_1;
                    _this.video.onplaying = oldHandler_1;
                    _this._texture.isReady = true;
                    _this._updateInternalTexture();
                    if (!error_1) {
                        _this.video.pause();
                    }
                    if (_this.onLoadObservable.hasObservers()) {
                        _this.onLoadObservable.notifyObservers(_this);
                    }
                };
                var playing = _this.video.play();
                if (playing) {
                    playing.then(function () {
                        // Everything is good.
                    })
                        .catch(function () {
                        error_1 = true;
                        // On Chrome for instance, new policies might prevent playing without user interaction.
                        if (_this._onUserActionRequestedObservable && _this._onUserActionRequestedObservable.hasObservers()) {
                            _this._onUserActionRequestedObservable.notifyObservers(_this);
                        }
                    });
                }
                else {
                    _this.video.onplaying = oldHandler_1;
                    _this._texture.isReady = true;
                    _this._updateInternalTexture();
                    if (_this.onLoadObservable.hasObservers()) {
                        _this.onLoadObservable.notifyObservers(_this);
                    }
                }
            }
            else {
                _this._texture.isReady = true;
                _this._updateInternalTexture();
                if (_this.onLoadObservable.hasObservers()) {
                    _this.onLoadObservable.notifyObservers(_this);
                }
            }
        };
        _this.reset = function () {
            if (_this._texture == null) {
                return;
            }
            if (!_this._displayingPosterTexture) {
                _this._texture.dispose();
                _this._texture = null;
            }
        };
        _this._updateInternalTexture = function () {
            if (_this._texture == null || !_this._texture.isReady) {
                return;
            }
            if (_this.video.readyState < _this.video.HAVE_CURRENT_DATA) {
                return;
            }
            if (_this._displayingPosterTexture) {
                return;
            }
            _this._engine.updateVideoTexture(_this._texture, _this.video, _this._invertY);
        };
        _this._engine = _this.getScene().getEngine();
        _this._generateMipMaps = generateMipMaps;
        _this._initialSamplingMode = samplingMode;
        _this.autoUpdateTexture = settings.autoUpdateTexture;
        _this.name = name || _this._getName(src);
        _this.video = _this._getVideo(src);
        _this._settings = settings;
        if (settings.poster) {
            _this.video.poster = settings.poster;
        }
        if (settings.autoPlay !== undefined) {
            _this.video.autoplay = settings.autoPlay;
        }
        if (settings.loop !== undefined) {
            _this.video.loop = settings.loop;
        }
        _this.video.setAttribute("playsinline", "");
        _this.video.addEventListener("paused", _this._updateInternalTexture);
        _this.video.addEventListener("seeked", _this._updateInternalTexture);
        _this.video.addEventListener("emptied", _this.reset);
        _this._createInternalTextureOnEvent = (settings.poster && !settings.autoPlay) ? "play" : "canplay";
        _this.video.addEventListener(_this._createInternalTextureOnEvent, _this._createInternalTexture);
        var videoHasEnoughData = (_this.video.readyState >= _this.video.HAVE_CURRENT_DATA);
        if (settings.poster &&
            (!settings.autoPlay || !videoHasEnoughData)) {
            _this._texture = _this._engine.createTexture(settings.poster, false, true, scene);
            _this._displayingPosterTexture = true;
        }
        else if (videoHasEnoughData) {
            _this._createInternalTexture();
        }
        return _this;
    }
    Object.defineProperty(VideoTexture.prototype, "onUserActionRequestedObservable", {
        /**
         * Event triggerd when a dom action is required by the user to play the video.
         * This happens due to recent changes in browser policies preventing video to auto start.
         */
        get: function () {
            if (!this._onUserActionRequestedObservable) {
                this._onUserActionRequestedObservable = new Observable();
            }
            return this._onUserActionRequestedObservable;
        },
        enumerable: true,
        configurable: true
    });
    VideoTexture.prototype._getName = function (src) {
        if (src instanceof HTMLVideoElement) {
            return src.currentSrc;
        }
        if (typeof src === "object") {
            return src.toString();
        }
        return src;
    };
    VideoTexture.prototype._getVideo = function (src) {
        if (src instanceof HTMLVideoElement) {
            Tools.SetCorsBehavior(src.currentSrc, src);
            return src;
        }
        var video = document.createElement("video");
        if (typeof src === "string") {
            Tools.SetCorsBehavior(src, video);
            video.src = src;
        }
        else {
            Tools.SetCorsBehavior(src[0], video);
            src.forEach(function (url) {
                var source = document.createElement("source");
                source.src = url;
                video.appendChild(source);
            });
        }
        return video;
    };
    /**
     * @hidden Internal method to initiate `update`.
     */
    VideoTexture.prototype._rebuild = function () {
        this.update();
    };
    /**
     * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.
     */
    VideoTexture.prototype.update = function () {
        if (!this.autoUpdateTexture) {
            // Expecting user to call `updateTexture` manually
            return;
        }
        this.updateTexture(true);
    };
    /**
     * Update Texture in `manual` mode. Does not do anything if not visible or paused.
     * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.
     */
    VideoTexture.prototype.updateTexture = function (isVisible) {
        if (!isVisible) {
            return;
        }
        if (this.video.paused && this._stillImageCaptured) {
            return;
        }
        this._stillImageCaptured = true;
        this._updateInternalTexture();
    };
    /**
     * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.
     * @param url New url.
     */
    VideoTexture.prototype.updateURL = function (url) {
        this.video.src = url;
    };
    /**
     * Dispose the texture and release its associated resources.
     */
    VideoTexture.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this._onUserActionRequestedObservable) {
            this._onUserActionRequestedObservable.clear();
            this._onUserActionRequestedObservable = null;
        }
        this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);
        this.video.removeEventListener("paused", this._updateInternalTexture);
        this.video.removeEventListener("seeked", this._updateInternalTexture);
        this.video.removeEventListener("emptied", this.reset);
        this.video.pause();
    };
    /**
     * Creates a video texture straight from a stream.
     * @param scene Define the scene the texture should be created in
     * @param stream Define the stream the texture should be created from
     * @returns The created video texture as a promise
     */
    VideoTexture.CreateFromStreamAsync = function (scene, stream) {
        var video = document.createElement("video");
        video.setAttribute('autoplay', '');
        video.setAttribute('muted', 'true');
        video.setAttribute('playsinline', '');
        video.muted = true;
        if (video.mozSrcObject !== undefined) {
            // hack for Firefox < 19
            video.mozSrcObject = stream;
        }
        else {
            if (typeof video.srcObject == "object") {
                video.srcObject = stream;
            }
            else {
                window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
                video.src = (window.URL && window.URL.createObjectURL(stream));
            }
        }
        return new Promise(function (resolve) {
            var onPlaying = function () {
                resolve(new VideoTexture("video", video, scene, true, true));
                video.removeEventListener("playing", onPlaying);
            };
            video.addEventListener("playing", onPlaying);
            video.play();
        });
    };
    /**
     * Creates a video texture straight from your WebCam video feed.
     * @param scene Define the scene the texture should be created in
     * @param constraints Define the constraints to use to create the web cam feed from WebRTC
     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC
     * @returns The created video texture as a promise
     */
    VideoTexture.CreateFromWebCamAsync = function (scene, constraints, audioConstaints) {
        var _this = this;
        if (audioConstaints === void 0) { audioConstaints = false; }
        var constraintsDeviceId;
        if (constraints && constraints.deviceId) {
            constraintsDeviceId = {
                exact: constraints.deviceId,
            };
        }
        if (navigator.mediaDevices) {
            return navigator.mediaDevices.getUserMedia({
                video: constraints,
                audio: audioConstaints
            })
                .then(function (stream) {
                return _this.CreateFromStreamAsync(scene, stream);
            });
        }
        else {
            navigator.getUserMedia =
                navigator.getUserMedia ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia ||
                    navigator.msGetUserMedia;
            if (navigator.getUserMedia) {
                navigator.getUserMedia({
                    video: {
                        deviceId: constraintsDeviceId,
                        width: {
                            min: (constraints && constraints.minWidth) || 256,
                            max: (constraints && constraints.maxWidth) || 640,
                        },
                        height: {
                            min: (constraints && constraints.minHeight) || 256,
                            max: (constraints && constraints.maxHeight) || 480,
                        },
                    },
                    audio: audioConstaints
                }, function (stream) {
                    return _this.CreateFromStreamAsync(scene, stream);
                }, function (e) {
                    Logger.Error(e.name);
                });
            }
        }
        return Promise.reject("No support for userMedia on this device");
    };
    /**
     * Creates a video texture straight from your WebCam video feed.
     * @param scene Define the scene the texture should be created in
     * @param onReady Define a callback to triggered once the texture will be ready
     * @param constraints Define the constraints to use to create the web cam feed from WebRTC
     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC
     */
    VideoTexture.CreateFromWebCam = function (scene, onReady, constraints, audioConstaints) {
        if (audioConstaints === void 0) { audioConstaints = false; }
        this.CreateFromWebCamAsync(scene, constraints, audioConstaints)
            .then(function (videoTexture) {
            if (onReady) {
                onReady(videoTexture);
            }
        })
            .catch(function (err) {
            Logger.Error(err.name);
        });
    };
    return VideoTexture;
}(Texture));

/**
 * Display a 360 degree video on an approximately spherical surface, useful for VR applications or skyboxes.
 * As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.
 * This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.
 * Potential additions to this helper include zoom and and non-infinite distance rendering effects.
 */
var VideoDome = /** @class */ (function (_super) {
    __extends(VideoDome, _super);
    /**
     * Create an instance of this class and pass through the parameters to the relevant classes, VideoTexture, StandardMaterial, and Mesh.
     * @param name Element's name, child elements will append suffixes for their own names.
     * @param urlsOrVideo defines the url(s) or the video element to use
     * @param options An object containing optional or exposed sub element properties
     */
    function VideoDome(name, urlsOrVideo, options, scene) {
        var _this = _super.call(this, name, scene) || this;
        _this._useDirectMapping = false;
        _this._videoMode = VideoDome.MODE_MONOSCOPIC;
        /**
         * Oberserver used in Stereoscopic VR Mode.
         */
        _this._onBeforeCameraRenderObserver = null;
        scene = _this.getScene();
        // set defaults and manage values
        name = name || "videoDome";
        options.resolution = (Math.abs(options.resolution) | 0) || 32;
        options.clickToPlay = Boolean(options.clickToPlay);
        options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);
        options.loop = options.loop === undefined ? true : Boolean(options.loop);
        options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);
        if (options.useDirectMapping === undefined) {
            _this._useDirectMapping = true;
        }
        else {
            _this._useDirectMapping = options.useDirectMapping;
        }
        if (options.faceForward === undefined) {
            options.faceForward = true;
        }
        _this._setReady(false);
        // create
        var tempOptions = { loop: options.loop, autoPlay: options.autoPlay, autoUpdateTexture: true, poster: options.poster };
        var material = _this._material = new BackgroundMaterial(name + "_material", scene);
        var texture = _this._videoTexture = new VideoTexture(name + "_texture", urlsOrVideo, scene, false, _this._useDirectMapping, Texture.TRILINEAR_SAMPLINGMODE, tempOptions);
        _this._mesh = Mesh.CreateSphere(name + "_mesh", options.resolution, options.size, scene, false, Mesh.BACKSIDE);
        texture.onLoadObservable.addOnce(function () {
            _this._setReady(true);
        });
        // configure material
        material.useEquirectangularFOV = true;
        material.fovMultiplier = 1.0;
        material.opacityFresnel = false;
        if (_this._useDirectMapping) {
            texture.wrapU = Texture.CLAMP_ADDRESSMODE;
            texture.wrapV = Texture.CLAMP_ADDRESSMODE;
            material.diffuseTexture = texture;
        }
        else {
            texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation
            texture.wrapV = Texture.CLAMP_ADDRESSMODE;
            material.reflectionTexture = texture;
        }
        // configure mesh
        _this._mesh.material = material;
        _this._mesh.parent = _this;
        // optional configuration
        if (options.clickToPlay) {
            scene.onPointerUp = function () {
                _this._videoTexture.video.play();
            };
        }
        // Initial rotation
        if (options.faceForward && scene.activeCamera) {
            var camera = scene.activeCamera;
            var forward = Vector3.Forward();
            var direction = Vector3.TransformNormal(forward, camera.getViewMatrix());
            direction.normalize();
            _this.rotation.y = Math.acos(Vector3.Dot(forward, direction));
        }
        return _this;
    }
    Object.defineProperty(VideoDome.prototype, "videoTexture", {
        /**
         * Gets the video texture being displayed on the sphere
         */
        get: function () {
            return this._videoTexture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VideoDome.prototype, "fovMultiplier", {
        /**
         * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
         * Also see the options.resolution property.
         */
        get: function () {
            return this._material.fovMultiplier;
        },
        set: function (value) {
            this._material.fovMultiplier = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VideoDome.prototype, "videoMode", {
        /**
         * Gets or set the current video mode for the video. It can be:
         * * VideoDome.MODE_MONOSCOPIC : Define the video source as a Monoscopic panoramic 360 video.
         * * VideoDome.MODE_TOPBOTTOM  : Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.
         * * VideoDome.MODE_SIDEBYSIDE : Define the video source as a Stereoscopic Side by Side panoramic 360 video.
         */
        get: function () {
            return this._videoMode;
        },
        set: function (value) {
            if (this._videoMode === value) {
                return;
            }
            this._changeVideoMode(value);
        },
        enumerable: true,
        configurable: true
    });
    VideoDome.prototype._changeVideoMode = function (value) {
        var _this = this;
        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
        this._videoMode = value;
        // Default Setup and Reset.
        this._videoTexture.uScale = 1;
        this._videoTexture.vScale = 1;
        this._videoTexture.uOffset = 0;
        this._videoTexture.vOffset = 0;
        switch (value) {
            case VideoDome.MODE_SIDEBYSIDE:
                this._videoTexture.uScale = 0.5;
                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function (camera) {
                    _this._videoTexture.uOffset = camera.isRightCamera ? 0.5 : 0.0;
                });
                break;
            case VideoDome.MODE_TOPBOTTOM:
                this._videoTexture.vScale = 0.5;
                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function (camera) {
                    _this._videoTexture.vOffset = camera.isRightCamera ? 0.5 : 0.0;
                });
                break;
        }
    };
    /**
     * Releases resources associated with this node.
     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
     */
    VideoDome.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {
        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }
        this._videoTexture.dispose();
        this._mesh.dispose();
        this._material.dispose();
        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
    };
    /**
     * Define the video source as a Monoscopic panoramic 360 video.
     */
    VideoDome.MODE_MONOSCOPIC = 0;
    /**
     * Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.
     */
    VideoDome.MODE_TOPBOTTOM = 1;
    /**
     * Define the video source as a Stereoscopic Side by Side panoramic 360 video.
     */
    VideoDome.MODE_SIDEBYSIDE = 2;
    return VideoDome;
}(TransformNode));

/**
 * This class can be used to get instrumentation data from a Babylon engine
 * @see http://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
 */
var EngineInstrumentation = /** @class */ (function () {
    /**
     * Instantiates a new engine instrumentation.
     * This class can be used to get instrumentation data from a Babylon engine
     * @see http://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
     * @param engine Defines the engine to instrument
     */
    function EngineInstrumentation(
    /**
     * Define the instrumented engine.
     */
    engine) {
        this.engine = engine;
        this._captureGPUFrameTime = false;
        this._gpuFrameTime = new PerfCounter();
        this._captureShaderCompilationTime = false;
        this._shaderCompilationTime = new PerfCounter();
        // Observers
        this._onBeginFrameObserver = null;
        this._onEndFrameObserver = null;
        this._onBeforeShaderCompilationObserver = null;
        this._onAfterShaderCompilationObserver = null;
    }
    Object.defineProperty(EngineInstrumentation.prototype, "gpuFrameTimeCounter", {
        // Properties
        /**
         * Gets the perf counter used for GPU frame time
         */
        get: function () {
            return this._gpuFrameTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EngineInstrumentation.prototype, "captureGPUFrameTime", {
        /**
         * Gets the GPU frame time capture status
         */
        get: function () {
            return this._captureGPUFrameTime;
        },
        /**
         * Enable or disable the GPU frame time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._captureGPUFrameTime) {
                return;
            }
            this._captureGPUFrameTime = value;
            if (value) {
                this._onBeginFrameObserver = this.engine.onBeginFrameObservable.add(function () {
                    if (!_this._gpuFrameTimeToken) {
                        _this._gpuFrameTimeToken = _this.engine.startTimeQuery();
                    }
                });
                this._onEndFrameObserver = this.engine.onEndFrameObservable.add(function () {
                    if (!_this._gpuFrameTimeToken) {
                        return;
                    }
                    var time = _this.engine.endTimeQuery(_this._gpuFrameTimeToken);
                    if (time > -1) {
                        _this._gpuFrameTimeToken = null;
                        _this._gpuFrameTime.fetchNewFrame();
                        _this._gpuFrameTime.addCount(time, true);
                    }
                });
            }
            else {
                this.engine.onBeginFrameObservable.remove(this._onBeginFrameObserver);
                this._onBeginFrameObserver = null;
                this.engine.onEndFrameObservable.remove(this._onEndFrameObserver);
                this._onEndFrameObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EngineInstrumentation.prototype, "shaderCompilationTimeCounter", {
        /**
         * Gets the perf counter used for shader compilation time
         */
        get: function () {
            return this._shaderCompilationTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EngineInstrumentation.prototype, "captureShaderCompilationTime", {
        /**
         * Gets the shader compilation time capture status
         */
        get: function () {
            return this._captureShaderCompilationTime;
        },
        /**
         * Enable or disable the shader compilation time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._captureShaderCompilationTime) {
                return;
            }
            this._captureShaderCompilationTime = value;
            if (value) {
                this._onBeforeShaderCompilationObserver = this.engine.onBeforeShaderCompilationObservable.add(function () {
                    _this._shaderCompilationTime.fetchNewFrame();
                    _this._shaderCompilationTime.beginMonitoring();
                });
                this._onAfterShaderCompilationObserver = this.engine.onAfterShaderCompilationObservable.add(function () {
                    _this._shaderCompilationTime.endMonitoring();
                });
            }
            else {
                this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);
                this._onBeforeShaderCompilationObserver = null;
                this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);
                this._onAfterShaderCompilationObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose and release associated resources.
     */
    EngineInstrumentation.prototype.dispose = function () {
        this.engine.onBeginFrameObservable.remove(this._onBeginFrameObserver);
        this._onBeginFrameObserver = null;
        this.engine.onEndFrameObservable.remove(this._onEndFrameObserver);
        this._onEndFrameObserver = null;
        this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);
        this._onBeforeShaderCompilationObserver = null;
        this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);
        this._onAfterShaderCompilationObserver = null;
        this.engine = null;
    };
    return EngineInstrumentation;
}());

/**
 * This class can be used to get instrumentation data from a Babylon engine
 * @see http://doc.babylonjs.com/how_to/optimizing_your_scene#sceneinstrumentation
 */
var SceneInstrumentation = /** @class */ (function () {
    /**
     * Instantiates a new scene instrumentation.
     * This class can be used to get instrumentation data from a Babylon engine
     * @see http://doc.babylonjs.com/how_to/optimizing_your_scene#sceneinstrumentation
     * @param scene Defines the scene to instrument
     */
    function SceneInstrumentation(
    /**
     * Defines the scene to instrument
     */
    scene) {
        var _this = this;
        this.scene = scene;
        this._captureActiveMeshesEvaluationTime = false;
        this._activeMeshesEvaluationTime = new PerfCounter();
        this._captureRenderTargetsRenderTime = false;
        this._renderTargetsRenderTime = new PerfCounter();
        this._captureFrameTime = false;
        this._frameTime = new PerfCounter();
        this._captureRenderTime = false;
        this._renderTime = new PerfCounter();
        this._captureInterFrameTime = false;
        this._interFrameTime = new PerfCounter();
        this._captureParticlesRenderTime = false;
        this._particlesRenderTime = new PerfCounter();
        this._captureSpritesRenderTime = false;
        this._spritesRenderTime = new PerfCounter();
        this._capturePhysicsTime = false;
        this._physicsTime = new PerfCounter();
        this._captureAnimationsTime = false;
        this._animationsTime = new PerfCounter();
        this._captureCameraRenderTime = false;
        this._cameraRenderTime = new PerfCounter();
        // Observers
        this._onBeforeActiveMeshesEvaluationObserver = null;
        this._onAfterActiveMeshesEvaluationObserver = null;
        this._onBeforeRenderTargetsRenderObserver = null;
        this._onAfterRenderTargetsRenderObserver = null;
        this._onAfterRenderObserver = null;
        this._onBeforeDrawPhaseObserver = null;
        this._onAfterDrawPhaseObserver = null;
        this._onBeforeAnimationsObserver = null;
        this._onBeforeParticlesRenderingObserver = null;
        this._onAfterParticlesRenderingObserver = null;
        this._onBeforeSpritesRenderingObserver = null;
        this._onAfterSpritesRenderingObserver = null;
        this._onBeforePhysicsObserver = null;
        this._onAfterPhysicsObserver = null;
        this._onAfterAnimationsObserver = null;
        this._onBeforeCameraRenderObserver = null;
        this._onAfterCameraRenderObserver = null;
        // Before render
        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(function () {
            if (_this._captureActiveMeshesEvaluationTime) {
                _this._activeMeshesEvaluationTime.fetchNewFrame();
            }
            if (_this._captureRenderTargetsRenderTime) {
                _this._renderTargetsRenderTime.fetchNewFrame();
            }
            if (_this._captureFrameTime) {
                Tools.StartPerformanceCounter("Scene rendering");
                _this._frameTime.beginMonitoring();
            }
            if (_this._captureInterFrameTime) {
                _this._interFrameTime.endMonitoring();
            }
            if (_this._captureParticlesRenderTime) {
                _this._particlesRenderTime.fetchNewFrame();
            }
            if (_this._captureSpritesRenderTime) {
                _this._spritesRenderTime.fetchNewFrame();
            }
            if (_this._captureAnimationsTime) {
                _this._animationsTime.beginMonitoring();
            }
            _this.scene.getEngine()._drawCalls.fetchNewFrame();
        });
        // After render
        this._onAfterRenderObserver = scene.onAfterRenderObservable.add(function () {
            if (_this._captureFrameTime) {
                Tools.EndPerformanceCounter("Scene rendering");
                _this._frameTime.endMonitoring();
            }
            if (_this._captureRenderTime) {
                _this._renderTime.endMonitoring(false);
            }
            if (_this._captureInterFrameTime) {
                _this._interFrameTime.beginMonitoring();
            }
        });
    }
    Object.defineProperty(SceneInstrumentation.prototype, "activeMeshesEvaluationTimeCounter", {
        // Properties
        /**
         * Gets the perf counter used for active meshes evaluation time
         */
        get: function () {
            return this._activeMeshesEvaluationTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "captureActiveMeshesEvaluationTime", {
        /**
         * Gets the active meshes evaluation time capture status
         */
        get: function () {
            return this._captureActiveMeshesEvaluationTime;
        },
        /**
         * Enable or disable the active meshes evaluation time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._captureActiveMeshesEvaluationTime) {
                return;
            }
            this._captureActiveMeshesEvaluationTime = value;
            if (value) {
                this._onBeforeActiveMeshesEvaluationObserver = this.scene.onBeforeActiveMeshesEvaluationObservable.add(function () {
                    Tools.StartPerformanceCounter("Active meshes evaluation");
                    _this._activeMeshesEvaluationTime.beginMonitoring();
                });
                this._onAfterActiveMeshesEvaluationObserver = this.scene.onAfterActiveMeshesEvaluationObservable.add(function () {
                    Tools.EndPerformanceCounter("Active meshes evaluation");
                    _this._activeMeshesEvaluationTime.endMonitoring();
                });
            }
            else {
                this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);
                this._onBeforeActiveMeshesEvaluationObserver = null;
                this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);
                this._onAfterActiveMeshesEvaluationObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "renderTargetsRenderTimeCounter", {
        /**
         * Gets the perf counter used for render targets render time
         */
        get: function () {
            return this._renderTargetsRenderTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "captureRenderTargetsRenderTime", {
        /**
         * Gets the render targets render time capture status
         */
        get: function () {
            return this._captureRenderTargetsRenderTime;
        },
        /**
         * Enable or disable the render targets render time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._captureRenderTargetsRenderTime) {
                return;
            }
            this._captureRenderTargetsRenderTime = value;
            if (value) {
                this._onBeforeRenderTargetsRenderObserver = this.scene.onBeforeRenderTargetsRenderObservable.add(function () {
                    Tools.StartPerformanceCounter("Render targets rendering");
                    _this._renderTargetsRenderTime.beginMonitoring();
                });
                this._onAfterRenderTargetsRenderObserver = this.scene.onAfterRenderTargetsRenderObservable.add(function () {
                    Tools.EndPerformanceCounter("Render targets rendering");
                    _this._renderTargetsRenderTime.endMonitoring(false);
                });
            }
            else {
                this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver);
                this._onBeforeRenderTargetsRenderObserver = null;
                this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver);
                this._onAfterRenderTargetsRenderObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "particlesRenderTimeCounter", {
        /**
         * Gets the perf counter used for particles render time
         */
        get: function () {
            return this._particlesRenderTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "captureParticlesRenderTime", {
        /**
         * Gets the particles render time capture status
         */
        get: function () {
            return this._captureParticlesRenderTime;
        },
        /**
         * Enable or disable the particles render time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._captureParticlesRenderTime) {
                return;
            }
            this._captureParticlesRenderTime = value;
            if (value) {
                this._onBeforeParticlesRenderingObserver = this.scene.onBeforeParticlesRenderingObservable.add(function () {
                    Tools.StartPerformanceCounter("Particles");
                    _this._particlesRenderTime.beginMonitoring();
                });
                this._onAfterParticlesRenderingObserver = this.scene.onAfterParticlesRenderingObservable.add(function () {
                    Tools.EndPerformanceCounter("Particles");
                    _this._particlesRenderTime.endMonitoring(false);
                });
            }
            else {
                this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);
                this._onBeforeParticlesRenderingObserver = null;
                this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);
                this._onAfterParticlesRenderingObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "spritesRenderTimeCounter", {
        /**
         * Gets the perf counter used for sprites render time
         */
        get: function () {
            return this._spritesRenderTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "captureSpritesRenderTime", {
        /**
         * Gets the sprites render time capture status
         */
        get: function () {
            return this._captureSpritesRenderTime;
        },
        /**
         * Enable or disable the sprites render time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._captureSpritesRenderTime) {
                return;
            }
            this._captureSpritesRenderTime = value;
            if (!this.scene.spriteManagers) {
                return;
            }
            if (value) {
                this._onBeforeSpritesRenderingObserver = this.scene.onBeforeSpritesRenderingObservable.add(function () {
                    Tools.StartPerformanceCounter("Sprites");
                    _this._spritesRenderTime.beginMonitoring();
                });
                this._onAfterSpritesRenderingObserver = this.scene.onAfterSpritesRenderingObservable.add(function () {
                    Tools.EndPerformanceCounter("Sprites");
                    _this._spritesRenderTime.endMonitoring(false);
                });
            }
            else {
                this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);
                this._onBeforeSpritesRenderingObserver = null;
                this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);
                this._onAfterSpritesRenderingObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "physicsTimeCounter", {
        /**
         * Gets the perf counter used for physics time
         */
        get: function () {
            return this._physicsTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "capturePhysicsTime", {
        /**
         * Gets the physics time capture status
         */
        get: function () {
            return this._capturePhysicsTime;
        },
        /**
         * Enable or disable the physics time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._capturePhysicsTime) {
                return;
            }
            if (!this.scene.onBeforePhysicsObservable) {
                return;
            }
            this._capturePhysicsTime = value;
            if (value) {
                this._onBeforePhysicsObserver = this.scene.onBeforePhysicsObservable.add(function () {
                    Tools.StartPerformanceCounter("Physics");
                    _this._physicsTime.beginMonitoring();
                });
                this._onAfterPhysicsObserver = this.scene.onAfterPhysicsObservable.add(function () {
                    Tools.EndPerformanceCounter("Physics");
                    _this._physicsTime.endMonitoring();
                });
            }
            else {
                this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);
                this._onBeforePhysicsObserver = null;
                this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);
                this._onAfterPhysicsObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "animationsTimeCounter", {
        /**
         * Gets the perf counter used for animations time
         */
        get: function () {
            return this._animationsTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "captureAnimationsTime", {
        /**
         * Gets the animations time capture status
         */
        get: function () {
            return this._captureAnimationsTime;
        },
        /**
         * Enable or disable the animations time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._captureAnimationsTime) {
                return;
            }
            this._captureAnimationsTime = value;
            if (value) {
                this._onAfterAnimationsObserver = this.scene.onAfterAnimationsObservable.add(function () {
                    _this._animationsTime.endMonitoring();
                });
            }
            else {
                this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);
                this._onAfterAnimationsObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "frameTimeCounter", {
        /**
         * Gets the perf counter used for frame time capture
         */
        get: function () {
            return this._frameTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "captureFrameTime", {
        /**
         * Gets the frame time capture status
         */
        get: function () {
            return this._captureFrameTime;
        },
        /**
         * Enable or disable the frame time capture
         */
        set: function (value) {
            this._captureFrameTime = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "interFrameTimeCounter", {
        /**
         * Gets the perf counter used for inter-frames time capture
         */
        get: function () {
            return this._interFrameTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "captureInterFrameTime", {
        /**
         * Gets the inter-frames time capture status
         */
        get: function () {
            return this._captureInterFrameTime;
        },
        /**
         * Enable or disable the inter-frames time capture
         */
        set: function (value) {
            this._captureInterFrameTime = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "renderTimeCounter", {
        /**
         * Gets the perf counter used for render time capture
         */
        get: function () {
            return this._renderTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "captureRenderTime", {
        /**
         * Gets the render time capture status
         */
        get: function () {
            return this._captureRenderTime;
        },
        /**
         * Enable or disable the render time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._captureRenderTime) {
                return;
            }
            this._captureRenderTime = value;
            if (value) {
                this._onBeforeDrawPhaseObserver = this.scene.onBeforeDrawPhaseObservable.add(function () {
                    _this._renderTime.beginMonitoring();
                    Tools.StartPerformanceCounter("Main render");
                });
                this._onAfterDrawPhaseObserver = this.scene.onAfterDrawPhaseObservable.add(function () {
                    _this._renderTime.endMonitoring(false);
                    Tools.EndPerformanceCounter("Main render");
                });
            }
            else {
                this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver);
                this._onBeforeDrawPhaseObserver = null;
                this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver);
                this._onAfterDrawPhaseObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "cameraRenderTimeCounter", {
        /**
         * Gets the perf counter used for camera render time capture
         */
        get: function () {
            return this._cameraRenderTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "captureCameraRenderTime", {
        /**
         * Gets the camera render time capture status
         */
        get: function () {
            return this._captureCameraRenderTime;
        },
        /**
         * Enable or disable the camera render time capture
         */
        set: function (value) {
            var _this = this;
            if (value === this._captureCameraRenderTime) {
                return;
            }
            this._captureCameraRenderTime = value;
            if (value) {
                this._onBeforeCameraRenderObserver = this.scene.onBeforeCameraRenderObservable.add(function (camera) {
                    _this._cameraRenderTime.beginMonitoring();
                    Tools.StartPerformanceCounter("Rendering camera " + camera.name);
                });
                this._onAfterCameraRenderObserver = this.scene.onAfterCameraRenderObservable.add(function (camera) {
                    _this._cameraRenderTime.endMonitoring(false);
                    Tools.EndPerformanceCounter("Rendering camera " + camera.name);
                });
            }
            else {
                this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
                this._onBeforeCameraRenderObserver = null;
                this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
                this._onAfterCameraRenderObserver = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneInstrumentation.prototype, "drawCallsCounter", {
        /**
         * Gets the perf counter used for draw calls
         */
        get: function () {
            return this.scene.getEngine()._drawCalls;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose and release associated resources.
     */
    SceneInstrumentation.prototype.dispose = function () {
        this.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver);
        this._onAfterRenderObserver = null;
        this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);
        this._onBeforeActiveMeshesEvaluationObserver = null;
        this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);
        this._onAfterActiveMeshesEvaluationObserver = null;
        this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver);
        this._onBeforeRenderTargetsRenderObserver = null;
        this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver);
        this._onAfterRenderTargetsRenderObserver = null;
        this.scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);
        this._onBeforeAnimationsObserver = null;
        this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);
        this._onBeforeParticlesRenderingObserver = null;
        this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);
        this._onAfterParticlesRenderingObserver = null;
        if (this._onBeforeSpritesRenderingObserver) {
            this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);
            this._onBeforeSpritesRenderingObserver = null;
        }
        if (this._onAfterSpritesRenderingObserver) {
            this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);
            this._onAfterSpritesRenderingObserver = null;
        }
        this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver);
        this._onBeforeDrawPhaseObserver = null;
        this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver);
        this._onAfterDrawPhaseObserver = null;
        if (this._onBeforePhysicsObserver) {
            this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);
            this._onBeforePhysicsObserver = null;
        }
        if (this._onAfterPhysicsObserver) {
            this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);
            this._onAfterPhysicsObserver = null;
        }
        this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);
        this._onAfterAnimationsObserver = null;
        this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
        this._onBeforeCameraRenderObserver = null;
        this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
        this._onAfterCameraRenderObserver = null;
        this.scene = null;
    };
    return SceneInstrumentation;
}());

var name$k = 'glowMapGenerationPixelShader';
var shader$k = "#ifdef DIFFUSE\nvarying vec2 vUVDiffuse;\nuniform sampler2D diffuseSampler;\n#endif\n#ifdef OPACITY\nvarying vec2 vUVOpacity;\nuniform sampler2D opacitySampler;\nuniform float opacityIntensity;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vUVEmissive;\nuniform sampler2D emissiveSampler;\n#endif\n#ifdef VERTEXALPHA\nvarying vec4 vColor;\n#endif\nuniform vec4 glowColor;\nvoid main(void)\n{\nvec4 finalColor=glowColor;\n\n#ifdef DIFFUSE\nvec4 albedoTexture=texture2D(diffuseSampler,vUVDiffuse);\nfinalColor.a*=albedoTexture.a;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vUVOpacity);\n#ifdef OPACITYRGB\nfinalColor.a*=getLuminance(opacityMap.rgb);\n#else\nfinalColor.a*=opacityMap.a;\n#endif\nfinalColor.a*=opacityIntensity;\n#endif\n#ifdef VERTEXALPHA\nfinalColor.a*=vColor.a;\n#endif\n#ifdef ALPHATEST\nif (finalColor.a<ALPHATESTVALUE)\ndiscard;\n#endif\n#ifdef EMISSIVE\ngl_FragColor=texture2D(emissiveSampler,vUVEmissive)*finalColor;\n#else\ngl_FragColor=finalColor;\n#endif\n}";
Effect.ShadersStore[name$k] = shader$k;

var name$l = 'glowMapGenerationVertexShader';
var shader$l = "\nattribute vec3 position;\n#include<bonesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nvarying vec4 vPosition;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef DIFFUSE\nvarying vec2 vUVDiffuse;\nuniform mat4 diffuseMatrix;\n#endif\n#ifdef OPACITY\nvarying vec2 vUVOpacity;\nuniform mat4 opacityMatrix;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vUVEmissive;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef VERTEXALPHA\nattribute vec4 color;\nvarying vec4 vColor;\n#endif\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#ifdef CUBEMAP\nvPosition=finalWorld*vec4(positionUpdated,1.0);\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#else\nvPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\ngl_Position=vPosition;\n#endif\n#ifdef DIFFUSE\n#ifdef DIFFUSEUV1\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef DIFFUSEUV2\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef OPACITY\n#ifdef OPACITYUV1\nvUVOpacity=vec2(opacityMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef OPACITYUV2\nvUVOpacity=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef EMISSIVE\n#ifdef EMISSIVEUV1\nvUVEmissive=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef EMISSIVEUV2\nvUVEmissive=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef VERTEXALPHA\nvColor=color;\n#endif\n}";
Effect.ShadersStore[name$l] = shader$l;

/**
 * The effect layer Helps adding post process effect blended with the main pass.
 *
 * This can be for instance use to generate glow or higlight effects on the scene.
 *
 * The effect layer class can not be used directly and is intented to inherited from to be
 * customized per effects.
 */
var EffectLayer = /** @class */ (function () {
    /**
     * Instantiates a new effect Layer and references it in the scene.
     * @param name The name of the layer
     * @param scene The scene to use the layer in
     */
    function EffectLayer(
    /** The Friendly of the effect in the scene */
    name, scene) {
        this._vertexBuffers = {};
        this._maxSize = 0;
        this._mainTextureDesiredSize = { width: 0, height: 0 };
        this._shouldRender = true;
        this._postProcesses = [];
        this._textures = [];
        this._emissiveTextureAndColor = { texture: null, color: new Color4() };
        /**
         * The clear color of the texture used to generate the glow map.
         */
        this.neutralColor = new Color4();
        /**
         * Specifies wether the highlight layer is enabled or not.
         */
        this.isEnabled = true;
        /**
         * An event triggered when the effect layer has been disposed.
         */
        this.onDisposeObservable = new Observable();
        /**
         * An event triggered when the effect layer is about rendering the main texture with the glowy parts.
         */
        this.onBeforeRenderMainTextureObservable = new Observable();
        /**
         * An event triggered when the generated texture is being merged in the scene.
         */
        this.onBeforeComposeObservable = new Observable();
        /**
         * An event triggered when the generated texture has been merged in the scene.
         */
        this.onAfterComposeObservable = new Observable();
        /**
         * An event triggered when the efffect layer changes its size.
         */
        this.onSizeChangedObservable = new Observable();
        this.name = name;
        this._scene = scene || EngineStore.LastCreatedScene;
        EffectLayer._SceneComponentInitialization(this._scene);
        this._engine = this._scene.getEngine();
        this._maxSize = this._engine.getCaps().maxTextureSize;
        this._scene.effectLayers.push(this);
        // Generate Buffers
        this._generateIndexBuffer();
        this._generateVertexBuffer();
    }
    Object.defineProperty(EffectLayer.prototype, "camera", {
        /**
         * Gets the camera attached to the layer.
         */
        get: function () {
            return this._effectLayerOptions.camera;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectLayer.prototype, "renderingGroupId", {
        /**
         * Gets the rendering group id the layer should render in.
         */
        get: function () {
            return this._effectLayerOptions.renderingGroupId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initializes the effect layer with the required options.
     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)
     */
    EffectLayer.prototype._init = function (options) {
        // Adapt options
        this._effectLayerOptions = __assign({ mainTextureRatio: 0.5, alphaBlendingMode: Constants.ALPHA_COMBINE, camera: null, renderingGroupId: -1 }, options);
        this._setMainTextureSize();
        this._createMainTexture();
        this._createTextureAndPostProcesses();
        this._mergeEffect = this._createMergeEffect();
    };
    /**
     * Generates the index buffer of the full screen quad blending to the main canvas.
     */
    EffectLayer.prototype._generateIndexBuffer = function () {
        // Indices
        var indices = [];
        indices.push(0);
        indices.push(1);
        indices.push(2);
        indices.push(0);
        indices.push(2);
        indices.push(3);
        this._indexBuffer = this._engine.createIndexBuffer(indices);
    };
    /**
     * Generates the vertex buffer of the full screen quad blending to the main canvas.
     */
    EffectLayer.prototype._generateVertexBuffer = function () {
        // VBO
        var vertices = [];
        vertices.push(1, 1);
        vertices.push(-1, 1);
        vertices.push(-1, -1);
        vertices.push(1, -1);
        var vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);
        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
    };
    /**
     * Sets the main texture desired size which is the closest power of two
     * of the engine canvas size.
     */
    EffectLayer.prototype._setMainTextureSize = function () {
        if (this._effectLayerOptions.mainTextureFixedSize) {
            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;
            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;
        }
        else {
            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;
            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;
            this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Tools.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;
            this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Tools.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;
        }
        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);
        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);
    };
    /**
     * Creates the main texture for the effect layer.
     */
    EffectLayer.prototype._createMainTexture = function () {
        var _this = this;
        this._mainTexture = new RenderTargetTexture("HighlightLayerMainRTT", {
            width: this._mainTextureDesiredSize.width,
            height: this._mainTextureDesiredSize.height
        }, this._scene, false, true, Constants.TEXTURETYPE_UNSIGNED_INT);
        this._mainTexture.activeCamera = this._effectLayerOptions.camera;
        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._mainTexture.anisotropicFilteringLevel = 1;
        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._mainTexture.renderParticles = false;
        this._mainTexture.renderList = null;
        this._mainTexture.ignoreCameraViewport = true;
        // Custom render function
        this._mainTexture.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
            _this.onBeforeRenderMainTextureObservable.notifyObservers(_this);
            var index;
            var engine = _this._scene.getEngine();
            if (depthOnlySubMeshes.length) {
                engine.setColorWrite(false);
                for (index = 0; index < depthOnlySubMeshes.length; index++) {
                    _this._renderSubMesh(depthOnlySubMeshes.data[index]);
                }
                engine.setColorWrite(true);
            }
            for (index = 0; index < opaqueSubMeshes.length; index++) {
                _this._renderSubMesh(opaqueSubMeshes.data[index]);
            }
            for (index = 0; index < alphaTestSubMeshes.length; index++) {
                _this._renderSubMesh(alphaTestSubMeshes.data[index]);
            }
            var previousAlphaMode = engine.getAlphaMode();
            for (index = 0; index < transparentSubMeshes.length; index++) {
                _this._renderSubMesh(transparentSubMeshes.data[index], true);
            }
            engine.setAlphaMode(previousAlphaMode);
        };
        this._mainTexture.onClearObservable.add(function (engine) {
            engine.clear(_this.neutralColor, true, true, true);
        });
    };
    /**
     * Adds specific effects defines.
     * @param defines The defines to add specifics to.
     */
    EffectLayer.prototype._addCustomEffectDefines = function (defines) {
        // Nothing to add by default.
    };
    /**
     * Checks for the readiness of the element composing the layer.
     * @param subMesh the mesh to check for
     * @param useInstances specify wether or not to use instances to render the mesh
     * @param emissiveTexture the associated emissive texture used to generate the glow
     * @return true if ready otherwise, false
     */
    EffectLayer.prototype._isReady = function (subMesh, useInstances, emissiveTexture) {
        var material = subMesh.getMaterial();
        if (!material) {
            return false;
        }
        if (!material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {
            return false;
        }
        var defines = [];
        var attribs = [VertexBuffer.PositionKind];
        var mesh = subMesh.getMesh();
        var uv1 = false;
        var uv2 = false;
        // Diffuse
        if (material) {
            var needAlphaTest = material.needAlphaTesting();
            var diffuseTexture = material.getAlphaTestTexture();
            var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha &&
                (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);
            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {
                defines.push("#define DIFFUSE");
                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) &&
                    diffuseTexture.coordinatesIndex === 1) {
                    defines.push("#define DIFFUSEUV2");
                    uv2 = true;
                }
                else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                    defines.push("#define DIFFUSEUV1");
                    uv1 = true;
                }
                if (needAlphaTest) {
                    defines.push("#define ALPHATEST");
                    defines.push("#define ALPHATESTVALUE 0.4");
                }
            }
            var opacityTexture = material.opacityTexture;
            if (opacityTexture) {
                defines.push("#define OPACITY");
                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) &&
                    opacityTexture.coordinatesIndex === 1) {
                    defines.push("#define OPACITYUV2");
                    uv2 = true;
                }
                else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                    defines.push("#define OPACITYUV1");
                    uv1 = true;
                }
            }
        }
        // Emissive
        if (emissiveTexture) {
            defines.push("#define EMISSIVE");
            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) &&
                emissiveTexture.coordinatesIndex === 1) {
                defines.push("#define EMISSIVEUV2");
                uv2 = true;
            }
            else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                defines.push("#define EMISSIVEUV1");
                uv1 = true;
            }
        }
        // Vertex
        if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha) {
            attribs.push(VertexBuffer.ColorKind);
            defines.push("#define VERTEXALPHA");
        }
        if (uv1) {
            attribs.push(VertexBuffer.UVKind);
            defines.push("#define UV1");
        }
        if (uv2) {
            attribs.push(VertexBuffer.UV2Kind);
            defines.push("#define UV2");
        }
        // Bones
        if (mesh.useBones && mesh.computeBonesUsingShaders) {
            attribs.push(VertexBuffer.MatricesIndicesKind);
            attribs.push(VertexBuffer.MatricesWeightsKind);
            if (mesh.numBoneInfluencers > 4) {
                attribs.push(VertexBuffer.MatricesIndicesExtraKind);
                attribs.push(VertexBuffer.MatricesWeightsExtraKind);
            }
            defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
            defines.push("#define BonesPerMesh " + (mesh.skeleton ? (mesh.skeleton.bones.length + 1) : 0));
        }
        else {
            defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        // Morph targets
        var manager = mesh.morphTargetManager;
        var morphInfluencers = 0;
        if (manager) {
            if (manager.numInfluencers > 0) {
                defines.push("#define MORPHTARGETS");
                morphInfluencers = manager.numInfluencers;
                defines.push("#define NUM_MORPH_INFLUENCERS " + morphInfluencers);
                MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, { "NUM_MORPH_INFLUENCERS": morphInfluencers });
            }
        }
        // Instances
        if (useInstances) {
            defines.push("#define INSTANCES");
            attribs.push("world0");
            attribs.push("world1");
            attribs.push("world2");
            attribs.push("world3");
        }
        this._addCustomEffectDefines(defines);
        // Get correct effect
        var join = defines.join("\n");
        if (this._cachedDefines !== join) {
            this._cachedDefines = join;
            this._effectLayerMapGenerationEffect = this._scene.getEngine().createEffect("glowMapGeneration", attribs, ["world", "mBones", "viewProjection",
                "glowColor", "morphTargetInfluences",
                "diffuseMatrix", "emissiveMatrix", "opacityMatrix", "opacityIntensity"], ["diffuseSampler", "emissiveSampler", "opacitySampler"], join, undefined, undefined, undefined, { maxSimultaneousMorphTargets: morphInfluencers });
        }
        return this._effectLayerMapGenerationEffect.isReady();
    };
    /**
     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.
     */
    EffectLayer.prototype.render = function () {
        var currentEffect = this._mergeEffect;
        // Check
        if (!currentEffect.isReady()) {
            return;
        }
        for (var i = 0; i < this._postProcesses.length; i++) {
            if (!this._postProcesses[i].isReady()) {
                return;
            }
        }
        var engine = this._scene.getEngine();
        this.onBeforeComposeObservable.notifyObservers(this);
        // Render
        engine.enableEffect(currentEffect);
        engine.setState(false);
        // VBOs
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);
        // Cache
        var previousAlphaMode = engine.getAlphaMode();
        // Go Blend.
        engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);
        // Blends the map on the main canvas.
        this._internalRender(currentEffect);
        // Restore Alpha
        engine.setAlphaMode(previousAlphaMode);
        this.onAfterComposeObservable.notifyObservers(this);
        // Handle size changes.
        var size = this._mainTexture.getSize();
        this._setMainTextureSize();
        if (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) {
            // Recreate RTT and post processes on size change.
            this.onSizeChangedObservable.notifyObservers(this);
            this._disposeTextureAndPostProcesses();
            this._createMainTexture();
            this._createTextureAndPostProcesses();
        }
    };
    /**
     * Determine if a given mesh will be used in the current effect.
     * @param mesh mesh to test
     * @returns true if the mesh will be used
     */
    EffectLayer.prototype.hasMesh = function (mesh) {
        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {
            return true;
        }
        return false;
    };
    /**
     * Returns true if the layer contains information to display, otherwise false.
     * @returns true if the glow layer should be rendered
     */
    EffectLayer.prototype.shouldRender = function () {
        return this.isEnabled && this._shouldRender;
    };
    /**
     * Returns true if the mesh should render, otherwise false.
     * @param mesh The mesh to render
     * @returns true if it should render otherwise false
     */
    EffectLayer.prototype._shouldRenderMesh = function (mesh) {
        return true;
    };
    /**
     * Returns true if the mesh can be rendered, otherwise false.
     * @param mesh The mesh to render
     * @param material The material used on the mesh
     * @returns true if it can be rendered otherwise false
     */
    EffectLayer.prototype._canRenderMesh = function (mesh, material) {
        return !material.needAlphaBlendingForMesh(mesh);
    };
    /**
     * Returns true if the mesh should render, otherwise false.
     * @param mesh The mesh to render
     * @returns true if it should render otherwise false
     */
    EffectLayer.prototype._shouldRenderEmissiveTextureForMesh = function () {
        return true;
    };
    /**
     * Renders the submesh passed in parameter to the generation map.
     */
    EffectLayer.prototype._renderSubMesh = function (subMesh, enableAlphaMode) {
        var _this = this;
        if (enableAlphaMode === void 0) { enableAlphaMode = false; }
        if (!this.shouldRender()) {
            return;
        }
        var material = subMesh.getMaterial();
        var mesh = subMesh.getRenderingMesh();
        var scene = this._scene;
        var engine = scene.getEngine();
        mesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        if (!material) {
            return;
        }
        // Do not block in blend mode.
        if (!this._canRenderMesh(mesh, material)) {
            return;
        }
        // Culling
        engine.setState(material.backFaceCulling);
        // Managing instances
        var batch = mesh._getInstancesRenderList(subMesh._id);
        if (batch.mustReturn) {
            return;
        }
        // Early Exit per mesh
        if (!this._shouldRenderMesh(mesh)) {
            return;
        }
        var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id];
        this._setEmissiveTextureAndColor(mesh, subMesh, material);
        if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {
            engine.enableEffect(this._effectLayerMapGenerationEffect);
            mesh._bind(subMesh, this._effectLayerMapGenerationEffect, Material.TriangleFillMode);
            this._effectLayerMapGenerationEffect.setMatrix("viewProjection", scene.getTransformMatrix());
            this._effectLayerMapGenerationEffect.setFloat4("glowColor", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);
            var needAlphaTest = material.needAlphaTesting();
            var diffuseTexture = material.getAlphaTestTexture();
            var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha &&
                (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);
            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {
                this._effectLayerMapGenerationEffect.setTexture("diffuseSampler", diffuseTexture);
                var textureMatrix = diffuseTexture.getTextureMatrix();
                if (textureMatrix) {
                    this._effectLayerMapGenerationEffect.setMatrix("diffuseMatrix", textureMatrix);
                }
            }
            var opacityTexture = material.opacityTexture;
            if (opacityTexture) {
                this._effectLayerMapGenerationEffect.setTexture("opacitySampler", opacityTexture);
                this._effectLayerMapGenerationEffect.setFloat("opacityIntensity", opacityTexture.level);
                var textureMatrix = opacityTexture.getTextureMatrix();
                if (textureMatrix) {
                    this._effectLayerMapGenerationEffect.setMatrix("opacityMatrix", textureMatrix);
                }
            }
            // Glow emissive only
            if (this._emissiveTextureAndColor.texture) {
                this._effectLayerMapGenerationEffect.setTexture("emissiveSampler", this._emissiveTextureAndColor.texture);
                this._effectLayerMapGenerationEffect.setMatrix("emissiveMatrix", this._emissiveTextureAndColor.texture.getTextureMatrix());
            }
            // Bones
            if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
                this._effectLayerMapGenerationEffect.setMatrices("mBones", mesh.skeleton.getTransformMatrices(mesh));
            }
            // Morph targets
            MaterialHelper.BindMorphTargetParameters(mesh, this._effectLayerMapGenerationEffect);
            // Alpha mode
            if (enableAlphaMode) {
                engine.setAlphaMode(material.alphaMode);
            }
            // Draw
            mesh._processRendering(subMesh, this._effectLayerMapGenerationEffect, Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return _this._effectLayerMapGenerationEffect.setMatrix("world", world); });
        }
        else {
            // Need to reset refresh rate of the main map
            this._mainTexture.resetRefreshCounter();
        }
    };
    /**
     * Rebuild the required buffers.
     * @hidden Internal use only.
     */
    EffectLayer.prototype._rebuild = function () {
        var vb = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vb) {
            vb._rebuild();
        }
        this._generateIndexBuffer();
    };
    /**
     * Dispose only the render target textures and post process.
     */
    EffectLayer.prototype._disposeTextureAndPostProcesses = function () {
        this._mainTexture.dispose();
        for (var i = 0; i < this._postProcesses.length; i++) {
            if (this._postProcesses[i]) {
                this._postProcesses[i].dispose();
            }
        }
        this._postProcesses = [];
        for (var i = 0; i < this._textures.length; i++) {
            if (this._textures[i]) {
                this._textures[i].dispose();
            }
        }
        this._textures = [];
    };
    /**
     * Dispose the highlight layer and free resources.
     */
    EffectLayer.prototype.dispose = function () {
        var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vertexBuffer) {
            vertexBuffer.dispose();
            this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        if (this._indexBuffer) {
            this._scene.getEngine()._releaseBuffer(this._indexBuffer);
            this._indexBuffer = null;
        }
        // Clean textures and post processes
        this._disposeTextureAndPostProcesses();
        // Remove from scene
        var index = this._scene.effectLayers.indexOf(this, 0);
        if (index > -1) {
            this._scene.effectLayers.splice(index, 1);
        }
        // Callback
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.onBeforeRenderMainTextureObservable.clear();
        this.onBeforeComposeObservable.clear();
        this.onAfterComposeObservable.clear();
        this.onSizeChangedObservable.clear();
    };
    /**
      * Gets the class name of the effect layer
      * @returns the string with the class name of the effect layer
      */
    EffectLayer.prototype.getClassName = function () {
        return "EffectLayer";
    };
    /**
     * Creates an effect layer from parsed effect layer data
     * @param parsedEffectLayer defines effect layer data
     * @param scene defines the current scene
     * @param rootUrl defines the root URL containing the effect layer information
     * @returns a parsed effect Layer
     */
    EffectLayer.Parse = function (parsedEffectLayer, scene, rootUrl) {
        var effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);
        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);
    };
    /** @hidden */
    EffectLayer._SceneComponentInitialization = function (_) {
        throw _DevTools.WarnImport("EffectLayerSceneComponent");
    };
    __decorate([
        serialize()
    ], EffectLayer.prototype, "name", void 0);
    __decorate([
        serializeAsColor4()
    ], EffectLayer.prototype, "neutralColor", void 0);
    __decorate([
        serialize()
    ], EffectLayer.prototype, "isEnabled", void 0);
    __decorate([
        serializeAsCameraReference()
    ], EffectLayer.prototype, "camera", null);
    __decorate([
        serialize()
    ], EffectLayer.prototype, "renderingGroupId", null);
    return EffectLayer;
}());

// Adds the parser to the scene parsers.
AbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, function (parsedData, scene, container, rootUrl) {
    if (parsedData.effectLayers) {
        if (!container.effectLayers) {
            container.effectLayers = new Array();
        }
        for (var index = 0; index < parsedData.effectLayers.length; index++) {
            var effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);
            container.effectLayers.push(effectLayer);
        }
    }
});
AbstractScene.prototype.removeEffectLayer = function (toRemove) {
    var index = this.effectLayers.indexOf(toRemove);
    if (index !== -1) {
        this.effectLayers.splice(index, 1);
    }
    return index;
};
AbstractScene.prototype.addEffectLayer = function (newEffectLayer) {
    this.effectLayers.push(newEffectLayer);
};
/**
 * Defines the layer scene component responsible to manage any effect layers
 * in a given scene.
 */
var EffectLayerSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function EffectLayerSceneComponent(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_EFFECTLAYER;
        this._renderEffects = false;
        this._needStencil = false;
        this._previousStencilState = false;
        this.scene = scene;
        this._engine = scene.getEngine();
        scene.effectLayers = new Array();
    }
    /**
     * Registers the component in a given scene
     */
    EffectLayerSceneComponent.prototype.register = function () {
        this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);
        this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);
        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);
        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);
        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);
        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    EffectLayerSceneComponent.prototype.rebuild = function () {
        var layers = this.scene.effectLayers;
        for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
            var effectLayer = layers_1[_i];
            effectLayer._rebuild();
        }
    };
    /**
     * Serializes the component data to the specified json object
     * @param serializationObject The object to serialize to
     */
    EffectLayerSceneComponent.prototype.serialize = function (serializationObject) {
        // Effect layers
        serializationObject.effectLayers = [];
        var layers = this.scene.effectLayers;
        for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {
            var effectLayer = layers_2[_i];
            if (effectLayer.serialize) {
                serializationObject.effectLayers.push(effectLayer.serialize());
            }
        }
    };
    /**
     * Adds all the element from the container to the scene
     * @param container the container holding the elements
     */
    EffectLayerSceneComponent.prototype.addFromContainer = function (container) {
        var _this = this;
        if (!container.effectLayers) {
            return;
        }
        container.effectLayers.forEach(function (o) {
            _this.scene.addEffectLayer(o);
        });
    };
    /**
     * Removes all the elements in the container from the scene
     * @param container contains the elements to remove
     * @param dispose if the removed element should be disposed (default: false)
     */
    EffectLayerSceneComponent.prototype.removeFromContainer = function (container, dispose) {
        var _this = this;
        if (!container.effectLayers) {
            return;
        }
        container.effectLayers.forEach(function (o) {
            _this.scene.removeEffectLayer(o);
            if (dispose) {
                o.dispose();
            }
        });
    };
    /**
     * Disposes the component and the associated ressources.
     */
    EffectLayerSceneComponent.prototype.dispose = function () {
        var layers = this.scene.effectLayers;
        while (layers.length) {
            layers[0].dispose();
        }
    };
    EffectLayerSceneComponent.prototype._isReadyForMesh = function (mesh, hardwareInstancedRendering) {
        var layers = this.scene.effectLayers;
        for (var _i = 0, layers_3 = layers; _i < layers_3.length; _i++) {
            var layer = layers_3[_i];
            if (!layer.hasMesh(mesh)) {
                continue;
            }
            for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
                var subMesh = _b[_a];
                if (!layer.isReady(subMesh, hardwareInstancedRendering)) {
                    return false;
                }
            }
        }
        return true;
    };
    EffectLayerSceneComponent.prototype._renderMainTexture = function (camera) {
        this._renderEffects = false;
        this._needStencil = false;
        var needRebind = false;
        var layers = this.scene.effectLayers;
        if (layers && layers.length > 0) {
            this._previousStencilState = this._engine.getStencilBuffer();
            for (var _i = 0, layers_4 = layers; _i < layers_4.length; _i++) {
                var effectLayer = layers_4[_i];
                if (effectLayer.shouldRender() &&
                    (!effectLayer.camera ||
                        (effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera) ||
                        (effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1))) {
                    this._renderEffects = true;
                    this._needStencil = this._needStencil || effectLayer.needStencil();
                    var renderTarget = effectLayer._mainTexture;
                    if (renderTarget._shouldRender()) {
                        this.scene.incrementRenderId();
                        renderTarget.render(false, false);
                        needRebind = true;
                    }
                }
            }
            this.scene.incrementRenderId();
        }
        return needRebind;
    };
    EffectLayerSceneComponent.prototype._setStencil = function () {
        // Activate effect Layer stencil
        if (this._needStencil) {
            this._engine.setStencilBuffer(true);
        }
    };
    EffectLayerSceneComponent.prototype._setStencilBack = function () {
        // Restore effect Layer stencil
        if (this._needStencil) {
            this._engine.setStencilBuffer(this._previousStencilState);
        }
    };
    EffectLayerSceneComponent.prototype._draw = function (renderingGroupId) {
        if (this._renderEffects) {
            this._engine.setDepthBuffer(false);
            var layers = this.scene.effectLayers;
            for (var i = 0; i < layers.length; i++) {
                var effectLayer = layers[i];
                if (effectLayer.renderingGroupId === renderingGroupId) {
                    if (effectLayer.shouldRender()) {
                        effectLayer.render();
                    }
                }
            }
            this._engine.setDepthBuffer(true);
        }
    };
    EffectLayerSceneComponent.prototype._drawCamera = function () {
        if (this._renderEffects) {
            this._draw(-1);
        }
    };
    EffectLayerSceneComponent.prototype._drawRenderingGroup = function (index) {
        if (!this.scene._isInIntermediateRendering() && this._renderEffects) {
            this._draw(index);
        }
    };
    return EffectLayerSceneComponent;
}());
EffectLayer._SceneComponentInitialization = function (scene) {
    var component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);
    if (!component) {
        component = new EffectLayerSceneComponent(scene);
        scene._addComponent(component);
    }
};

var name$m = 'glowMapMergePixelShader';
var shader$m = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n#ifdef EMISSIVE\nuniform sampler2D textureSampler2;\n#endif\n\nuniform float offset;\nvoid main(void) {\nvec4 baseColor=texture2D(textureSampler,vUV);\n#ifdef EMISSIVE\nbaseColor+=texture2D(textureSampler2,vUV);\nbaseColor*=offset;\n#else\nbaseColor.a=abs(offset-baseColor.a);\n#ifdef STROKE\nfloat alpha=smoothstep(.0,.1,baseColor.a);\nbaseColor.a=alpha;\nbaseColor.rgb=baseColor.rgb*alpha;\n#endif\n#endif\ngl_FragColor=baseColor;\n}";
Effect.ShadersStore[name$m] = shader$m;

var name$n = 'glowMapMergeVertexShader';
var shader$n = "\nattribute vec2 position;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvUV=position*madd+madd;\ngl_Position=vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name$n] = shader$n;

AbstractScene.prototype.getGlowLayerByName = function (name) {
    for (var index = 0; index < this.effectLayers.length; index++) {
        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {
            return this.effectLayers[index];
        }
    }
    return null;
};
/**
 * The glow layer Helps adding a glow effect around the emissive parts of a mesh.
 *
 * Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
 * glowy meshes to your scene.
 *
 * Documentation: https://doc.babylonjs.com/how_to/glow_layer
 */
var GlowLayer = /** @class */ (function (_super) {
    __extends(GlowLayer, _super);
    /**
     * Instantiates a new glow Layer and references it to the scene.
     * @param name The name of the layer
     * @param scene The scene to use the layer in
     * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)
     */
    function GlowLayer(name, scene, options) {
        var _this = _super.call(this, name, scene) || this;
        _this._intensity = 1.0;
        _this._includedOnlyMeshes = [];
        _this._excludedMeshes = [];
        _this.neutralColor = new Color4(0, 0, 0, 1);
        // Adapt options
        _this._options = __assign({ mainTextureRatio: GlowLayer.DefaultTextureRatio, blurKernelSize: 32, mainTextureFixedSize: undefined, camera: null, mainTextureSamples: 1, renderingGroupId: -1 }, options);
        // Initialize the layer
        _this._init({
            alphaBlendingMode: Constants.ALPHA_ADD,
            camera: _this._options.camera,
            mainTextureFixedSize: _this._options.mainTextureFixedSize,
            mainTextureRatio: _this._options.mainTextureRatio,
            renderingGroupId: _this._options.renderingGroupId
        });
        return _this;
    }
    Object.defineProperty(GlowLayer.prototype, "blurKernelSize", {
        /**
         * Gets the kernel size of the blur.
         */
        get: function () {
            return this._horizontalBlurPostprocess1.kernel;
        },
        /**
         * Sets the kernel size of the blur.
         */
        set: function (value) {
            this._horizontalBlurPostprocess1.kernel = value;
            this._verticalBlurPostprocess1.kernel = value;
            this._horizontalBlurPostprocess2.kernel = value;
            this._verticalBlurPostprocess2.kernel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GlowLayer.prototype, "intensity", {
        /**
         * Gets the glow intensity.
         */
        get: function () {
            return this._intensity;
        },
        /**
         * Sets the glow intensity.
         */
        set: function (value) {
            this._intensity = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the effect name of the layer.
     * @return The effect name
     */
    GlowLayer.prototype.getEffectName = function () {
        return GlowLayer.EffectName;
    };
    /**
     * Create the merge effect. This is the shader use to blit the information back
     * to the main canvas at the end of the scene rendering.
     */
    GlowLayer.prototype._createMergeEffect = function () {
        // Effect
        return this._engine.createEffect("glowMapMerge", [VertexBuffer.PositionKind], ["offset"], ["textureSampler", "textureSampler2"], "#define EMISSIVE \n");
    };
    /**
     * Creates the render target textures and post processes used in the glow layer.
     */
    GlowLayer.prototype._createTextureAndPostProcesses = function () {
        var _this = this;
        var blurTextureWidth = this._mainTextureDesiredSize.width;
        var blurTextureHeight = this._mainTextureDesiredSize.height;
        blurTextureWidth = this._engine.needPOTTextures ? Tools.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;
        blurTextureHeight = this._engine.needPOTTextures ? Tools.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;
        var textureType = 0;
        if (this._engine.getCaps().textureHalfFloatRender) {
            textureType = Constants.TEXTURETYPE_HALF_FLOAT;
        }
        else {
            textureType = Constants.TEXTURETYPE_UNSIGNED_INT;
        }
        this._blurTexture1 = new RenderTargetTexture("GlowLayerBlurRTT", {
            width: blurTextureWidth,
            height: blurTextureHeight
        }, this._scene, false, true, textureType);
        this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._blurTexture1.renderParticles = false;
        this._blurTexture1.ignoreCameraViewport = true;
        var blurTextureWidth2 = Math.floor(blurTextureWidth / 2);
        var blurTextureHeight2 = Math.floor(blurTextureHeight / 2);
        this._blurTexture2 = new RenderTargetTexture("GlowLayerBlurRTT2", {
            width: blurTextureWidth2,
            height: blurTextureHeight2
        }, this._scene, false, true, textureType);
        this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._blurTexture2.renderParticles = false;
        this._blurTexture2.ignoreCameraViewport = true;
        this._textures = [this._blurTexture1, this._blurTexture2];
        this._horizontalBlurPostprocess1 = new BlurPostProcess("GlowLayerHBP1", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {
            width: blurTextureWidth,
            height: blurTextureHeight
        }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
        this._horizontalBlurPostprocess1.width = blurTextureWidth;
        this._horizontalBlurPostprocess1.height = blurTextureHeight;
        this._horizontalBlurPostprocess1.onApplyObservable.add(function (effect) {
            effect.setTexture("textureSampler", _this._mainTexture);
        });
        this._verticalBlurPostprocess1 = new BlurPostProcess("GlowLayerVBP1", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {
            width: blurTextureWidth,
            height: blurTextureHeight
        }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
        this._horizontalBlurPostprocess2 = new BlurPostProcess("GlowLayerHBP2", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {
            width: blurTextureWidth2,
            height: blurTextureHeight2
        }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
        this._horizontalBlurPostprocess2.width = blurTextureWidth2;
        this._horizontalBlurPostprocess2.height = blurTextureHeight2;
        this._horizontalBlurPostprocess2.onApplyObservable.add(function (effect) {
            effect.setTexture("textureSampler", _this._blurTexture1);
        });
        this._verticalBlurPostprocess2 = new BlurPostProcess("GlowLayerVBP2", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {
            width: blurTextureWidth2,
            height: blurTextureHeight2
        }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];
        this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];
        this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];
        this._mainTexture.samples = this._options.mainTextureSamples;
        this._mainTexture.onAfterUnbindObservable.add(function () {
            var internalTexture = _this._blurTexture1.getInternalTexture();
            if (internalTexture) {
                _this._scene.postProcessManager.directRender(_this._postProcesses1, internalTexture, true);
                internalTexture = _this._blurTexture2.getInternalTexture();
                if (internalTexture) {
                    _this._scene.postProcessManager.directRender(_this._postProcesses2, internalTexture, true);
                }
            }
        });
        // Prevent autoClear.
        this._postProcesses.map(function (pp) { pp.autoClear = false; });
    };
    /**
     * Checks for the readiness of the element composing the layer.
     * @param subMesh the mesh to check for
     * @param useInstances specify wether or not to use instances to render the mesh
     * @param emissiveTexture the associated emissive texture used to generate the glow
     * @return true if ready otherwise, false
     */
    GlowLayer.prototype.isReady = function (subMesh, useInstances) {
        var material = subMesh.getMaterial();
        var mesh = subMesh.getRenderingMesh();
        if (!material || !mesh) {
            return false;
        }
        var emissiveTexture = material.emissiveTexture;
        return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);
    };
    /**
     * Returns wether or nood the layer needs stencil enabled during the mesh rendering.
     */
    GlowLayer.prototype.needStencil = function () {
        return false;
    };
    /**
     * Returns true if the mesh can be rendered, otherwise false.
     * @param mesh The mesh to render
     * @param material The material used on the mesh
     * @returns true if it can be rendered otherwise false
     */
    GlowLayer.prototype._canRenderMesh = function (mesh, material) {
        return true;
    };
    /**
     * Implementation specific of rendering the generating effect on the main canvas.
     * @param effect The effect used to render through
     */
    GlowLayer.prototype._internalRender = function (effect) {
        // Texture
        effect.setTexture("textureSampler", this._blurTexture1);
        effect.setTexture("textureSampler2", this._blurTexture2);
        effect.setFloat("offset", this._intensity);
        // Cache
        var engine = this._engine;
        var previousStencilBuffer = engine.getStencilBuffer();
        // Draw order
        engine.setStencilBuffer(false);
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        // Draw order
        engine.setStencilBuffer(previousStencilBuffer);
    };
    /**
     * Sets the required values for both the emissive texture and and the main color.
     */
    GlowLayer.prototype._setEmissiveTextureAndColor = function (mesh, subMesh, material) {
        var textureLevel = 1.0;
        if (this.customEmissiveTextureSelector) {
            this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);
        }
        else {
            if (material) {
                this._emissiveTextureAndColor.texture = material.emissiveTexture;
                if (this._emissiveTextureAndColor.texture) {
                    textureLevel = this._emissiveTextureAndColor.texture.level;
                }
            }
            else {
                this._emissiveTextureAndColor.texture = null;
            }
        }
        if (this.customEmissiveColorSelector) {
            this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);
        }
        else {
            if (material.emissiveColor) {
                this._emissiveTextureAndColor.color.set(material.emissiveColor.r * textureLevel, material.emissiveColor.g * textureLevel, material.emissiveColor.b * textureLevel, material.alpha);
            }
            else {
                this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);
            }
        }
    };
    /**
     * Returns true if the mesh should render, otherwise false.
     * @param mesh The mesh to render
     * @returns true if it should render otherwise false
     */
    GlowLayer.prototype._shouldRenderMesh = function (mesh) {
        return this.hasMesh(mesh);
    };
    /**
     * Adds specific effects defines.
     * @param defines The defines to add specifics to.
     */
    GlowLayer.prototype._addCustomEffectDefines = function (defines) {
        defines.push("#define GLOW");
    };
    /**
     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.
     * @param mesh The mesh to exclude from the glow layer
     */
    GlowLayer.prototype.addExcludedMesh = function (mesh) {
        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {
            this._excludedMeshes.push(mesh.uniqueId);
        }
    };
    /**
      * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.
      * @param mesh The mesh to remove
      */
    GlowLayer.prototype.removeExcludedMesh = function (mesh) {
        var index = this._excludedMeshes.indexOf(mesh.uniqueId);
        if (index !== -1) {
            this._excludedMeshes.splice(index, 1);
        }
    };
    /**
     * Add a mesh in the inclusion list to impact or being impacted by the glow layer.
     * @param mesh The mesh to include in the glow layer
     */
    GlowLayer.prototype.addIncludedOnlyMesh = function (mesh) {
        if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {
            this._includedOnlyMeshes.push(mesh.uniqueId);
        }
    };
    /**
      * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.
      * @param mesh The mesh to remove
      */
    GlowLayer.prototype.removeIncludedOnlyMesh = function (mesh) {
        var index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);
        if (index !== -1) {
            this._includedOnlyMeshes.splice(index, 1);
        }
    };
    /**
     * Determine if a given mesh will be used in the glow layer
     * @param mesh The mesh to test
     * @returns true if the mesh will be highlighted by the current glow layer
     */
    GlowLayer.prototype.hasMesh = function (mesh) {
        if (!_super.prototype.hasMesh.call(this, mesh)) {
            return false;
        }
        // Included Mesh
        if (this._includedOnlyMeshes.length) {
            return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;
        }
        // Excluded Mesh
        if (this._excludedMeshes.length) {
            return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;
        }
        return true;
    };
    /**
     * Free any resources and references associated to a mesh.
     * Internal use
     * @param mesh The mesh to free.
     * @hidden
     */
    GlowLayer.prototype._disposeMesh = function (mesh) {
        this.removeIncludedOnlyMesh(mesh);
        this.removeExcludedMesh(mesh);
    };
    /**
      * Gets the class name of the effect layer
      * @returns the string with the class name of the effect layer
      */
    GlowLayer.prototype.getClassName = function () {
        return "GlowLayer";
    };
    /**
     * Serializes this glow layer
     * @returns a serialized glow layer object
     */
    GlowLayer.prototype.serialize = function () {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "BABYLON.GlowLayer";
        var index;
        // Included meshes
        serializationObject.includedMeshes = [];
        if (this._includedOnlyMeshes.length) {
            for (index = 0; index < this._includedOnlyMeshes.length; index++) {
                var mesh = this._scene.getMeshByUniqueID(this._includedOnlyMeshes[index]);
                if (mesh) {
                    serializationObject.includedMeshes.push(mesh.id);
                }
            }
        }
        // Excluded meshes
        serializationObject.excludedMeshes = [];
        if (this._excludedMeshes.length) {
            for (index = 0; index < this._excludedMeshes.length; index++) {
                var mesh = this._scene.getMeshByUniqueID(this._excludedMeshes[index]);
                if (mesh) {
                    serializationObject.excludedMeshes.push(mesh.id);
                }
            }
        }
        return serializationObject;
    };
    /**
     * Creates a Glow Layer from parsed glow layer data
     * @param parsedGlowLayer defines glow layer data
     * @param scene defines the current scene
     * @param rootUrl defines the root URL containing the glow layer information
     * @returns a parsed Glow Layer
     */
    GlowLayer.Parse = function (parsedGlowLayer, scene, rootUrl) {
        var gl = SerializationHelper.Parse(function () { return new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options); }, parsedGlowLayer, scene, rootUrl);
        var index;
        // Excluded meshes
        for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {
            var mesh = scene.getMeshByID(parsedGlowLayer.excludedMeshes[index]);
            if (mesh) {
                gl.addExcludedMesh(mesh);
            }
        }
        // Included meshes
        for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {
            var mesh = scene.getMeshByID(parsedGlowLayer.includedMeshes[index]);
            if (mesh) {
                gl.addIncludedOnlyMesh(mesh);
            }
        }
        return gl;
    };
    /**
     * Effect Name of the layer.
     */
    GlowLayer.EffectName = "GlowLayer";
    /**
     * The default blur kernel size used for the glow.
     */
    GlowLayer.DefaultBlurKernelSize = 32;
    /**
     * The default texture size ratio used for the glow.
     */
    GlowLayer.DefaultTextureRatio = 0.5;
    __decorate([
        serialize()
    ], GlowLayer.prototype, "blurKernelSize", null);
    __decorate([
        serialize()
    ], GlowLayer.prototype, "intensity", null);
    __decorate([
        serialize("options")
    ], GlowLayer.prototype, "_options", void 0);
    return GlowLayer;
}(EffectLayer));
_TypeStore.RegisteredTypes["BABYLON.GlowLayer"] = GlowLayer;

var name$o = 'glowBlurPostProcessPixelShader';
var shader$o = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nuniform vec2 direction;\nuniform float blurWidth;\n\nfloat getLuminance(vec3 color)\n{\nreturn dot(color,vec3(0.2126,0.7152,0.0722));\n}\nvoid main(void)\n{\nfloat weights[7];\nweights[0]=0.05;\nweights[1]=0.1;\nweights[2]=0.2;\nweights[3]=0.3;\nweights[4]=0.2;\nweights[5]=0.1;\nweights[6]=0.05;\nvec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);\nvec2 texelStep=texelSize*direction*blurWidth;\nvec2 start=vUV-3.0*texelStep;\nvec4 baseColor=vec4(0.,0.,0.,0.);\nvec2 texelOffset=vec2(0.,0.);\nfor (int i=0; i<7; i++)\n{\n\nvec4 texel=texture2D(textureSampler,start+texelOffset);\nbaseColor.a+=texel.a*weights[i];\n\nfloat luminance=getLuminance(baseColor.rgb);\nfloat luminanceTexel=getLuminance(texel.rgb);\nfloat choice=step(luminanceTexel,luminance);\nbaseColor.rgb=choice*baseColor.rgb+(1.0-choice)*texel.rgb;\ntexelOffset+=texelStep;\n}\ngl_FragColor=baseColor;\n}";
Effect.ShadersStore[name$o] = shader$o;

AbstractScene.prototype.getHighlightLayerByName = function (name) {
    for (var index = 0; index < this.effectLayers.length; index++) {
        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {
            return this.effectLayers[index];
        }
    }
    return null;
};
/**
 * Special Glow Blur post process only blurring the alpha channel
 * It enforces keeping the most luminous color in the color channel.
 */
var GlowBlurPostProcess = /** @class */ (function (_super) {
    __extends(GlowBlurPostProcess, _super);
    function GlowBlurPostProcess(name, direction, kernel, options, camera, samplingMode, engine, reusable) {
        if (samplingMode === void 0) { samplingMode = Texture.BILINEAR_SAMPLINGMODE; }
        var _this = _super.call(this, name, "glowBlurPostProcess", ["screenSize", "direction", "blurWidth"], null, options, camera, samplingMode, engine, reusable) || this;
        _this.direction = direction;
        _this.kernel = kernel;
        _this.onApplyObservable.add(function (effect) {
            effect.setFloat2("screenSize", _this.width, _this.height);
            effect.setVector2("direction", _this.direction);
            effect.setFloat("blurWidth", _this.kernel);
        });
        return _this;
    }
    return GlowBlurPostProcess;
}(PostProcess));
/**
 * The highlight layer Helps adding a glow effect around a mesh.
 *
 * Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
 * glowy meshes to your scene.
 *
 * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
 */
var HighlightLayer = /** @class */ (function (_super) {
    __extends(HighlightLayer, _super);
    /**
     * Instantiates a new highlight Layer and references it to the scene..
     * @param name The name of the layer
     * @param scene The scene to use the layer in
     * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)
     */
    function HighlightLayer(name, scene, options) {
        var _this = _super.call(this, name, scene) || this;
        _this.name = name;
        /**
         * Specifies whether or not the inner glow is ACTIVE in the layer.
         */
        _this.innerGlow = true;
        /**
         * Specifies whether or not the outer glow is ACTIVE in the layer.
         */
        _this.outerGlow = true;
        /**
         * An event triggered when the highlight layer is being blurred.
         */
        _this.onBeforeBlurObservable = new Observable();
        /**
         * An event triggered when the highlight layer has been blurred.
         */
        _this.onAfterBlurObservable = new Observable();
        _this._instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;
        _this._meshes = {};
        _this._excludedMeshes = {};
        _this.neutralColor = HighlightLayer.NeutralColor;
        // Warn on stencil
        if (!_this._engine.isStencilEnable) {
            Logger.Warn("Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }");
        }
        // Adapt options
        _this._options = __assign({ mainTextureRatio: 0.5, blurTextureSizeRatio: 0.5, blurHorizontalSize: 1.0, blurVerticalSize: 1.0, alphaBlendingMode: Constants.ALPHA_COMBINE, camera: null, renderingGroupId: -1 }, options);
        // Initialize the layer
        _this._init({
            alphaBlendingMode: _this._options.alphaBlendingMode,
            camera: _this._options.camera,
            mainTextureFixedSize: _this._options.mainTextureFixedSize,
            mainTextureRatio: _this._options.mainTextureRatio,
            renderingGroupId: _this._options.renderingGroupId
        });
        // Do not render as long as no meshes have been added
        _this._shouldRender = false;
        return _this;
    }
    Object.defineProperty(HighlightLayer.prototype, "blurHorizontalSize", {
        /**
         * Gets the horizontal size of the blur.
         */
        get: function () {
            return this._horizontalBlurPostprocess.kernel;
        },
        /**
         * Specifies the horizontal size of the blur.
         */
        set: function (value) {
            this._horizontalBlurPostprocess.kernel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HighlightLayer.prototype, "blurVerticalSize", {
        /**
         * Gets the vertical size of the blur.
         */
        get: function () {
            return this._verticalBlurPostprocess.kernel;
        },
        /**
         * Specifies the vertical size of the blur.
         */
        set: function (value) {
            this._verticalBlurPostprocess.kernel = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the effect name of the layer.
     * @return The effect name
     */
    HighlightLayer.prototype.getEffectName = function () {
        return HighlightLayer.EffectName;
    };
    /**
     * Create the merge effect. This is the shader use to blit the information back
     * to the main canvas at the end of the scene rendering.
     */
    HighlightLayer.prototype._createMergeEffect = function () {
        // Effect
        return this._engine.createEffect("glowMapMerge", [VertexBuffer.PositionKind], ["offset"], ["textureSampler"], this._options.isStroke ? "#define STROKE \n" : undefined);
    };
    /**
     * Creates the render target textures and post processes used in the highlight layer.
     */
    HighlightLayer.prototype._createTextureAndPostProcesses = function () {
        var _this = this;
        var blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;
        var blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;
        blurTextureWidth = this._engine.needPOTTextures ? Tools.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;
        blurTextureHeight = this._engine.needPOTTextures ? Tools.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;
        var textureType = 0;
        if (this._engine.getCaps().textureHalfFloatRender) {
            textureType = Constants.TEXTURETYPE_HALF_FLOAT;
        }
        else {
            textureType = Constants.TEXTURETYPE_UNSIGNED_INT;
        }
        this._blurTexture = new RenderTargetTexture("HighlightLayerBlurRTT", {
            width: blurTextureWidth,
            height: blurTextureHeight
        }, this._scene, false, true, textureType);
        this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture.anisotropicFilteringLevel = 16;
        this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);
        this._blurTexture.renderParticles = false;
        this._blurTexture.ignoreCameraViewport = true;
        this._textures = [this._blurTexture];
        if (this._options.alphaBlendingMode === Constants.ALPHA_COMBINE) {
            this._downSamplePostprocess = new PassPostProcess("HighlightLayerPPP", this._options.blurTextureSizeRatio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());
            this._downSamplePostprocess.onApplyObservable.add(function (effect) {
                effect.setTexture("textureSampler", _this._mainTexture);
            });
            this._horizontalBlurPostprocess = new GlowBlurPostProcess("HighlightLayerHBP", new Vector2(1.0, 0), this._options.blurHorizontalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());
            this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {
                effect.setFloat2("screenSize", blurTextureWidth, blurTextureHeight);
            });
            this._verticalBlurPostprocess = new GlowBlurPostProcess("HighlightLayerVBP", new Vector2(0, 1.0), this._options.blurVerticalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());
            this._verticalBlurPostprocess.onApplyObservable.add(function (effect) {
                effect.setFloat2("screenSize", blurTextureWidth, blurTextureHeight);
            });
            this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];
        }
        else {
            this._horizontalBlurPostprocess = new BlurPostProcess("HighlightLayerHBP", new Vector2(1.0, 0), this._options.blurHorizontalSize / 2, {
                width: blurTextureWidth,
                height: blurTextureHeight
            }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
            this._horizontalBlurPostprocess.width = blurTextureWidth;
            this._horizontalBlurPostprocess.height = blurTextureHeight;
            this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {
                effect.setTexture("textureSampler", _this._mainTexture);
            });
            this._verticalBlurPostprocess = new BlurPostProcess("HighlightLayerVBP", new Vector2(0, 1.0), this._options.blurVerticalSize / 2, {
                width: blurTextureWidth,
                height: blurTextureHeight
            }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);
            this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];
        }
        this._mainTexture.onAfterUnbindObservable.add(function () {
            _this.onBeforeBlurObservable.notifyObservers(_this);
            var internalTexture = _this._blurTexture.getInternalTexture();
            if (internalTexture) {
                _this._scene.postProcessManager.directRender(_this._postProcesses, internalTexture, true);
            }
            _this.onAfterBlurObservable.notifyObservers(_this);
        });
        // Prevent autoClear.
        this._postProcesses.map(function (pp) { pp.autoClear = false; });
    };
    /**
     * Returns wether or nood the layer needs stencil enabled during the mesh rendering.
     */
    HighlightLayer.prototype.needStencil = function () {
        return true;
    };
    /**
     * Checks for the readiness of the element composing the layer.
     * @param subMesh the mesh to check for
     * @param useInstances specify wether or not to use instances to render the mesh
     * @param emissiveTexture the associated emissive texture used to generate the glow
     * @return true if ready otherwise, false
     */
    HighlightLayer.prototype.isReady = function (subMesh, useInstances) {
        var material = subMesh.getMaterial();
        var mesh = subMesh.getRenderingMesh();
        if (!material || !mesh || !this._meshes) {
            return false;
        }
        var emissiveTexture = null;
        var highlightLayerMesh = this._meshes[mesh.uniqueId];
        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {
            emissiveTexture = material.emissiveTexture;
        }
        return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);
    };
    /**
     * Implementation specific of rendering the generating effect on the main canvas.
     * @param effect The effect used to render through
     */
    HighlightLayer.prototype._internalRender = function (effect) {
        // Texture
        effect.setTexture("textureSampler", this._blurTexture);
        // Cache
        var engine = this._engine;
        engine.cacheStencilState();
        // Stencil operations
        engine.setStencilOperationPass(Constants.REPLACE);
        engine.setStencilOperationFail(Constants.KEEP);
        engine.setStencilOperationDepthFail(Constants.KEEP);
        // Draw order
        engine.setStencilMask(0x00);
        engine.setStencilBuffer(true);
        engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);
        // 2 passes inner outer
        if (this.outerGlow) {
            effect.setFloat("offset", 0);
            engine.setStencilFunction(Constants.NOTEQUAL);
            engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        }
        if (this.innerGlow) {
            effect.setFloat("offset", 1);
            engine.setStencilFunction(Constants.EQUAL);
            engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        }
        // Restore Cache
        engine.restoreStencilState();
    };
    /**
     * Returns true if the layer contains information to display, otherwise false.
     */
    HighlightLayer.prototype.shouldRender = function () {
        if (_super.prototype.shouldRender.call(this)) {
            return this._meshes ? true : false;
        }
        return false;
    };
    /**
     * Returns true if the mesh should render, otherwise false.
     * @param mesh The mesh to render
     * @returns true if it should render otherwise false
     */
    HighlightLayer.prototype._shouldRenderMesh = function (mesh) {
        // Excluded Mesh
        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {
            return false;
        }
        if (!_super.prototype.hasMesh.call(this, mesh)) {
            return false;
        }
        return true;
    };
    /**
     * Sets the required values for both the emissive texture and and the main color.
     */
    HighlightLayer.prototype._setEmissiveTextureAndColor = function (mesh, subMesh, material) {
        var highlightLayerMesh = this._meshes[mesh.uniqueId];
        if (highlightLayerMesh) {
            this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);
        }
        else {
            this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);
        }
        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {
            this._emissiveTextureAndColor.texture = material.emissiveTexture;
            this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);
        }
        else {
            this._emissiveTextureAndColor.texture = null;
        }
    };
    /**
     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.
     * @param mesh The mesh to exclude from the highlight layer
     */
    HighlightLayer.prototype.addExcludedMesh = function (mesh) {
        if (!this._excludedMeshes) {
            return;
        }
        var meshExcluded = this._excludedMeshes[mesh.uniqueId];
        if (!meshExcluded) {
            this._excludedMeshes[mesh.uniqueId] = {
                mesh: mesh,
                beforeBind: mesh.onBeforeBindObservable.add(function (mesh) {
                    mesh.getEngine().setStencilBuffer(false);
                }),
                afterRender: mesh.onAfterRenderObservable.add(function (mesh) {
                    mesh.getEngine().setStencilBuffer(true);
                }),
            };
        }
    };
    /**
      * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.
      * @param mesh The mesh to highlight
      */
    HighlightLayer.prototype.removeExcludedMesh = function (mesh) {
        if (!this._excludedMeshes) {
            return;
        }
        var meshExcluded = this._excludedMeshes[mesh.uniqueId];
        if (meshExcluded) {
            if (meshExcluded.beforeBind) {
                mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);
            }
            if (meshExcluded.afterRender) {
                mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);
            }
        }
        this._excludedMeshes[mesh.uniqueId] = null;
    };
    /**
     * Determine if a given mesh will be highlighted by the current HighlightLayer
     * @param mesh mesh to test
     * @returns true if the mesh will be highlighted by the current HighlightLayer
     */
    HighlightLayer.prototype.hasMesh = function (mesh) {
        if (!this._meshes) {
            return false;
        }
        if (!_super.prototype.hasMesh.call(this, mesh)) {
            return false;
        }
        return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;
    };
    /**
     * Add a mesh in the highlight layer in order to make it glow with the chosen color.
     * @param mesh The mesh to highlight
     * @param color The color of the highlight
     * @param glowEmissiveOnly Extract the glow from the emissive texture
     */
    HighlightLayer.prototype.addMesh = function (mesh, color, glowEmissiveOnly) {
        var _this = this;
        if (glowEmissiveOnly === void 0) { glowEmissiveOnly = false; }
        if (!this._meshes) {
            return;
        }
        var meshHighlight = this._meshes[mesh.uniqueId];
        if (meshHighlight) {
            meshHighlight.color = color;
        }
        else {
            this._meshes[mesh.uniqueId] = {
                mesh: mesh,
                color: color,
                // Lambda required for capture due to Observable this context
                observerHighlight: mesh.onBeforeBindObservable.add(function (mesh) {
                    if (_this._excludedMeshes && _this._excludedMeshes[mesh.uniqueId]) {
                        _this._defaultStencilReference(mesh);
                    }
                    else {
                        mesh.getScene().getEngine().setStencilFunctionReference(_this._instanceGlowingMeshStencilReference);
                    }
                }),
                observerDefault: mesh.onAfterRenderObservable.add(this._defaultStencilReference),
                glowEmissiveOnly: glowEmissiveOnly
            };
            mesh.onDisposeObservable.add(function () {
                _this._disposeMesh(mesh);
            });
        }
        this._shouldRender = true;
    };
    /**
     * Remove a mesh from the highlight layer in order to make it stop glowing.
     * @param mesh The mesh to highlight
     */
    HighlightLayer.prototype.removeMesh = function (mesh) {
        if (!this._meshes) {
            return;
        }
        var meshHighlight = this._meshes[mesh.uniqueId];
        if (meshHighlight) {
            if (meshHighlight.observerHighlight) {
                mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);
            }
            if (meshHighlight.observerDefault) {
                mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);
            }
            delete this._meshes[mesh.uniqueId];
        }
        this._shouldRender = false;
        for (var meshHighlightToCheck in this._meshes) {
            if (this._meshes[meshHighlightToCheck]) {
                this._shouldRender = true;
                break;
            }
        }
    };
    /**
     * Force the stencil to the normal expected value for none glowing parts
     */
    HighlightLayer.prototype._defaultStencilReference = function (mesh) {
        mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);
    };
    /**
     * Free any resources and references associated to a mesh.
     * Internal use
     * @param mesh The mesh to free.
     * @hidden
     */
    HighlightLayer.prototype._disposeMesh = function (mesh) {
        this.removeMesh(mesh);
        this.removeExcludedMesh(mesh);
    };
    /**
     * Dispose the highlight layer and free resources.
     */
    HighlightLayer.prototype.dispose = function () {
        if (this._meshes) {
            // Clean mesh references
            for (var id in this._meshes) {
                var meshHighlight = this._meshes[id];
                if (meshHighlight && meshHighlight.mesh) {
                    if (meshHighlight.observerHighlight) {
                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);
                    }
                    if (meshHighlight.observerDefault) {
                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);
                    }
                }
            }
            this._meshes = null;
        }
        if (this._excludedMeshes) {
            for (var id in this._excludedMeshes) {
                var meshHighlight = this._excludedMeshes[id];
                if (meshHighlight) {
                    if (meshHighlight.beforeBind) {
                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);
                    }
                    if (meshHighlight.afterRender) {
                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);
                    }
                }
            }
            this._excludedMeshes = null;
        }
        _super.prototype.dispose.call(this);
    };
    /**
      * Gets the class name of the effect layer
      * @returns the string with the class name of the effect layer
      */
    HighlightLayer.prototype.getClassName = function () {
        return "HighlightLayer";
    };
    /**
     * Serializes this Highlight layer
     * @returns a serialized Highlight layer object
     */
    HighlightLayer.prototype.serialize = function () {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "BABYLON.HighlightLayer";
        // Highlighted meshes
        serializationObject.meshes = [];
        if (this._meshes) {
            for (var m in this._meshes) {
                var mesh = this._meshes[m];
                if (mesh) {
                    serializationObject.meshes.push({
                        glowEmissiveOnly: mesh.glowEmissiveOnly,
                        color: mesh.color.asArray(),
                        meshId: mesh.mesh.id
                    });
                }
            }
        }
        // Excluded meshes
        serializationObject.excludedMeshes = [];
        if (this._excludedMeshes) {
            for (var e in this._excludedMeshes) {
                var excludedMesh = this._excludedMeshes[e];
                if (excludedMesh) {
                    serializationObject.excludedMeshes.push(excludedMesh.mesh.id);
                }
            }
        }
        return serializationObject;
    };
    /**
     * Creates a Highlight layer from parsed Highlight layer data
     * @param parsedHightlightLayer defines the Highlight layer data
     * @param scene defines the current scene
     * @param rootUrl defines the root URL containing the Highlight layer information
     * @returns a parsed Highlight layer
     */
    HighlightLayer.Parse = function (parsedHightlightLayer, scene, rootUrl) {
        var hl = SerializationHelper.Parse(function () { return new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options); }, parsedHightlightLayer, scene, rootUrl);
        var index;
        // Excluded meshes
        for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {
            var mesh = scene.getMeshByID(parsedHightlightLayer.excludedMeshes[index]);
            if (mesh) {
                hl.addExcludedMesh(mesh);
            }
        }
        // Included meshes
        for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {
            var highlightedMesh = parsedHightlightLayer.meshes[index];
            var mesh = scene.getMeshByID(highlightedMesh.meshId);
            if (mesh) {
                hl.addMesh(mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);
            }
        }
        return hl;
    };
    /**
     * Effect Name of the highlight layer.
     */
    HighlightLayer.EffectName = "HighlightLayer";
    /**
     * The neutral color used during the preparation of the glow effect.
     * This is black by default as the blend operation is a blend operation.
     */
    HighlightLayer.NeutralColor = new Color4(0, 0, 0, 0);
    /**
     * Stencil value used for glowing meshes.
     */
    HighlightLayer.GlowingMeshStencilReference = 0x02;
    /**
     * Stencil value used for the other meshes in the scene.
     */
    HighlightLayer.NormalMeshStencilReference = 0x01;
    __decorate([
        serialize()
    ], HighlightLayer.prototype, "innerGlow", void 0);
    __decorate([
        serialize()
    ], HighlightLayer.prototype, "outerGlow", void 0);
    __decorate([
        serialize()
    ], HighlightLayer.prototype, "blurHorizontalSize", null);
    __decorate([
        serialize()
    ], HighlightLayer.prototype, "blurVerticalSize", null);
    __decorate([
        serialize("options")
    ], HighlightLayer.prototype, "_options", void 0);
    return HighlightLayer;
}(EffectLayer));
_TypeStore.RegisteredTypes["BABYLON.HighlightLayer"] = HighlightLayer;

/**
 * This represents one of the lens effect in a `lensFlareSystem`.
 * It controls one of the indiviual texture used in the effect.
 * @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
 */
var LensFlare = /** @class */ (function () {
    /**
     * Instantiates a new Lens Flare.
     * This represents one of the lens effect in a `lensFlareSystem`.
     * It controls one of the indiviual texture used in the effect.
     * @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
     * @param size Define the size of the lens flare in the system (a floating value between 0 and 1)
     * @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
     * @param color Define the lens color
     * @param imgUrl Define the lens texture url
     * @param system Define the `lensFlareSystem` this flare is part of
     */
    function LensFlare(
    /**
     * Define the size of the lens flare in the system (a floating value between 0 and 1)
     */
    size, 
    /**
     * Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
     */
    position, color, imgUrl, system) {
        this.size = size;
        this.position = position;
        /**
         * Define the alpha mode to render this particular lens.
         */
        this.alphaMode = Constants.ALPHA_ONEONE;
        this.color = color || new Color3(1, 1, 1);
        this.texture = imgUrl ? new Texture(imgUrl, system.getScene(), true) : null;
        this._system = system;
        system.lensFlares.push(this);
    }
    /**
     * Creates a new Lens Flare.
     * This represents one of the lens effect in a `lensFlareSystem`.
     * It controls one of the indiviual texture used in the effect.
     * @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
     * @param size Define the size of the lens flare (a floating value between 0 and 1)
     * @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
     * @param color Define the lens color
     * @param imgUrl Define the lens texture url
     * @param system Define the `lensFlareSystem` this flare is part of
     * @returns The newly created Lens Flare
     */
    LensFlare.AddFlare = function (size, position, color, imgUrl, system) {
        return new LensFlare(size, position, color, imgUrl, system);
    };
    /**
     * Dispose and release the lens flare with its associated resources.
     */
    LensFlare.prototype.dispose = function () {
        if (this.texture) {
            this.texture.dispose();
        }
        // Remove from scene
        var index = this._system.lensFlares.indexOf(this);
        this._system.lensFlares.splice(index, 1);
    };
    return LensFlare;
}());

var name$p = 'lensFlarePixelShader';
var shader$p = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec4 color;\nvoid main(void) {\nvec4 baseColor=texture2D(textureSampler,vUV);\ngl_FragColor=baseColor*color;\n}";
Effect.ShadersStore[name$p] = shader$p;

var name$q = 'lensFlareVertexShader';
var shader$q = "\nattribute vec2 position;\n\nuniform mat4 viewportMatrix;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvUV=position*madd+madd;\ngl_Position=viewportMatrix*vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name$q] = shader$q;

/**
 * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.
 * It is usually composed of several `lensFlare`.
 * @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
 */
var LensFlareSystem = /** @class */ (function () {
    /**
     * Instantiates a lens flare system.
     * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.
     * It is usually composed of several `lensFlare`.
     * @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
     * @param name Define the name of the lens flare system in the scene
     * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).
     * @param scene Define the scene the lens flare system belongs to
     */
    function LensFlareSystem(
    /**
     * Define the name of the lens flare system
     */
    name, emitter, scene) {
        this.name = name;
        /**
         * List of lens flares used in this system.
         */
        this.lensFlares = new Array();
        /**
         * Define a limit from the border the lens flare can be visible.
         */
        this.borderLimit = 300;
        /**
         * Define a viewport border we do not want to see the lens flare in.
         */
        this.viewportBorder = 0;
        /**
         * Restricts the rendering of the effect to only the camera rendering this layer mask.
         */
        this.layerMask = 0x0FFFFFFF;
        this._vertexBuffers = {};
        this._isEnabled = true;
        this._scene = scene || EngineStore.LastCreatedScene;
        LensFlareSystem._SceneComponentInitialization(this._scene);
        this._emitter = emitter;
        this.id = name;
        scene.lensFlareSystems.push(this);
        this.meshesSelectionPredicate = function (m) { return (scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && ((m.layerMask & scene.activeCamera.layerMask) != 0)); };
        var engine = scene.getEngine();
        // VBO
        var vertices = [];
        vertices.push(1, 1);
        vertices.push(-1, 1);
        vertices.push(-1, -1);
        vertices.push(1, -1);
        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);
        // Indices
        var indices = [];
        indices.push(0);
        indices.push(1);
        indices.push(2);
        indices.push(0);
        indices.push(2);
        indices.push(3);
        this._indexBuffer = engine.createIndexBuffer(indices);
        // Effects
        this._effect = engine.createEffect("lensFlare", [VertexBuffer.PositionKind], ["color", "viewportMatrix"], ["textureSampler"], "");
    }
    Object.defineProperty(LensFlareSystem.prototype, "isEnabled", {
        /**
         * Define if the lens flare system is enabled.
         */
        get: function () {
            return this._isEnabled;
        },
        set: function (value) {
            this._isEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the scene the effects belongs to.
     * @returns the scene holding the lens flare system
     */
    LensFlareSystem.prototype.getScene = function () {
        return this._scene;
    };
    /**
     * Get the emitter of the lens flare system.
     * It defines the source of the lens flares (it can be a camera, a light or a mesh).
     * @returns the emitter of the lens flare system
     */
    LensFlareSystem.prototype.getEmitter = function () {
        return this._emitter;
    };
    /**
     * Set the emitter of the lens flare system.
     * It defines the source of the lens flares (it can be a camera, a light or a mesh).
     * @param newEmitter Define the new emitter of the system
     */
    LensFlareSystem.prototype.setEmitter = function (newEmitter) {
        this._emitter = newEmitter;
    };
    /**
     * Get the lens flare system emitter position.
     * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).
     * @returns the position
     */
    LensFlareSystem.prototype.getEmitterPosition = function () {
        return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;
    };
    /**
     * @hidden
     */
    LensFlareSystem.prototype.computeEffectivePosition = function (globalViewport) {
        var position = this.getEmitterPosition();
        position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);
        this._positionX = position.x;
        this._positionY = position.y;
        position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());
        if (this.viewportBorder > 0) {
            globalViewport.x -= this.viewportBorder;
            globalViewport.y -= this.viewportBorder;
            globalViewport.width += this.viewportBorder * 2;
            globalViewport.height += this.viewportBorder * 2;
            position.x += this.viewportBorder;
            position.y += this.viewportBorder;
            this._positionX += this.viewportBorder;
            this._positionY += this.viewportBorder;
        }
        if (position.z > 0) {
            if ((this._positionX > globalViewport.x) && (this._positionX < globalViewport.x + globalViewport.width)) {
                if ((this._positionY > globalViewport.y) && (this._positionY < globalViewport.y + globalViewport.height)) {
                    return true;
                }
            }
            return true;
        }
        return false;
    };
    /** @hidden */
    LensFlareSystem.prototype._isVisible = function () {
        if (!this._isEnabled || !this._scene.activeCamera) {
            return false;
        }
        var emitterPosition = this.getEmitterPosition();
        var direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);
        var distance = direction.length();
        direction.normalize();
        var ray = new Ray(this._scene.activeCamera.globalPosition, direction);
        var pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);
        return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;
    };
    /**
     * @hidden
     */
    LensFlareSystem.prototype.render = function () {
        if (!this._effect.isReady() || !this._scene.activeCamera) {
            return false;
        }
        var engine = this._scene.getEngine();
        var viewport = this._scene.activeCamera.viewport;
        var globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));
        // Position
        if (!this.computeEffectivePosition(globalViewport)) {
            return false;
        }
        // Visibility
        if (!this._isVisible()) {
            return false;
        }
        // Intensity
        var awayX;
        var awayY;
        if (this._positionX < this.borderLimit + globalViewport.x) {
            awayX = this.borderLimit + globalViewport.x - this._positionX;
        }
        else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {
            awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;
        }
        else {
            awayX = 0;
        }
        if (this._positionY < this.borderLimit + globalViewport.y) {
            awayY = this.borderLimit + globalViewport.y - this._positionY;
        }
        else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {
            awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;
        }
        else {
            awayY = 0;
        }
        var away = (awayX > awayY) ? awayX : awayY;
        away -= this.viewportBorder;
        if (away > this.borderLimit) {
            away = this.borderLimit;
        }
        var intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);
        if (intensity < 0) {
            return false;
        }
        if (intensity > 1.0) {
            intensity = 1.0;
        }
        if (this.viewportBorder > 0) {
            globalViewport.x += this.viewportBorder;
            globalViewport.y += this.viewportBorder;
            globalViewport.width -= this.viewportBorder * 2;
            globalViewport.height -= this.viewportBorder * 2;
            this._positionX -= this.viewportBorder;
            this._positionY -= this.viewportBorder;
        }
        // Position
        var centerX = globalViewport.x + globalViewport.width / 2;
        var centerY = globalViewport.y + globalViewport.height / 2;
        var distX = centerX - this._positionX;
        var distY = centerY - this._positionY;
        // Effects
        engine.enableEffect(this._effect);
        engine.setState(false);
        engine.setDepthBuffer(false);
        // VBOs
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);
        // Flares
        for (var index = 0; index < this.lensFlares.length; index++) {
            var flare = this.lensFlares[index];
            engine.setAlphaMode(flare.alphaMode);
            var x = centerX - (distX * flare.position);
            var y = centerY - (distY * flare.position);
            var cw = flare.size;
            var ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);
            var cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;
            var cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));
            var viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);
            this._effect.setMatrix("viewportMatrix", viewportMatrix);
            // Texture
            this._effect.setTexture("textureSampler", flare.texture);
            // Color
            this._effect.setFloat4("color", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);
            // Draw order
            engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        }
        engine.setDepthBuffer(true);
        engine.setAlphaMode(Constants.ALPHA_DISABLE);
        return true;
    };
    /**
     * Dispose and release the lens flare with its associated resources.
     */
    LensFlareSystem.prototype.dispose = function () {
        var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vertexBuffer) {
            vertexBuffer.dispose();
            this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        if (this._indexBuffer) {
            this._scene.getEngine()._releaseBuffer(this._indexBuffer);
            this._indexBuffer = null;
        }
        while (this.lensFlares.length) {
            this.lensFlares[0].dispose();
        }
        // Remove from scene
        var index = this._scene.lensFlareSystems.indexOf(this);
        this._scene.lensFlareSystems.splice(index, 1);
    };
    /**
     * Parse a lens flare system from a JSON repressentation
     * @param parsedLensFlareSystem Define the JSON to parse
     * @param scene Define the scene the parsed system should be instantiated in
     * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures
     * @returns the parsed system
     */
    LensFlareSystem.Parse = function (parsedLensFlareSystem, scene, rootUrl) {
        var emitter = scene.getLastEntryByID(parsedLensFlareSystem.emitterId);
        var name = parsedLensFlareSystem.name || "lensFlareSystem#" + parsedLensFlareSystem.emitterId;
        var lensFlareSystem = new LensFlareSystem(name, emitter, scene);
        lensFlareSystem.id = parsedLensFlareSystem.id || name;
        lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;
        for (var index = 0; index < parsedLensFlareSystem.flares.length; index++) {
            var parsedFlare = parsedLensFlareSystem.flares[index];
            LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : "", lensFlareSystem);
        }
        return lensFlareSystem;
    };
    /**
     * Serialize the current Lens Flare System into a JSON representation.
     * @returns the serialized JSON
     */
    LensFlareSystem.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.id = this.id;
        serializationObject.name = this.name;
        serializationObject.emitterId = this.getEmitter().id;
        serializationObject.borderLimit = this.borderLimit;
        serializationObject.flares = [];
        for (var index = 0; index < this.lensFlares.length; index++) {
            var flare = this.lensFlares[index];
            serializationObject.flares.push({
                size: flare.size,
                position: flare.position,
                color: flare.color.asArray(),
                textureName: Tools.GetFilename(flare.texture ? flare.texture.name : "")
            });
        }
        return serializationObject;
    };
    /** @hidden */
    LensFlareSystem._SceneComponentInitialization = function (_) {
        throw _DevTools.WarnImport("LensFlareSystemSceneComponent");
    };
    return LensFlareSystem;
}());

// Adds the parser to the scene parsers.
AbstractScene.AddParser(SceneComponentConstants.NAME_LENSFLARESYSTEM, function (parsedData, scene, container, rootUrl) {
    // Lens flares
    if (parsedData.lensFlareSystems !== undefined && parsedData.lensFlareSystems !== null) {
        if (!container.lensFlareSystems) {
            container.lensFlareSystems = new Array();
        }
        for (var index = 0, cache = parsedData.lensFlareSystems.length; index < cache; index++) {
            var parsedLensFlareSystem = parsedData.lensFlareSystems[index];
            var lf = LensFlareSystem.Parse(parsedLensFlareSystem, scene, rootUrl);
            container.lensFlareSystems.push(lf);
        }
    }
});
AbstractScene.prototype.getLensFlareSystemByName = function (name) {
    for (var index = 0; index < this.lensFlareSystems.length; index++) {
        if (this.lensFlareSystems[index].name === name) {
            return this.lensFlareSystems[index];
        }
    }
    return null;
};
AbstractScene.prototype.getLensFlareSystemByID = function (id) {
    for (var index = 0; index < this.lensFlareSystems.length; index++) {
        if (this.lensFlareSystems[index].id === id) {
            return this.lensFlareSystems[index];
        }
    }
    return null;
};
AbstractScene.prototype.removeLensFlareSystem = function (toRemove) {
    var index = this.lensFlareSystems.indexOf(toRemove);
    if (index !== -1) {
        this.lensFlareSystems.splice(index, 1);
    }
    return index;
};
AbstractScene.prototype.addLensFlareSystem = function (newLensFlareSystem) {
    this.lensFlareSystems.push(newLensFlareSystem);
};
/**
 * Defines the lens flare scene component responsible to manage any lens flares
 * in a given scene.
 */
var LensFlareSystemSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function LensFlareSystemSceneComponent(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_LENSFLARESYSTEM;
        this.scene = scene;
        scene.lensFlareSystems = new Array();
    }
    /**
     * Registers the component in a given scene
     */
    LensFlareSystemSceneComponent.prototype.register = function () {
        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM, this, this._draw);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    LensFlareSystemSceneComponent.prototype.rebuild = function () {
        // Nothing to do for lens flare
    };
    /**
     * Adds all the element from the container to the scene
     * @param container the container holding the elements
     */
    LensFlareSystemSceneComponent.prototype.addFromContainer = function (container) {
        var _this = this;
        if (!container.lensFlareSystems) {
            return;
        }
        container.lensFlareSystems.forEach(function (o) {
            _this.scene.addLensFlareSystem(o);
        });
    };
    /**
     * Removes all the elements in the container from the scene
     * @param container contains the elements to remove
     * @param dispose if the removed element should be disposed (default: false)
     */
    LensFlareSystemSceneComponent.prototype.removeFromContainer = function (container, dispose) {
        var _this = this;
        if (!container.lensFlareSystems) {
            return;
        }
        container.lensFlareSystems.forEach(function (o) {
            _this.scene.removeLensFlareSystem(o);
            if (dispose) {
                o.dispose();
            }
        });
    };
    /**
     * Serializes the component data to the specified json object
     * @param serializationObject The object to serialize to
     */
    LensFlareSystemSceneComponent.prototype.serialize = function (serializationObject) {
        // Lens flares
        serializationObject.lensFlareSystems = [];
        var lensFlareSystems = this.scene.lensFlareSystems;
        for (var _i = 0, lensFlareSystems_1 = lensFlareSystems; _i < lensFlareSystems_1.length; _i++) {
            var lensFlareSystem = lensFlareSystems_1[_i];
            serializationObject.lensFlareSystems.push(lensFlareSystem.serialize());
        }
    };
    /**
     * Disposes the component and the associated ressources.
     */
    LensFlareSystemSceneComponent.prototype.dispose = function () {
        var lensFlareSystems = this.scene.lensFlareSystems;
        while (lensFlareSystems.length) {
            lensFlareSystems[0].dispose();
        }
    };
    LensFlareSystemSceneComponent.prototype._draw = function (camera) {
        // Lens flares
        if (this.scene.lensFlaresEnabled) {
            var lensFlareSystems = this.scene.lensFlareSystems;
            Tools.StartPerformanceCounter("Lens flares", lensFlareSystems.length > 0);
            for (var _i = 0, lensFlareSystems_2 = lensFlareSystems; _i < lensFlareSystems_2.length; _i++) {
                var lensFlareSystem = lensFlareSystems_2[_i];
                if ((camera.layerMask & lensFlareSystem.layerMask) !== 0) {
                    lensFlareSystem.render();
                }
            }
            Tools.EndPerformanceCounter("Lens flares", lensFlareSystems.length > 0);
        }
    };
    return LensFlareSystemSceneComponent;
}());
LensFlareSystem._SceneComponentInitialization = function (scene) {
    var component = scene._getComponent(SceneComponentConstants.NAME_LENSFLARESYSTEM);
    if (!component) {
        component = new LensFlareSystemSceneComponent(scene);
        scene._addComponent(component);
    }
};

var name$r = 'shadowMapPixelShader';
var shader$r = "#ifndef FLOAT\nvec4 pack(float depth)\n{\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\nvec4 res=fract(depth*bit_shift);\nres-=res.xxyz*bit_mask;\nreturn res;\n}\n#endif\nvarying float vDepthMetric;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\nuniform vec3 biasAndScale;\nuniform vec2 depthValues;\nvoid main(void)\n{\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\nfloat depth=vDepthMetric;\n#ifdef ESM\ndepth=clamp(exp(-min(87.,biasAndScale.z*depth)),0.,1.);\n#endif\n#ifdef FLOAT\ngl_FragColor=vec4(depth,1.0,1.0,1.0);\n#else\ngl_FragColor=pack(depth);\n#endif\n}";
Effect.ShadersStore[name$r] = shader$r;

var name$s = 'shadowMapVertexShader';
var shader$s = "\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\nuniform vec3 lightData;\n#endif\n#include<bonesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n#include<instancesDeclaration>\n#include<helperFunctions>\nuniform mat4 viewProjection;\nuniform vec3 biasAndScale;\nuniform vec2 depthValues;\nvarying float vDepthMetric;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvec3 worldNor=normalize(normalWorld*normal);\n#ifdef DIRECTIONINLIGHTDATA\nvec3 worldLightDir=normalize(-lightData.xyz);\n#else\nvec3 directionToLight=lightData.xyz-worldPos.xyz;\nvec3 worldLightDir=normalize(directionToLight);\n#endif\nfloat ndl=dot(worldNor,worldLightDir);\nfloat sinNL=sqrt(1.0-ndl*ndl);\nfloat normalBias=biasAndScale.y*sinNL;\nworldPos.xyz-=worldNor*normalBias;\n#endif\n\ngl_Position=viewProjection*worldPos;\n#ifdef DEPTHTEXTURE\n\ngl_Position.z+=biasAndScale.x*gl_Position.w;\n#endif\n\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y))+biasAndScale.x;\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}";
Effect.ShadersStore[name$s] = shader$s;

var name$t = 'depthBoxBlurPixelShader';
var shader$t = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nvoid main(void)\n{\nvec4 colorDepth=vec4(0.0);\nfor (int x=-OFFSET; x<=OFFSET; x++)\nfor (int y=-OFFSET; y<=OFFSET; y++)\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);\ngl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));\n}";
Effect.ShadersStore[name$t] = shader$t;

/**
 * Default implementation IShadowGenerator.
 * This is the main object responsible of generating shadows in the framework.
 * Documentation: https://doc.babylonjs.com/babylon101/shadows
 */
var ShadowGenerator = /** @class */ (function () {
    /**
     * Creates a ShadowGenerator object.
     * A ShadowGenerator is the required tool to use the shadows.
     * Each light casting shadows needs to use its own ShadowGenerator.
     * Documentation : https://doc.babylonjs.com/babylon101/shadows
     * @param mapSize The size of the texture what stores the shadows. Example : 1024.
     * @param light The light object generating the shadows.
     * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
     */
    function ShadowGenerator(mapSize, light, usefulFloatFirst) {
        /**
         * Observable triggered before the shadow is rendered. Can be used to update internal effect state
         */
        this.onBeforeShadowMapRenderObservable = new Observable();
        /**
         * Observable triggered before a mesh is rendered in the shadow map.
         * Can be used to update internal effect state (that you can get from the onBeforeShadowMapRenderObservable)
         */
        this.onBeforeShadowMapRenderMeshObservable = new Observable();
        this._bias = 0.00005;
        this._normalBias = 0;
        this._blurBoxOffset = 1;
        this._blurScale = 2;
        this._blurKernel = 1;
        this._useKernelBlur = false;
        this._filter = ShadowGenerator.FILTER_NONE;
        this._filteringQuality = ShadowGenerator.QUALITY_HIGH;
        this._contactHardeningLightSizeUVRatio = 0.1;
        this._darkness = 0;
        this._transparencyShadow = false;
        /**
         * Controls the extent to which the shadows fade out at the edge of the frustum
         * Used only by directionals and spots
         */
        this.frustumEdgeFalloff = 0;
        /**
         * If true the shadow map is generated by rendering the back face of the mesh instead of the front face.
         * This can help with self-shadowing as the geometry making up the back of objects is slightly offset.
         * It might on the other hand introduce peter panning.
         */
        this.forceBackFacesOnly = false;
        this._lightDirection = Vector3.Zero();
        this._viewMatrix = Matrix.Zero();
        this._projectionMatrix = Matrix.Zero();
        this._transformMatrix = Matrix.Zero();
        this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._currentFaceIndex = 0;
        this._currentFaceIndexCache = 0;
        this._defaultTextureMatrix = Matrix.Identity();
        this._mapSize = mapSize;
        this._light = light;
        this._scene = light.getScene();
        light._shadowGenerator = this;
        ShadowGenerator._SceneComponentInitialization(this._scene);
        // Texture type fallback from float to int if not supported.
        var caps = this._scene.getEngine().getCaps();
        if (!usefulFloatFirst) {
            if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
                this._textureType = Constants.TEXTURETYPE_HALF_FLOAT;
            }
            else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
                this._textureType = Constants.TEXTURETYPE_FLOAT;
            }
            else {
                this._textureType = Constants.TEXTURETYPE_UNSIGNED_INT;
            }
        }
        else {
            if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
                this._textureType = Constants.TEXTURETYPE_FLOAT;
            }
            else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
                this._textureType = Constants.TEXTURETYPE_HALF_FLOAT;
            }
            else {
                this._textureType = Constants.TEXTURETYPE_UNSIGNED_INT;
            }
        }
        this._initializeGenerator();
        this._applyFilterValues();
    }
    Object.defineProperty(ShadowGenerator.prototype, "bias", {
        /**
         * Gets the bias: offset applied on the depth preventing acnea (in light direction).
         */
        get: function () {
            return this._bias;
        },
        /**
         * Sets the bias: offset applied on the depth preventing acnea (in light direction).
         */
        set: function (bias) {
            this._bias = bias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "normalBias", {
        /**
         * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
         */
        get: function () {
            return this._normalBias;
        },
        /**
         * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
         */
        set: function (normalBias) {
            this._normalBias = normalBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "blurBoxOffset", {
        /**
         * Gets the blur box offset: offset applied during the blur pass.
         * Only useful if useKernelBlur = false
         */
        get: function () {
            return this._blurBoxOffset;
        },
        /**
         * Sets the blur box offset: offset applied during the blur pass.
         * Only useful if useKernelBlur = false
         */
        set: function (value) {
            if (this._blurBoxOffset === value) {
                return;
            }
            this._blurBoxOffset = value;
            this._disposeBlurPostProcesses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "blurScale", {
        /**
         * Gets the blur scale: scale of the blurred texture compared to the main shadow map.
         * 2 means half of the size.
         */
        get: function () {
            return this._blurScale;
        },
        /**
         * Sets the blur scale: scale of the blurred texture compared to the main shadow map.
         * 2 means half of the size.
         */
        set: function (value) {
            if (this._blurScale === value) {
                return;
            }
            this._blurScale = value;
            this._disposeBlurPostProcesses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "blurKernel", {
        /**
         * Gets the blur kernel: kernel size of the blur pass.
         * Only useful if useKernelBlur = true
         */
        get: function () {
            return this._blurKernel;
        },
        /**
         * Sets the blur kernel: kernel size of the blur pass.
         * Only useful if useKernelBlur = true
         */
        set: function (value) {
            if (this._blurKernel === value) {
                return;
            }
            this._blurKernel = value;
            this._disposeBlurPostProcesses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useKernelBlur", {
        /**
         * Gets whether the blur pass is a kernel blur (if true) or box blur.
         * Only useful in filtered mode (useBlurExponentialShadowMap...)
         */
        get: function () {
            return this._useKernelBlur;
        },
        /**
         * Sets whether the blur pass is a kernel blur (if true) or box blur.
         * Only useful in filtered mode (useBlurExponentialShadowMap...)
         */
        set: function (value) {
            if (this._useKernelBlur === value) {
                return;
            }
            this._useKernelBlur = value;
            this._disposeBlurPostProcesses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "depthScale", {
        /**
         * Gets the depth scale used in ESM mode.
         */
        get: function () {
            return this._depthScale !== undefined ? this._depthScale : this._light.getDepthScale();
        },
        /**
         * Sets the depth scale used in ESM mode.
         * This can override the scale stored on the light.
         */
        set: function (value) {
            this._depthScale = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "filter", {
        /**
         * Gets the current mode of the shadow generator (normal, PCF, ESM...).
         * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
         */
        get: function () {
            return this._filter;
        },
        /**
         * Sets the current mode of the shadow generator (normal, PCF, ESM...).
         * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
         */
        set: function (value) {
            // Blurring the cubemap is going to be too expensive. Reverting to unblurred version
            if (this._light.needCube()) {
                if (value === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
                    this.useExponentialShadowMap = true;
                    return;
                }
                else if (value === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
                    this.useCloseExponentialShadowMap = true;
                    return;
                }
                // PCF on cubemap would also be expensive
                else if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {
                    this.usePoissonSampling = true;
                    return;
                }
            }
            // Weblg1 fallback for PCF.
            if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {
                if (this._scene.getEngine().webGLVersion === 1) {
                    this.usePoissonSampling = true;
                    return;
                }
            }
            if (this._filter === value) {
                return;
            }
            this._filter = value;
            this._disposeBlurPostProcesses();
            this._applyFilterValues();
            this._light._markMeshesAsLightDirty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "usePoissonSampling", {
        /**
         * Gets if the current filter is set to Poisson Sampling.
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_POISSONSAMPLING;
        },
        /**
         * Sets the current filter to Poisson Sampling.
         */
        set: function (value) {
            if (!value && this.filter !== ShadowGenerator.FILTER_POISSONSAMPLING) {
                return;
            }
            this.filter = (value ? ShadowGenerator.FILTER_POISSONSAMPLING : ShadowGenerator.FILTER_NONE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useExponentialShadowMap", {
        /**
         * Gets if the current filter is set to ESM.
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;
        },
        /**
         * Sets the current filter is to ESM.
         */
        set: function (value) {
            if (!value && this.filter !== ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {
                return;
            }
            this.filter = (value ? ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP : ShadowGenerator.FILTER_NONE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useBlurExponentialShadowMap", {
        /**
         * Gets if the current filter is set to filtered ESM.
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;
        },
        /**
         * Gets if the current filter is set to filtered  ESM.
         */
        set: function (value) {
            if (!value && this.filter !== ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
                return;
            }
            this.filter = (value ? ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP : ShadowGenerator.FILTER_NONE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useCloseExponentialShadowMap", {
        /**
         * Gets if the current filter is set to "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;
        },
        /**
         * Sets the current filter to "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        set: function (value) {
            if (!value && this.filter !== ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {
                return;
            }
            this.filter = (value ? ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP : ShadowGenerator.FILTER_NONE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useBlurCloseExponentialShadowMap", {
        /**
         * Gets if the current filter is set to filtered "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
        },
        /**
         * Sets the current filter to filtered "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        set: function (value) {
            if (!value && this.filter !== ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
                return;
            }
            this.filter = (value ? ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP : ShadowGenerator.FILTER_NONE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "usePercentageCloserFiltering", {
        /**
         * Gets if the current filter is set to "PCF" (percentage closer filtering).
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_PCF;
        },
        /**
         * Sets the current filter to "PCF" (percentage closer filtering).
         */
        set: function (value) {
            if (!value && this.filter !== ShadowGenerator.FILTER_PCF) {
                return;
            }
            this.filter = (value ? ShadowGenerator.FILTER_PCF : ShadowGenerator.FILTER_NONE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "filteringQuality", {
        /**
         * Gets the PCF or PCSS Quality.
         * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
         */
        get: function () {
            return this._filteringQuality;
        },
        /**
         * Sets the PCF or PCSS Quality.
         * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
         */
        set: function (filteringQuality) {
            this._filteringQuality = filteringQuality;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "useContactHardeningShadow", {
        /**
         * Gets if the current filter is set to "PCSS" (contact hardening).
         */
        get: function () {
            return this.filter === ShadowGenerator.FILTER_PCSS;
        },
        /**
         * Sets the current filter to "PCSS" (contact hardening).
         */
        set: function (value) {
            if (!value && this.filter !== ShadowGenerator.FILTER_PCSS) {
                return;
            }
            this.filter = (value ? ShadowGenerator.FILTER_PCSS : ShadowGenerator.FILTER_NONE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowGenerator.prototype, "contactHardeningLightSizeUVRatio", {
        /**
         * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
         * Using a ratio helps keeping shape stability independently of the map size.
         *
         * It does not account for the light projection as it was having too much
         * instability during the light setup or during light position changes.
         *
         * Only valid if useContactHardeningShadow is true.
         */
        get: function () {
            return this._contactHardeningLightSizeUVRatio;
        },
        /**
         * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
         * Using a ratio helps keeping shape stability independently of the map size.
         *
         * It does not account for the light projection as it was having too much
         * instability during the light setup or during light position changes.
         *
         * Only valid if useContactHardeningShadow is true.
         */
        set: function (contactHardeningLightSizeUVRatio) {
            this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
     * 0 means strongest and 1 would means no shadow.
     * @returns the darkness.
     */
    ShadowGenerator.prototype.getDarkness = function () {
        return this._darkness;
    };
    /**
     * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
     * @param darkness The darkness value 0 means strongest and 1 would means no shadow.
     * @returns the shadow generator allowing fluent coding.
     */
    ShadowGenerator.prototype.setDarkness = function (darkness) {
        if (darkness >= 1.0) {
            this._darkness = 1.0;
        }
        else if (darkness <= 0.0) {
            this._darkness = 0.0;
        }
        else {
            this._darkness = darkness;
        }
        return this;
    };
    /**
     * Sets the ability to have transparent shadow (boolean).
     * @param transparent True if transparent else False
     * @returns the shadow generator allowing fluent coding
     */
    ShadowGenerator.prototype.setTransparencyShadow = function (transparent) {
        this._transparencyShadow = transparent;
        return this;
    };
    /**
     * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
     * @returns The render target texture if present otherwise, null
     */
    ShadowGenerator.prototype.getShadowMap = function () {
        return this._shadowMap;
    };
    /**
     * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
     * @returns The render target texture if the shadow map is present otherwise, null
     */
    ShadowGenerator.prototype.getShadowMapForRendering = function () {
        if (this._shadowMap2) {
            return this._shadowMap2;
        }
        return this._shadowMap;
    };
    /**
     * Helper function to add a mesh and its descendants to the list of shadow casters.
     * @param mesh Mesh to add
     * @param includeDescendants boolean indicating if the descendants should be added. Default to true
     * @returns the Shadow Generator itself
     */
    ShadowGenerator.prototype.addShadowCaster = function (mesh, includeDescendants) {
        var _a;
        if (includeDescendants === void 0) { includeDescendants = true; }
        if (!this._shadowMap) {
            return this;
        }
        if (!this._shadowMap.renderList) {
            this._shadowMap.renderList = [];
        }
        this._shadowMap.renderList.push(mesh);
        if (includeDescendants) {
            (_a = this._shadowMap.renderList).push.apply(_a, mesh.getChildMeshes());
        }
        return this;
    };
    /**
     * Helper function to remove a mesh and its descendants from the list of shadow casters
     * @param mesh Mesh to remove
     * @param includeDescendants boolean indicating if the descendants should be removed. Default to true
     * @returns the Shadow Generator itself
     */
    ShadowGenerator.prototype.removeShadowCaster = function (mesh, includeDescendants) {
        if (includeDescendants === void 0) { includeDescendants = true; }
        if (!this._shadowMap || !this._shadowMap.renderList) {
            return this;
        }
        var index = this._shadowMap.renderList.indexOf(mesh);
        if (index !== -1) {
            this._shadowMap.renderList.splice(index, 1);
        }
        if (includeDescendants) {
            for (var _i = 0, _a = mesh.getChildren(); _i < _a.length; _i++) {
                var child = _a[_i];
                this.removeShadowCaster(child);
            }
        }
        return this;
    };
    /**
     * Returns the associated light object.
     * @returns the light generating the shadow
     */
    ShadowGenerator.prototype.getLight = function () {
        return this._light;
    };
    ShadowGenerator.prototype._initializeGenerator = function () {
        this._light._markMeshesAsLightDirty();
        this._initializeShadowMap();
    };
    ShadowGenerator.prototype._initializeShadowMap = function () {
        var _this = this;
        // Render target
        var engine = this._scene.getEngine();
        if (engine.webGLVersion > 1) {
            this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), undefined, false, false);
            this._shadowMap.createDepthStencilTexture(Constants.LESS, true);
        }
        else {
            this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());
        }
        this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._shadowMap.anisotropicFilteringLevel = 1;
        this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._shadowMap.renderParticles = false;
        this._shadowMap.ignoreCameraViewport = true;
        // Record Face Index before render.
        this._shadowMap.onBeforeRenderObservable.add(function (faceIndex) {
            _this._currentFaceIndex = faceIndex;
            if (_this._filter === ShadowGenerator.FILTER_PCF) {
                engine.setColorWrite(false);
            }
        });
        // Custom render function.
        this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this);
        // Blur if required afer render.
        this._shadowMap.onAfterUnbindObservable.add(function () {
            if (_this._filter === ShadowGenerator.FILTER_PCF) {
                engine.setColorWrite(true);
            }
            if (!_this.useBlurExponentialShadowMap && !_this.useBlurCloseExponentialShadowMap) {
                return;
            }
            var shadowMap = _this.getShadowMapForRendering();
            if (shadowMap) {
                _this._scene.postProcessManager.directRender(_this._blurPostProcesses, shadowMap.getInternalTexture(), true);
            }
        });
        // Clear according to the chosen filter.
        var clearZero = new Color4(0, 0, 0, 0);
        var clearOne = new Color4(1.0, 1.0, 1.0, 1.0);
        this._shadowMap.onClearObservable.add(function (engine) {
            if (_this._filter === ShadowGenerator.FILTER_PCF) {
                engine.clear(clearOne, false, true, false);
            }
            else if (_this.useExponentialShadowMap || _this.useBlurExponentialShadowMap) {
                engine.clear(clearZero, true, true, false);
            }
            else {
                engine.clear(clearOne, true, true, false);
            }
        });
    };
    ShadowGenerator.prototype._initializeBlurRTTAndPostProcesses = function () {
        var _this = this;
        var engine = this._scene.getEngine();
        var targetSize = this._mapSize / this.blurScale;
        if (!this.useKernelBlur || this.blurScale !== 1.0) {
            this._shadowMap2 = new RenderTargetTexture(this._light.name + "_shadowMap2", targetSize, this._scene, false, true, this._textureType);
            this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;
            this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;
            this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        }
        if (this.useKernelBlur) {
            this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + "KernelBlurX", new Vector2(1, 0), this.blurKernel, 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
            this._kernelBlurXPostprocess.width = targetSize;
            this._kernelBlurXPostprocess.height = targetSize;
            this._kernelBlurXPostprocess.onApplyObservable.add(function (effect) {
                effect.setTexture("textureSampler", _this._shadowMap);
            });
            this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + "KernelBlurY", new Vector2(0, 1), this.blurKernel, 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
            this._kernelBlurXPostprocess.autoClear = false;
            this._kernelBlurYPostprocess.autoClear = false;
            if (this._textureType === Constants.TEXTURETYPE_UNSIGNED_INT) {
                this._kernelBlurXPostprocess.packedFloat = true;
                this._kernelBlurYPostprocess.packedFloat = true;
            }
            this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];
        }
        else {
            this._boxBlurPostprocess = new PostProcess(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, "#define OFFSET " + this._blurBoxOffset, this._textureType);
            this._boxBlurPostprocess.onApplyObservable.add(function (effect) {
                effect.setFloat2("screenSize", targetSize, targetSize);
                effect.setTexture("textureSampler", _this._shadowMap);
            });
            this._boxBlurPostprocess.autoClear = false;
            this._blurPostProcesses = [this._boxBlurPostprocess];
        }
    };
    ShadowGenerator.prototype._renderForShadowMap = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
        var index;
        var engine = this._scene.getEngine();
        if (depthOnlySubMeshes.length) {
            engine.setColorWrite(false);
            for (index = 0; index < depthOnlySubMeshes.length; index++) {
                this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);
            }
            engine.setColorWrite(true);
        }
        for (index = 0; index < opaqueSubMeshes.length; index++) {
            this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);
        }
        for (index = 0; index < alphaTestSubMeshes.length; index++) {
            this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);
        }
        if (this._transparencyShadow) {
            for (index = 0; index < transparentSubMeshes.length; index++) {
                this._renderSubMeshForShadowMap(transparentSubMeshes.data[index]);
            }
        }
    };
    ShadowGenerator.prototype._renderSubMeshForShadowMap = function (subMesh) {
        var _this = this;
        var mesh = subMesh.getRenderingMesh();
        var scene = this._scene;
        var engine = scene.getEngine();
        var material = subMesh.getMaterial();
        mesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        if (!material || subMesh.verticesCount === 0) {
            return;
        }
        // Culling
        engine.setState(material.backFaceCulling);
        // Managing instances
        var batch = mesh._getInstancesRenderList(subMesh._id);
        if (batch.mustReturn) {
            return;
        }
        var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null) && (batch.visibleInstances[subMesh._id] !== undefined);
        if (this.isReady(subMesh, hardwareInstancedRendering)) {
            engine.enableEffect(this._effect);
            mesh._bind(subMesh, this._effect, Material.TriangleFillMode);
            this._effect.setFloat3("biasAndScale", this.bias, this.normalBias, this.depthScale);
            this._effect.setMatrix("viewProjection", this.getTransformMatrix());
            if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
                this._effect.setVector3("lightData", this._cachedDirection);
            }
            else {
                this._effect.setVector3("lightData", this._cachedPosition);
            }
            if (scene.activeCamera) {
                this._effect.setFloat2("depthValues", this.getLight().getDepthMinZ(scene.activeCamera), this.getLight().getDepthMinZ(scene.activeCamera) + this.getLight().getDepthMaxZ(scene.activeCamera));
            }
            // Alpha test
            if (material && material.needAlphaTesting()) {
                var alphaTexture = material.getAlphaTestTexture();
                if (alphaTexture) {
                    this._effect.setTexture("diffuseSampler", alphaTexture);
                    this._effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix() || this._defaultTextureMatrix);
                }
            }
            // Bones
            if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
                var skeleton = mesh.skeleton;
                if (skeleton.isUsingTextureForMatrices) {
                    var boneTexture = skeleton.getTransformMatrixTexture();
                    if (!boneTexture) {
                        return;
                    }
                    this._effect.setTexture("boneSampler", boneTexture);
                    this._effect.setFloat("boneTextureWidth", 4.0 * (skeleton.bones.length + 1));
                }
                else {
                    this._effect.setMatrices("mBones", skeleton.getTransformMatrices((mesh)));
                }
            }
            // Morph targets
            MaterialHelper.BindMorphTargetParameters(mesh, this._effect);
            if (this.forceBackFacesOnly) {
                engine.setState(true, 0, false, true);
            }
            // Observables
            this.onBeforeShadowMapRenderMeshObservable.notifyObservers(mesh);
            this.onBeforeShadowMapRenderObservable.notifyObservers(this._effect);
            // Draw
            mesh._processRendering(subMesh, this._effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return _this._effect.setMatrix("world", world); });
            if (this.forceBackFacesOnly) {
                engine.setState(true, 0, false, false);
            }
        }
        else {
            // Need to reset refresh rate of the shadowMap
            if (this._shadowMap) {
                this._shadowMap.resetRefreshCounter();
            }
        }
    };
    ShadowGenerator.prototype._applyFilterValues = function () {
        if (!this._shadowMap) {
            return;
        }
        if (this.filter === ShadowGenerator.FILTER_NONE || this.filter === ShadowGenerator.FILTER_PCSS) {
            this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);
        }
        else {
            this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        }
    };
    /**
     * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
     * @param onCompiled Callback triggered at the and of the effects compilation
     * @param options Sets of optional options forcing the compilation with different modes
     */
    ShadowGenerator.prototype.forceCompilation = function (onCompiled, options) {
        var _this = this;
        var localOptions = __assign({ useInstances: false }, options);
        var shadowMap = this.getShadowMap();
        if (!shadowMap) {
            if (onCompiled) {
                onCompiled(this);
            }
            return;
        }
        var renderList = shadowMap.renderList;
        if (!renderList) {
            if (onCompiled) {
                onCompiled(this);
            }
            return;
        }
        var subMeshes = new Array();
        for (var _i = 0, renderList_1 = renderList; _i < renderList_1.length; _i++) {
            var mesh = renderList_1[_i];
            subMeshes.push.apply(subMeshes, mesh.subMeshes);
        }
        if (subMeshes.length === 0) {
            if (onCompiled) {
                onCompiled(this);
            }
            return;
        }
        var currentIndex = 0;
        var checkReady = function () {
            if (!_this._scene || !_this._scene.getEngine()) {
                return;
            }
            while (_this.isReady(subMeshes[currentIndex], localOptions.useInstances)) {
                currentIndex++;
                if (currentIndex >= subMeshes.length) {
                    if (onCompiled) {
                        onCompiled(_this);
                    }
                    return;
                }
            }
            setTimeout(checkReady, 16);
        };
        checkReady();
    };
    /**
     * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
     * @param options Sets of optional options forcing the compilation with different modes
     * @returns A promise that resolves when the compilation completes
     */
    ShadowGenerator.prototype.forceCompilationAsync = function (options) {
        var _this = this;
        return new Promise(function (resolve) {
            _this.forceCompilation(function () {
                resolve();
            }, options);
        });
    };
    /**
     * Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
     * @param subMesh The submesh we want to render in the shadow map
     * @param useInstances Defines wether will draw in the map using instances
     * @returns true if ready otherwise, false
     */
    ShadowGenerator.prototype.isReady = function (subMesh, useInstances) {
        var defines = [];
        if (this._textureType !== Constants.TEXTURETYPE_UNSIGNED_INT) {
            defines.push("#define FLOAT");
        }
        if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
            defines.push("#define ESM");
        }
        else if (this.usePercentageCloserFiltering || this.useContactHardeningShadow) {
            defines.push("#define DEPTHTEXTURE");
        }
        var attribs = [VertexBuffer.PositionKind];
        var mesh = subMesh.getMesh();
        var material = subMesh.getMaterial();
        // Normal bias.
        if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
            attribs.push(VertexBuffer.NormalKind);
            defines.push("#define NORMAL");
            if (mesh.nonUniformScaling) {
                defines.push("#define NONUNIFORMSCALING");
            }
            if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
                defines.push("#define DIRECTIONINLIGHTDATA");
            }
        }
        // Alpha test
        if (material && material.needAlphaTesting()) {
            var alphaTexture = material.getAlphaTestTexture();
            if (alphaTexture) {
                defines.push("#define ALPHATEST");
                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                    attribs.push(VertexBuffer.UVKind);
                    defines.push("#define UV1");
                }
                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
                    if (alphaTexture.coordinatesIndex === 1) {
                        attribs.push(VertexBuffer.UV2Kind);
                        defines.push("#define UV2");
                    }
                }
            }
        }
        // Bones
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
            attribs.push(VertexBuffer.MatricesIndicesKind);
            attribs.push(VertexBuffer.MatricesWeightsKind);
            if (mesh.numBoneInfluencers > 4) {
                attribs.push(VertexBuffer.MatricesIndicesExtraKind);
                attribs.push(VertexBuffer.MatricesWeightsExtraKind);
            }
            var skeleton = mesh.skeleton;
            defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
            if (skeleton.isUsingTextureForMatrices) {
                defines.push("#define BONETEXTURE");
            }
            else {
                defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
            }
        }
        else {
            defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        // Morph targets
        var manager = mesh.morphTargetManager;
        var morphInfluencers = 0;
        if (manager) {
            if (manager.numInfluencers > 0) {
                defines.push("#define MORPHTARGETS");
                morphInfluencers = manager.numInfluencers;
                defines.push("#define NUM_MORPH_INFLUENCERS " + morphInfluencers);
                MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, { "NUM_MORPH_INFLUENCERS": morphInfluencers });
            }
        }
        // Instances
        if (useInstances) {
            defines.push("#define INSTANCES");
            attribs.push("world0");
            attribs.push("world1");
            attribs.push("world2");
            attribs.push("world3");
        }
        if (this.customShaderOptions) {
            if (this.customShaderOptions.defines) {
                for (var _i = 0, _a = this.customShaderOptions.defines; _i < _a.length; _i++) {
                    var define = _a[_i];
                    if (defines.indexOf(define) === -1) {
                        defines.push(define);
                    }
                }
            }
        }
        // Get correct effect
        var join = defines.join("\n");
        if (this._cachedDefines !== join) {
            this._cachedDefines = join;
            var shaderName = "shadowMap";
            var uniforms = ["world", "mBones", "viewProjection", "diffuseMatrix", "lightData", "depthValues", "biasAndScale", "morphTargetInfluences", "boneTextureWidth"];
            var samplers = ["diffuseSampler", "boneSampler"];
            // Custom shader?
            if (this.customShaderOptions) {
                shaderName = this.customShaderOptions.shaderName;
                if (this.customShaderOptions.attributes) {
                    for (var _b = 0, _c = this.customShaderOptions.attributes; _b < _c.length; _b++) {
                        var attrib = _c[_b];
                        if (attribs.indexOf(attrib) === -1) {
                            attribs.push(attrib);
                        }
                    }
                }
                if (this.customShaderOptions.uniforms) {
                    for (var _d = 0, _e = this.customShaderOptions.uniforms; _d < _e.length; _d++) {
                        var uniform = _e[_d];
                        if (uniforms.indexOf(uniform) === -1) {
                            uniforms.push(uniform);
                        }
                    }
                }
                if (this.customShaderOptions.samplers) {
                    for (var _f = 0, _g = this.customShaderOptions.samplers; _f < _g.length; _f++) {
                        var sampler = _g[_f];
                        if (samplers.indexOf(sampler) === -1) {
                            samplers.push(sampler);
                        }
                    }
                }
            }
            this._effect = this._scene.getEngine().createEffect(shaderName, attribs, uniforms, samplers, join, undefined, undefined, undefined, { maxSimultaneousMorphTargets: morphInfluencers });
        }
        if (!this._effect.isReady()) {
            return false;
        }
        if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
            if (!this._blurPostProcesses || !this._blurPostProcesses.length) {
                this._initializeBlurRTTAndPostProcesses();
            }
        }
        if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {
            return false;
        }
        if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {
            return false;
        }
        if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {
            return false;
        }
        return true;
    };
    /**
     * Prepare all the defines in a material relying on a shadow map at the specified light index.
     * @param defines Defines of the material we want to update
     * @param lightIndex Index of the light in the enabled light list of the material
     */
    ShadowGenerator.prototype.prepareDefines = function (defines, lightIndex) {
        var scene = this._scene;
        var light = this._light;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
            return;
        }
        defines["SHADOW" + lightIndex] = true;
        if (this.useContactHardeningShadow) {
            defines["SHADOWPCSS" + lightIndex] = true;
            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {
                defines["SHADOWLOWQUALITY" + lightIndex] = true;
            }
            else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {
                defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
            }
            // else default to high.
        }
        if (this.usePercentageCloserFiltering) {
            defines["SHADOWPCF" + lightIndex] = true;
            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {
                defines["SHADOWLOWQUALITY" + lightIndex] = true;
            }
            else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {
                defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
            }
            // else default to high.
        }
        else if (this.usePoissonSampling) {
            defines["SHADOWPOISSON" + lightIndex] = true;
        }
        else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
            defines["SHADOWESM" + lightIndex] = true;
        }
        else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
            defines["SHADOWCLOSEESM" + lightIndex] = true;
        }
        if (light.needCube()) {
            defines["SHADOWCUBE" + lightIndex] = true;
        }
    };
    /**
     * Binds the shadow related information inside of an effect (information like near, far, darkness...
     * defined in the generator but impacting the effect).
     * @param lightIndex Index of the light in the enabled light list of the material owning the effect
     * @param effect The effect we are binfing the information for
     */
    ShadowGenerator.prototype.bindShadowLight = function (lightIndex, effect) {
        var light = this._light;
        var scene = this._scene;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
            return;
        }
        var camera = scene.activeCamera;
        if (!camera) {
            return;
        }
        var shadowMap = this.getShadowMap();
        if (!shadowMap) {
            return;
        }
        if (!light.needCube()) {
            effect.setMatrix("lightMatrix" + lightIndex, this.getTransformMatrix());
        }
        // Only PCF uses depth stencil texture.
        if (this._filter === ShadowGenerator.FILTER_PCF) {
            effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
            light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
        }
        else if (this._filter === ShadowGenerator.FILTER_PCSS) {
            effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
            effect.setTexture("depthSampler" + lightIndex, this.getShadowMapForRendering());
            light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
        }
        else {
            effect.setTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
            light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);
        }
        light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
    };
    /**
     * Gets the transformation matrix used to project the meshes into the map from the light point of view.
     * (eq to shadow prjection matrix * light transform matrix)
     * @returns The transform matrix used to create the shadow map
     */
    ShadowGenerator.prototype.getTransformMatrix = function () {
        var scene = this._scene;
        if (this._currentRenderID === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {
            return this._transformMatrix;
        }
        this._currentRenderID = scene.getRenderId();
        this._currentFaceIndexCache = this._currentFaceIndex;
        var lightPosition = this._light.position;
        if (this._light.computeTransformedInformation()) {
            lightPosition = this._light.transformedPosition;
        }
        Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);
        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {
            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light
        }
        if (this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !lightPosition.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
            this._cachedPosition.copyFrom(lightPosition);
            this._cachedDirection.copyFrom(this._lightDirection);
            Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);
            var shadowMap = this.getShadowMap();
            if (shadowMap) {
                var renderList = shadowMap.renderList;
                if (renderList) {
                    this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);
                }
            }
            this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
        }
        return this._transformMatrix;
    };
    /**
     * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
     * Cube and 2D textures for instance.
     */
    ShadowGenerator.prototype.recreateShadowMap = function () {
        var shadowMap = this._shadowMap;
        if (!shadowMap) {
            return;
        }
        // Track render list.
        var renderList = shadowMap.renderList;
        // Clean up existing data.
        this._disposeRTTandPostProcesses();
        // Reinitializes.
        this._initializeGenerator();
        // Reaffect the filter to ensure a correct fallback if necessary.
        this.filter = this.filter;
        // Reaffect the filter.
        this._applyFilterValues();
        // Reaffect Render List.
        this._shadowMap.renderList = renderList;
    };
    ShadowGenerator.prototype._disposeBlurPostProcesses = function () {
        if (this._shadowMap2) {
            this._shadowMap2.dispose();
            this._shadowMap2 = null;
        }
        if (this._boxBlurPostprocess) {
            this._boxBlurPostprocess.dispose();
            this._boxBlurPostprocess = null;
        }
        if (this._kernelBlurXPostprocess) {
            this._kernelBlurXPostprocess.dispose();
            this._kernelBlurXPostprocess = null;
        }
        if (this._kernelBlurYPostprocess) {
            this._kernelBlurYPostprocess.dispose();
            this._kernelBlurYPostprocess = null;
        }
        this._blurPostProcesses = [];
    };
    ShadowGenerator.prototype._disposeRTTandPostProcesses = function () {
        if (this._shadowMap) {
            this._shadowMap.dispose();
            this._shadowMap = null;
        }
        this._disposeBlurPostProcesses();
    };
    /**
     * Disposes the ShadowGenerator.
     * Returns nothing.
     */
    ShadowGenerator.prototype.dispose = function () {
        this._disposeRTTandPostProcesses();
        if (this._light) {
            this._light._shadowGenerator = null;
            this._light._markMeshesAsLightDirty();
        }
    };
    /**
     * Serializes the shadow generator setup to a json object.
     * @returns The serialized JSON object
     */
    ShadowGenerator.prototype.serialize = function () {
        var serializationObject = {};
        var shadowMap = this.getShadowMap();
        if (!shadowMap) {
            return serializationObject;
        }
        serializationObject.lightId = this._light.id;
        serializationObject.mapSize = shadowMap.getRenderSize();
        serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;
        serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.usePoissonSampling = this.usePoissonSampling;
        serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;
        serializationObject.depthScale = this.depthScale;
        serializationObject.darkness = this.getDarkness();
        serializationObject.blurBoxOffset = this.blurBoxOffset;
        serializationObject.blurKernel = this.blurKernel;
        serializationObject.blurScale = this.blurScale;
        serializationObject.useKernelBlur = this.useKernelBlur;
        serializationObject.transparencyShadow = this._transparencyShadow;
        serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;
        serializationObject.bias = this.bias;
        serializationObject.normalBias = this.normalBias;
        serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;
        serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;
        serializationObject.filteringQuality = this.filteringQuality;
        serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;
        serializationObject.renderList = [];
        if (shadowMap.renderList) {
            for (var meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
                var mesh = shadowMap.renderList[meshIndex];
                serializationObject.renderList.push(mesh.id);
            }
        }
        return serializationObject;
    };
    /**
     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
     * @param parsedShadowGenerator The JSON object to parse
     * @param scene The scene to create the shadow map for
     * @returns The parsed shadow generator
     */
    ShadowGenerator.Parse = function (parsedShadowGenerator, scene) {
        var light = scene.getLightByID(parsedShadowGenerator.lightId);
        var shadowGenerator = new ShadowGenerator(parsedShadowGenerator.mapSize, light);
        var shadowMap = shadowGenerator.getShadowMap();
        for (var meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {
            var meshes = scene.getMeshesByID(parsedShadowGenerator.renderList[meshIndex]);
            meshes.forEach(function (mesh) {
                if (!shadowMap) {
                    return;
                }
                if (!shadowMap.renderList) {
                    shadowMap.renderList = [];
                }
                shadowMap.renderList.push(mesh);
            });
        }
        if (parsedShadowGenerator.usePoissonSampling) {
            shadowGenerator.usePoissonSampling = true;
        }
        else if (parsedShadowGenerator.useExponentialShadowMap) {
            shadowGenerator.useExponentialShadowMap = true;
        }
        else if (parsedShadowGenerator.useBlurExponentialShadowMap) {
            shadowGenerator.useBlurExponentialShadowMap = true;
        }
        else if (parsedShadowGenerator.useCloseExponentialShadowMap) {
            shadowGenerator.useCloseExponentialShadowMap = true;
        }
        else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {
            shadowGenerator.useBlurCloseExponentialShadowMap = true;
        }
        else if (parsedShadowGenerator.usePercentageCloserFiltering) {
            shadowGenerator.usePercentageCloserFiltering = true;
        }
        else if (parsedShadowGenerator.useContactHardeningShadow) {
            shadowGenerator.useContactHardeningShadow = true;
        }
        if (parsedShadowGenerator.filteringQuality) {
            shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;
        }
        if (parsedShadowGenerator.contactHardeningLightSizeUVRatio) {
            shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;
        }
        // Backward compat
        else if (parsedShadowGenerator.useVarianceShadowMap) {
            shadowGenerator.useExponentialShadowMap = true;
        }
        else if (parsedShadowGenerator.useBlurVarianceShadowMap) {
            shadowGenerator.useBlurExponentialShadowMap = true;
        }
        if (parsedShadowGenerator.depthScale) {
            shadowGenerator.depthScale = parsedShadowGenerator.depthScale;
        }
        if (parsedShadowGenerator.blurScale) {
            shadowGenerator.blurScale = parsedShadowGenerator.blurScale;
        }
        if (parsedShadowGenerator.blurBoxOffset) {
            shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;
        }
        if (parsedShadowGenerator.useKernelBlur) {
            shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;
        }
        if (parsedShadowGenerator.blurKernel) {
            shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;
        }
        if (parsedShadowGenerator.bias !== undefined) {
            shadowGenerator.bias = parsedShadowGenerator.bias;
        }
        if (parsedShadowGenerator.normalBias !== undefined) {
            shadowGenerator.normalBias = parsedShadowGenerator.normalBias;
        }
        if (parsedShadowGenerator.frustumEdgeFalloff !== undefined) {
            shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;
        }
        if (parsedShadowGenerator.darkness) {
            shadowGenerator.setDarkness(parsedShadowGenerator.darkness);
        }
        if (parsedShadowGenerator.transparencyShadow) {
            shadowGenerator.setTransparencyShadow(true);
        }
        shadowGenerator.forceBackFacesOnly = parsedShadowGenerator.forceBackFacesOnly;
        return shadowGenerator;
    };
    /**
     * Shadow generator mode None: no filtering applied.
     */
    ShadowGenerator.FILTER_NONE = 0;
    /**
     * Shadow generator mode ESM: Exponential Shadow Mapping.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP = 1;
    /**
     * Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
     * (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
     */
    ShadowGenerator.FILTER_POISSONSAMPLING = 2;
    /**
     * Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
    /**
     * Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
     * edge artifacts on steep falloff.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
    /**
     * Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
     * edge artifacts on steep falloff.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
    /**
     * Shadow generator mode PCF: Percentage Closer Filtering
     * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
     * (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
     */
    ShadowGenerator.FILTER_PCF = 6;
    /**
     * Shadow generator mode PCSS: Percentage Closering Soft Shadow.
     * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
     * Contact Hardening
     */
    ShadowGenerator.FILTER_PCSS = 7;
    /**
     * Reserved for PCF and PCSS
     * Highest Quality.
     *
     * Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
     *
     * Execute PCSS with 32 taps blocker search and 64 taps PCF.
     */
    ShadowGenerator.QUALITY_HIGH = 0;
    /**
     * Reserved for PCF and PCSS
     * Good tradeoff for quality/perf cross devices
     *
     * Execute PCF on a 3*3 kernel.
     *
     * Execute PCSS with 16 taps blocker search and 32 taps PCF.
     */
    ShadowGenerator.QUALITY_MEDIUM = 1;
    /**
     * Reserved for PCF and PCSS
     * The lowest quality but the fastest.
     *
     * Execute PCF on a 1*1 kernel.
     *
     * Execute PCSS with 16 taps blocker search and 16 taps PCF.
     */
    ShadowGenerator.QUALITY_LOW = 2;
    /** @hidden */
    ShadowGenerator._SceneComponentInitialization = function (_) {
        throw _DevTools.WarnImport("ShadowGeneratorSceneComponent");
    };
    return ShadowGenerator;
}());

// Adds the parser to the scene parsers.
AbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, function (parsedData, scene) {
    // Shadows
    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {
        for (var index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {
            var parsedShadowGenerator = parsedData.shadowGenerators[index];
            ShadowGenerator.Parse(parsedShadowGenerator, scene);
            // SG would be available on their associated lights
        }
    }
});
/**
 * Defines the shadow generator component responsible to manage any shadow generators
 * in a given scene.
 */
var ShadowGeneratorSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function ShadowGeneratorSceneComponent(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;
        this.scene = scene;
    }
    /**
     * Registers the component in a given scene
     */
    ShadowGeneratorSceneComponent.prototype.register = function () {
        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    ShadowGeneratorSceneComponent.prototype.rebuild = function () {
        // Nothing To Do Here.
    };
    /**
     * Serializes the component data to the specified json object
     * @param serializationObject The object to serialize to
     */
    ShadowGeneratorSceneComponent.prototype.serialize = function (serializationObject) {
        // Shadows
        serializationObject.shadowGenerators = [];
        var lights = this.scene.lights;
        for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
            var light = lights_1[_i];
            var shadowGenerator = light.getShadowGenerator();
            if (shadowGenerator) {
                serializationObject.shadowGenerators.push(shadowGenerator.serialize());
            }
        }
    };
    /**
     * Adds all the element from the container to the scene
     * @param container the container holding the elements
     */
    ShadowGeneratorSceneComponent.prototype.addFromContainer = function (container) {
        // Nothing To Do Here. (directly attached to a light)
    };
    /**
     * Removes all the elements in the container from the scene
     * @param container contains the elements to remove
     * @param dispose if the removed element should be disposed (default: false)
     */
    ShadowGeneratorSceneComponent.prototype.removeFromContainer = function (container, dispose) {
        // Nothing To Do Here. (directly attached to a light)
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    ShadowGeneratorSceneComponent.prototype.dispose = function () {
        // Nothing To Do Here.
    };
    ShadowGeneratorSceneComponent.prototype._gatherRenderTargets = function (renderTargets) {
        // Shadows
        var scene = this.scene;
        if (this.scene.shadowsEnabled) {
            for (var lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {
                var light = scene.lights[lightIndex];
                var shadowGenerator = light.getShadowGenerator();
                if (light.isEnabled() && light.shadowEnabled && shadowGenerator) {
                    var shadowMap = (shadowGenerator.getShadowMap());
                    if (scene.textures.indexOf(shadowMap) !== -1) {
                        renderTargets.push(shadowMap);
                    }
                }
            }
        }
    };
    return ShadowGeneratorSceneComponent;
}());
ShadowGenerator._SceneComponentInitialization = function (scene) {
    var component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);
    if (!component) {
        component = new ShadowGeneratorSceneComponent(scene);
        scene._addComponent(component);
    }
};

/**
 * Class used for the default loading screen
 * @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
 */
var DefaultLoadingScreen = /** @class */ (function () {
    /**
     * Creates a new default loading screen
     * @param _renderingCanvas defines the canvas used to render the scene
     * @param _loadingText defines the default text to display
     * @param _loadingDivBackgroundColor defines the default background color
     */
    function DefaultLoadingScreen(_renderingCanvas, _loadingText, _loadingDivBackgroundColor) {
        var _this = this;
        if (_loadingText === void 0) { _loadingText = ""; }
        if (_loadingDivBackgroundColor === void 0) { _loadingDivBackgroundColor = "black"; }
        this._renderingCanvas = _renderingCanvas;
        this._loadingText = _loadingText;
        this._loadingDivBackgroundColor = _loadingDivBackgroundColor;
        // Resize
        this._resizeLoadingUI = function () {
            var canvasRect = _this._renderingCanvas.getBoundingClientRect();
            var canvasPositioning = window.getComputedStyle(_this._renderingCanvas).position;
            if (!_this._loadingDiv) {
                return;
            }
            _this._loadingDiv.style.position = (canvasPositioning === "fixed") ? "fixed" : "absolute";
            _this._loadingDiv.style.left = canvasRect.left + "px";
            _this._loadingDiv.style.top = canvasRect.top + "px";
            _this._loadingDiv.style.width = canvasRect.width + "px";
            _this._loadingDiv.style.height = canvasRect.height + "px";
        };
    }
    /**
     * Function called to display the loading screen
     */
    DefaultLoadingScreen.prototype.displayLoadingUI = function () {
        if (this._loadingDiv) {
            // Do not add a loading screen if there is already one
            return;
        }
        this._loadingDiv = document.createElement("div");
        this._loadingDiv.id = "babylonjsLoadingDiv";
        this._loadingDiv.style.opacity = "0";
        this._loadingDiv.style.transition = "opacity 1.5s ease";
        this._loadingDiv.style.pointerEvents = "none";
        // Loading text
        this._loadingTextDiv = document.createElement("div");
        this._loadingTextDiv.style.position = "absolute";
        this._loadingTextDiv.style.left = "0";
        this._loadingTextDiv.style.top = "50%";
        this._loadingTextDiv.style.marginTop = "80px";
        this._loadingTextDiv.style.width = "100%";
        this._loadingTextDiv.style.height = "20px";
        this._loadingTextDiv.style.fontFamily = "Arial";
        this._loadingTextDiv.style.fontSize = "14px";
        this._loadingTextDiv.style.color = "white";
        this._loadingTextDiv.style.textAlign = "center";
        this._loadingTextDiv.innerHTML = "Loading";
        this._loadingDiv.appendChild(this._loadingTextDiv);
        //set the predefined text
        this._loadingTextDiv.innerHTML = this._loadingText;
        // Generating keyframes
        var style = document.createElement('style');
        style.type = 'text/css';
        var keyFrames = "@-webkit-keyframes spin1 {                    0% { -webkit-transform: rotate(0deg);}\n                    100% { -webkit-transform: rotate(360deg);}\n                }                @keyframes spin1 {                    0% { transform: rotate(0deg);}\n                    100% { transform: rotate(360deg);}\n                }";
        style.innerHTML = keyFrames;
        document.getElementsByTagName('head')[0].appendChild(style);
        // Loading img
        var imgBack = new Image();
        if (!DefaultLoadingScreen.DefaultLogoUrl) {
            imgBack.src = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxODAuMTcgMjA4LjA0Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9LmNscy0ye2ZpbGw6I2UwNjg0Yjt9LmNscy0ze2ZpbGw6I2JiNDY0Yjt9LmNscy00e2ZpbGw6I2UwZGVkODt9LmNscy01e2ZpbGw6I2Q1ZDJjYTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPkJhYnlsb25Mb2dvPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iUGFnZV9FbGVtZW50cyIgZGF0YS1uYW1lPSJQYWdlIEVsZW1lbnRzIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik05MC4wOSwwLDAsNTJWMTU2bDkwLjA5LDUyLDkwLjA4LTUyVjUyWiIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMiIgcG9pbnRzPSIxODAuMTcgNTIuMDEgMTUxLjk3IDM1LjczIDEyNC44NSA1MS4zOSAxNTMuMDUgNjcuNjcgMTgwLjE3IDUyLjAxIi8+PHBvbHlnb24gY2xhc3M9ImNscy0yIiBwb2ludHM9IjI3LjEyIDY3LjY3IDExNy4yMSAxNS42NiA5MC4wOCAwIDAgNTIuMDEgMjcuMTIgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTIiIHBvaW50cz0iNjEuODkgMTIwLjMgOTAuMDggMTM2LjU4IDExOC4yOCAxMjAuMyA5MC4wOCAxMDQuMDIgNjEuODkgMTIwLjMiLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDE1My4wNSAxNDAuMzcgOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyAwIDUyLjAxIDAgMTU2LjAzIDkwLjA4IDIwOC4wNCAxODAuMTcgMTU2LjAzIDE4MC4xNyA1Mi4wMSAxNTMuMDUgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iOTAuMDggNzEuNDYgNjEuODkgODcuNzQgNjEuODkgMTIwLjMgOTAuMDggMTA0LjAyIDExOC4yOCAxMjAuMyAxMTguMjggODcuNzQgOTAuMDggNzEuNDYiLz48cG9seWdvbiBjbGFzcz0iY2xzLTQiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDExOC4yOCA4Ny43NCAxMTguMjggMTIwLjMgOTAuMDggMTM2LjU4IDkwLjA4IDE3Ni43MiAxNTMuMDUgMTQwLjM3IDE1My4wNSA2Ny42NyIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtNSIgcG9pbnRzPSIyNy4xMiA2Ny42NyA2MS44OSA4Ny43NCA2MS44OSAxMjAuMyA5MC4wOCAxMzYuNTggOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyIvPjwvZz48L2c+PC9zdmc+";
        }
        else {
            imgBack.src = DefaultLoadingScreen.DefaultLogoUrl;
        }
        imgBack.style.position = "absolute";
        imgBack.style.left = "50%";
        imgBack.style.top = "50%";
        imgBack.style.width = "10vw";
        imgBack.style.height = "10vw";
        imgBack.style.marginLeft = "-5vw";
        imgBack.style.marginTop = "-5vw";
        // Loading spinner
        var imgSpinner = new Image();
        if (!DefaultLoadingScreen.DefaultSpinnerUrl) {
            imgSpinner.src = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzOTIgMzkyIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2UwNjg0Yjt9LmNscy0ye2ZpbGw6bm9uZTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPlNwaW5uZXJJY29uPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iU3Bpbm5lciI+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNDAuMjEsMTI2LjQzYzMuNy03LjMxLDcuNjctMTQuNDQsMTItMjEuMzJsMy4zNi01LjEsMy41Mi01YzEuMjMtMS42MywyLjQxLTMuMjksMy42NS00LjkxczIuNTMtMy4yMSwzLjgyLTQuNzlBMTg1LjIsMTg1LjIsMCwwLDEsODMuNCw2Ny40M2EyMDgsMjA4LDAsMCwxLDE5LTE1LjY2YzMuMzUtMi40MSw2Ljc0LTQuNzgsMTAuMjUtN3M3LjExLTQuMjgsMTAuNzUtNi4zMmM3LjI5LTQsMTQuNzMtOCwyMi41My0xMS40OSwzLjktMS43Miw3Ljg4LTMuMywxMi00LjY0YTEwNC4yMiwxMDQuMjIsMCwwLDEsMTIuNDQtMy4yMyw2Mi40NCw2Mi40NCwwLDAsMSwxMi43OC0xLjM5QTI1LjkyLDI1LjkyLDAsMCwxLDE5NiwyMS40NGE2LjU1LDYuNTUsMCwwLDEsMi4wNSw5LDYuNjYsNi42NiwwLDAsMS0xLjY0LDEuNzhsLS40MS4yOWEyMi4wNywyMi4wNywwLDAsMS01Ljc4LDMsMzAuNDIsMzAuNDIsMCwwLDEtNS42NywxLjYyLDM3LjgyLDM3LjgyLDAsMCwxLTUuNjkuNzFjLTEsMC0xLjkuMTgtMi44NS4yNmwtMi44NS4yNHEtNS43Mi41MS0xMS40OCwxLjFjLTMuODQuNC03LjcxLjgyLTExLjU4LDEuNGExMTIuMzQsMTEyLjM0LDAsMCwwLTIyLjk0LDUuNjFjLTMuNzIsMS4zNS03LjM0LDMtMTAuOTQsNC42NHMtNy4xNCwzLjUxLTEwLjYsNS41MUExNTEuNiwxNTEuNiwwLDAsMCw2OC41Niw4N0M2Ny4yMyw4OC40OCw2Niw5MCw2NC42NCw5MS41NnMtMi41MSwzLjE1LTMuNzUsNC43M2wtMy41NCw0LjljLTEuMTMsMS42Ni0yLjIzLDMuMzUtMy4zMyw1YTEyNywxMjcsMCwwLDAtMTAuOTMsMjEuNDksMS41OCwxLjU4LDAsMSwxLTMtMS4xNVM0MC4xOSwxMjYuNDcsNDAuMjEsMTI2LjQzWiIvPjxyZWN0IGNsYXNzPSJjbHMtMiIgd2lkdGg9IjM5MiIgaGVpZ2h0PSIzOTIiLz48L2c+PC9nPjwvc3ZnPg==";
        }
        else {
            imgSpinner.src = DefaultLoadingScreen.DefaultSpinnerUrl;
        }
        imgSpinner.style.position = "absolute";
        imgSpinner.style.left = "50%";
        imgSpinner.style.top = "50%";
        imgSpinner.style.width = "18vw";
        imgSpinner.style.height = "18vw";
        imgSpinner.style.marginLeft = "-9vw";
        imgSpinner.style.marginTop = "-9vw";
        imgSpinner.style.animation = "spin1 0.75s infinite linear";
        imgSpinner.style.webkitAnimation = "spin1 0.75s infinite linear";
        imgSpinner.style.transformOrigin = "50% 50%";
        imgSpinner.style.webkitTransformOrigin = "50% 50%";
        this._loadingDiv.appendChild(imgBack);
        this._loadingDiv.appendChild(imgSpinner);
        this._resizeLoadingUI();
        window.addEventListener("resize", this._resizeLoadingUI);
        this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;
        document.body.appendChild(this._loadingDiv);
        this._loadingDiv.style.opacity = "1";
    };
    /**
     * Function called to hide the loading screen
     */
    DefaultLoadingScreen.prototype.hideLoadingUI = function () {
        var _this = this;
        if (!this._loadingDiv) {
            return;
        }
        var onTransitionEnd = function () {
            if (!_this._loadingDiv) {
                return;
            }
            if (_this._loadingDiv.parentElement) {
                _this._loadingDiv.parentElement.removeChild(_this._loadingDiv);
            }
            window.removeEventListener("resize", _this._resizeLoadingUI);
            _this._loadingDiv = null;
        };
        this._loadingDiv.style.opacity = "0";
        this._loadingDiv.addEventListener("transitionend", onTransitionEnd);
    };
    Object.defineProperty(DefaultLoadingScreen.prototype, "loadingUIText", {
        get: function () {
            return this._loadingText;
        },
        /**
         * Gets or sets the text to display while loading
         */
        set: function (text) {
            this._loadingText = text;
            if (this._loadingTextDiv) {
                this._loadingTextDiv.innerHTML = this._loadingText;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultLoadingScreen.prototype, "loadingUIBackgroundColor", {
        /**
         * Gets or sets the color to use for the background
         */
        get: function () {
            return this._loadingDivBackgroundColor;
        },
        set: function (color) {
            this._loadingDivBackgroundColor = color;
            if (!this._loadingDiv) {
                return;
            }
            this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;
        },
        enumerable: true,
        configurable: true
    });
    /** Gets or sets the logo url to use for the default loading screen */
    DefaultLoadingScreen.DefaultLogoUrl = "";
    /** Gets or sets the spinner url to use for the default loading screen */
    DefaultLoadingScreen.DefaultSpinnerUrl = "";
    return DefaultLoadingScreen;
}());
Engine.DefaultLoadingScreenFactory = function (canvas) { return new DefaultLoadingScreen(canvas); };

/**
 * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.
 */
var PanoramaToCubeMapTools = /** @class */ (function () {
    function PanoramaToCubeMapTools() {
    }
    /**
     * Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).
     *
     * @param float32Array The source data.
     * @param inputWidth The width of the input panorama.
     * @param inputHeight The height of the input panorama.
     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)
     * @return The cubemap data
     */
    PanoramaToCubeMapTools.ConvertPanoramaToCubemap = function (float32Array, inputWidth, inputHeight, size) {
        if (!float32Array) {
            throw "ConvertPanoramaToCubemap: input cannot be null";
        }
        if (float32Array.length != inputWidth * inputHeight * 3) {
            throw "ConvertPanoramaToCubemap: input size is wrong";
        }
        var textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);
        var textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);
        var textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);
        var textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);
        var textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);
        var textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);
        return {
            front: textureFront,
            back: textureBack,
            left: textureLeft,
            right: textureRight,
            up: textureUp,
            down: textureDown,
            size: size,
            type: Constants.TEXTURETYPE_FLOAT,
            format: Constants.TEXTUREFORMAT_RGB,
            gammaSpace: false,
        };
    };
    PanoramaToCubeMapTools.CreateCubemapTexture = function (texSize, faceData, float32Array, inputWidth, inputHeight) {
        var buffer = new ArrayBuffer(texSize * texSize * 4 * 3);
        var textureArray = new Float32Array(buffer);
        var rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);
        var rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);
        var dy = 1 / texSize;
        var fy = 0;
        for (var y = 0; y < texSize; y++) {
            var xv1 = faceData[0];
            var xv2 = faceData[2];
            for (var x = 0; x < texSize; x++) {
                var v = xv2.subtract(xv1).scale(fy).add(xv1);
                v.normalize();
                var color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);
                // 3 channels per pixels
                textureArray[y * texSize * 3 + (x * 3) + 0] = color.r;
                textureArray[y * texSize * 3 + (x * 3) + 1] = color.g;
                textureArray[y * texSize * 3 + (x * 3) + 2] = color.b;
                xv1 = xv1.add(rotDX1);
                xv2 = xv2.add(rotDX2);
            }
            fy += dy;
        }
        return textureArray;
    };
    PanoramaToCubeMapTools.CalcProjectionSpherical = function (vDir, float32Array, inputWidth, inputHeight) {
        var theta = Math.atan2(vDir.z, vDir.x);
        var phi = Math.acos(vDir.y);
        while (theta < -Math.PI) {
            theta += 2 * Math.PI;
        }
        while (theta > Math.PI) {
            theta -= 2 * Math.PI;
        }
        var dx = theta / Math.PI;
        var dy = phi / Math.PI;
        // recenter.
        dx = dx * 0.5 + 0.5;
        var px = Math.round(dx * inputWidth);
        if (px < 0) {
            px = 0;
        }
        else if (px >= inputWidth) {
            px = inputWidth - 1;
        }
        var py = Math.round(dy * inputHeight);
        if (py < 0) {
            py = 0;
        }
        else if (py >= inputHeight) {
            py = inputHeight - 1;
        }
        var inputY = (inputHeight - py - 1);
        var r = float32Array[inputY * inputWidth * 3 + (px * 3) + 0];
        var g = float32Array[inputY * inputWidth * 3 + (px * 3) + 1];
        var b = float32Array[inputY * inputWidth * 3 + (px * 3) + 2];
        return {
            r: r,
            g: g,
            b: b
        };
    };
    PanoramaToCubeMapTools.FACE_FRONT = [
        new Vector3(-1.0, -1.0, -1.0),
        new Vector3(1.0, -1.0, -1.0),
        new Vector3(-1.0, 1.0, -1.0),
        new Vector3(1.0, 1.0, -1.0)
    ];
    PanoramaToCubeMapTools.FACE_BACK = [
        new Vector3(1.0, -1.0, 1.0),
        new Vector3(-1.0, -1.0, 1.0),
        new Vector3(1.0, 1.0, 1.0),
        new Vector3(-1.0, 1.0, 1.0)
    ];
    PanoramaToCubeMapTools.FACE_RIGHT = [
        new Vector3(1.0, -1.0, -1.0),
        new Vector3(1.0, -1.0, 1.0),
        new Vector3(1.0, 1.0, -1.0),
        new Vector3(1.0, 1.0, 1.0)
    ];
    PanoramaToCubeMapTools.FACE_LEFT = [
        new Vector3(-1.0, -1.0, 1.0),
        new Vector3(-1.0, -1.0, -1.0),
        new Vector3(-1.0, 1.0, 1.0),
        new Vector3(-1.0, 1.0, -1.0)
    ];
    PanoramaToCubeMapTools.FACE_DOWN = [
        new Vector3(-1.0, 1.0, -1.0),
        new Vector3(1.0, 1.0, -1.0),
        new Vector3(-1.0, 1.0, 1.0),
        new Vector3(1.0, 1.0, 1.0)
    ];
    PanoramaToCubeMapTools.FACE_UP = [
        new Vector3(-1.0, -1.0, 1.0),
        new Vector3(1.0, -1.0, 1.0),
        new Vector3(-1.0, -1.0, -1.0),
        new Vector3(1.0, -1.0, -1.0)
    ];
    return PanoramaToCubeMapTools;
}());

/**
 * This groups tools to convert HDR texture to native colors array.
 */
var HDRTools = /** @class */ (function () {
    function HDRTools() {
    }
    HDRTools.Ldexp = function (mantissa, exponent) {
        if (exponent > 1023) {
            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
        }
        if (exponent < -1074) {
            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
        }
        return mantissa * Math.pow(2, exponent);
    };
    HDRTools.Rgbe2float = function (float32array, red, green, blue, exponent, index) {
        if (exponent > 0) { /*nonzero pixel*/
            exponent = this.Ldexp(1.0, exponent - (128 + 8));
            float32array[index + 0] = red * exponent;
            float32array[index + 1] = green * exponent;
            float32array[index + 2] = blue * exponent;
        }
        else {
            float32array[index + 0] = 0;
            float32array[index + 1] = 0;
            float32array[index + 2] = 0;
        }
    };
    HDRTools.readStringLine = function (uint8array, startIndex) {
        var line = "";
        var character = "";
        for (var i = startIndex; i < uint8array.length - startIndex; i++) {
            character = String.fromCharCode(uint8array[i]);
            if (character == "\n") {
                break;
            }
            line += character;
        }
        return line;
    };
    /**
     * Reads header information from an RGBE texture stored in a native array.
     * More information on this format are available here:
     * https://en.wikipedia.org/wiki/RGBE_image_format
     *
     * @param uint8array The binary file stored in  native array.
     * @return The header information.
     */
    HDRTools.RGBE_ReadHeader = function (uint8array) {
        var height = 0;
        var width = 0;
        var line = this.readStringLine(uint8array, 0);
        if (line[0] != '#' || line[1] != '?') {
            throw "Bad HDR Format.";
        }
        var endOfHeader = false;
        var findFormat = false;
        var lineIndex = 0;
        do {
            lineIndex += (line.length + 1);
            line = this.readStringLine(uint8array, lineIndex);
            if (line == "FORMAT=32-bit_rle_rgbe") {
                findFormat = true;
            }
            else if (line.length == 0) {
                endOfHeader = true;
            }
        } while (!endOfHeader);
        if (!findFormat) {
            throw "HDR Bad header format, unsupported FORMAT";
        }
        lineIndex += (line.length + 1);
        line = this.readStringLine(uint8array, lineIndex);
        var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
        var match = sizeRegexp.exec(line);
        // TODO. Support +Y and -X if needed.
        if (!match || match.length < 3) {
            throw "HDR Bad header format, no size";
        }
        width = parseInt(match[2]);
        height = parseInt(match[1]);
        if (width < 8 || width > 0x7fff) {
            throw "HDR Bad header format, unsupported size";
        }
        lineIndex += (line.length + 1);
        return {
            height: height,
            width: width,
            dataPosition: lineIndex
        };
    };
    /**
     * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.
     * This RGBE texture needs to store the information as a panorama.
     *
     * More information on this format are available here:
     * https://en.wikipedia.org/wiki/RGBE_image_format
     *
     * @param buffer The binary file stored in an array buffer.
     * @param size The expected size of the extracted cubemap.
     * @return The Cube Map information.
     */
    HDRTools.GetCubeMapTextureData = function (buffer, size) {
        var uint8array = new Uint8Array(buffer);
        var hdrInfo = this.RGBE_ReadHeader(uint8array);
        var data = this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);
        var cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);
        return cubeMapData;
    };
    /**
     * Returns the pixels data extracted from an RGBE texture.
     * This pixels will be stored left to right up to down in the R G B order in one array.
     *
     * More information on this format are available here:
     * https://en.wikipedia.org/wiki/RGBE_image_format
     *
     * @param uint8array The binary file stored in an array buffer.
     * @param hdrInfo The header information of the file.
     * @return The pixels data in RGB right to left up to down order.
     */
    HDRTools.RGBE_ReadPixels = function (uint8array, hdrInfo) {
        // Keep for multi format supports.
        return this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);
    };
    HDRTools.RGBE_ReadPixels_RLE = function (uint8array, hdrInfo) {
        var num_scanlines = hdrInfo.height;
        var scanline_width = hdrInfo.width;
        var a, b, c, d, count;
        var dataIndex = hdrInfo.dataPosition;
        var index = 0, endIndex = 0, i = 0;
        var scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E
        var scanLineArray = new Uint8Array(scanLineArrayBuffer);
        // 3 channels of 4 bytes per pixel in float.
        var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
        var resultArray = new Float32Array(resultBuffer);
        // read in each successive scanline
        while (num_scanlines > 0) {
            a = uint8array[dataIndex++];
            b = uint8array[dataIndex++];
            c = uint8array[dataIndex++];
            d = uint8array[dataIndex++];
            if (a != 2 || b != 2 || (c & 0x80)) {
                // this file is not run length encoded
                throw "HDR Bad header format, not RLE";
            }
            if (((c << 8) | d) != scanline_width) {
                throw "HDR Bad header format, wrong scan line width";
            }
            index = 0;
            // read each of the four channels for the scanline into the buffer
            for (i = 0; i < 4; i++) {
                endIndex = (i + 1) * scanline_width;
                while (index < endIndex) {
                    a = uint8array[dataIndex++];
                    b = uint8array[dataIndex++];
                    if (a > 128) {
                        // a run of the same value
                        count = a - 128;
                        if ((count == 0) || (count > endIndex - index)) {
                            throw "HDR Bad Format, bad scanline data (run)";
                        }
                        while (count-- > 0) {
                            scanLineArray[index++] = b;
                        }
                    }
                    else {
                        // a non-run
                        count = a;
                        if ((count == 0) || (count > endIndex - index)) {
                            throw "HDR Bad Format, bad scanline data (non-run)";
                        }
                        scanLineArray[index++] = b;
                        if (--count > 0) {
                            for (var j = 0; j < count; j++) {
                                scanLineArray[index++] = uint8array[dataIndex++];
                            }
                        }
                    }
                }
            }
            // now convert data from buffer into floats
            for (i = 0; i < scanline_width; i++) {
                a = scanLineArray[i];
                b = scanLineArray[i + scanline_width];
                c = scanLineArray[i + 2 * scanline_width];
                d = scanLineArray[i + 3 * scanline_width];
                this.Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);
            }
            num_scanlines--;
        }
        return resultArray;
    };
    return HDRTools;
}());

/**
 * This represents a texture coming from an HDR input.
 *
 * The only supported format is currently panorama picture stored in RGBE format.
 * Example of such files can be found on HDRLib: http://hdrlib.com/
 */
var HDRCubeTexture = /** @class */ (function (_super) {
    __extends(HDRCubeTexture, _super);
    /**
     * Instantiates an HDRTexture from the following parameters.
     *
     * @param url The location of the HDR raw data (Panorama stored in RGBE format)
     * @param scene The scene the texture will be used in
     * @param size The cubemap desired size (the more it increases the longer the generation will be)
     * @param noMipmap Forces to not generate the mipmap if true
     * @param generateHarmonics Specifies whether you want to extract the polynomial harmonics during the generation process
     * @param gammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)
     * @param reserved Reserved flag for internal use.
     */
    function HDRCubeTexture(url, scene, size, noMipmap, generateHarmonics, gammaSpace, reserved, onLoad, onError) {
        if (noMipmap === void 0) { noMipmap = false; }
        if (gammaSpace === void 0) { gammaSpace = false; }
        if (onLoad === void 0) { onLoad = null; }
        if (onError === void 0) { onError = null; }
        var _this = _super.call(this, scene) || this;
        _this._generateHarmonics = true;
        _this._onLoad = null;
        _this._onError = null;
        /**
         * The texture coordinates mode. As this texture is stored in a cube format, please modify carefully.
         */
        _this.coordinatesMode = Texture.CUBIC_MODE;
        _this._isBlocking = true;
        _this._rotationY = 0;
        /**
         * Gets or sets the center of the bounding box associated with the cube texture
         * It must define where the camera used to render the texture was set
         */
        _this.boundingBoxPosition = Vector3.Zero();
        if (!url) {
            return _this;
        }
        _this.name = url;
        _this.url = url;
        _this.hasAlpha = false;
        _this.isCube = true;
        _this._textureMatrix = Matrix.Identity();
        _this._onLoad = onLoad;
        _this._onError = onError;
        _this.gammaSpace = gammaSpace;
        _this._noMipmap = noMipmap;
        _this._size = size;
        _this._texture = _this._getFromCache(url, _this._noMipmap);
        if (!_this._texture) {
            if (!scene.useDelayedTextureLoading) {
                _this.loadTexture();
            }
            else {
                _this.delayLoadState = Engine.DELAYLOADSTATE_NOTLOADED;
            }
        }
        else if (onLoad) {
            if (_this._texture.isReady) {
                Tools.SetImmediate(function () { return onLoad(); });
            }
            else {
                _this._texture.onLoadedObservable.add(onLoad);
            }
        }
        return _this;
    }
    Object.defineProperty(HDRCubeTexture.prototype, "isBlocking", {
        /**
         * Gets wether or not the texture is blocking during loading.
         */
        get: function () {
            return this._isBlocking;
        },
        /**
         * Sets wether or not the texture is blocking during loading.
         */
        set: function (value) {
            this._isBlocking = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HDRCubeTexture.prototype, "rotationY", {
        /**
         * Gets texture matrix rotation angle around Y axis radians.
         */
        get: function () {
            return this._rotationY;
        },
        /**
         * Sets texture matrix rotation angle around Y axis in radians.
         */
        set: function (value) {
            this._rotationY = value;
            this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HDRCubeTexture.prototype, "boundingBoxSize", {
        get: function () {
            return this._boundingBoxSize;
        },
        /**
         * Gets or sets the size of the bounding box associated with the cube texture
         * When defined, the cubemap will switch to local mode
         * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
         * @example https://www.babylonjs-playground.com/#RNASML
         */
        set: function (value) {
            if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
                return;
            }
            this._boundingBoxSize = value;
            var scene = this.getScene();
            if (scene) {
                scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the current class name of the texture useful for serialization or dynamic coding.
     * @returns "HDRCubeTexture"
     */
    HDRCubeTexture.prototype.getClassName = function () {
        return "HDRCubeTexture";
    };
    /**
     * Occurs when the file is raw .hdr file.
     */
    HDRCubeTexture.prototype.loadTexture = function () {
        var _this = this;
        var callback = function (buffer) {
            _this.lodGenerationOffset = 0.0;
            _this.lodGenerationScale = 0.8;
            var scene = _this.getScene();
            if (!scene) {
                return null;
            }
            // Extract the raw linear data.
            var data = HDRTools.GetCubeMapTextureData(buffer, _this._size);
            // Generate harmonics if needed.
            if (_this._generateHarmonics) {
                var sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(data);
                _this.sphericalPolynomial = sphericalPolynomial;
            }
            var results = [];
            var byteArray = null;
            // Push each faces.
            for (var j = 0; j < 6; j++) {
                // Create uintarray fallback.
                if (!scene.getEngine().getCaps().textureFloat) {
                    // 3 channels of 1 bytes per pixel in bytes.
                    var byteBuffer = new ArrayBuffer(_this._size * _this._size * 3);
                    byteArray = new Uint8Array(byteBuffer);
                }
                var dataFace = (data[HDRCubeTexture._facesMapping[j]]);
                // If special cases.
                if (_this.gammaSpace || byteArray) {
                    for (var i = 0; i < _this._size * _this._size; i++) {
                        // Put in gamma space if requested.
                        if (_this.gammaSpace) {
                            dataFace[(i * 3) + 0] = Math.pow(dataFace[(i * 3) + 0], ToGammaSpace);
                            dataFace[(i * 3) + 1] = Math.pow(dataFace[(i * 3) + 1], ToGammaSpace);
                            dataFace[(i * 3) + 2] = Math.pow(dataFace[(i * 3) + 2], ToGammaSpace);
                        }
                        // Convert to int texture for fallback.
                        if (byteArray) {
                            var r = Math.max(dataFace[(i * 3) + 0] * 255, 0);
                            var g = Math.max(dataFace[(i * 3) + 1] * 255, 0);
                            var b = Math.max(dataFace[(i * 3) + 2] * 255, 0);
                            // May use luminance instead if the result is not accurate.
                            var max = Math.max(Math.max(r, g), b);
                            if (max > 255) {
                                var scale = 255 / max;
                                r *= scale;
                                g *= scale;
                                b *= scale;
                            }
                            byteArray[(i * 3) + 0] = r;
                            byteArray[(i * 3) + 1] = g;
                            byteArray[(i * 3) + 2] = b;
                        }
                    }
                }
                if (byteArray) {
                    results.push(byteArray);
                }
                else {
                    results.push(dataFace);
                }
            }
            return results;
        };
        var scene = this.getScene();
        if (scene) {
            this._texture = scene.getEngine().createRawCubeTextureFromUrl(this.url, scene, this._size, Engine.TEXTUREFORMAT_RGB, scene.getEngine().getCaps().textureFloat ? Engine.TEXTURETYPE_FLOAT : Engine.TEXTURETYPE_UNSIGNED_INT, this._noMipmap, callback, null, this._onLoad, this._onError);
        }
    };
    HDRCubeTexture.prototype.clone = function () {
        var scene = this.getScene();
        if (!scene) {
            return this;
        }
        var newTexture = new HDRCubeTexture(this.url, scene, this._size, this._noMipmap, this._generateHarmonics, this.gammaSpace);
        // Base texture
        newTexture.level = this.level;
        newTexture.wrapU = this.wrapU;
        newTexture.wrapV = this.wrapV;
        newTexture.coordinatesIndex = this.coordinatesIndex;
        newTexture.coordinatesMode = this.coordinatesMode;
        return newTexture;
    };
    // Methods
    HDRCubeTexture.prototype.delayLoad = function () {
        if (this.delayLoadState !== Engine.DELAYLOADSTATE_NOTLOADED) {
            return;
        }
        this.delayLoadState = Engine.DELAYLOADSTATE_LOADED;
        this._texture = this._getFromCache(this.url, this._noMipmap);
        if (!this._texture) {
            this.loadTexture();
        }
    };
    /**
     * Get the texture reflection matrix used to rotate/transform the reflection.
     * @returns the reflection matrix
     */
    HDRCubeTexture.prototype.getReflectionTextureMatrix = function () {
        return this._textureMatrix;
    };
    /**
     * Set the texture reflection matrix used to rotate/transform the reflection.
     * @param value Define the reflection matrix to set
     */
    HDRCubeTexture.prototype.setReflectionTextureMatrix = function (value) {
        var _this = this;
        this._textureMatrix = value;
        if (value.updateFlag === this._textureMatrix.updateFlag) {
            return;
        }
        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
            this.getScene().markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, function (mat) { return mat.getActiveTextures().indexOf(_this) !== -1; });
        }
    };
    /**
     * Parses a JSON representation of an HDR Texture in order to create the texture
     * @param parsedTexture Define the JSON representation
     * @param scene Define the scene the texture should be created in
     * @param rootUrl Define the root url in case we need to load relative dependencies
     * @returns the newly created texture after parsing
     */
    HDRCubeTexture.Parse = function (parsedTexture, scene, rootUrl) {
        var texture = null;
        if (parsedTexture.name && !parsedTexture.isRenderTarget) {
            texture = new HDRCubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.size, parsedTexture.noMipmap, parsedTexture.generateHarmonics, parsedTexture.useInGammaSpace);
            texture.name = parsedTexture.name;
            texture.hasAlpha = parsedTexture.hasAlpha;
            texture.level = parsedTexture.level;
            texture.coordinatesMode = parsedTexture.coordinatesMode;
            texture.isBlocking = parsedTexture.isBlocking;
        }
        if (texture) {
            if (parsedTexture.boundingBoxPosition) {
                texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
            }
            if (parsedTexture.boundingBoxSize) {
                texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
            }
            if (parsedTexture.rotationY) {
                texture.rotationY = parsedTexture.rotationY;
            }
        }
        return texture;
    };
    HDRCubeTexture.prototype.serialize = function () {
        if (!this.name) {
            return null;
        }
        var serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.hasAlpha = this.hasAlpha;
        serializationObject.isCube = true;
        serializationObject.level = this.level;
        serializationObject.size = this._size;
        serializationObject.coordinatesMode = this.coordinatesMode;
        serializationObject.useInGammaSpace = this.gammaSpace;
        serializationObject.generateHarmonics = this._generateHarmonics;
        serializationObject.customType = "BABYLON.HDRCubeTexture";
        serializationObject.noMipmap = this._noMipmap;
        serializationObject.isBlocking = this._isBlocking;
        serializationObject.rotationY = this._rotationY;
        return serializationObject;
    };
    HDRCubeTexture._facesMapping = [
        "right",
        "left",
        "up",
        "down",
        "front",
        "back"
    ];
    return HDRCubeTexture;
}(BaseTexture));
_TypeStore.RegisteredTypes["BABYLON.HDRCubeTexture"] = HDRCubeTexture;

/**
 * Class used to control physics engine
 * @see http://doc.babylonjs.com/how_to/using_the_physics_engine
 */
var PhysicsEngine = /** @class */ (function () {
    /**
     * Creates a new Physics Engine
     * @param gravity defines the gravity vector used by the simulation
     * @param _physicsPlugin defines the plugin to use (CannonJS by default)
     */
    function PhysicsEngine(gravity, _physicsPlugin) {
        if (_physicsPlugin === void 0) { _physicsPlugin = PhysicsEngine.DefaultPluginFactory(); }
        this._physicsPlugin = _physicsPlugin;
        this._impostors = [];
        this._joints = [];
        if (!this._physicsPlugin.isSupported()) {
            throw new Error("Physics Engine " + this._physicsPlugin.name + " cannot be found. "
                + "Please make sure it is included.");
        }
        gravity = gravity || new Vector3(0, -9.807, 0);
        this.setGravity(gravity);
        this.setTimeStep();
    }
    /**
     * Factory used to create the default physics plugin.
     * @returns The default physics plugin
     */
    PhysicsEngine.DefaultPluginFactory = function () {
        throw _DevTools.WarnImport("CannonJSPlugin");
    };
    /**
     * Sets the gravity vector used by the simulation
     * @param gravity defines the gravity vector to use
     */
    PhysicsEngine.prototype.setGravity = function (gravity) {
        this.gravity = gravity;
        this._physicsPlugin.setGravity(this.gravity);
    };
    /**
     * Set the time step of the physics engine.
     * Default is 1/60.
     * To slow it down, enter 1/600 for example.
     * To speed it up, 1/30
     * @param newTimeStep defines the new timestep to apply to this world.
     */
    PhysicsEngine.prototype.setTimeStep = function (newTimeStep) {
        if (newTimeStep === void 0) { newTimeStep = 1 / 60; }
        this._physicsPlugin.setTimeStep(newTimeStep);
    };
    /**
     * Get the time step of the physics engine.
     * @returns the current time step
     */
    PhysicsEngine.prototype.getTimeStep = function () {
        return this._physicsPlugin.getTimeStep();
    };
    /**
     * Release all resources
     */
    PhysicsEngine.prototype.dispose = function () {
        this._impostors.forEach(function (impostor) {
            impostor.dispose();
        });
        this._physicsPlugin.dispose();
    };
    /**
     * Gets the name of the current physics plugin
     * @returns the name of the plugin
     */
    PhysicsEngine.prototype.getPhysicsPluginName = function () {
        return this._physicsPlugin.name;
    };
    /**
     * Adding a new impostor for the impostor tracking.
     * This will be done by the impostor itself.
     * @param impostor the impostor to add
     */
    PhysicsEngine.prototype.addImpostor = function (impostor) {
        impostor.uniqueId = this._impostors.push(impostor);
        //if no parent, generate the body
        if (!impostor.parent) {
            this._physicsPlugin.generatePhysicsBody(impostor);
        }
    };
    /**
     * Remove an impostor from the engine.
     * This impostor and its mesh will not longer be updated by the physics engine.
     * @param impostor the impostor to remove
     */
    PhysicsEngine.prototype.removeImpostor = function (impostor) {
        var index = this._impostors.indexOf(impostor);
        if (index > -1) {
            var removed = this._impostors.splice(index, 1);
            //Is it needed?
            if (removed.length) {
                this.getPhysicsPlugin().removePhysicsBody(impostor);
            }
        }
    };
    /**
     * Add a joint to the physics engine
     * @param mainImpostor defines the main impostor to which the joint is added.
     * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint
     * @param joint defines the joint that will connect both impostors.
     */
    PhysicsEngine.prototype.addJoint = function (mainImpostor, connectedImpostor, joint) {
        var impostorJoint = {
            mainImpostor: mainImpostor,
            connectedImpostor: connectedImpostor,
            joint: joint
        };
        joint.physicsPlugin = this._physicsPlugin;
        this._joints.push(impostorJoint);
        this._physicsPlugin.generateJoint(impostorJoint);
    };
    /**
     * Removes a joint from the simulation
     * @param mainImpostor defines the impostor used with the joint
     * @param connectedImpostor defines the other impostor connected to the main one by the joint
     * @param joint defines the joint to remove
     */
    PhysicsEngine.prototype.removeJoint = function (mainImpostor, connectedImpostor, joint) {
        var matchingJoints = this._joints.filter(function (impostorJoint) {
            return (impostorJoint.connectedImpostor === connectedImpostor
                && impostorJoint.joint === joint
                && impostorJoint.mainImpostor === mainImpostor);
        });
        if (matchingJoints.length) {
            this._physicsPlugin.removeJoint(matchingJoints[0]);
            //TODO remove it from the list as well
        }
    };
    /**
     * Called by the scene. No need to call it.
     * @param delta defines the timespam between frames
     */
    PhysicsEngine.prototype._step = function (delta) {
        var _this = this;
        //check if any mesh has no body / requires an update
        this._impostors.forEach(function (impostor) {
            if (impostor.isBodyInitRequired()) {
                _this._physicsPlugin.generatePhysicsBody(impostor);
            }
        });
        if (delta > 0.1) {
            delta = 0.1;
        }
        else if (delta <= 0) {
            delta = 1.0 / 60.0;
        }
        this._physicsPlugin.executeStep(delta, this._impostors);
    };
    /**
     * Gets the current plugin used to run the simulation
     * @returns current plugin
     */
    PhysicsEngine.prototype.getPhysicsPlugin = function () {
        return this._physicsPlugin;
    };
    /**
     * Gets the list of physic impostors
     * @returns an array of PhysicsImpostor
     */
    PhysicsEngine.prototype.getImpostors = function () {
        return this._impostors;
    };
    /**
     * Gets the impostor for a physics enabled object
     * @param object defines the object impersonated by the impostor
     * @returns the PhysicsImpostor or null if not found
     */
    PhysicsEngine.prototype.getImpostorForPhysicsObject = function (object) {
        for (var i = 0; i < this._impostors.length; ++i) {
            if (this._impostors[i].object === object) {
                return this._impostors[i];
            }
        }
        return null;
    };
    /**
     * Gets the impostor for a physics body object
     * @param body defines physics body used by the impostor
     * @returns the PhysicsImpostor or null if not found
     */
    PhysicsEngine.prototype.getImpostorWithPhysicsBody = function (body) {
        for (var i = 0; i < this._impostors.length; ++i) {
            if (this._impostors[i].physicsBody === body) {
                return this._impostors[i];
            }
        }
        return null;
    };
    /**
     * Does a raycast in the physics world
     * @param from when should the ray start?
     * @param to when should the ray end?
     * @returns PhysicsRaycastResult
     */
    PhysicsEngine.prototype.raycast = function (from, to) {
        return this._physicsPlugin.raycast(from, to);
    };
    /**
     * Global value used to control the smallest number supported by the simulation
     */
    PhysicsEngine.Epsilon = 0.001;
    return PhysicsEngine;
}());

/**
 * Holds the data for the raycast result
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
 */
var PhysicsRaycastResult = /** @class */ (function () {
    function PhysicsRaycastResult() {
        this._hasHit = false;
        this._hitDistance = 0;
        this._hitNormalWorld = Vector3.Zero();
        this._hitPointWorld = Vector3.Zero();
        this._rayFromWorld = Vector3.Zero();
        this._rayToWorld = Vector3.Zero();
    }
    Object.defineProperty(PhysicsRaycastResult.prototype, "hasHit", {
        /**
         * Gets if there was a hit
         */
        get: function () {
            return this._hasHit;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsRaycastResult.prototype, "hitDistance", {
        /**
         * Gets the distance from the hit
         */
        get: function () {
            return this._hitDistance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsRaycastResult.prototype, "hitNormalWorld", {
        /**
         * Gets the hit normal/direction in the world
         */
        get: function () {
            return this._hitNormalWorld;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsRaycastResult.prototype, "hitPointWorld", {
        /**
         * Gets the hit point in the world
         */
        get: function () {
            return this._hitPointWorld;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsRaycastResult.prototype, "rayFromWorld", {
        /**
         * Gets the ray "start point" of the ray in the world
         */
        get: function () {
            return this._rayFromWorld;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicsRaycastResult.prototype, "rayToWorld", {
        /**
         * Gets the ray "end point" of the ray in the world
         */
        get: function () {
            return this._rayToWorld;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the hit data (normal & point in world space)
     * @param hitNormalWorld defines the normal in world space
     * @param hitPointWorld defines the point in world space
     */
    PhysicsRaycastResult.prototype.setHitData = function (hitNormalWorld, hitPointWorld) {
        this._hasHit = true;
        this._hitNormalWorld = new Vector3(hitNormalWorld.x, hitNormalWorld.y, hitNormalWorld.z);
        this._hitPointWorld = new Vector3(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z);
    };
    /**
     * Sets the distance from the start point to the hit point
     * @param distance
     */
    PhysicsRaycastResult.prototype.setHitDistance = function (distance) {
        this._hitDistance = distance;
    };
    /**
     * Calculates the distance manually
     */
    PhysicsRaycastResult.prototype.calculateHitDistance = function () {
        this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPointWorld);
    };
    /**
     * Resets all the values to default
     * @param from The from point on world space
     * @param to The to point on world space
     */
    PhysicsRaycastResult.prototype.reset = function (from, to) {
        if (from === void 0) { from = Vector3.Zero(); }
        if (to === void 0) { to = Vector3.Zero(); }
        this._rayFromWorld = from;
        this._rayToWorld = to;
        this._hasHit = false;
        this._hitDistance = 0;
        this._hitNormalWorld = Vector3.Zero();
        this._hitPointWorld = Vector3.Zero();
    };
    return PhysicsRaycastResult;
}());

/** @hidden */
var CannonJSPlugin = /** @class */ (function () {
    function CannonJSPlugin(_useDeltaForWorldStep, iterations, cannonInjection) {
        if (_useDeltaForWorldStep === void 0) { _useDeltaForWorldStep = true; }
        if (iterations === void 0) { iterations = 10; }
        if (cannonInjection === void 0) { cannonInjection = CANNON; }
        this._useDeltaForWorldStep = _useDeltaForWorldStep;
        this.name = "CannonJSPlugin";
        this._physicsMaterials = new Array();
        this._fixedTimeStep = 1 / 60;
        this._removeAfterStep = new Array();
        this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);
        this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);
        this._tmpPosition = Vector3.Zero();
        this._tmpDeltaPosition = Vector3.Zero();
        this._tmpUnityRotation = new Quaternion();
        this.BJSCANNON = cannonInjection;
        if (!this.isSupported()) {
            Logger.Error("CannonJS is not available. Please make sure you included the js file.");
            return;
        }
        this._extendNamespace();
        this.world = new this.BJSCANNON.World();
        this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();
        this.world.solver.iterations = iterations;
        this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();
        this._raycastResult = new PhysicsRaycastResult();
    }
    CannonJSPlugin.prototype.setGravity = function (gravity) {
        this.world.gravity.copy(gravity);
    };
    CannonJSPlugin.prototype.setTimeStep = function (timeStep) {
        this._fixedTimeStep = timeStep;
    };
    CannonJSPlugin.prototype.getTimeStep = function () {
        return this._fixedTimeStep;
    };
    CannonJSPlugin.prototype.executeStep = function (delta) {
        var _this = this;
        this.world.step(this._fixedTimeStep, this._useDeltaForWorldStep ? delta : 0, 3);
        if (this._removeAfterStep.length > 0) {
            this._removeAfterStep.forEach(function (impostor) {
                _this.world.remove(impostor.physicsBody);
            });
            this._removeAfterStep = [];
        }
    };
    CannonJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {
        var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
        var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);
        impostor.physicsBody.applyImpulse(impulse, worldPoint);
    };
    CannonJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {
        var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
        var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);
        impostor.physicsBody.applyForce(impulse, worldPoint);
    };
    CannonJSPlugin.prototype.generatePhysicsBody = function (impostor) {
        //parent-child relationship. Does this impostor has a parent impostor?
        if (impostor.parent) {
            if (impostor.physicsBody) {
                this.removePhysicsBody(impostor);
                //TODO is that needed?
                impostor.forceUpdate();
            }
            return;
        }
        //should a new body be created for this impostor?
        if (impostor.isBodyInitRequired()) {
            var shape = this._createShape(impostor);
            //unregister events, if body is being changed
            var oldBody = impostor.physicsBody;
            if (oldBody) {
                this.removePhysicsBody(impostor);
            }
            //create the body and material
            var material = this._addMaterial("mat-" + impostor.uniqueId, impostor.getParam("friction"), impostor.getParam("restitution"));
            var bodyCreationObject = {
                mass: impostor.getParam("mass"),
                material: material
            };
            // A simple extend, in case native options were used.
            var nativeOptions = impostor.getParam("nativeOptions");
            for (var key in nativeOptions) {
                if (nativeOptions.hasOwnProperty(key)) {
                    bodyCreationObject[key] = nativeOptions[key];
                }
            }
            impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);
            impostor.physicsBody.addEventListener("collide", impostor.onCollide);
            this.world.addEventListener("preStep", impostor.beforeStep);
            this.world.addEventListener("postStep", impostor.afterStep);
            impostor.physicsBody.addShape(shape);
            this.world.add(impostor.physicsBody);
            //try to keep the body moving in the right direction by taking old properties.
            //Should be tested!
            if (oldBody) {
                ['force', 'torque', 'velocity', 'angularVelocity'].forEach(function (param) {
                    impostor.physicsBody[param].copy(oldBody[param]);
                });
            }
            this._processChildMeshes(impostor);
        }
        //now update the body's transformation
        this._updatePhysicsBodyTransformation(impostor);
    };
    CannonJSPlugin.prototype._processChildMeshes = function (mainImpostor) {
        var _this = this;
        var meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];
        var currentRotation = mainImpostor.object.rotationQuaternion;
        if (meshChildren.length) {
            var processMesh = function (localPosition, mesh) {
                if (!currentRotation || !mesh.rotationQuaternion) {
                    return;
                }
                var childImpostor = mesh.getPhysicsImpostor();
                if (childImpostor) {
                    var parent = childImpostor.parent;
                    if (parent !== mainImpostor) {
                        var pPosition = mesh.getAbsolutePosition().subtract(mainImpostor.object.getAbsolutePosition());
                        var localRotation = mesh.rotationQuaternion.multiply(Quaternion.Inverse(currentRotation));
                        if (childImpostor.physicsBody) {
                            _this.removePhysicsBody(childImpostor);
                            childImpostor.physicsBody = null;
                        }
                        childImpostor.parent = mainImpostor;
                        childImpostor.resetUpdateFlags();
                        mainImpostor.physicsBody.addShape(_this._createShape(childImpostor), new _this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new _this.BJSCANNON.Quaternion(localRotation.x, localRotation.y, localRotation.z, localRotation.w));
                        //Add the mass of the children.
                        mainImpostor.physicsBody.mass += childImpostor.getParam("mass");
                    }
                }
                currentRotation.multiplyInPlace(mesh.rotationQuaternion);
                mesh.getChildMeshes(true).filter(function (m) { return !!m.physicsImpostor; }).forEach(processMesh.bind(_this, mesh.getAbsolutePosition()));
            };
            meshChildren.filter(function (m) { return !!m.physicsImpostor; }).forEach(processMesh.bind(this, mainImpostor.object.getAbsolutePosition()));
        }
    };
    CannonJSPlugin.prototype.removePhysicsBody = function (impostor) {
        impostor.physicsBody.removeEventListener("collide", impostor.onCollide);
        this.world.removeEventListener("preStep", impostor.beforeStep);
        this.world.removeEventListener("postStep", impostor.afterStep);
        // Only remove the physics body after the physics step to avoid disrupting cannon's internal state
        this._removeAfterStep.push(impostor);
    };
    CannonJSPlugin.prototype.generateJoint = function (impostorJoint) {
        var mainBody = impostorJoint.mainImpostor.physicsBody;
        var connectedBody = impostorJoint.connectedImpostor.physicsBody;
        if (!mainBody || !connectedBody) {
            return;
        }
        var constraint;
        var jointData = impostorJoint.joint.jointData;
        //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html
        var constraintData = {
            pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().copy(jointData.mainPivot) : null,
            pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().copy(jointData.connectedPivot) : null,
            axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().copy(jointData.mainAxis) : null,
            axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().copy(jointData.connectedAxis) : null,
            maxForce: jointData.nativeParams.maxForce,
            collideConnected: !!jointData.collision
        };
        switch (impostorJoint.joint.type) {
            case PhysicsJoint.HingeJoint:
            case PhysicsJoint.Hinge2Joint:
                constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);
                break;
            case PhysicsJoint.DistanceJoint:
                constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);
                break;
            case PhysicsJoint.SpringJoint:
                var springData = jointData;
                constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {
                    restLength: springData.length,
                    stiffness: springData.stiffness,
                    damping: springData.damping,
                    localAnchorA: constraintData.pivotA,
                    localAnchorB: constraintData.pivotB
                });
                break;
            case PhysicsJoint.LockJoint:
                constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);
                break;
            case PhysicsJoint.PointToPointJoint:
            case PhysicsJoint.BallAndSocketJoint:
            default:
                constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);
                break;
        }
        //set the collideConnected flag after the creation, since DistanceJoint ignores it.
        constraint.collideConnected = !!jointData.collision;
        impostorJoint.joint.physicsJoint = constraint;
        //don't add spring as constraint, as it is not one.
        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {
            this.world.addConstraint(constraint);
        }
        else {
            impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function () {
                constraint.applyForce();
            };
            impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);
        }
    };
    CannonJSPlugin.prototype.removeJoint = function (impostorJoint) {
        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {
            this.world.removeConstraint(impostorJoint.joint.physicsJoint);
        }
        else {
            impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);
        }
    };
    CannonJSPlugin.prototype._addMaterial = function (name, friction, restitution) {
        var index;
        var mat;
        for (index = 0; index < this._physicsMaterials.length; index++) {
            mat = this._physicsMaterials[index];
            if (mat.friction === friction && mat.restitution === restitution) {
                return mat;
            }
        }
        var currentMat = new this.BJSCANNON.Material(name);
        currentMat.friction = friction;
        currentMat.restitution = restitution;
        this._physicsMaterials.push(currentMat);
        return currentMat;
    };
    CannonJSPlugin.prototype._checkWithEpsilon = function (value) {
        return value < PhysicsEngine.Epsilon ? PhysicsEngine.Epsilon : value;
    };
    CannonJSPlugin.prototype._createShape = function (impostor) {
        var object = impostor.object;
        var returnValue;
        var extendSize = impostor.getObjectExtendSize();
        switch (impostor.type) {
            case PhysicsImpostor.SphereImpostor:
                var radiusX = extendSize.x;
                var radiusY = extendSize.y;
                var radiusZ = extendSize.z;
                returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);
                break;
            //TMP also for cylinder - TODO Cannon supports cylinder natively.
            case PhysicsImpostor.CylinderImpostor:
                var nativeParams = impostor.getParam("nativeOptions");
                if (!nativeParams) {
                    nativeParams = {};
                }
                var radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(extendSize.x) / 2;
                var radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(extendSize.x) / 2;
                var height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(extendSize.y);
                var numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;
                returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);
                // Rotate 90 degrees as this shape is horizontal in cannon
                var quat = new this.BJSCANNON.Quaternion();
                quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);
                var translation = new this.BJSCANNON.Vec3(0, 0, 0);
                returnValue.transformAllPoints(translation, quat);
                break;
            case PhysicsImpostor.BoxImpostor:
                var box = extendSize.scale(0.5);
                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));
                break;
            case PhysicsImpostor.PlaneImpostor:
                Logger.Warn("Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead");
                returnValue = new this.BJSCANNON.Plane();
                break;
            case PhysicsImpostor.MeshImpostor:
                // should transform the vertex data to world coordinates!!
                var rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];
                var rawFaces = object.getIndices ? object.getIndices() : [];
                if (!rawVerts) {
                    return;
                }
                // get only scale! so the object could transform correctly.
                var oldPosition = object.position.clone();
                var oldRotation = object.rotation && object.rotation.clone();
                var oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();
                object.position.copyFromFloats(0, 0, 0);
                object.rotation && object.rotation.copyFromFloats(0, 0, 0);
                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());
                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();
                var transform = object.computeWorldMatrix(true);
                // convert rawVerts to object space
                var temp = new Array();
                var index;
                for (index = 0; index < rawVerts.length; index += 3) {
                    Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(temp, index);
                }
                Logger.Warn("MeshImpostor only collides against spheres.");
                returnValue = new this.BJSCANNON.Trimesh(temp, rawFaces);
                //now set back the transformation!
                object.position.copyFrom(oldPosition);
                oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);
                oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);
                break;
            case PhysicsImpostor.HeightmapImpostor:
                var oldPosition2 = object.position.clone();
                var oldRotation2 = object.rotation && object.rotation.clone();
                var oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();
                object.position.copyFromFloats(0, 0, 0);
                object.rotation && object.rotation.copyFromFloats(0, 0, 0);
                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());
                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();
                object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);
                returnValue = this._createHeightmap(object);
                object.position.copyFrom(oldPosition2);
                oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);
                oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);
                object.computeWorldMatrix(true);
                break;
            case PhysicsImpostor.ParticleImpostor:
                returnValue = new this.BJSCANNON.Particle();
                break;
            case PhysicsImpostor.NoImpostor:
                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));
                break;
        }
        return returnValue;
    };
    CannonJSPlugin.prototype._createHeightmap = function (object, pointDepth) {
        var pos = (object.getVerticesData(VertexBuffer.PositionKind));
        var transform = object.computeWorldMatrix(true);
        // convert rawVerts to object space
        var temp = new Array();
        var index;
        for (index = 0; index < pos.length; index += 3) {
            Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(temp, index);
        }
        pos = temp;
        var matrix = new Array();
        //For now pointDepth will not be used and will be automatically calculated.
        //Future reference - try and find the best place to add a reference to the pointDepth variable.
        var arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);
        var boundingInfo = object.getBoundingInfo();
        var dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);
        var minY = boundingInfo.boundingBox.extendSizeWorld.z;
        var elementSize = dim * 2 / arraySize;
        for (var i = 0; i < pos.length; i = i + 3) {
            var x = Math.round((pos[i + 0]) / elementSize + arraySize / 2);
            var z = Math.round(((pos[i + 1]) / elementSize - arraySize / 2) * -1);
            var y = -pos[i + 2] + minY;
            if (!matrix[x]) {
                matrix[x] = [];
            }
            if (!matrix[x][z]) {
                matrix[x][z] = y;
            }
            matrix[x][z] = Math.max(y, matrix[x][z]);
        }
        for (var x = 0; x <= arraySize; ++x) {
            if (!matrix[x]) {
                var loc = 1;
                while (!matrix[(x + loc) % arraySize]) {
                    loc++;
                }
                matrix[x] = matrix[(x + loc) % arraySize].slice();
                //console.log("missing x", x);
            }
            for (var z = 0; z <= arraySize; ++z) {
                if (!matrix[x][z]) {
                    var loc = 1;
                    var newValue;
                    while (newValue === undefined) {
                        newValue = matrix[x][(z + loc++) % arraySize];
                    }
                    matrix[x][z] = newValue;
                }
            }
        }
        var shape = new this.BJSCANNON.Heightfield(matrix, {
            elementSize: elementSize
        });
        //For future reference, needed for body transformation
        shape.minY = minY;
        return shape;
    };
    CannonJSPlugin.prototype._updatePhysicsBodyTransformation = function (impostor) {
        var object = impostor.object;
        //make sure it is updated...
        object.computeWorldMatrix && object.computeWorldMatrix(true);
        // The delta between the mesh position and the mesh bounding box center
        var bInfo = object.getBoundingInfo();
        if (!bInfo) {
            return;
        }
        var center = impostor.getObjectCenter();
        //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)
        this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));
        this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);
        this._tmpPosition.copyFrom(center);
        var quaternion = object.rotationQuaternion;
        if (!quaternion) {
            return;
        }
        //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.
        //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron
        if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {
            //-90 DEG in X, precalculated
            quaternion = quaternion.multiply(this._minus90X);
            //Invert! (Precalculated, 90 deg in X)
            //No need to clone. this will never change.
            impostor.setDeltaRotation(this._plus90X);
        }
        //If it is a heightfield, if should be centered.
        if (impostor.type === PhysicsImpostor.HeightmapImpostor) {
            var mesh = object;
            var boundingInfo = mesh.getBoundingInfo();
            //calculate the correct body position:
            var rotationQuaternion = mesh.rotationQuaternion;
            mesh.rotationQuaternion = this._tmpUnityRotation;
            mesh.computeWorldMatrix(true);
            //get original center with no rotation
            var c = center.clone();
            var oldPivot = mesh.getPivotMatrix();
            if (oldPivot) {
                // create a copy the pivot Matrix as it is modified in place
                oldPivot = oldPivot.clone();
            }
            else {
                oldPivot = Matrix.Identity();
            }
            //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)
            var p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);
            mesh.setPreTransformMatrix(p);
            mesh.computeWorldMatrix(true);
            //calculate the translation
            var translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();
            this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);
            //add it inverted to the delta
            this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));
            this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;
            //rotation is back
            mesh.rotationQuaternion = rotationQuaternion;
            mesh.setPreTransformMatrix(oldPivot);
            mesh.computeWorldMatrix(true);
        }
        else if (impostor.type === PhysicsImpostor.MeshImpostor) {
            this._tmpDeltaPosition.copyFromFloats(0, 0, 0);
            //this._tmpPosition.copyFrom(object.position);
        }
        impostor.setDeltaPosition(this._tmpDeltaPosition);
        //Now update the impostor object
        impostor.physicsBody.position.copy(this._tmpPosition);
        impostor.physicsBody.quaternion.copy(quaternion);
    };
    CannonJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {
        impostor.object.position.copyFrom(impostor.physicsBody.position);
        if (impostor.object.rotationQuaternion) {
            impostor.object.rotationQuaternion.copyFrom(impostor.physicsBody.quaternion);
        }
    };
    CannonJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {
        impostor.physicsBody.position.copy(newPosition);
        impostor.physicsBody.quaternion.copy(newRotation);
    };
    CannonJSPlugin.prototype.isSupported = function () {
        return this.BJSCANNON !== undefined;
    };
    CannonJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {
        impostor.physicsBody.velocity.copy(velocity);
    };
    CannonJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {
        impostor.physicsBody.angularVelocity.copy(velocity);
    };
    CannonJSPlugin.prototype.getLinearVelocity = function (impostor) {
        var v = impostor.physicsBody.velocity;
        if (!v) {
            return null;
        }
        return new Vector3(v.x, v.y, v.z);
    };
    CannonJSPlugin.prototype.getAngularVelocity = function (impostor) {
        var v = impostor.physicsBody.angularVelocity;
        if (!v) {
            return null;
        }
        return new Vector3(v.x, v.y, v.z);
    };
    CannonJSPlugin.prototype.setBodyMass = function (impostor, mass) {
        impostor.physicsBody.mass = mass;
        impostor.physicsBody.updateMassProperties();
    };
    CannonJSPlugin.prototype.getBodyMass = function (impostor) {
        return impostor.physicsBody.mass;
    };
    CannonJSPlugin.prototype.getBodyFriction = function (impostor) {
        return impostor.physicsBody.material.friction;
    };
    CannonJSPlugin.prototype.setBodyFriction = function (impostor, friction) {
        impostor.physicsBody.material.friction = friction;
    };
    CannonJSPlugin.prototype.getBodyRestitution = function (impostor) {
        return impostor.physicsBody.material.restitution;
    };
    CannonJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {
        impostor.physicsBody.material.restitution = restitution;
    };
    CannonJSPlugin.prototype.sleepBody = function (impostor) {
        impostor.physicsBody.sleep();
    };
    CannonJSPlugin.prototype.wakeUpBody = function (impostor) {
        impostor.physicsBody.wakeUp();
    };
    CannonJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance) {
        joint.physicsJoint.distance = maxDistance;
    };
    // private enableMotor(joint: IMotorEnabledJoint, motorIndex?: number) {
    //     if (!motorIndex) {
    //         joint.physicsJoint.enableMotor();
    //     }
    // }
    // private disableMotor(joint: IMotorEnabledJoint, motorIndex?: number) {
    //     if (!motorIndex) {
    //         joint.physicsJoint.disableMotor();
    //     }
    // }
    CannonJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {
        if (!motorIndex) {
            joint.physicsJoint.enableMotor();
            joint.physicsJoint.setMotorSpeed(speed);
            if (maxForce) {
                this.setLimit(joint, maxForce);
            }
        }
    };
    CannonJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit) {
        joint.physicsJoint.motorEquation.maxForce = upperLimit;
        joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;
    };
    CannonJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {
        var body = impostor.physicsBody;
        mesh.position.x = body.position.x;
        mesh.position.y = body.position.y;
        mesh.position.z = body.position.z;
        if (mesh.rotationQuaternion) {
            mesh.rotationQuaternion.x = body.quaternion.x;
            mesh.rotationQuaternion.y = body.quaternion.y;
            mesh.rotationQuaternion.z = body.quaternion.z;
            mesh.rotationQuaternion.w = body.quaternion.w;
        }
    };
    CannonJSPlugin.prototype.getRadius = function (impostor) {
        var shape = impostor.physicsBody.shapes[0];
        return shape.boundingSphereRadius;
    };
    CannonJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {
        var shape = impostor.physicsBody.shapes[0];
        result.x = shape.halfExtents.x * 2;
        result.y = shape.halfExtents.y * 2;
        result.z = shape.halfExtents.z * 2;
    };
    CannonJSPlugin.prototype.dispose = function () {
    };
    CannonJSPlugin.prototype._extendNamespace = function () {
        //this will force cannon to execute at least one step when using interpolation
        var step_tmp1 = new this.BJSCANNON.Vec3();
        var Engine = this.BJSCANNON;
        this.BJSCANNON.World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
            maxSubSteps = maxSubSteps || 10;
            timeSinceLastCalled = timeSinceLastCalled || 0;
            if (timeSinceLastCalled === 0) {
                this.internalStep(dt);
                this.time += dt;
            }
            else {
                var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
                internalSteps = Math.min(internalSteps, maxSubSteps) || 1;
                var t0 = performance.now();
                for (var i = 0; i !== internalSteps; i++) {
                    this.internalStep(dt);
                    if (performance.now() - t0 > dt * 1000) {
                        break;
                    }
                }
                this.time += timeSinceLastCalled;
                var h = this.time % dt;
                var h_div_dt = h / dt;
                var interpvelo = step_tmp1;
                var bodies = this.bodies;
                for (var j = 0; j !== bodies.length; j++) {
                    var b = bodies[j];
                    if (b.type !== Engine.Body.STATIC && b.sleepState !== Engine.Body.SLEEPING) {
                        b.position.vsub(b.previousPosition, interpvelo);
                        interpvelo.scale(h_div_dt, interpvelo);
                        b.position.vadd(interpvelo, b.interpolatedPosition);
                    }
                    else {
                        b.interpolatedPosition.copy(b.position);
                        b.interpolatedQuaternion.copy(b.quaternion);
                    }
                }
            }
        };
    };
    /**
     * Does a raycast in the physics world
     * @param from when should the ray start?
     * @param to when should the ray end?
     * @returns PhysicsRaycastResult
     */
    CannonJSPlugin.prototype.raycast = function (from, to) {
        this._cannonRaycastResult.reset();
        this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);
        this._raycastResult.reset(from, to);
        if (this._cannonRaycastResult.hasHit) {
            // TODO: do we also want to get the body it hit?
            this._raycastResult.setHitData({
                x: this._cannonRaycastResult.hitNormalWorld.x,
                y: this._cannonRaycastResult.hitNormalWorld.y,
                z: this._cannonRaycastResult.hitNormalWorld.z,
            }, {
                x: this._cannonRaycastResult.hitPointWorld.x,
                y: this._cannonRaycastResult.hitPointWorld.y,
                z: this._cannonRaycastResult.hitPointWorld.z,
            });
            this._raycastResult.setHitDistance(this._cannonRaycastResult.distance);
        }
        return this._raycastResult;
    };
    return CannonJSPlugin;
}());
PhysicsEngine.DefaultPluginFactory = function () { return new CannonJSPlugin(); };

/** @hidden */
var OimoJSPlugin = /** @class */ (function () {
    function OimoJSPlugin(iterations, oimoInjection) {
        if (oimoInjection === void 0) { oimoInjection = OIMO; }
        this.name = "OimoJSPlugin";
        this._tmpImpostorsArray = [];
        this._tmpPositionVector = Vector3.Zero();
        this.BJSOIMO = oimoInjection;
        this.world = new this.BJSOIMO.World({
            iterations: iterations
        });
        this.world.clear();
        this._raycastResult = new PhysicsRaycastResult();
    }
    OimoJSPlugin.prototype.setGravity = function (gravity) {
        this.world.gravity.copy(gravity);
    };
    OimoJSPlugin.prototype.setTimeStep = function (timeStep) {
        this.world.timeStep = timeStep;
    };
    OimoJSPlugin.prototype.getTimeStep = function () {
        return this.world.timeStep;
    };
    OimoJSPlugin.prototype.executeStep = function (delta, impostors) {
        var _this = this;
        impostors.forEach(function (impostor) {
            impostor.beforeStep();
        });
        this.world.step();
        impostors.forEach(function (impostor) {
            impostor.afterStep();
            //update the ordered impostors array
            _this._tmpImpostorsArray[impostor.uniqueId] = impostor;
        });
        //check for collisions
        var contact = this.world.contacts;
        while (contact !== null) {
            if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {
                contact = contact.next;
                continue;
            }
            //is this body colliding with any other? get the impostor
            var mainImpostor = this._tmpImpostorsArray[+contact.body1.name];
            var collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];
            if (!mainImpostor || !collidingImpostor) {
                contact = contact.next;
                continue;
            }
            mainImpostor.onCollide({ body: collidingImpostor.physicsBody });
            collidingImpostor.onCollide({ body: mainImpostor.physicsBody });
            contact = contact.next;
        }
    };
    OimoJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {
        var mass = impostor.physicsBody.mass;
        impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));
    };
    OimoJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {
        Logger.Warn("Oimo doesn't support applying force. Using impule instead.");
        this.applyImpulse(impostor, force, contactPoint);
    };
    OimoJSPlugin.prototype.generatePhysicsBody = function (impostor) {
        var _this = this;
        //parent-child relationship. Does this impostor has a parent impostor?
        if (impostor.parent) {
            if (impostor.physicsBody) {
                this.removePhysicsBody(impostor);
                //TODO is that needed?
                impostor.forceUpdate();
            }
            return;
        }
        if (impostor.isBodyInitRequired()) {
            var bodyConfig = {
                name: impostor.uniqueId,
                //Oimo must have mass, also for static objects.
                config: [impostor.getParam("mass") || 1, impostor.getParam("friction"), impostor.getParam("restitution")],
                size: [],
                type: [],
                pos: [],
                posShape: [],
                rot: [],
                rotShape: [],
                move: impostor.getParam("mass") !== 0,
                density: impostor.getParam("mass"),
                friction: impostor.getParam("friction"),
                restitution: impostor.getParam("restitution"),
                //Supporting older versions of Oimo
                world: this.world
            };
            var impostors = [impostor];
            var addToArray = function (parent) {
                if (!parent.getChildMeshes) {
                    return;
                }
                parent.getChildMeshes().forEach(function (m) {
                    if (m.physicsImpostor) {
                        impostors.push(m.physicsImpostor);
                        //m.physicsImpostor._init();
                    }
                });
            };
            addToArray(impostor.object);
            var checkWithEpsilon_1 = function (value) {
                return Math.max(value, PhysicsEngine.Epsilon);
            };
            var globalQuaternion_1 = new Quaternion();
            impostors.forEach(function (i) {
                if (!i.object.rotationQuaternion) {
                    return;
                }
                //get the correct bounding box
                var oldQuaternion = i.object.rotationQuaternion;
                globalQuaternion_1 = oldQuaternion.clone();
                var rot = oldQuaternion.toEulerAngles();
                var extendSize = i.getObjectExtendSize();
                var radToDeg = 57.295779513082320876;
                if (i === impostor) {
                    var center = impostor.getObjectCenter();
                    impostor.object.getAbsolutePivotPoint().subtractToRef(center, _this._tmpPositionVector);
                    _this._tmpPositionVector.divideInPlace(impostor.object.scaling);
                    //Can also use Array.prototype.push.apply
                    bodyConfig.pos.push(center.x);
                    bodyConfig.pos.push(center.y);
                    bodyConfig.pos.push(center.z);
                    bodyConfig.posShape.push(0, 0, 0);
                    bodyConfig.rotShape.push(0, 0, 0);
                }
                else {
                    var localPosition = i.object.getAbsolutePosition().subtract(impostor.object.getAbsolutePosition());
                    bodyConfig.posShape.push(localPosition.x);
                    bodyConfig.posShape.push(localPosition.y);
                    bodyConfig.posShape.push(localPosition.z);
                    bodyConfig.pos.push(0, 0, 0);
                    bodyConfig.rotShape.push(rot.x * radToDeg);
                    bodyConfig.rotShape.push(rot.y * radToDeg);
                    bodyConfig.rotShape.push(rot.z * radToDeg);
                }
                // register mesh
                switch (i.type) {
                    case PhysicsImpostor.ParticleImpostor:
                        Logger.Warn("No Particle support in OIMO.js. using SphereImpostor instead");
                    case PhysicsImpostor.SphereImpostor:
                        var radiusX = extendSize.x;
                        var radiusY = extendSize.y;
                        var radiusZ = extendSize.z;
                        var size = Math.max(checkWithEpsilon_1(radiusX), checkWithEpsilon_1(radiusY), checkWithEpsilon_1(radiusZ)) / 2;
                        bodyConfig.type.push('sphere');
                        //due to the way oimo works with compounds, add 3 times
                        bodyConfig.size.push(size);
                        bodyConfig.size.push(size);
                        bodyConfig.size.push(size);
                        break;
                    case PhysicsImpostor.CylinderImpostor:
                        var sizeX = checkWithEpsilon_1(extendSize.x) / 2;
                        var sizeY = checkWithEpsilon_1(extendSize.y);
                        bodyConfig.type.push('cylinder');
                        bodyConfig.size.push(sizeX);
                        bodyConfig.size.push(sizeY);
                        //due to the way oimo works with compounds, add one more value.
                        bodyConfig.size.push(sizeY);
                        break;
                    case PhysicsImpostor.PlaneImpostor:
                    case PhysicsImpostor.BoxImpostor:
                    default:
                        var sizeX = checkWithEpsilon_1(extendSize.x);
                        var sizeY = checkWithEpsilon_1(extendSize.y);
                        var sizeZ = checkWithEpsilon_1(extendSize.z);
                        bodyConfig.type.push('box');
                        //if (i === impostor) {
                        bodyConfig.size.push(sizeX);
                        bodyConfig.size.push(sizeY);
                        bodyConfig.size.push(sizeZ);
                        //} else {
                        //    bodyConfig.size.push(0,0,0);
                        //}
                        break;
                }
                //actually not needed, but hey...
                i.object.rotationQuaternion = oldQuaternion;
            });
            impostor.physicsBody = this.world.add(bodyConfig);
            // set the quaternion, ignoring the previously defined (euler) rotation
            impostor.physicsBody.resetQuaternion(globalQuaternion_1);
            // update with delta 0, so the body will reveive the new rotation.
            impostor.physicsBody.updatePosition(0);
        }
        else {
            this._tmpPositionVector.copyFromFloats(0, 0, 0);
        }
        impostor.setDeltaPosition(this._tmpPositionVector);
        //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);
        //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);
    };
    OimoJSPlugin.prototype.removePhysicsBody = function (impostor) {
        //impostor.physicsBody.dispose();
        //Same as : (older oimo versions)
        this.world.removeRigidBody(impostor.physicsBody);
    };
    OimoJSPlugin.prototype.generateJoint = function (impostorJoint) {
        var mainBody = impostorJoint.mainImpostor.physicsBody;
        var connectedBody = impostorJoint.connectedImpostor.physicsBody;
        if (!mainBody || !connectedBody) {
            return;
        }
        var jointData = impostorJoint.joint.jointData;
        var options = jointData.nativeParams || {};
        var type;
        var nativeJointData = {
            body1: mainBody,
            body2: connectedBody,
            axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),
            axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),
            pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),
            pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),
            min: options.min,
            max: options.max,
            collision: options.collision || jointData.collision,
            spring: options.spring,
            //supporting older version of Oimo
            world: this.world
        };
        switch (impostorJoint.joint.type) {
            case PhysicsJoint.BallAndSocketJoint:
                type = "jointBall";
                break;
            case PhysicsJoint.SpringJoint:
                Logger.Warn("OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead");
                var springData = jointData;
                nativeJointData.min = springData.length || nativeJointData.min;
                //Max should also be set, just make sure it is at least min
                nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);
            case PhysicsJoint.DistanceJoint:
                type = "jointDistance";
                nativeJointData.max = jointData.maxDistance;
                break;
            case PhysicsJoint.PrismaticJoint:
                type = "jointPrisme";
                break;
            case PhysicsJoint.SliderJoint:
                type = "jointSlide";
                break;
            case PhysicsJoint.WheelJoint:
                type = "jointWheel";
                break;
            case PhysicsJoint.HingeJoint:
            default:
                type = "jointHinge";
                break;
        }
        nativeJointData.type = type;
        impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);
    };
    OimoJSPlugin.prototype.removeJoint = function (impostorJoint) {
        //Bug in Oimo prevents us from disposing a joint in the playground
        //joint.joint.physicsJoint.dispose();
        //So we will bruteforce it!
        try {
            this.world.removeJoint(impostorJoint.joint.physicsJoint);
        }
        catch (e) {
            Logger.Warn(e);
        }
    };
    OimoJSPlugin.prototype.isSupported = function () {
        return this.BJSOIMO !== undefined;
    };
    OimoJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {
        if (!impostor.physicsBody.sleeping) {
            //TODO check that
            /*if (impostor.physicsBody.shapes.next) {
                var parentShape = this._getLastShape(impostor.physicsBody);
                impostor.object.position.copyFrom(parentShape.position);
                console.log(parentShape.position);
            } else {*/
            impostor.object.position.copyFrom(impostor.physicsBody.getPosition());
            //}
            if (impostor.object.rotationQuaternion) {
                impostor.object.rotationQuaternion.copyFrom(impostor.physicsBody.getQuaternion());
            }
        }
    };
    OimoJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {
        var body = impostor.physicsBody;
        body.position.copy(newPosition);
        body.orientation.copy(newRotation);
        body.syncShapes();
        body.awake();
    };
    /*private _getLastShape(body: any): any {
        var lastShape = body.shapes;
        while (lastShape.next) {
            lastShape = lastShape.next;
        }
        return lastShape;
    }*/
    OimoJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {
        impostor.physicsBody.linearVelocity.copy(velocity);
    };
    OimoJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {
        impostor.physicsBody.angularVelocity.copy(velocity);
    };
    OimoJSPlugin.prototype.getLinearVelocity = function (impostor) {
        var v = impostor.physicsBody.linearVelocity;
        if (!v) {
            return null;
        }
        return new Vector3(v.x, v.y, v.z);
    };
    OimoJSPlugin.prototype.getAngularVelocity = function (impostor) {
        var v = impostor.physicsBody.angularVelocity;
        if (!v) {
            return null;
        }
        return new Vector3(v.x, v.y, v.z);
    };
    OimoJSPlugin.prototype.setBodyMass = function (impostor, mass) {
        var staticBody = mass === 0;
        //this will actually set the body's density and not its mass.
        //But this is how oimo treats the mass variable.
        impostor.physicsBody.shapes.density = staticBody ? 1 : mass;
        impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);
    };
    OimoJSPlugin.prototype.getBodyMass = function (impostor) {
        return impostor.physicsBody.shapes.density;
    };
    OimoJSPlugin.prototype.getBodyFriction = function (impostor) {
        return impostor.physicsBody.shapes.friction;
    };
    OimoJSPlugin.prototype.setBodyFriction = function (impostor, friction) {
        impostor.physicsBody.shapes.friction = friction;
    };
    OimoJSPlugin.prototype.getBodyRestitution = function (impostor) {
        return impostor.physicsBody.shapes.restitution;
    };
    OimoJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {
        impostor.physicsBody.shapes.restitution = restitution;
    };
    OimoJSPlugin.prototype.sleepBody = function (impostor) {
        impostor.physicsBody.sleep();
    };
    OimoJSPlugin.prototype.wakeUpBody = function (impostor) {
        impostor.physicsBody.awake();
    };
    OimoJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {
        joint.physicsJoint.limitMotor.upperLimit = maxDistance;
        if (minDistance !== void 0) {
            joint.physicsJoint.limitMotor.lowerLimit = minDistance;
        }
    };
    OimoJSPlugin.prototype.setMotor = function (joint, speed, force, motorIndex) {
        if (force !== undefined) {
            Logger.Warn("OimoJS plugin currently has unexpected behavior when using setMotor with force parameter");
        }
        else {
            force = 1e6;
        }
        speed *= -1;
        //TODO separate rotational and transational motors.
        var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
        if (motor) {
            motor.setMotor(speed, force);
        }
    };
    OimoJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit, motorIndex) {
        //TODO separate rotational and transational motors.
        var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
        if (motor) {
            motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);
        }
    };
    OimoJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {
        var body = impostor.physicsBody;
        mesh.position.x = body.position.x;
        mesh.position.y = body.position.y;
        mesh.position.z = body.position.z;
        if (mesh.rotationQuaternion) {
            mesh.rotationQuaternion.x = body.orientation.x;
            mesh.rotationQuaternion.y = body.orientation.y;
            mesh.rotationQuaternion.z = body.orientation.z;
            mesh.rotationQuaternion.w = body.orientation.s;
        }
    };
    OimoJSPlugin.prototype.getRadius = function (impostor) {
        return impostor.physicsBody.shapes.radius;
    };
    OimoJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {
        var shape = impostor.physicsBody.shapes;
        result.x = shape.halfWidth * 2;
        result.y = shape.halfHeight * 2;
        result.z = shape.halfDepth * 2;
    };
    OimoJSPlugin.prototype.dispose = function () {
        this.world.clear();
    };
    /**
     * Does a raycast in the physics world
     * @param from when should the ray start?
     * @param to when should the ray end?
     * @returns PhysicsRaycastResult
     */
    OimoJSPlugin.prototype.raycast = function (from, to) {
        Logger.Warn("raycast is not currently supported by the Oimo physics plugin");
        this._raycastResult.reset(from, to);
        return this._raycastResult;
    };
    return OimoJSPlugin;
}());

VertexData.CreateRibbon = function (options) {
    var pathArray = options.pathArray;
    var closeArray = options.closeArray || false;
    var closePath = options.closePath || false;
    var invertUV = options.invertUV || false;
    var defaultOffset = Math.floor(pathArray[0].length / 2);
    var offset = options.offset || defaultOffset;
    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset
    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
    var customUV = options.uvs;
    var customColors = options.colors;
    var positions = [];
    var indices = [];
    var normals = [];
    var uvs = [];
    var us = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id
    var vs = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutives paths from pathArray
    var uTotalDistance = []; // uTotalDistance[p] : total distance of path p
    var vTotalDistance = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray
    var minlg; // minimal length among all paths from pathArray
    var lg = []; // array of path lengths : nb of vertex per path
    var idx = []; // array of path indexes : index of each path (first vertex) in the total vertex number
    var p; // path iterator
    var i; // point iterator
    var j; // point iterator
    // if single path in pathArray
    if (pathArray.length < 2) {
        var ar1 = [];
        var ar2 = [];
        for (i = 0; i < pathArray[0].length - offset; i++) {
            ar1.push(pathArray[0][i]);
            ar2.push(pathArray[0][i + offset]);
        }
        pathArray = [ar1, ar2];
    }
    // positions and horizontal distances (u)
    var idc = 0;
    var closePathCorr = (closePath) ? 1 : 0; // the final index will be +1 if closePath
    var path;
    var l;
    minlg = pathArray[0].length;
    var vectlg;
    var dist;
    for (p = 0; p < pathArray.length; p++) {
        uTotalDistance[p] = 0;
        us[p] = [0];
        path = pathArray[p];
        l = path.length;
        minlg = (minlg < l) ? minlg : l;
        j = 0;
        while (j < l) {
            positions.push(path[j].x, path[j].y, path[j].z);
            if (j > 0) {
                vectlg = path[j].subtract(path[j - 1]).length();
                dist = vectlg + uTotalDistance[p];
                us[p].push(dist);
                uTotalDistance[p] = dist;
            }
            j++;
        }
        if (closePath) { // an extra hidden vertex is added in the "positions" array
            j--;
            positions.push(path[0].x, path[0].y, path[0].z);
            vectlg = path[j].subtract(path[0]).length();
            dist = vectlg + uTotalDistance[p];
            us[p].push(dist);
            uTotalDistance[p] = dist;
        }
        lg[p] = l + closePathCorr;
        idx[p] = idc;
        idc += (l + closePathCorr);
    }
    // vertical distances (v)
    var path1;
    var path2;
    var vertex1 = null;
    var vertex2 = null;
    for (i = 0; i < minlg + closePathCorr; i++) {
        vTotalDistance[i] = 0;
        vs[i] = [0];
        for (p = 0; p < pathArray.length - 1; p++) {
            path1 = pathArray[p];
            path2 = pathArray[p + 1];
            if (i === minlg) { // closePath
                vertex1 = path1[0];
                vertex2 = path2[0];
            }
            else {
                vertex1 = path1[i];
                vertex2 = path2[i];
            }
            vectlg = vertex2.subtract(vertex1).length();
            dist = vectlg + vTotalDistance[i];
            vs[i].push(dist);
            vTotalDistance[i] = dist;
        }
        if (closeArray && vertex2 && vertex1) {
            path1 = pathArray[p];
            path2 = pathArray[0];
            if (i === minlg) { // closePath
                vertex2 = path2[0];
            }
            vectlg = vertex2.subtract(vertex1).length();
            dist = vectlg + vTotalDistance[i];
            vTotalDistance[i] = dist;
        }
    }
    // uvs
    var u;
    var v;
    if (customUV) {
        for (p = 0; p < customUV.length; p++) {
            uvs.push(customUV[p].x, customUV[p].y);
        }
    }
    else {
        for (p = 0; p < pathArray.length; p++) {
            for (i = 0; i < minlg + closePathCorr; i++) {
                u = (uTotalDistance[p] != 0.0) ? us[p][i] / uTotalDistance[p] : 0.0;
                v = (vTotalDistance[i] != 0.0) ? vs[i][p] / vTotalDistance[i] : 0.0;
                if (invertUV) {
                    uvs.push(v, u);
                }
                else {
                    uvs.push(u, v);
                }
            }
        }
    }
    // indices
    p = 0; // path index
    var pi = 0; // positions array index
    var l1 = lg[p] - 1; // path1 length
    var l2 = lg[p + 1] - 1; // path2 length
    var min = (l1 < l2) ? l1 : l2; // current path stop index
    var shft = idx[1] - idx[0]; // shift
    var path1nb = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate	on
    while (pi <= min && p < path1nb) { //  stay under min and don't go over next to last path
        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise
        indices.push(pi, pi + shft, pi + 1);
        indices.push(pi + shft + 1, pi + 1, pi + shft);
        pi += 1;
        if (pi === min) { // if end of one of two consecutive paths reached, go to next existing path
            p++;
            if (p === lg.length - 1) { // last path of pathArray reached <=> closeArray == true
                shft = idx[0] - idx[p];
                l1 = lg[p] - 1;
                l2 = lg[0] - 1;
            }
            else {
                shft = idx[p + 1] - idx[p];
                l1 = lg[p] - 1;
                l2 = lg[p + 1] - 1;
            }
            pi = idx[p];
            min = (l1 < l2) ? l1 + pi : l2 + pi;
        }
    }
    // normals
    VertexData.ComputeNormals(positions, indices, normals);
    if (closePath) { // update both the first and last vertex normals to their average value
        var indexFirst = 0;
        var indexLast = 0;
        for (p = 0; p < pathArray.length; p++) {
            indexFirst = idx[p] * 3;
            if (p + 1 < pathArray.length) {
                indexLast = (idx[p + 1] - 1) * 3;
            }
            else {
                indexLast = normals.length - 3;
            }
            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
            normals[indexLast] = normals[indexFirst];
            normals[indexLast + 1] = normals[indexFirst + 1];
            normals[indexLast + 2] = normals[indexFirst + 2];
        }
    }
    // sides
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
    // Colors
    var colors = null;
    if (customColors) {
        colors = new Float32Array(customColors.length * 4);
        for (var c = 0; c < customColors.length; c++) {
            colors[c * 4] = customColors[c].r;
            colors[c * 4 + 1] = customColors[c].g;
            colors[c * 4 + 2] = customColors[c].b;
            colors[c * 4 + 3] = customColors[c].a;
        }
    }
    // Result
    var vertexData = new VertexData();
    var positions32 = new Float32Array(positions);
    var normals32 = new Float32Array(normals);
    var uvs32 = new Float32Array(uvs);
    vertexData.indices = indices;
    vertexData.positions = positions32;
    vertexData.normals = normals32;
    vertexData.uvs = uvs32;
    if (colors) {
        vertexData.set(colors, VertexBuffer.ColorKind);
    }
    if (closePath) {
        vertexData._idx = idx;
    }
    return vertexData;
};
Mesh.CreateRibbon = function (name, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {
    if (closeArray === void 0) { closeArray = false; }
    if (updatable === void 0) { updatable = false; }
    return RibbonBuilder.CreateRibbon(name, {
        pathArray: pathArray,
        closeArray: closeArray,
        closePath: closePath,
        offset: offset,
        updatable: updatable,
        sideOrientation: sideOrientation,
        instance: instance
    }, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var RibbonBuilder = /** @class */ (function () {
    function RibbonBuilder() {
    }
    /**
     * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
     * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
     * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
     * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
     * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
     * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
     * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
     * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
     * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
     * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
     * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the ribbon mesh
     * @see https://doc.babylonjs.com/how_to/ribbon_tutorial
     * @see https://doc.babylonjs.com/how_to/parametric_shapes
     */
    RibbonBuilder.CreateRibbon = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var pathArray = options.pathArray;
        var closeArray = options.closeArray;
        var closePath = options.closePath;
        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        var instance = options.instance;
        var updatable = options.updatable;
        if (instance) { // existing ribbon instance update
            // positionFunction : ribbon case
            // only pathArray and sideOrientation parameters are taken into account for positions update
            var minimum_1 = Tmp.Vector3[0].setAll(Number.MAX_VALUE);
            var maximum_1 = Tmp.Vector3[1].setAll(-Number.MAX_VALUE);
            var positionFunction = function (positions) {
                var minlg = pathArray[0].length;
                var mesh = instance;
                var i = 0;
                var ns = (mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE) ? 2 : 1;
                for (var si = 1; si <= ns; ++si) {
                    for (var p = 0; p < pathArray.length; ++p) {
                        var path = pathArray[p];
                        var l = path.length;
                        minlg = (minlg < l) ? minlg : l;
                        for (var j = 0; j < minlg; ++j) {
                            var pathPoint = path[j];
                            positions[i] = pathPoint.x;
                            positions[i + 1] = pathPoint.y;
                            positions[i + 2] = pathPoint.z;
                            minimum_1.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
                            maximum_1.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
                            i += 3;
                        }
                        if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {
                            var pathPoint = path[0];
                            positions[i] = pathPoint.x;
                            positions[i + 1] = pathPoint.y;
                            positions[i + 2] = pathPoint.z;
                            i += 3;
                        }
                    }
                }
            };
            var positions = instance.getVerticesData(VertexBuffer.PositionKind);
            positionFunction(positions);
            if (instance._boundingInfo) {
                instance._boundingInfo.reConstruct(minimum_1, maximum_1, instance._worldMatrix);
            }
            else {
                instance._boundingInfo = new BoundingInfo(minimum_1, maximum_1, instance._worldMatrix);
            }
            instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
            if (options.colors) {
                var colors = instance.getVerticesData(VertexBuffer.ColorKind);
                for (var c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {
                    var color = options.colors[c];
                    colors[colorIndex] = color.r;
                    colors[colorIndex + 1] = color.g;
                    colors[colorIndex + 2] = color.b;
                    colors[colorIndex + 3] = color.a;
                }
                instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);
            }
            if (options.uvs) {
                var uvs = instance.getVerticesData(VertexBuffer.UVKind);
                for (var i = 0; i < options.uvs.length; i++) {
                    uvs[i * 2] = options.uvs[i].x;
                    uvs[i * 2 + 1] = options.uvs[i].y;
                }
                instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);
            }
            if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {
                var indices = instance.getIndices();
                var normals = instance.getVerticesData(VertexBuffer.NormalKind);
                var params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;
                VertexData.ComputeNormals(positions, indices, normals, params);
                if (instance._creationDataStorage && instance._creationDataStorage.closePath) {
                    var indexFirst = 0;
                    var indexLast = 0;
                    for (var p = 0; p < pathArray.length; p++) {
                        indexFirst = instance._creationDataStorage.idx[p] * 3;
                        if (p + 1 < pathArray.length) {
                            indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;
                        }
                        else {
                            indexLast = normals.length - 3;
                        }
                        normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
                        normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
                        normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
                        normals[indexLast] = normals[indexFirst];
                        normals[indexLast + 1] = normals[indexFirst + 1];
                        normals[indexLast + 2] = normals[indexFirst + 2];
                    }
                }
                if (!(instance.areNormalsFrozen)) {
                    instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
                }
            }
            return instance;
        }
        else { // new ribbon creation
            var ribbon = new Mesh(name, scene);
            ribbon._originalBuilderSideOrientation = sideOrientation;
            ribbon._creationDataStorage = new _CreationDataStorage();
            var vertexData = VertexData.CreateRibbon(options);
            if (closePath) {
                ribbon._creationDataStorage.idx = vertexData._idx;
            }
            ribbon._creationDataStorage.closePath = closePath;
            ribbon._creationDataStorage.closeArray = closeArray;
            vertexData.applyToMesh(ribbon, updatable);
            return ribbon;
        }
    };
    return RibbonBuilder;
}());

Mesh.ExtrudeShape = function (name, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {
    if (scene === void 0) { scene = null; }
    var options = {
        shape: shape,
        path: path,
        scale: scale,
        rotation: rotation,
        cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,
        sideOrientation: sideOrientation,
        instance: instance,
        updatable: updatable
    };
    return ShapeBuilder.ExtrudeShape(name, options, scene);
};
Mesh.ExtrudeShapeCustom = function (name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {
    var options = {
        shape: shape,
        path: path,
        scaleFunction: scaleFunction,
        rotationFunction: rotationFunction,
        ribbonCloseArray: ribbonCloseArray,
        ribbonClosePath: ribbonClosePath,
        cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,
        sideOrientation: sideOrientation,
        instance: instance,
        updatable: updatable
    };
    return ShapeBuilder.ExtrudeShapeCustom(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var ShapeBuilder = /** @class */ (function () {
    function ShapeBuilder() {
    }
    /**
     * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
     * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
     * * The parameter `scale` (float, default 1) is the value to scale the shape.
     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the extruded shape mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
     */
    ShapeBuilder.ExtrudeShape = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var path = options.path;
        var shape = options.shape;
        var scale = options.scale || 1;
        var rotation = options.rotation || 0;
        var cap = (options.cap === 0) ? 0 : options.cap || Mesh.NO_CAP;
        var updatable = options.updatable;
        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        var instance = options.instance || null;
        var invertUV = options.invertUV || false;
        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);
    };
    /**
     * Creates an custom extruded shape mesh.
     * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
     * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
     * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
     * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
     * * It must returns a float value that will be the scale value applied to the shape on each path point
     * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
     * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the custom extruded shape mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes
     * @see https://doc.babylonjs.com/how_to/parametric_shapes
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
     */
    ShapeBuilder.ExtrudeShapeCustom = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var path = options.path;
        var shape = options.shape;
        var scaleFunction = options.scaleFunction || (function () { return 1; });
        var rotationFunction = options.rotationFunction || (function () { return 0; });
        var ribbonCloseArray = options.ribbonCloseArray || false;
        var ribbonClosePath = options.ribbonClosePath || false;
        var cap = (options.cap === 0) ? 0 : options.cap || Mesh.NO_CAP;
        var updatable = options.updatable;
        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        var instance = options.instance;
        var invertUV = options.invertUV || false;
        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);
    };
    ShapeBuilder._ExtrudeShapeGeneric = function (name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs) {
        // extrusion geometry
        var extrusionPathArray = function (shape, curve, path3D, shapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom) {
            var tangents = path3D.getTangents();
            var normals = path3D.getNormals();
            var binormals = path3D.getBinormals();
            var distances = path3D.getDistances();
            var angle = 0;
            var returnScale = function () { return scale !== null ? scale : 1; };
            var returnRotation = function () { return rotation !== null ? rotation : 0; };
            var rotate = custom && rotateFunction ? rotateFunction : returnRotation;
            var scl = custom && scaleFunction ? scaleFunction : returnScale;
            var index = (cap === Mesh.NO_CAP || cap === Mesh.CAP_END) ? 0 : 2;
            var rotationMatrix = Tmp.Matrix[0];
            for (var i = 0; i < curve.length; i++) {
                var shapePath = new Array();
                var angleStep = rotate(i, distances[i]);
                var scaleRatio = scl(i, distances[i]);
                for (var p = 0; p < shape.length; p++) {
                    Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);
                    var planed = ((tangents[i].scale(shape[p].z)).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y)));
                    var rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();
                    Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);
                    rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);
                    shapePath[p] = rotated;
                }
                shapePaths[index] = shapePath;
                angle += angleStep;
                index++;
            }
            // cap
            var capPath = function (shapePath) {
                var pointCap = Array();
                var barycenter = Vector3.Zero();
                var i;
                for (i = 0; i < shapePath.length; i++) {
                    barycenter.addInPlace(shapePath[i]);
                }
                barycenter.scaleInPlace(1.0 / shapePath.length);
                for (i = 0; i < shapePath.length; i++) {
                    pointCap.push(barycenter);
                }
                return pointCap;
            };
            switch (cap) {
                case Mesh.NO_CAP:
                    break;
                case Mesh.CAP_START:
                    shapePaths[0] = capPath(shapePaths[2]);
                    shapePaths[1] = shapePaths[2];
                    break;
                case Mesh.CAP_END:
                    shapePaths[index] = shapePaths[index - 1];
                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);
                    break;
                case Mesh.CAP_ALL:
                    shapePaths[0] = capPath(shapePaths[2]);
                    shapePaths[1] = shapePaths[2];
                    shapePaths[index] = shapePaths[index - 1];
                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);
                    break;
            }
            return shapePaths;
        };
        var path3D;
        var pathArray;
        if (instance) { // instance update
            var storage = instance._creationDataStorage;
            path3D = storage.path3D.update(curve);
            pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);
            instance = Mesh.CreateRibbon("", pathArray, false, false, 0, scene || undefined, false, 0, instance);
            return instance;
        }
        // extruded shape creation
        path3D = new Path3D(curve);
        var newShapePaths = new Array();
        cap = (cap < 0 || cap > 3) ? 0 : cap;
        pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);
        var extrudedGeneric = RibbonBuilder.CreateRibbon(name, { pathArray: pathArray, closeArray: rbCA, closePath: rbCP, updatable: updtbl, sideOrientation: side, invertUV: invertUV, frontUVs: frontUVs || undefined, backUVs: backUVs || undefined }, scene);
        extrudedGeneric._creationDataStorage.pathArray = pathArray;
        extrudedGeneric._creationDataStorage.path3D = path3D;
        extrudedGeneric._creationDataStorage.cap = cap;
        return extrudedGeneric;
    };
    return ShapeBuilder;
}());

/**
 * AmmoJS Physics plugin
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
 * @see https://github.com/kripken/ammo.js/
 */
var AmmoJSPlugin = /** @class */ (function () {
    /**
     * Initializes the ammoJS plugin
     * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)
     * @param ammoInjection can be used to inject your own ammo reference
     */
    function AmmoJSPlugin(_useDeltaForWorldStep, ammoInjection) {
        var _this = this;
        if (_useDeltaForWorldStep === void 0) { _useDeltaForWorldStep = true; }
        if (ammoInjection === void 0) { ammoInjection = Ammo; }
        this._useDeltaForWorldStep = _useDeltaForWorldStep;
        /**
         * Reference to the Ammo library
         */
        this.bjsAMMO = {};
        /**
         * Name of the plugin
         */
        this.name = "AmmoJSPlugin";
        this._timeStep = 1 / 60;
        this._fixedTimeStep = 1 / 60;
        this._maxSteps = 5;
        this._tmpQuaternion = new Quaternion();
        this._tmpContactCallbackResult = false;
        this._tmpVector = new Vector3();
        this._tmpMatrix = new Matrix();
        if (typeof ammoInjection === "function") {
            ammoInjection(this.bjsAMMO);
        }
        else {
            this.bjsAMMO = ammoInjection;
        }
        if (!this.isSupported()) {
            Logger.Error("AmmoJS is not available. Please make sure you included the js file.");
            return;
        }
        // Initialize the physics world
        this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();
        this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);
        this._overlappingPairCache = new this.bjsAMMO.btDbvtBroadphase();
        this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();
        this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();
        this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);
        this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();
        this._tmpAmmoConcreteContactResultCallback.addSingleResult = function () { _this._tmpContactCallbackResult = true; };
        this._raycastResult = new PhysicsRaycastResult();
        // Create temp ammo variables
        this._tmpAmmoTransform = new this.bjsAMMO.btTransform();
        this._tmpAmmoTransform.setIdentity();
        this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);
        this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);
        this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);
        this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);
        this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);
    }
    /**
     * Sets the gravity of the physics world (m/(s^2))
     * @param gravity Gravity to set
     */
    AmmoJSPlugin.prototype.setGravity = function (gravity) {
        this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);
        this.world.setGravity(this._tmpAmmoVectorA);
        this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);
    };
    /**
     * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)
     * @param timeStep timestep to use in seconds
     */
    AmmoJSPlugin.prototype.setTimeStep = function (timeStep) {
        this._timeStep = timeStep;
    };
    /**
     * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)
     * @param fixedTimeStep fixedTimeStep to use in seconds
     */
    AmmoJSPlugin.prototype.setFixedTimeStep = function (fixedTimeStep) {
        this._fixedTimeStep = fixedTimeStep;
    };
    /**
     * Sets the maximum number of steps by the physics engine per frame (Default: 5)
     * @param maxSteps the maximum number of steps by the physics engine per frame
     */
    AmmoJSPlugin.prototype.setMaxSteps = function (maxSteps) {
        this._maxSteps = maxSteps;
    };
    /**
     * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)
     * @returns the current timestep in seconds
     */
    AmmoJSPlugin.prototype.getTimeStep = function () {
        return this._timeStep;
    };
    // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume
    AmmoJSPlugin.prototype._isImpostorInContact = function (impostor) {
        this._tmpContactCallbackResult = false;
        this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);
        return this._tmpContactCallbackResult;
    };
    // Ammo's collision events have some weird quirks
    // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not
    // so only fire event if both contactTest and contactPairTest have a hit
    AmmoJSPlugin.prototype._isImpostorPairInContact = function (impostorA, impostorB) {
        this._tmpContactCallbackResult = false;
        this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);
        return this._tmpContactCallbackResult;
    };
    // Ammo's behavior when maxSteps > 0 does not behave as described in docs
    // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
    //
    // When maxSteps is 0 do the entire simulation in one step
    // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)
    // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep
    AmmoJSPlugin.prototype._stepSimulation = function (timeStep, maxSteps, fixedTimeStep) {
        if (timeStep === void 0) { timeStep = 1 / 60; }
        if (maxSteps === void 0) { maxSteps = 10; }
        if (fixedTimeStep === void 0) { fixedTimeStep = 1 / 60; }
        if (maxSteps == 0) {
            this.world.stepSimulation(timeStep, 0);
        }
        else {
            while (maxSteps > 0 && timeStep > 0) {
                if (timeStep - fixedTimeStep < fixedTimeStep) {
                    this.world.stepSimulation(timeStep, 0);
                    timeStep = 0;
                }
                else {
                    timeStep -= fixedTimeStep;
                    this.world.stepSimulation(fixedTimeStep, 0);
                }
                maxSteps--;
            }
        }
    };
    /**
     * Moves the physics simulation forward delta seconds and updates the given physics imposters
     * Prior to the step the imposters physics location is set to the position of the babylon meshes
     * After the step the babylon meshes are set to the position of the physics imposters
     * @param delta amount of time to step forward
     * @param impostors array of imposters to update before/after the step
     */
    AmmoJSPlugin.prototype.executeStep = function (delta, impostors) {
        for (var _i = 0, impostors_1 = impostors; _i < impostors_1.length; _i++) {
            var impostor = impostors_1[_i];
            // Update physics world objects to match babylon world
            if (!impostor.soft) {
                impostor.beforeStep();
            }
        }
        this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);
        for (var _a = 0, impostors_2 = impostors; _a < impostors_2.length; _a++) {
            var mainImpostor = impostors_2[_a];
            // After physics update make babylon world objects match physics world objects
            if (mainImpostor.soft) {
                this._afterSoftStep(mainImpostor);
            }
            else {
                mainImpostor.afterStep();
            }
            // Handle collision event
            if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {
                if (this._isImpostorInContact(mainImpostor)) {
                    for (var _b = 0, _c = mainImpostor._onPhysicsCollideCallbacks; _b < _c.length; _b++) {
                        var collideCallback = _c[_b];
                        for (var _d = 0, _e = collideCallback.otherImpostors; _d < _e.length; _d++) {
                            var otherImpostor = _e[_d];
                            if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {
                                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {
                                    mainImpostor.onCollide({ body: otherImpostor.physicsBody });
                                    otherImpostor.onCollide({ body: mainImpostor.physicsBody });
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    /**
     * Update babylon mesh to match physics world object
     * @param impostor imposter to match
     */
    AmmoJSPlugin.prototype._afterSoftStep = function (impostor) {
        if (impostor.type === PhysicsImpostor.RopeImpostor) {
            this._ropeStep(impostor);
        }
        else {
            this._softbodyOrClothStep(impostor);
        }
    };
    /**
     * Update babylon mesh vertices vertices to match physics world softbody or cloth
     * @param impostor imposter to match
     */
    AmmoJSPlugin.prototype._ropeStep = function (impostor) {
        var bodyVertices = impostor.physicsBody.get_m_nodes();
        var nbVertices = bodyVertices.size();
        var node;
        var nodePositions;
        var x, y, z;
        var path = new Array();
        for (var n = 0; n < nbVertices; n++) {
            node = bodyVertices.at(n);
            nodePositions = node.get_m_x();
            x = nodePositions.x();
            y = nodePositions.y();
            z = nodePositions.z();
            path.push(new Vector3(x, y, z));
        }
        var object = impostor.object;
        var shape = impostor.getParam("shape");
        if (impostor._isFromLine) {
            impostor.object = LinesBuilder.CreateLines("lines", { points: path, instance: object });
        }
        else {
            impostor.object = ShapeBuilder.ExtrudeShape("ext", { shape: shape, path: path, instance: object });
        }
    };
    /**
     * Update babylon mesh vertices vertices to match physics world softbody or cloth
     * @param impostor imposter to match
     */
    AmmoJSPlugin.prototype._softbodyOrClothStep = function (impostor) {
        var normalDirection = (impostor.type === PhysicsImpostor.ClothImpostor) ? 1 : -1;
        var object = impostor.object;
        var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
        if (!vertexPositions) {
            vertexPositions = [];
        }
        var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);
        if (!vertexNormals) {
            vertexNormals = [];
        }
        var nbVertices = vertexPositions.length / 3;
        var bodyVertices = impostor.physicsBody.get_m_nodes();
        var node;
        var nodePositions;
        var nodeNormals;
        var x, y, z;
        var nx, ny, nz;
        for (var n = 0; n < nbVertices; n++) {
            node = bodyVertices.at(n);
            nodePositions = node.get_m_x();
            x = nodePositions.x();
            y = nodePositions.y();
            z = nodePositions.z() * normalDirection;
            var nodeNormals = node.get_m_n();
            nx = nodeNormals.x();
            ny = nodeNormals.y();
            nz = nodeNormals.z() * normalDirection;
            vertexPositions[3 * n] = x;
            vertexPositions[3 * n + 1] = y;
            vertexPositions[3 * n + 2] = z;
            vertexNormals[3 * n] = nx;
            vertexNormals[3 * n + 1] = ny;
            vertexNormals[3 * n + 2] = nz;
        }
        var vertex_data = new VertexData();
        vertex_data.positions = vertexPositions;
        vertex_data.normals = vertexNormals;
        vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);
        vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);
        if (object && object.getIndices) {
            vertex_data.indices = object.getIndices();
        }
        vertex_data.applyToMesh(object);
    };
    /**
     * Applies an impulse on the imposter
     * @param impostor imposter to apply impulse to
     * @param force amount of force to be applied to the imposter
     * @param contactPoint the location to apply the impulse on the imposter
     */
    AmmoJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {
        if (!impostor.soft) {
            impostor.physicsBody.activate();
            var worldPoint = this._tmpAmmoVectorA;
            var impulse = this._tmpAmmoVectorB;
            // Convert contactPoint into world space
            if (impostor.object && impostor.object.getWorldMatrix) {
                impostor.object.getWorldMatrix().invertToRef(this._tmpMatrix);
                Vector3.TransformCoordinatesToRef(contactPoint, this._tmpMatrix, this._tmpVector);
                contactPoint = this._tmpVector;
            }
            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);
            impulse.setValue(force.x, force.y, force.z);
            impostor.physicsBody.applyImpulse(impulse, worldPoint);
        }
        else {
            Logger.Warn("Cannot be applied to a soft body");
        }
    };
    /**
     * Applies a force on the imposter
     * @param impostor imposter to apply force
     * @param force amount of force to be applied to the imposter
     * @param contactPoint the location to apply the force on the imposter
     */
    AmmoJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {
        if (!impostor.soft) {
            impostor.physicsBody.activate();
            var worldPoint = this._tmpAmmoVectorA;
            var impulse = this._tmpAmmoVectorB;
            // Convert contactPoint into world space
            if (impostor.object && impostor.object.getWorldMatrix) {
                impostor.object.getWorldMatrix().invertToRef(this._tmpMatrix);
                Vector3.TransformCoordinatesToRef(contactPoint, this._tmpMatrix, this._tmpVector);
                contactPoint = this._tmpVector;
            }
            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);
            impulse.setValue(force.x, force.y, force.z);
            impostor.physicsBody.applyForce(impulse, worldPoint);
        }
        else {
            Logger.Warn("Cannot be applied to a soft body");
        }
    };
    /**
     * Creates a physics body using the plugin
     * @param impostor the imposter to create the physics body on
     */
    AmmoJSPlugin.prototype.generatePhysicsBody = function (impostor) {
        // Note: this method will not be called on child imposotrs for compound impostors
        impostor._pluginData.toDispose = [];
        //parent-child relationship
        if (impostor.parent) {
            if (impostor.physicsBody) {
                this.removePhysicsBody(impostor);
                impostor.forceUpdate();
            }
            return;
        }
        if (impostor.isBodyInitRequired()) {
            var colShape = this._createShape(impostor);
            var mass = impostor.getParam("mass");
            impostor._pluginData.mass = mass;
            if (impostor.soft) {
                colShape.get_m_cfg().set_collisions(0x11);
                colShape.get_m_cfg().set_kDP(impostor.getParam("damping"));
                Ammo.castObject(colShape, Ammo.btCollisionObject).getCollisionShape().setMargin(impostor.getParam("margin"));
                colShape.setActivationState(AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG);
                this.world.addSoftBody(colShape, 1, -1);
                impostor.physicsBody = colShape;
                impostor._pluginData.toDispose.push(colShape);
                this.setBodyPressure(impostor, 0);
                if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {
                    this.setBodyPressure(impostor, impostor.getParam("pressure"));
                }
                this.setBodyStiffness(impostor, impostor.getParam("stiffness"));
                this.setBodyVelocityIterations(impostor, impostor.getParam("velocityIterations"));
                this.setBodyPositionIterations(impostor, impostor.getParam("positionIterations"));
            }
            else {
                var localInertia = new Ammo.btVector3(0, 0, 0);
                var startTransform = new Ammo.btTransform();
                startTransform.setIdentity();
                if (mass !== 0) {
                    colShape.calculateLocalInertia(mass, localInertia);
                }
                this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);
                this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion.x, impostor.object.rotationQuaternion.y, impostor.object.rotationQuaternion.z, impostor.object.rotationQuaternion.w);
                startTransform.setOrigin(this._tmpAmmoVectorA);
                startTransform.setRotation(this._tmpAmmoQuaternion);
                var myMotionState = new Ammo.btDefaultMotionState(startTransform);
                var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);
                var body = new Ammo.btRigidBody(rbInfo);
                // Make objects kinematic if it's mass is 0
                if (mass === 0) {
                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin.KINEMATIC_FLAG);
                    body.setActivationState(AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG);
                }
                // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape
                if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {
                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin.DISABLE_COLLISION_FLAG);
                }
                this.world.addRigidBody(body);
                impostor.physicsBody = body;
                impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);
            }
            this.setBodyRestitution(impostor, impostor.getParam("restitution"));
            this.setBodyFriction(impostor, impostor.getParam("friction"));
        }
    };
    /**
     * Removes the physics body from the imposter and disposes of the body's memory
     * @param impostor imposter to remove the physics body from
     */
    AmmoJSPlugin.prototype.removePhysicsBody = function (impostor) {
        var _this = this;
        if (this.world) {
            this.world.removeRigidBody(impostor.physicsBody);
            if (impostor._pluginData) {
                impostor._pluginData.toDispose.forEach(function (d) {
                    _this.bjsAMMO.destroy(d);
                });
            }
        }
    };
    /**
     * Generates a joint
     * @param impostorJoint the imposter joint to create the joint with
     */
    AmmoJSPlugin.prototype.generateJoint = function (impostorJoint) {
        var mainBody = impostorJoint.mainImpostor.physicsBody;
        var connectedBody = impostorJoint.connectedImpostor.physicsBody;
        if (!mainBody || !connectedBody) {
            return;
        }
        var jointData = impostorJoint.joint.jointData;
        if (!jointData.mainPivot) {
            jointData.mainPivot = new Vector3(0, 0, 0);
        }
        if (!jointData.connectedPivot) {
            jointData.connectedPivot = new Vector3(0, 0, 0);
        }
        var joint;
        switch (impostorJoint.joint.type) {
            case PhysicsJoint.DistanceJoint:
                var distance = jointData.maxDistance;
                if (distance) {
                    jointData.mainPivot = new Vector3(0, -distance / 2, 0);
                    jointData.connectedPivot = new Vector3(0, distance / 2, 0);
                }
                joint = new Ammo.btPoint2PointConstraint(mainBody, connectedBody, new Ammo.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new Ammo.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));
                break;
            case PhysicsJoint.HingeJoint:
                if (!jointData.mainAxis) {
                    jointData.mainAxis = new Vector3(0, 0, 0);
                }
                if (!jointData.connectedAxis) {
                    jointData.connectedAxis = new Vector3(0, 0, 0);
                }
                var mainAxis = new Ammo.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);
                var connectedAxis = new Ammo.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);
                joint = new Ammo.btHingeConstraint(mainBody, connectedBody, new Ammo.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new Ammo.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);
                break;
            case PhysicsJoint.BallAndSocketJoint:
                joint = new Ammo.btPoint2PointConstraint(mainBody, connectedBody, new Ammo.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new Ammo.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));
                break;
            default:
                Logger.Warn("JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint");
                joint = new Ammo.btPoint2PointConstraint(mainBody, connectedBody, new Ammo.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new Ammo.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));
                break;
        }
        this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);
        impostorJoint.joint.physicsJoint = joint;
    };
    /**
     * Removes a joint
     * @param impostorJoint the imposter joint to remove the joint from
     */
    AmmoJSPlugin.prototype.removeJoint = function (impostorJoint) {
        if (this.world) {
            this.world.removeConstraint(impostorJoint.joint.physicsJoint);
        }
    };
    // adds all verticies (including child verticies) to the triangle mesh
    AmmoJSPlugin.prototype._addMeshVerts = function (btTriangleMesh, topLevelObject, object) {
        var _this = this;
        var triangleCount = 0;
        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {
            var indices = object.getIndices();
            if (!indices) {
                indices = [];
            }
            var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
            if (!vertexPositions) {
                vertexPositions = [];
            }
            object.computeWorldMatrix(false);
            var faceCount = indices.length / 3;
            for (var i = 0; i < faceCount; i++) {
                var triPoints = [];
                for (var point = 0; point < 3; point++) {
                    var v = new Vector3(vertexPositions[(indices[(i * 3) + point] * 3) + 0], vertexPositions[(indices[(i * 3) + point] * 3) + 1], vertexPositions[(indices[(i * 3) + point] * 3) + 2]);
                    // Adjust for initial scaling
                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);
                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);
                    var vec;
                    if (point == 0) {
                        vec = this._tmpAmmoVectorA;
                    }
                    else if (point == 1) {
                        vec = this._tmpAmmoVectorB;
                    }
                    else {
                        vec = this._tmpAmmoVectorC;
                    }
                    vec.setValue(v.x, v.y, v.z);
                    triPoints.push(vec);
                }
                btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);
                triangleCount++;
            }
            object.getChildMeshes().forEach(function (m) {
                triangleCount += _this._addMeshVerts(btTriangleMesh, topLevelObject, m);
            });
        }
        return triangleCount;
    };
    /**
     * Initialise the soft body vertices to match its object's (mesh) vertices
     * Softbody vertices (nodes) are in world space and to match this
     * The object's position and rotation is set to zero and so its vertices are also then set in world space
     * @param impostor to create the softbody for
     */
    AmmoJSPlugin.prototype._softVertexData = function (impostor) {
        var object = impostor.object;
        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {
            var indices = object.getIndices();
            if (!indices) {
                indices = [];
            }
            var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
            if (!vertexPositions) {
                vertexPositions = [];
            }
            var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);
            if (!vertexNormals) {
                vertexNormals = [];
            }
            object.computeWorldMatrix(false);
            var newPoints = [];
            var newNorms = [];
            for (var i = 0; i < vertexPositions.length; i += 3) {
                var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);
                var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);
                v = Vector3.TransformCoordinates(v, object.getWorldMatrix());
                n = Vector3.TransformNormal(n, object.getWorldMatrix());
                newPoints.push(v.x, v.y, v.z);
                newNorms.push(n.x, n.y, n.z);
            }
            var vertex_data = new VertexData();
            vertex_data.positions = newPoints;
            vertex_data.normals = newNorms;
            vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);
            vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);
            if (object && object.getIndices) {
                vertex_data.indices = object.getIndices();
            }
            vertex_data.applyToMesh(object);
            object.position = Vector3.Zero();
            object.rotationQuaternion = null;
            object.rotation = Vector3.Zero();
            object.computeWorldMatrix(true);
            return vertex_data;
        }
        return VertexData.ExtractFromMesh(object);
    };
    /**
     * Create an impostor's soft body
     * @param impostor to create the softbody for
     */
    AmmoJSPlugin.prototype._createSoftbody = function (impostor) {
        var object = impostor.object;
        if (object && object.getIndices) {
            var indices = object.getIndices();
            if (!indices) {
                indices = [];
            }
            var vertex_data = this._softVertexData(impostor);
            var vertexPositions = vertex_data.positions;
            var vertexNormals = vertex_data.normals;
            if (vertexPositions === null || vertexNormals === null) {
                return new Ammo.btCompoundShape();
            }
            else {
                var triPoints = [];
                var triNorms = [];
                for (var i = 0; i < vertexPositions.length; i += 3) {
                    var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);
                    var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);
                    triPoints.push(v.x, v.y, -v.z);
                    triNorms.push(n.x, n.y, -n.z);
                }
                var softBody = new Ammo.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);
                var nbVertices = vertexPositions.length / 3;
                var bodyVertices = softBody.get_m_nodes();
                var node;
                var nodeNormals;
                for (var i = 0; i < nbVertices; i++) {
                    node = bodyVertices.at(i);
                    var nodeNormals = node.get_m_n();
                    nodeNormals.setX(triNorms[3 * i]);
                    nodeNormals.setY(triNorms[3 * i + 1]);
                    nodeNormals.setZ(triNorms[3 * i + 2]);
                }
                return softBody;
            }
        }
    };
    /**
     * Create cloth for an impostor
     * @param impostor to create the softbody for
     */
    AmmoJSPlugin.prototype._createCloth = function (impostor) {
        var object = impostor.object;
        if (object && object.getIndices) {
            var indices = object.getIndices();
            if (!indices) {
                indices = [];
            }
            var vertex_data = this._softVertexData(impostor);
            var vertexPositions = vertex_data.positions;
            var vertexNormals = vertex_data.normals;
            if (vertexPositions === null || vertexNormals === null) {
                return new Ammo.btCompoundShape();
            }
            else {
                var len = vertexPositions.length;
                var segments = Math.sqrt(len / 3);
                impostor.segments = segments;
                var segs = segments - 1;
                this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);
                this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);
                this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);
                this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);
                var clothBody = new Ammo.btSoftBodyHelpers().CreatePatch(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, this._tmpAmmoVectorC, this._tmpAmmoVectorD, segments, segments, impostor.getParam("fixedPoints"), true);
                return clothBody;
            }
        }
    };
    /**
     * Create rope for an impostor
     * @param impostor to create the softbody for
     */
    AmmoJSPlugin.prototype._createRope = function (impostor) {
        var len;
        var segments;
        var vertex_data = this._softVertexData(impostor);
        var vertexPositions = vertex_data.positions;
        var vertexNormals = vertex_data.normals;
        if (vertexPositions === null || vertexNormals === null) {
            return new Ammo.btCompoundShape();
        }
        //force the mesh to be updatable
        vertex_data.applyToMesh(impostor.object, true);
        impostor._isFromLine = true;
        // If in lines mesh all normals will be zero
        var vertexSquared = vertexNormals.map(function (x) { return x * x; });
        var reducer = function (accumulator, currentValue) { return accumulator + currentValue; };
        var reduced = vertexSquared.reduce(reducer);
        if (reduced === 0) { // line mesh
            len = vertexPositions.length;
            segments = len / 3 - 1;
            this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);
            this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);
        }
        else { //extruded mesh
            impostor._isFromLine = false;
            var pathVectors = impostor.getParam("path");
            var shape = impostor.getParam("shape");
            if (shape === null) {
                Logger.Warn("No shape available for extruded mesh");
                return new Ammo.btCompoundShape();
            }
            if ((vertexPositions.length % (3 * pathVectors.length)) !== 0) {
                Logger.Warn("Path does not match extrusion");
                return new Ammo.btCompoundShape();
            }
            len = pathVectors.length;
            segments = len - 1;
            this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);
            this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);
        }
        impostor.segments = segments;
        var fixedPoints = impostor.getParam("fixedPoints");
        fixedPoints = (fixedPoints > 3) ? 3 : fixedPoints;
        var ropeBody = new Ammo.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);
        ropeBody.get_m_cfg().set_collisions(0x11);
        return ropeBody;
    };
    // adds all verticies (including child verticies) to the convex hull shape
    AmmoJSPlugin.prototype._addHullVerts = function (btConvexHullShape, topLevelObject, object) {
        var _this = this;
        var triangleCount = 0;
        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {
            var indices = object.getIndices();
            if (!indices) {
                indices = [];
            }
            var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);
            if (!vertexPositions) {
                vertexPositions = [];
            }
            object.computeWorldMatrix(false);
            var faceCount = indices.length / 3;
            for (var i = 0; i < faceCount; i++) {
                var triPoints = [];
                for (var point = 0; point < 3; point++) {
                    var v = new Vector3(vertexPositions[(indices[(i * 3) + point] * 3) + 0], vertexPositions[(indices[(i * 3) + point] * 3) + 1], vertexPositions[(indices[(i * 3) + point] * 3) + 2]);
                    // Adjust for initial scaling
                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);
                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);
                    var vec;
                    if (point == 0) {
                        vec = this._tmpAmmoVectorA;
                    }
                    else if (point == 1) {
                        vec = this._tmpAmmoVectorB;
                    }
                    else {
                        vec = this._tmpAmmoVectorC;
                    }
                    vec.setValue(v.x, v.y, v.z);
                    triPoints.push(vec);
                }
                btConvexHullShape.addPoint(triPoints[0], true);
                btConvexHullShape.addPoint(triPoints[1], true);
                btConvexHullShape.addPoint(triPoints[2], true);
                triangleCount++;
            }
            object.getChildMeshes().forEach(function (m) {
                triangleCount += _this._addHullVerts(btConvexHullShape, topLevelObject, m);
            });
        }
        return triangleCount;
    };
    AmmoJSPlugin.prototype._createShape = function (impostor, ignoreChildren) {
        var _this = this;
        if (ignoreChildren === void 0) { ignoreChildren = false; }
        var object = impostor.object;
        var returnValue;
        var extendSize = impostor.getObjectExtendSize();
        if (!ignoreChildren) {
            var meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];
            returnValue = new Ammo.btCompoundShape();
            // Add shape of all children to the compound shape
            var childrenAdded = 0;
            meshChildren.forEach(function (childMesh) {
                var childImpostor = childMesh.getPhysicsImpostor();
                if (childImpostor) {
                    if (childImpostor.type == PhysicsImpostor.MeshImpostor) {
                        throw "A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)";
                    }
                    var shape = _this._createShape(childImpostor);
                    // Position needs to be scaled based on parent's scaling
                    var parentMat = childMesh.parent.getWorldMatrix().clone();
                    var s = new Vector3();
                    parentMat.decompose(s);
                    _this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);
                    _this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion.x, childMesh.rotationQuaternion.y, childMesh.rotationQuaternion.z, childMesh.rotationQuaternion.w);
                    _this._tmpAmmoTransform.setRotation(_this._tmpAmmoQuaternion);
                    returnValue.addChildShape(_this._tmpAmmoTransform, shape);
                    childImpostor.dispose();
                    childrenAdded++;
                }
            });
            if (childrenAdded > 0) {
                // Add parents shape as a child if present
                if (impostor.type != PhysicsImpostor.NoImpostor) {
                    var shape = this._createShape(impostor, true);
                    if (shape) {
                        this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);
                        this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);
                        this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);
                        returnValue.addChildShape(this._tmpAmmoTransform, shape);
                    }
                }
                return returnValue;
            }
            else {
                // If no children with impostors create the actual shape below instead
                Ammo.destroy(returnValue);
                returnValue = null;
            }
        }
        switch (impostor.type) {
            case PhysicsImpostor.SphereImpostor:
                returnValue = new Ammo.btSphereShape(extendSize.x / 2);
                break;
            case PhysicsImpostor.CylinderImpostor:
                this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);
                returnValue = new Ammo.btCylinderShape(this._tmpAmmoVectorA);
                break;
            case PhysicsImpostor.PlaneImpostor:
            case PhysicsImpostor.BoxImpostor:
                this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);
                returnValue = new Ammo.btBoxShape(this._tmpAmmoVectorA);
                break;
            case PhysicsImpostor.MeshImpostor:
                if (impostor.getParam("mass") == 0) {
                    // Only create btBvhTriangleMeshShape impostor is static
                    // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283
                    var tetraMesh = new Ammo.btTriangleMesh();
                    impostor._pluginData.toDispose.push(tetraMesh);
                    var triangeCount = this._addMeshVerts(tetraMesh, object, object);
                    if (triangeCount == 0) {
                        returnValue = new Ammo.btCompoundShape();
                    }
                    else {
                        returnValue = new Ammo.btBvhTriangleMeshShape(tetraMesh);
                    }
                    break;
                }
            // Otherwise create convexHullImpostor
            case PhysicsImpostor.ConvexHullImpostor:
                var convexMesh = new Ammo.btConvexHullShape();
                var triangeCount = this._addHullVerts(convexMesh, object, object);
                if (triangeCount == 0) {
                    // Cleanup Unused Convex Hull Shape
                    impostor._pluginData.toDispose.push(convexMesh);
                    returnValue = new Ammo.btCompoundShape();
                }
                else {
                    returnValue = convexMesh;
                }
                break;
            case PhysicsImpostor.NoImpostor:
                // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints
                returnValue = new Ammo.btSphereShape(extendSize.x / 2);
                break;
            case PhysicsImpostor.SoftbodyImpostor:
                // Only usable with a mesh that has sufficient and shared vertices
                returnValue = this._createSoftbody(impostor);
                break;
            case PhysicsImpostor.ClothImpostor:
                // Only usable with a ground mesh that has sufficient and shared vertices
                returnValue = this._createCloth(impostor);
                break;
            case PhysicsImpostor.RopeImpostor:
                // Only usable with a line mesh or an extruded mesh that is updatable
                returnValue = this._createRope(impostor);
                break;
            default:
                Logger.Warn("The impostor type is not currently supported by the ammo plugin.");
                break;
        }
        return returnValue;
    };
    /**
     * Sets the physics body position/rotation from the babylon mesh's position/rotation
     * @param impostor imposter containing the physics body and babylon object
     */
    AmmoJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {
        impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);
        impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());
        if (!impostor.object.rotationQuaternion) {
            if (impostor.object.rotation) {
                this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());
                this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);
            }
        }
        else {
            impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());
        }
    };
    /**
     * Sets the babylon object's position/rotation from the physics body's position/rotation
     * @param impostor imposter containing the physics body and babylon object
     * @param newPosition new position
     * @param newRotation new rotation
     */
    AmmoJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {
        var trans = impostor.physicsBody.getWorldTransform();
        // If rotation/position has changed update and activate riged body
        if (trans.getOrigin().x() != newPosition.x ||
            trans.getOrigin().y() != newPosition.y ||
            trans.getOrigin().z() != newPosition.z ||
            trans.getRotation().x() != newRotation.x ||
            trans.getRotation().y() != newRotation.y ||
            trans.getRotation().z() != newRotation.z ||
            trans.getRotation().w() != newRotation.w) {
            this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);
            trans.setOrigin(this._tmpAmmoVectorA);
            this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);
            trans.setRotation(this._tmpAmmoQuaternion);
            impostor.physicsBody.setWorldTransform(trans);
            if (impostor.mass == 0) {
                // Kinematic objects must be updated using motion state
                var motionState = impostor.physicsBody.getMotionState();
                if (motionState) {
                    motionState.setWorldTransform(trans);
                }
            }
            else {
                impostor.physicsBody.activate();
            }
        }
    };
    /**
     * If this plugin is supported
     * @returns true if its supported
     */
    AmmoJSPlugin.prototype.isSupported = function () {
        return this.bjsAMMO !== undefined;
    };
    /**
     * Sets the linear velocity of the physics body
     * @param impostor imposter to set the velocity on
     * @param velocity velocity to set
     */
    AmmoJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {
        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);
        if (impostor.soft) {
            impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);
        }
        else {
            impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);
        }
    };
    /**
     * Sets the angular velocity of the physics body
     * @param impostor imposter to set the velocity on
     * @param velocity velocity to set
     */
    AmmoJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {
        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);
        if (impostor.soft) {
            impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);
        }
        else {
            impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);
        }
    };
    /**
     * gets the linear velocity
     * @param impostor imposter to get linear velocity from
     * @returns linear velocity
     */
    AmmoJSPlugin.prototype.getLinearVelocity = function (impostor) {
        if (impostor.soft) {
            var v = impostor.physicsBody.linearVelocity();
        }
        else {
            var v = impostor.physicsBody.getLinearVelocity();
        }
        if (!v) {
            return null;
        }
        var result = new Vector3(v.x(), v.y(), v.z());
        Ammo.destroy(v);
        return result;
    };
    /**
     * gets the angular velocity
     * @param impostor imposter to get angular velocity from
     * @returns angular velocity
     */
    AmmoJSPlugin.prototype.getAngularVelocity = function (impostor) {
        if (impostor.soft) {
            var v = impostor.physicsBody.angularVelocity();
        }
        else {
            var v = impostor.physicsBody.getAngularVelocity();
        }
        if (!v) {
            return null;
        }
        var result = new Vector3(v.x(), v.y(), v.z());
        Ammo.destroy(v);
        return result;
    };
    /**
     * Sets the mass of physics body
     * @param impostor imposter to set the mass on
     * @param mass mass to set
     */
    AmmoJSPlugin.prototype.setBodyMass = function (impostor, mass) {
        if (impostor.soft) {
            impostor.physicsBody.setTotalMass(mass, false);
        }
        else {
            impostor.physicsBody.setMassProps(mass);
        }
        impostor._pluginData.mass = mass;
    };
    /**
     * Gets the mass of the physics body
     * @param impostor imposter to get the mass from
     * @returns mass
     */
    AmmoJSPlugin.prototype.getBodyMass = function (impostor) {
        return impostor._pluginData.mass || 0;
    };
    /**
     * Gets friction of the impostor
     * @param impostor impostor to get friction from
     * @returns friction value
     */
    AmmoJSPlugin.prototype.getBodyFriction = function (impostor) {
        return impostor._pluginData.friction || 0;
    };
    /**
     * Sets friction of the impostor
     * @param impostor impostor to set friction on
     * @param friction friction value
     */
    AmmoJSPlugin.prototype.setBodyFriction = function (impostor, friction) {
        if (impostor.soft) {
            impostor.physicsBody.get_m_cfg().set_kDF(friction);
        }
        else {
            impostor.physicsBody.setFriction(friction);
        }
        impostor._pluginData.friction = friction;
    };
    /**
     * Gets restitution of the impostor
     * @param impostor impostor to get restitution from
     * @returns restitution value
     */
    AmmoJSPlugin.prototype.getBodyRestitution = function (impostor) {
        return impostor._pluginData.restitution || 0;
    };
    /**
     * Sets resitution of the impostor
     * @param impostor impostor to set resitution on
     * @param restitution resitution value
     */
    AmmoJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {
        impostor.physicsBody.setRestitution(restitution);
        impostor._pluginData.restitution = restitution;
    };
    /**
     * Gets pressure inside the impostor
     * @param impostor impostor to get pressure from
     * @returns pressure value
     */
    AmmoJSPlugin.prototype.getBodyPressure = function (impostor) {
        if (!impostor.soft) {
            Logger.Warn("Pressure is not a property of a rigid body");
            return 0;
        }
        return impostor._pluginData.pressure || 0;
    };
    /**
     * Sets pressure inside a soft body impostor
     * Cloth and rope must remain 0 pressure
     * @param impostor impostor to set pressure on
     * @param pressure pressure value
     */
    AmmoJSPlugin.prototype.setBodyPressure = function (impostor, pressure) {
        if (impostor.soft) {
            if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {
                impostor.physicsBody.get_m_cfg().set_kPR(pressure);
                impostor._pluginData.pressure = pressure;
            }
            else {
                impostor.physicsBody.get_m_cfg().set_kPR(0);
                impostor._pluginData.pressure = 0;
            }
        }
        else {
            Logger.Warn("Pressure can only be applied to a softbody");
        }
    };
    /**
     * Gets stiffness of the impostor
     * @param impostor impostor to get stiffness from
     * @returns pressure value
     */
    AmmoJSPlugin.prototype.getBodyStiffness = function (impostor) {
        if (!impostor.soft) {
            Logger.Warn("Stiffness is not a property of a rigid body");
            return 0;
        }
        return impostor._pluginData.stiffness || 0;
    };
    /**
     * Sets stiffness of the impostor
     * @param impostor impostor to set stiffness on
     * @param stiffness stiffness value from 0 to 1
     */
    AmmoJSPlugin.prototype.setBodyStiffness = function (impostor, stiffness) {
        if (impostor.soft) {
            stiffness = stiffness < 0 ? 0 : stiffness;
            stiffness = stiffness > 1 ? 1 : stiffness;
            impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);
            impostor._pluginData.stiffness = stiffness;
        }
        else {
            Logger.Warn("Stiffness cannot be applied to a rigid body");
        }
    };
    /**
     * Gets velocityIterations of the impostor
     * @param impostor impostor to get velocity iterations from
     * @returns velocityIterations value
     */
    AmmoJSPlugin.prototype.getBodyVelocityIterations = function (impostor) {
        if (!impostor.soft) {
            Logger.Warn("Velocity iterations is not a property of a rigid body");
            return 0;
        }
        return impostor._pluginData.velocityIterations || 0;
    };
    /**
     * Sets velocityIterations of the impostor
     * @param impostor impostor to set velocity iterations on
     * @param velocityIterations velocityIterations value
     */
    AmmoJSPlugin.prototype.setBodyVelocityIterations = function (impostor, velocityIterations) {
        if (impostor.soft) {
            velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;
            impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);
            impostor._pluginData.velocityIterations = velocityIterations;
        }
        else {
            Logger.Warn("Velocity iterations cannot be applied to a rigid body");
        }
    };
    /**
     * Gets positionIterations of the impostor
     * @param impostor impostor to get position iterations from
     * @returns positionIterations value
     */
    AmmoJSPlugin.prototype.getBodyPositionIterations = function (impostor) {
        if (!impostor.soft) {
            Logger.Warn("Position iterations is not a property of a rigid body");
            return 0;
        }
        return impostor._pluginData.positionIterations || 0;
    };
    /**
     * Sets positionIterations of the impostor
     * @param impostor impostor to set position on
     * @param positionIterations positionIterations value
     */
    AmmoJSPlugin.prototype.setBodyPositionIterations = function (impostor, positionIterations) {
        if (impostor.soft) {
            positionIterations = positionIterations < 0 ? 0 : positionIterations;
            impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);
            impostor._pluginData.positionIterations = positionIterations;
        }
        else {
            Logger.Warn("Position iterations cannot be applied to a rigid body");
        }
    };
    /**
    * Append an anchor to a cloth object
    * @param impostor is the cloth impostor to add anchor to
    * @param otherImpostor is the rigid impostor to anchor to
    * @param width ratio across width from 0 to 1
    * @param height ratio up height from 0 to 1
    * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech
    * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
    */
    AmmoJSPlugin.prototype.appendAnchor = function (impostor, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {
        if (influence === void 0) { influence = 1; }
        if (noCollisionBetweenLinkedBodies === void 0) { noCollisionBetweenLinkedBodies = false; }
        var segs = impostor.segments;
        var nbAcross = Math.round((segs - 1) * width);
        var nbUp = Math.round((segs - 1) * height);
        var nbDown = segs - 1 - nbUp;
        var node = nbAcross + segs * nbDown;
        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);
    };
    /**
     * Append an hook to a rope object
     * @param impostor is the rope impostor to add hook to
     * @param otherImpostor is the rigid impostor to hook to
     * @param length ratio along the rope from 0 to 1
     * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little strech
     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
     */
    AmmoJSPlugin.prototype.appendHook = function (impostor, otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {
        if (influence === void 0) { influence = 1; }
        if (noCollisionBetweenLinkedBodies === void 0) { noCollisionBetweenLinkedBodies = false; }
        var node = Math.round(impostor.segments * length);
        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);
    };
    /**
     * Sleeps the physics body and stops it from being active
     * @param impostor impostor to sleep
     */
    AmmoJSPlugin.prototype.sleepBody = function (impostor) {
        Logger.Warn("sleepBody is not currently supported by the Ammo physics plugin");
    };
    /**
     * Activates the physics body
     * @param impostor impostor to activate
     */
    AmmoJSPlugin.prototype.wakeUpBody = function (impostor) {
        impostor.physicsBody.activate();
    };
    /**
     * Updates the distance parameters of the joint
     * @param joint joint to update
     * @param maxDistance maximum distance of the joint
     * @param minDistance minimum distance of the joint
     */
    AmmoJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {
        Logger.Warn("updateDistanceJoint is not currently supported by the Ammo physics plugin");
    };
    /**
     * Sets a motor on the joint
     * @param joint joint to set motor on
     * @param speed speed of the motor
     * @param maxForce maximum force of the motor
     * @param motorIndex index of the motor
     */
    AmmoJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {
        joint.physicsJoint.enableAngularMotor(true, speed, maxForce);
    };
    /**
     * Sets the motors limit
     * @param joint joint to set limit on
     * @param upperLimit upper limit
     * @param lowerLimit lower limit
     */
    AmmoJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit) {
        Logger.Warn("setLimit is not currently supported by the Ammo physics plugin");
    };
    /**
     * Syncs the position and rotation of a mesh with the impostor
     * @param mesh mesh to sync
     * @param impostor impostor to update the mesh with
     */
    AmmoJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {
        var body = impostor.physicsBody;
        body.getMotionState().getWorldTransform(this._tmpAmmoTransform);
        mesh.position.x = this._tmpAmmoTransform.getOrigin().x();
        mesh.position.y = this._tmpAmmoTransform.getOrigin().y();
        mesh.position.z = this._tmpAmmoTransform.getOrigin().z();
        if (mesh.rotationQuaternion) {
            mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();
            mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();
            mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();
            mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();
        }
    };
    /**
     * Gets the radius of the impostor
     * @param impostor impostor to get radius from
     * @returns the radius
     */
    AmmoJSPlugin.prototype.getRadius = function (impostor) {
        var exntend = impostor.getObjectExtendSize();
        return exntend.x / 2;
    };
    /**
     * Gets the box size of the impostor
     * @param impostor impostor to get box size from
     * @param result the resulting box size
     */
    AmmoJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {
        var exntend = impostor.getObjectExtendSize();
        result.x = exntend.x;
        result.y = exntend.y;
        result.z = exntend.z;
    };
    /**
     * Disposes of the impostor
     */
    AmmoJSPlugin.prototype.dispose = function () {
        // Dispose of world
        Ammo.destroy(this.world);
        Ammo.destroy(this._solver);
        Ammo.destroy(this._overlappingPairCache);
        Ammo.destroy(this._dispatcher);
        Ammo.destroy(this._collisionConfiguration);
        // Dispose of tmp variables
        Ammo.destroy(this._tmpAmmoVectorA);
        Ammo.destroy(this._tmpAmmoVectorB);
        Ammo.destroy(this._tmpAmmoVectorC);
        Ammo.destroy(this._tmpAmmoTransform);
        Ammo.destroy(this._tmpAmmoQuaternion);
        Ammo.destroy(this._tmpAmmoConcreteContactResultCallback);
        this.world = null;
    };
    /**
     * Does a raycast in the physics world
     * @param from when should the ray start?
     * @param to when should the ray end?
     * @returns PhysicsRaycastResult
     */
    AmmoJSPlugin.prototype.raycast = function (from, to) {
        this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);
        this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);
        var rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);
        this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);
        this._raycastResult.reset(from, to);
        if (rayCallback.hasHit()) {
            // TODO: do we want/need the body? If so, set all the data
            /*
            var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(
                rayCallback.get_m_collisionObject()
            );
            var body = {};
            */
            this._raycastResult.setHitData({
                x: rayCallback.get_m_hitNormalWorld().x(),
                y: rayCallback.get_m_hitNormalWorld().y(),
                z: rayCallback.get_m_hitNormalWorld().z(),
            }, {
                x: rayCallback.get_m_hitPointWorld().x(),
                y: rayCallback.get_m_hitPointWorld().y(),
                z: rayCallback.get_m_hitPointWorld().z(),
            });
            this._raycastResult.calculateHitDistance();
        }
        Ammo.destroy(rayCallback);
        Ammo.destroy(this._tmpAmmoVectorRCA);
        Ammo.destroy(this._tmpAmmoVectorRCB);
        return this._raycastResult;
    };
    AmmoJSPlugin.DISABLE_COLLISION_FLAG = 4;
    AmmoJSPlugin.KINEMATIC_FLAG = 2;
    AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG = 4;
    return AmmoJSPlugin;
}());

AbstractScene.prototype.removeReflectionProbe = function (toRemove) {
    if (!this.reflectionProbes) {
        return -1;
    }
    var index = this.reflectionProbes.indexOf(toRemove);
    if (index !== -1) {
        this.reflectionProbes.splice(index, 1);
    }
    return index;
};
AbstractScene.prototype.addReflectionProbe = function (newReflectionProbe) {
    if (!this.reflectionProbes) {
        this.reflectionProbes = [];
    }
    this.reflectionProbes.push(newReflectionProbe);
};
/**
 * Class used to generate realtime reflection / refraction cube textures
 * @see http://doc.babylonjs.com/how_to/how_to_use_reflection_probes
 */
var ReflectionProbe = /** @class */ (function () {
    /**
     * Creates a new reflection probe
     * @param name defines the name of the probe
     * @param size defines the texture resolution (for each face)
     * @param scene defines the hosting scene
     * @param generateMipMaps defines if mip maps should be generated automatically (true by default)
     * @param useFloat defines if HDR data (flaot data) should be used to store colors (false by default)
     */
    function ReflectionProbe(
    /** defines the name of the probe */
    name, size, scene, generateMipMaps, useFloat) {
        var _this = this;
        if (generateMipMaps === void 0) { generateMipMaps = true; }
        if (useFloat === void 0) { useFloat = false; }
        this.name = name;
        this._viewMatrix = Matrix.Identity();
        this._target = Vector3.Zero();
        this._add = Vector3.Zero();
        this._invertYAxis = false;
        /** Gets or sets probe position (center of the cube map) */
        this.position = Vector3.Zero();
        this._scene = scene;
        // Create the scene field if not exist.
        if (!this._scene.reflectionProbes) {
            this._scene.reflectionProbes = new Array();
        }
        this._scene.reflectionProbes.push(this);
        this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, useFloat ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_UNSIGNED_INT, true);
        this._renderTargetTexture.onBeforeRenderObservable.add(function (faceIndex) {
            switch (faceIndex) {
                case 0:
                    _this._add.copyFromFloats(1, 0, 0);
                    break;
                case 1:
                    _this._add.copyFromFloats(-1, 0, 0);
                    break;
                case 2:
                    _this._add.copyFromFloats(0, _this._invertYAxis ? 1 : -1, 0);
                    break;
                case 3:
                    _this._add.copyFromFloats(0, _this._invertYAxis ? -1 : 1, 0);
                    break;
                case 4:
                    _this._add.copyFromFloats(0, 0, 1);
                    break;
                case 5:
                    _this._add.copyFromFloats(0, 0, -1);
                    break;
            }
            if (_this._attachedMesh) {
                _this.position.copyFrom(_this._attachedMesh.getAbsolutePosition());
            }
            _this.position.addToRef(_this._add, _this._target);
            Matrix.LookAtLHToRef(_this.position, _this._target, Vector3.Up(), _this._viewMatrix);
            if (scene.activeCamera) {
                _this._projectionMatrix = Matrix.PerspectiveFovLH(Math.PI / 2, 1, scene.activeCamera.minZ, scene.activeCamera.maxZ);
                scene.setTransformMatrix(_this._viewMatrix, _this._projectionMatrix);
            }
            scene._forcedViewPosition = _this.position;
        });
        this._renderTargetTexture.onAfterUnbindObservable.add(function () {
            scene._forcedViewPosition = null;
            scene.updateTransformMatrix(true);
        });
    }
    Object.defineProperty(ReflectionProbe.prototype, "samples", {
        /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */
        get: function () {
            return this._renderTargetTexture.samples;
        },
        set: function (value) {
            this._renderTargetTexture.samples = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReflectionProbe.prototype, "refreshRate", {
        /** Gets or sets the refresh rate to use (on every frame by default) */
        get: function () {
            return this._renderTargetTexture.refreshRate;
        },
        set: function (value) {
            this._renderTargetTexture.refreshRate = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the hosting scene
     * @returns a Scene
     */
    ReflectionProbe.prototype.getScene = function () {
        return this._scene;
    };
    Object.defineProperty(ReflectionProbe.prototype, "cubeTexture", {
        /** Gets the internal CubeTexture used to render to */
        get: function () {
            return this._renderTargetTexture;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReflectionProbe.prototype, "renderList", {
        /** Gets the list of meshes to render */
        get: function () {
            return this._renderTargetTexture.renderList;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)
     * @param mesh defines the mesh to attach to
     */
    ReflectionProbe.prototype.attachToMesh = function (mesh) {
        this._attachedMesh = mesh;
    };
    /**
     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups
     * @param renderingGroupId The rendering group id corresponding to its index
     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
     */
    ReflectionProbe.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil) {
        this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
    };
    /**
     * Clean all associated resources
     */
    ReflectionProbe.prototype.dispose = function () {
        var index = this._scene.reflectionProbes.indexOf(this);
        if (index !== -1) {
            // Remove from the scene if found
            this._scene.reflectionProbes.splice(index, 1);
        }
        if (this._renderTargetTexture) {
            this._renderTargetTexture.dispose();
            this._renderTargetTexture = null;
        }
    };
    /**
     * Converts the reflection probe information to a readable string for debug purpose.
     * @param fullDetails Supports for multiple levels of logging within scene loading
     * @returns the human readable reflection probe info
     */
    ReflectionProbe.prototype.toString = function (fullDetails) {
        var ret = "Name: " + this.name;
        if (fullDetails) {
            ret += ", position: " + this.position.toString();
            if (this._attachedMesh) {
                ret += ", attached mesh: " + this._attachedMesh.name;
            }
        }
        return ret;
    };
    /**
     * Get the class name of the relfection probe.
     * @returns "ReflectionProbe"
     */
    ReflectionProbe.prototype.getClassName = function () {
        return "ReflectionProbe";
    };
    /**
     * Serialize the reflection probe to a JSON representation we can easily use in the resepective Parse function.
     * @returns The JSON representation of the texture
     */
    ReflectionProbe.prototype.serialize = function () {
        var serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());
        serializationObject.isReflectionProbe = true;
        return serializationObject;
    };
    /**
     * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.
     * @param parsedReflectionProbe Define the JSON representation of the reflection probe
     * @param scene Define the scene the parsed reflection probe should be instantiated in
     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies
     * @returns The parsed reflection probe if successful
     */
    ReflectionProbe.Parse = function (parsedReflectionProbe, scene, rootUrl) {
        var reflectionProbe = null;
        if (scene.reflectionProbes) {
            for (var index = 0; index < scene.reflectionProbes.length; index++) {
                var rp = scene.reflectionProbes[index];
                if (rp.name === parsedReflectionProbe.name) {
                    reflectionProbe = rp;
                    break;
                }
            }
        }
        reflectionProbe = SerializationHelper.Parse(function () { return reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps); }, parsedReflectionProbe, scene, rootUrl);
        reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;
        if (parsedReflectionProbe._attachedMesh) {
            reflectionProbe.attachToMesh(scene.getMeshByID(parsedReflectionProbe._attachedMesh));
        }
        return reflectionProbe;
    };
    __decorate([
        serializeAsMeshReference()
    ], ReflectionProbe.prototype, "_attachedMesh", void 0);
    __decorate([
        serializeAsVector3()
    ], ReflectionProbe.prototype, "position", void 0);
    return ReflectionProbe;
}());

/** @hidden */
var _BabylonLoaderRegistered = true;
var parseMaterialById = function (id, parsedData, scene, rootUrl) {
    for (var index = 0, cache = parsedData.materials.length; index < cache; index++) {
        var parsedMaterial = parsedData.materials[index];
        if (parsedMaterial.id === id) {
            return Material.Parse(parsedMaterial, scene, rootUrl);
        }
    }
    return null;
};
var isDescendantOf = function (mesh, names, hierarchyIds) {
    for (var i in names) {
        if (mesh.name === names[i]) {
            hierarchyIds.push(mesh.id);
            return true;
        }
    }
    if (mesh.parentId && hierarchyIds.indexOf(mesh.parentId) !== -1) {
        hierarchyIds.push(mesh.id);
        return true;
    }
    return false;
};
var logOperation = function (operation, producer) {
    return operation + " of " + (producer ? producer.file + " from " + producer.name + " version: " + producer.version + ", exporter version: " + producer.exporter_version : "unknown");
};
var loadDetailLevels = function (scene, mesh) {
    var mastermesh = mesh;
    // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.
    // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.
    if (mesh._waitingData.lods) {
        if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {
            var lodmeshes = mesh._waitingData.lods.ids;
            var wasenabled = mastermesh.isEnabled(false);
            if (mesh._waitingData.lods.distances) {
                var distances = mesh._waitingData.lods.distances;
                if (distances.length >= lodmeshes.length) {
                    var culling = (distances.length > lodmeshes.length) ? distances[distances.length - 1] : 0;
                    mastermesh.setEnabled(false);
                    for (var index = 0; index < lodmeshes.length; index++) {
                        var lodid = lodmeshes[index];
                        var lodmesh = scene.getMeshByID(lodid);
                        if (lodmesh != null) {
                            mastermesh.addLODLevel(distances[index], lodmesh);
                        }
                    }
                    if (culling > 0) {
                        mastermesh.addLODLevel(culling, null);
                    }
                    if (wasenabled === true) {
                        mastermesh.setEnabled(true);
                    }
                }
                else {
                    Tools.Warn("Invalid level of detail distances for " + mesh.name);
                }
            }
        }
        mesh._waitingData.lods = null;
    }
};
var loadAssetContainer = function (scene, data, rootUrl, onError, addToScene) {
    if (addToScene === void 0) { addToScene = false; }
    var container = new AssetContainer(scene);
    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details
    // when SceneLoader.debugLogging = true (default), or exception encountered.
    // Everything stored in var log instead of writing separate lines to support only writing in exception,
    // and avoid problems with multiple concurrent .babylon loads.
    var log = "importScene has failed JSON parse";
    try {
        var parsedData = JSON.parse(data);
        log = "";
        var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;
        var index;
        var cache;
        // Environment texture
        if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {
            // PBR needed for both HDR texture (gamma space) & a sky box
            var isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;
            if (parsedData.environmentTextureType && parsedData.environmentTextureType === "BABYLON.HDRCubeTexture") {
                var hdrSize = (parsedData.environmentTextureSize) ? parsedData.environmentTextureSize : 128;
                var hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\/\//g) ? "" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR);
                if (parsedData.environmentTextureRotationY) {
                    hdrTexture.rotationY = parsedData.environmentTextureRotationY;
                }
                scene.environmentTexture = hdrTexture;
            }
            else {
                if (Tools.EndsWith(parsedData.environmentTexture, ".env")) {
                    var compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\/\//g) ? "" : rootUrl) + parsedData.environmentTexture, scene);
                    if (parsedData.environmentTextureRotationY) {
                        compressedTexture.rotationY = parsedData.environmentTextureRotationY;
                    }
                    scene.environmentTexture = compressedTexture;
                }
                else {
                    var cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\/\//g) ? "" : rootUrl) + parsedData.environmentTexture, scene);
                    if (parsedData.environmentTextureRotationY) {
                        cubeTexture.rotationY = parsedData.environmentTextureRotationY;
                    }
                    scene.environmentTexture = cubeTexture;
                }
            }
            if (parsedData.createDefaultSkybox === true) {
                var skyboxScale = (scene.activeCamera !== undefined && scene.activeCamera !== null) ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;
                var skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;
                scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);
            }
            container.environmentTexture = scene.environmentTexture;
        }
        // Lights
        if (parsedData.lights !== undefined && parsedData.lights !== null) {
            for (index = 0, cache = parsedData.lights.length; index < cache; index++) {
                var parsedLight = parsedData.lights[index];
                var light = Light.Parse(parsedLight, scene);
                if (light) {
                    container.lights.push(light);
                    log += (index === 0 ? "\n\tLights:" : "");
                    log += "\n\t\t" + light.toString(fullDetails);
                }
            }
        }
        // Reflection probes
        if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {
            for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {
                var parsedReflectionProbe = parsedData.reflectionProbes[index];
                var reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);
                if (reflectionProbe) {
                    container.reflectionProbes.push(reflectionProbe);
                    log += (index === 0 ? "\n\tReflection Probes:" : "");
                    log += "\n\t\t" + reflectionProbe.toString(fullDetails);
                }
            }
        }
        // Animations
        if (parsedData.animations !== undefined && parsedData.animations !== null) {
            for (index = 0, cache = parsedData.animations.length; index < cache; index++) {
                var parsedAnimation = parsedData.animations[index];
                var internalClass = _TypeStore.GetClass("BABYLON.Animation");
                if (internalClass) {
                    var animation = internalClass.Parse(parsedAnimation);
                    scene.animations.push(animation);
                    container.animations.push(animation);
                    log += (index === 0 ? "\n\tAnimations:" : "");
                    log += "\n\t\t" + animation.toString(fullDetails);
                }
            }
        }
        // Materials
        if (parsedData.materials !== undefined && parsedData.materials !== null) {
            for (index = 0, cache = parsedData.materials.length; index < cache; index++) {
                var parsedMaterial = parsedData.materials[index];
                var mat = Material.Parse(parsedMaterial, scene, rootUrl);
                if (mat) {
                    container.materials.push(mat);
                    log += (index === 0 ? "\n\tMaterials:" : "");
                    log += "\n\t\t" + mat.toString(fullDetails);
                    // Textures
                    var textures = mat.getActiveTextures();
                    textures.forEach(function (t) {
                        if (container.textures.indexOf(t) == -1) {
                            container.textures.push(t);
                        }
                    });
                }
            }
        }
        if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {
            for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {
                var parsedMultiMaterial = parsedData.multiMaterials[index];
                var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);
                container.multiMaterials.push(mmat);
                log += (index === 0 ? "\n\tMultiMaterials:" : "");
                log += "\n\t\t" + mmat.toString(fullDetails);
                // Textures
                var textures = mmat.getActiveTextures();
                textures.forEach(function (t) {
                    if (container.textures.indexOf(t) == -1) {
                        container.textures.push(t);
                    }
                });
            }
        }
        // Morph targets
        if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {
            for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {
                var managerData = _a[_i];
                container.morphTargetManagers.push(MorphTargetManager.Parse(managerData, scene));
            }
        }
        // Skeletons
        if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {
            for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {
                var parsedSkeleton = parsedData.skeletons[index];
                var skeleton = Skeleton.Parse(parsedSkeleton, scene);
                container.skeletons.push(skeleton);
                log += (index === 0 ? "\n\tSkeletons:" : "");
                log += "\n\t\t" + skeleton.toString(fullDetails);
            }
        }
        // Geometries
        var geometries = parsedData.geometries;
        if (geometries !== undefined && geometries !== null) {
            var addedGeometry = new Array();
            // VertexData
            var vertexData = geometries.vertexData;
            if (vertexData !== undefined && vertexData !== null) {
                for (index = 0, cache = vertexData.length; index < cache; index++) {
                    var parsedVertexData = vertexData[index];
                    addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));
                }
            }
            addedGeometry.forEach(function (g) {
                if (g) {
                    container.geometries.push(g);
                }
            });
        }
        // Transform nodes
        if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {
            for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {
                var parsedTransformNode = parsedData.transformNodes[index];
                var node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);
                container.transformNodes.push(node);
            }
        }
        // Meshes
        if (parsedData.meshes !== undefined && parsedData.meshes !== null) {
            for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {
                var parsedMesh = parsedData.meshes[index];
                var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);
                container.meshes.push(mesh);
                log += (index === 0 ? "\n\tMeshes:" : "");
                log += "\n\t\t" + mesh.toString(fullDetails);
            }
        }
        // Cameras
        if (parsedData.cameras !== undefined && parsedData.cameras !== null) {
            for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {
                var parsedCamera = parsedData.cameras[index];
                var camera = Camera.Parse(parsedCamera, scene);
                container.cameras.push(camera);
                log += (index === 0 ? "\n\tCameras:" : "");
                log += "\n\t\t" + camera.toString(fullDetails);
            }
        }
        // Animation Groups
        if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {
            for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {
                var parsedAnimationGroup = parsedData.animationGroups[index];
                var animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);
                container.animationGroups.push(animationGroup);
                log += (index === 0 ? "\n\tAnimationGroups:" : "");
                log += "\n\t\t" + animationGroup.toString(fullDetails);
            }
        }
        // Browsing all the graph to connect the dots
        for (index = 0, cache = scene.cameras.length; index < cache; index++) {
            var camera = scene.cameras[index];
            if (camera._waitingParentId) {
                camera.parent = scene.getLastEntryByID(camera._waitingParentId);
                camera._waitingParentId = null;
            }
        }
        for (index = 0, cache = scene.lights.length; index < cache; index++) {
            var light_1 = scene.lights[index];
            if (light_1 && light_1._waitingParentId) {
                light_1.parent = scene.getLastEntryByID(light_1._waitingParentId);
                light_1._waitingParentId = null;
            }
        }
        // Connect parents & children and parse actions and lods
        for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {
            var transformNode = scene.transformNodes[index];
            if (transformNode._waitingParentId) {
                transformNode.parent = scene.getLastEntryByID(transformNode._waitingParentId);
                transformNode._waitingParentId = null;
            }
        }
        for (index = 0, cache = scene.meshes.length; index < cache; index++) {
            var mesh = scene.meshes[index];
            if (mesh._waitingParentId) {
                mesh.parent = scene.getLastEntryByID(mesh._waitingParentId);
                mesh._waitingParentId = null;
            }
            if (mesh._waitingData.lods) {
                loadDetailLevels(scene, mesh);
            }
        }
        // link skeleton transform nodes
        for (index = 0, cache = scene.skeletons.length; index < cache; index++) {
            var skeleton = scene.skeletons[index];
            if (skeleton._hasWaitingData) {
                if (skeleton.bones != null) {
                    skeleton.bones.forEach(function (bone) {
                        if (bone._waitingTransformNodeId) {
                            var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId);
                            if (linkTransformNode) {
                                bone.linkTransformNode(linkTransformNode);
                            }
                            bone._waitingTransformNodeId = null;
                        }
                    });
                }
                skeleton._hasWaitingData = null;
            }
        }
        // freeze world matrix application
        for (index = 0, cache = scene.meshes.length; index < cache; index++) {
            var currentMesh = scene.meshes[index];
            if (currentMesh._waitingData.freezeWorldMatrix) {
                currentMesh.freezeWorldMatrix();
                currentMesh._waitingData.freezeWorldMatrix = null;
            }
            else {
                currentMesh.computeWorldMatrix(true);
            }
        }
        // Lights exclusions / inclusions
        for (index = 0, cache = scene.lights.length; index < cache; index++) {
            var light_2 = scene.lights[index];
            // Excluded check
            if (light_2._excludedMeshesIds.length > 0) {
                for (var excludedIndex = 0; excludedIndex < light_2._excludedMeshesIds.length; excludedIndex++) {
                    var excludedMesh = scene.getMeshByID(light_2._excludedMeshesIds[excludedIndex]);
                    if (excludedMesh) {
                        light_2.excludedMeshes.push(excludedMesh);
                    }
                }
                light_2._excludedMeshesIds = [];
            }
            // Included check
            if (light_2._includedOnlyMeshesIds.length > 0) {
                for (var includedOnlyIndex = 0; includedOnlyIndex < light_2._includedOnlyMeshesIds.length; includedOnlyIndex++) {
                    var includedOnlyMesh = scene.getMeshByID(light_2._includedOnlyMeshesIds[includedOnlyIndex]);
                    if (includedOnlyMesh) {
                        light_2.includedOnlyMeshes.push(includedOnlyMesh);
                    }
                }
                light_2._includedOnlyMeshesIds = [];
            }
        }
        AbstractScene.Parse(parsedData, scene, container, rootUrl);
        // Actions (scene) Done last as it can access other objects.
        for (index = 0, cache = scene.meshes.length; index < cache; index++) {
            var mesh = scene.meshes[index];
            if (mesh._waitingData.actions) {
                ActionManager.Parse(mesh._waitingData.actions, mesh, scene);
                mesh._waitingData.actions = null;
            }
        }
        if (parsedData.actions !== undefined && parsedData.actions !== null) {
            ActionManager.Parse(parsedData.actions, null, scene);
        }
        if (!addToScene) {
            container.removeAllFromScene();
        }
    }
    catch (err) {
        var msg = logOperation("loadAssets", parsedData ? parsedData.producer : "Unknown") + log;
        if (onError) {
            onError(msg, err);
        }
        else {
            Logger.Log(msg);
            throw err;
        }
    }
    finally {
        if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
            Logger.Log(logOperation("loadAssets", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
        }
    }
    return container;
};
SceneLoader.RegisterPlugin({
    name: "babylon.js",
    extensions: ".babylon",
    canDirectLoad: function (data) {
        if (data.indexOf("babylon") !== -1) { // We consider that the producer string is filled
            return true;
        }
        return false;
    },
    importMesh: function (meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) {
        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details
        // when SceneLoader.debugLogging = true (default), or exception encountered.
        // Everything stored in var log instead of writing separate lines to support only writing in exception,
        // and avoid problems with multiple concurrent .babylon loads.
        var log = "importMesh has failed JSON parse";
        try {
            var parsedData = JSON.parse(data);
            log = "";
            var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;
            if (!meshesNames) {
                meshesNames = null;
            }
            else if (!Array.isArray(meshesNames)) {
                meshesNames = [meshesNames];
            }
            var hierarchyIds = new Array();
            if (parsedData.meshes !== undefined && parsedData.meshes !== null) {
                var loadedSkeletonsIds = [];
                var loadedMaterialsIds = [];
                var index;
                var cache;
                for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {
                    var parsedMesh = parsedData.meshes[index];
                    if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {
                        if (meshesNames !== null) {
                            // Remove found mesh name from list.
                            delete meshesNames[meshesNames.indexOf(parsedMesh.name)];
                        }
                        //Geometry?
                        if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {
                            //does the file contain geometries?
                            if (parsedData.geometries !== undefined && parsedData.geometries !== null) {
                                //find the correct geometry and add it to the scene
                                var found = false;
                                ["boxes", "spheres", "cylinders", "toruses", "grounds", "planes", "torusKnots", "vertexData"].forEach(function (geometryType) {
                                    if (found === true || !parsedData.geometries[geometryType] || !(Array.isArray(parsedData.geometries[geometryType]))) {
                                        return;
                                    }
                                    else {
                                        parsedData.geometries[geometryType].forEach(function (parsedGeometryData) {
                                            if (parsedGeometryData.id === parsedMesh.geometryId) {
                                                switch (geometryType) {
                                                    case "vertexData":
                                                        Geometry.Parse(parsedGeometryData, scene, rootUrl);
                                                        break;
                                                }
                                                found = true;
                                            }
                                        });
                                    }
                                });
                                if (found === false) {
                                    Logger.Warn("Geometry not found for mesh " + parsedMesh.id);
                                }
                            }
                        }
                        // Material ?
                        if (parsedMesh.materialId) {
                            var materialFound = (loadedMaterialsIds.indexOf(parsedMesh.materialId) !== -1);
                            if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {
                                for (var multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {
                                    var parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];
                                    if (parsedMultiMaterial.id === parsedMesh.materialId) {
                                        for (var matIndex = 0, matCache = parsedMultiMaterial.materials.length; matIndex < matCache; matIndex++) {
                                            var subMatId = parsedMultiMaterial.materials[matIndex];
                                            loadedMaterialsIds.push(subMatId);
                                            var mat = parseMaterialById(subMatId, parsedData, scene, rootUrl);
                                            if (mat) {
                                                log += "\n\tMaterial " + mat.toString(fullDetails);
                                            }
                                        }
                                        loadedMaterialsIds.push(parsedMultiMaterial.id);
                                        var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);
                                        if (mmat) {
                                            materialFound = true;
                                            log += "\n\tMulti-Material " + mmat.toString(fullDetails);
                                        }
                                        break;
                                    }
                                }
                            }
                            if (materialFound === false) {
                                loadedMaterialsIds.push(parsedMesh.materialId);
                                var mat = parseMaterialById(parsedMesh.materialId, parsedData, scene, rootUrl);
                                if (!mat) {
                                    Logger.Warn("Material not found for mesh " + parsedMesh.id);
                                }
                                else {
                                    log += "\n\tMaterial " + mat.toString(fullDetails);
                                }
                            }
                        }
                        // Skeleton ?
                        if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {
                            var skeletonAlreadyLoaded = (loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1);
                            if (skeletonAlreadyLoaded === false) {
                                for (var skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {
                                    var parsedSkeleton = parsedData.skeletons[skeletonIndex];
                                    if (parsedSkeleton.id === parsedMesh.skeletonId) {
                                        var skeleton = Skeleton.Parse(parsedSkeleton, scene);
                                        skeletons.push(skeleton);
                                        loadedSkeletonsIds.push(parsedSkeleton.id);
                                        log += "\n\tSkeleton " + skeleton.toString(fullDetails);
                                    }
                                }
                            }
                        }
                        // Morph targets ?
                        if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {
                            for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {
                                var managerData = _a[_i];
                                MorphTargetManager.Parse(managerData, scene);
                            }
                        }
                        var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);
                        meshes.push(mesh);
                        log += "\n\tMesh " + mesh.toString(fullDetails);
                    }
                }
                // Connecting parents and lods
                var currentMesh;
                for (index = 0, cache = scene.meshes.length; index < cache; index++) {
                    currentMesh = scene.meshes[index];
                    if (currentMesh._waitingParentId) {
                        currentMesh.parent = scene.getLastEntryByID(currentMesh._waitingParentId);
                        currentMesh._waitingParentId = null;
                    }
                    if (currentMesh._waitingData.lods) {
                        loadDetailLevels(scene, currentMesh);
                    }
                }
                // link skeleton transform nodes
                for (index = 0, cache = scene.skeletons.length; index < cache; index++) {
                    var skeleton = scene.skeletons[index];
                    if (skeleton._hasWaitingData) {
                        if (skeleton.bones != null) {
                            skeleton.bones.forEach(function (bone) {
                                if (bone._waitingTransformNodeId) {
                                    var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId);
                                    if (linkTransformNode) {
                                        bone.linkTransformNode(linkTransformNode);
                                    }
                                    bone._waitingTransformNodeId = null;
                                }
                            });
                        }
                        skeleton._hasWaitingData = null;
                    }
                }
                // freeze and compute world matrix application
                for (index = 0, cache = scene.meshes.length; index < cache; index++) {
                    currentMesh = scene.meshes[index];
                    if (currentMesh._waitingData.freezeWorldMatrix) {
                        currentMesh.freezeWorldMatrix();
                        currentMesh._waitingData.freezeWorldMatrix = null;
                    }
                    else {
                        currentMesh.computeWorldMatrix(true);
                    }
                }
            }
            // Particles
            if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {
                var parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);
                if (parser) {
                    for (index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {
                        var parsedParticleSystem = parsedData.particleSystems[index];
                        if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {
                            particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));
                        }
                    }
                }
            }
            return true;
        }
        catch (err) {
            var msg = logOperation("importMesh", parsedData ? parsedData.producer : "Unknown") + log;
            if (onError) {
                onError(msg, err);
            }
            else {
                Logger.Log(msg);
                throw err;
            }
        }
        finally {
            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
                Logger.Log(logOperation("importMesh", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
            }
        }
        return false;
    },
    load: function (scene, data, rootUrl, onError) {
        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details
        // when SceneLoader.debugLogging = true (default), or exception encountered.
        // Everything stored in var log instead of writing separate lines to support only writing in exception,
        // and avoid problems with multiple concurrent .babylon loads.
        var log = "importScene has failed JSON parse";
        try {
            var parsedData = JSON.parse(data);
            log = "";
            // Scene
            if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {
                scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;
            }
            if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {
                scene.autoClear = parsedData.autoClear;
            }
            if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {
                scene.clearColor = Color4.FromArray(parsedData.clearColor);
            }
            if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {
                scene.ambientColor = Color3.FromArray(parsedData.ambientColor);
            }
            if (parsedData.gravity !== undefined && parsedData.gravity !== null) {
                scene.gravity = Vector3.FromArray(parsedData.gravity);
            }
            // Fog
            if (parsedData.fogMode && parsedData.fogMode !== 0) {
                scene.fogMode = parsedData.fogMode;
                scene.fogColor = Color3.FromArray(parsedData.fogColor);
                scene.fogStart = parsedData.fogStart;
                scene.fogEnd = parsedData.fogEnd;
                scene.fogDensity = parsedData.fogDensity;
                log += "\tFog mode for scene:  ";
                switch (scene.fogMode) {
                    // getters not compiling, so using hardcoded
                    case 1:
                        log += "exp\n";
                        break;
                    case 2:
                        log += "exp2\n";
                        break;
                    case 3:
                        log += "linear\n";
                        break;
                }
            }
            //Physics
            if (parsedData.physicsEnabled) {
                var physicsPlugin;
                if (parsedData.physicsEngine === "cannon") {
                    physicsPlugin = new CannonJSPlugin();
                }
                else if (parsedData.physicsEngine === "oimo") {
                    physicsPlugin = new OimoJSPlugin();
                }
                else if (parsedData.physicsEngine === "ammo") {
                    physicsPlugin = new AmmoJSPlugin();
                }
                log = "\tPhysics engine " + (parsedData.physicsEngine ? parsedData.physicsEngine : "oimo") + " enabled\n";
                //else - default engine, which is currently oimo
                var physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;
                scene.enablePhysics(physicsGravity, physicsPlugin);
            }
            // Metadata
            if (parsedData.metadata !== undefined && parsedData.metadata !== null) {
                scene.metadata = parsedData.metadata;
            }
            //collisions, if defined. otherwise, default is true
            if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {
                scene.collisionsEnabled = parsedData.collisionsEnabled;
            }
            var container = loadAssetContainer(scene, data, rootUrl, onError, true);
            if (!container) {
                return false;
            }
            if (parsedData.autoAnimate) {
                scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);
            }
            if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {
                scene.setActiveCameraByID(parsedData.activeCameraID);
            }
            // Environment texture
            if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {
                // PBR needed for both HDR texture (gamma space) & a sky box
                var isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;
                if (parsedData.environmentTextureType && parsedData.environmentTextureType === "BABYLON.HDRCubeTexture") {
                    var hdrSize = (parsedData.environmentTextureSize) ? parsedData.environmentTextureSize : 128;
                    var hdrTexture = new HDRCubeTexture(rootUrl + parsedData.environmentTexture, scene, hdrSize, true, !isPBR);
                    if (parsedData.environmentTextureRotationY) {
                        hdrTexture.rotationY = parsedData.environmentTextureRotationY;
                    }
                    scene.environmentTexture = hdrTexture;
                }
                else {
                    if (Tools.EndsWith(parsedData.environmentTexture, ".env")) {
                        var compressedTexture = new CubeTexture(rootUrl + parsedData.environmentTexture, scene);
                        if (parsedData.environmentTextureRotationY) {
                            compressedTexture.rotationY = parsedData.environmentTextureRotationY;
                        }
                        scene.environmentTexture = compressedTexture;
                    }
                    else {
                        var cubeTexture = CubeTexture.CreateFromPrefilteredData(rootUrl + parsedData.environmentTexture, scene);
                        if (parsedData.environmentTextureRotationY) {
                            cubeTexture.rotationY = parsedData.environmentTextureRotationY;
                        }
                        scene.environmentTexture = cubeTexture;
                    }
                }
                if (parsedData.createDefaultSkybox === true) {
                    var skyboxScale = (scene.activeCamera !== undefined && scene.activeCamera !== null) ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;
                    var skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;
                    scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);
                }
            }
            // Finish
            return true;
        }
        catch (err) {
            var msg = logOperation("importScene", parsedData ? parsedData.producer : "Unknown") + log;
            if (onError) {
                onError(msg, err);
            }
            else {
                Logger.Log(msg);
                throw err;
            }
        }
        finally {
            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
                Logger.Log(logOperation("importScene", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
            }
        }
        return false;
    },
    loadAssetContainer: function (scene, data, rootUrl, onError) {
        var container = loadAssetContainer(scene, data, rootUrl, onError);
        return container;
    }
});

/**
 * This represents all the required information to add a fresnel effect on a material:
 * @see http://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
 */
var FresnelParameters = /** @class */ (function () {
    function FresnelParameters() {
        this._isEnabled = true;
        /**
         * Define the color used on edges (grazing angle)
         */
        this.leftColor = Color3.White();
        /**
         * Define the color used on center
         */
        this.rightColor = Color3.Black();
        /**
         * Define bias applied to computed fresnel term
         */
        this.bias = 0;
        /**
         * Defined the power exponent applied to fresnel term
         */
        this.power = 1;
    }
    Object.defineProperty(FresnelParameters.prototype, "isEnabled", {
        /**
         * Define if the fresnel effect is enable or not.
         */
        get: function () {
            return this._isEnabled;
        },
        set: function (value) {
            if (this._isEnabled === value) {
                return;
            }
            this._isEnabled = value;
            Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_FresnelDirtyFlag | Constants.MATERIAL_MiscDirtyFlag);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the current fresnel and its valuues
     * @returns a clone fresnel configuration
     */
    FresnelParameters.prototype.clone = function () {
        var newFresnelParameters = new FresnelParameters();
        DeepCopier.DeepCopy(this, newFresnelParameters);
        return newFresnelParameters;
    };
    /**
     * Serializes the current fresnel parameters to a JSON representation.
     * @return the JSON serialization
     */
    FresnelParameters.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.isEnabled = this.isEnabled;
        serializationObject.leftColor = this.leftColor.asArray();
        serializationObject.rightColor = this.rightColor.asArray();
        serializationObject.bias = this.bias;
        serializationObject.power = this.power;
        return serializationObject;
    };
    /**
     * Parse a JSON object and deserialize it to a new Fresnel parameter object.
     * @param parsedFresnelParameters Define the JSON representation
     * @returns the parsed parameters
     */
    FresnelParameters.Parse = function (parsedFresnelParameters) {
        var fresnelParameters = new FresnelParameters();
        fresnelParameters.isEnabled = parsedFresnelParameters.isEnabled;
        fresnelParameters.leftColor = Color3.FromArray(parsedFresnelParameters.leftColor);
        fresnelParameters.rightColor = Color3.FromArray(parsedFresnelParameters.rightColor);
        fresnelParameters.bias = parsedFresnelParameters.bias;
        fresnelParameters.power = parsedFresnelParameters.power || 1.0;
        return fresnelParameters;
    };
    return FresnelParameters;
}());
// References the dependencies.
SerializationHelper._FresnelParametersParser = FresnelParameters.Parse;

/**
 * The Physically based simple base material of BJS.
 *
 * This enables better naming and convention enforcements on top of the pbrMaterial.
 * It is used as the base class for both the specGloss and metalRough conventions.
 */
var PBRBaseSimpleMaterial = /** @class */ (function (_super) {
    __extends(PBRBaseSimpleMaterial, _super);
    /**
     * Instantiates a new PBRMaterial instance.
     *
     * @param name The material name
     * @param scene The scene the material will be use in.
     */
    function PBRBaseSimpleMaterial(name, scene) {
        var _this = _super.call(this, name, scene) || this;
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        _this.maxSimultaneousLights = 4;
        /**
         * If sets to true, disables all the lights affecting the material.
         */
        _this.disableLighting = false;
        /**
         * If sets to true, x component of normal map value will invert (x = 1.0 - x).
         */
        _this.invertNormalMapX = false;
        /**
         * If sets to true, y component of normal map value will invert (y = 1.0 - y).
         */
        _this.invertNormalMapY = false;
        /**
         * Emissivie color used to self-illuminate the model.
         */
        _this.emissiveColor = new Color3(0, 0, 0);
        /**
         * Occlusion Channel Strenght.
         */
        _this.occlusionStrength = 1.0;
        /**
         * If true, the light map contains occlusion information instead of lighting info.
         */
        _this.useLightmapAsShadowmap = false;
        _this._useAlphaFromAlbedoTexture = true;
        _this._useAmbientInGrayScale = true;
        return _this;
    }
    Object.defineProperty(PBRBaseSimpleMaterial.prototype, "doubleSided", {
        /**
         * Gets the current double sided mode.
         */
        get: function () {
            return this._twoSidedLighting;
        },
        /**
         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
         */
        set: function (value) {
            if (this._twoSidedLighting === value) {
                return;
            }
            this._twoSidedLighting = value;
            this.backFaceCulling = !value;
            this._markAllSubMeshesAsTexturesDirty();
        },
        enumerable: true,
        configurable: true
    });
    PBRBaseSimpleMaterial.prototype.getClassName = function () {
        return "PBRBaseSimpleMaterial";
    };
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], PBRBaseSimpleMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], PBRBaseSimpleMaterial.prototype, "disableLighting", void 0);
    __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_reflectionTexture")
    ], PBRBaseSimpleMaterial.prototype, "environmentTexture", void 0);
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRBaseSimpleMaterial.prototype, "invertNormalMapX", void 0);
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRBaseSimpleMaterial.prototype, "invertNormalMapY", void 0);
    __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_bumpTexture")
    ], PBRBaseSimpleMaterial.prototype, "normalTexture", void 0);
    __decorate([
        serializeAsColor3("emissive"),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRBaseSimpleMaterial.prototype, "emissiveColor", void 0);
    __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRBaseSimpleMaterial.prototype, "emissiveTexture", void 0);
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_ambientTextureStrength")
    ], PBRBaseSimpleMaterial.prototype, "occlusionStrength", void 0);
    __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_ambientTexture")
    ], PBRBaseSimpleMaterial.prototype, "occlusionTexture", void 0);
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_alphaCutOff")
    ], PBRBaseSimpleMaterial.prototype, "alphaCutOff", void 0);
    __decorate([
        serialize()
    ], PBRBaseSimpleMaterial.prototype, "doubleSided", null);
    __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
    ], PBRBaseSimpleMaterial.prototype, "lightmapTexture", void 0);
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRBaseSimpleMaterial.prototype, "useLightmapAsShadowmap", void 0);
    return PBRBaseSimpleMaterial;
}(PBRBaseMaterial));

/**
 * The PBR material of BJS following the metal roughness convention.
 *
 * This fits to the PBR convention in the GLTF definition:
 * https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0
 */
var PBRMetallicRoughnessMaterial = /** @class */ (function (_super) {
    __extends(PBRMetallicRoughnessMaterial, _super);
    /**
     * Instantiates a new PBRMetalRoughnessMaterial instance.
     *
     * @param name The material name
     * @param scene The scene the material will be use in.
     */
    function PBRMetallicRoughnessMaterial(name, scene) {
        var _this = _super.call(this, name, scene) || this;
        _this._useRoughnessFromMetallicTextureAlpha = false;
        _this._useRoughnessFromMetallicTextureGreen = true;
        _this._useMetallnessFromMetallicTextureBlue = true;
        _this.metallic = 1.0;
        _this.roughness = 1.0;
        return _this;
    }
    /**
     * Return the currrent class name of the material.
     */
    PBRMetallicRoughnessMaterial.prototype.getClassName = function () {
        return "PBRMetallicRoughnessMaterial";
    };
    /**
     * Makes a duplicate of the current material.
     * @param name - name to use for the new material.
     */
    PBRMetallicRoughnessMaterial.prototype.clone = function (name) {
        var _this = this;
        var clone = SerializationHelper.Clone(function () { return new PBRMetallicRoughnessMaterial(name, _this.getScene()); }, this);
        clone.id = name;
        clone.name = name;
        this.clearCoat.copyTo(clone.clearCoat);
        this.anisotropy.copyTo(clone.anisotropy);
        this.brdf.copyTo(clone.brdf);
        this.sheen.copyTo(clone.sheen);
        return clone;
    };
    /**
     * Serialize the material to a parsable JSON object.
     */
    PBRMetallicRoughnessMaterial.prototype.serialize = function () {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "BABYLON.PBRMetallicRoughnessMaterial";
        serializationObject.clearCoat = this.clearCoat.serialize();
        serializationObject.anisotropy = this.anisotropy.serialize();
        serializationObject.brdf = this.brdf.serialize();
        serializationObject.sheen = this.sheen.serialize();
        return serializationObject;
    };
    /**
     * Parses a JSON object correponding to the serialize function.
     */
    PBRMetallicRoughnessMaterial.Parse = function (source, scene, rootUrl) {
        var material = SerializationHelper.Parse(function () { return new PBRMetallicRoughnessMaterial(source.name, scene); }, source, scene, rootUrl);
        if (source.clearCoat) {
            material.clearCoat.parse(source.clearCoat);
        }
        if (source.anisotropy) {
            material.anisotropy.parse(source.anisotropy);
        }
        if (source.brdf) {
            material.brdf.parse(source.brdf);
        }
        if (source.sheen) {
            material.sheen.parse(source.brdf);
        }
        return material;
    };
    __decorate([
        serializeAsColor3(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoColor")
    ], PBRMetallicRoughnessMaterial.prototype, "baseColor", void 0);
    __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoTexture")
    ], PBRMetallicRoughnessMaterial.prototype, "baseTexture", void 0);
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMetallicRoughnessMaterial.prototype, "metallic", void 0);
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMetallicRoughnessMaterial.prototype, "roughness", void 0);
    __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_metallicTexture")
    ], PBRMetallicRoughnessMaterial.prototype, "metallicRoughnessTexture", void 0);
    return PBRMetallicRoughnessMaterial;
}(PBRBaseSimpleMaterial));
_TypeStore.RegisteredTypes["BABYLON.PBRMetallicRoughnessMaterial"] = PBRMetallicRoughnessMaterial;

/**
 * The PBR material of BJS following the specular glossiness convention.
 *
 * This fits to the PBR convention in the GLTF definition:
 * https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
 */
var PBRSpecularGlossinessMaterial = /** @class */ (function (_super) {
    __extends(PBRSpecularGlossinessMaterial, _super);
    /**
     * Instantiates a new PBRSpecularGlossinessMaterial instance.
     *
     * @param name The material name
     * @param scene The scene the material will be use in.
     */
    function PBRSpecularGlossinessMaterial(name, scene) {
        var _this = _super.call(this, name, scene) || this;
        _this._useMicroSurfaceFromReflectivityMapAlpha = true;
        return _this;
    }
    /**
     * Return the currrent class name of the material.
     */
    PBRSpecularGlossinessMaterial.prototype.getClassName = function () {
        return "PBRSpecularGlossinessMaterial";
    };
    /**
     * Makes a duplicate of the current material.
     * @param name - name to use for the new material.
     */
    PBRSpecularGlossinessMaterial.prototype.clone = function (name) {
        var _this = this;
        var clone = SerializationHelper.Clone(function () { return new PBRSpecularGlossinessMaterial(name, _this.getScene()); }, this);
        clone.id = name;
        clone.name = name;
        this.clearCoat.copyTo(clone.clearCoat);
        this.anisotropy.copyTo(clone.anisotropy);
        this.brdf.copyTo(clone.brdf);
        this.sheen.copyTo(clone.sheen);
        return clone;
    };
    /**
     * Serialize the material to a parsable JSON object.
     */
    PBRSpecularGlossinessMaterial.prototype.serialize = function () {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "BABYLON.PBRSpecularGlossinessMaterial";
        serializationObject.clearCoat = this.clearCoat.serialize();
        serializationObject.anisotropy = this.anisotropy.serialize();
        serializationObject.brdf = this.brdf.serialize();
        serializationObject.sheen = this.sheen.serialize();
        return serializationObject;
    };
    /**
     * Parses a JSON object correponding to the serialize function.
     */
    PBRSpecularGlossinessMaterial.Parse = function (source, scene, rootUrl) {
        var material = SerializationHelper.Parse(function () { return new PBRSpecularGlossinessMaterial(source.name, scene); }, source, scene, rootUrl);
        if (source.clearCoat) {
            material.clearCoat.parse(source.clearCoat);
        }
        if (source.anisotropy) {
            material.anisotropy.parse(source.anisotropy);
        }
        if (source.brdf) {
            material.brdf.parse(source.brdf);
        }
        if (source.sheen) {
            material.sheen.parse(source.brdf);
        }
        return material;
    };
    __decorate([
        serializeAsColor3("diffuse"),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoColor")
    ], PBRSpecularGlossinessMaterial.prototype, "diffuseColor", void 0);
    __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_albedoTexture")
    ], PBRSpecularGlossinessMaterial.prototype, "diffuseTexture", void 0);
    __decorate([
        serializeAsColor3("specular"),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_reflectivityColor")
    ], PBRSpecularGlossinessMaterial.prototype, "specularColor", void 0);
    __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_microSurface")
    ], PBRSpecularGlossinessMaterial.prototype, "glossiness", void 0);
    __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", "_reflectivityTexture")
    ], PBRSpecularGlossinessMaterial.prototype, "specularGlossinessTexture", void 0);
    return PBRSpecularGlossinessMaterial;
}(PBRBaseSimpleMaterial));
_TypeStore.RegisteredTypes["BABYLON.PBRSpecularGlossinessMaterial"] = PBRSpecularGlossinessMaterial;

/**
 * This represents a color grading texture. This acts as a lookup table LUT, useful during post process
 * It can help converting any input color in a desired output one. This can then be used to create effects
 * from sepia, black and white to sixties or futuristic rendering...
 *
 * The only supported format is currently 3dl.
 * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table
 */
var ColorGradingTexture = /** @class */ (function (_super) {
    __extends(ColorGradingTexture, _super);
    /**
     * Instantiates a ColorGradingTexture from the following parameters.
     *
     * @param url The location of the color gradind data (currently only supporting 3dl)
     * @param scene The scene the texture will be used in
     */
    function ColorGradingTexture(url, scene) {
        var _this = _super.call(this, scene) || this;
        if (!url) {
            return _this;
        }
        _this._engine = scene.getEngine();
        _this._textureMatrix = Matrix.Identity();
        _this.name = url;
        _this.url = url;
        _this.hasAlpha = false;
        _this.isCube = false;
        _this.is3D = _this._engine.webGLVersion > 1;
        _this.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;
        _this.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;
        _this.wrapR = Constants.TEXTURE_CLAMP_ADDRESSMODE;
        _this.anisotropicFilteringLevel = 1;
        _this._texture = _this._getFromCache(url, true);
        if (!_this._texture) {
            if (!scene.useDelayedTextureLoading) {
                _this.loadTexture();
            }
            else {
                _this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;
            }
        }
        return _this;
    }
    /**
     * Returns the texture matrix used in most of the material.
     * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).
     */
    ColorGradingTexture.prototype.getTextureMatrix = function () {
        return this._textureMatrix;
    };
    /**
     * Occurs when the file being loaded is a .3dl LUT file.
     */
    ColorGradingTexture.prototype.load3dlTexture = function () {
        var engine = this._engine;
        var texture;
        if (engine.webGLVersion === 1) {
            texture = engine.createRawTexture(null, 1, 1, Constants.TEXTUREFORMAT_RGBA, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE);
        }
        else {
            texture = engine.createRawTexture3D(null, 1, 1, 1, Constants.TEXTUREFORMAT_RGBA, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE);
        }
        this._texture = texture;
        var callback = function (text) {
            if (typeof text !== "string") {
                return;
            }
            var data = null;
            var tempData = null;
            var line;
            var lines = text.split('\n');
            var size = 0, pixelIndexW = 0, pixelIndexH = 0, pixelIndexSlice = 0;
            var maxColor = 0;
            for (var i = 0; i < lines.length; i++) {
                line = lines[i];
                if (!ColorGradingTexture._noneEmptyLineRegex.test(line)) {
                    continue;
                }
                if (line.indexOf('#') === 0) {
                    continue;
                }
                var words = line.split(" ");
                if (size === 0) {
                    // Number of space + one
                    size = words.length;
                    data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8
                    tempData = new Float32Array(size * size * size * 4);
                    continue;
                }
                if (size != 0) {
                    var r = Math.max(parseInt(words[0]), 0);
                    var g = Math.max(parseInt(words[1]), 0);
                    var b = Math.max(parseInt(words[2]), 0);
                    maxColor = Math.max(r, maxColor);
                    maxColor = Math.max(g, maxColor);
                    maxColor = Math.max(b, maxColor);
                    var pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;
                    if (tempData) {
                        tempData[pixelStorageIndex + 0] = r;
                        tempData[pixelStorageIndex + 1] = g;
                        tempData[pixelStorageIndex + 2] = b;
                    }
                    // Keep for reference in case of back compat problems.
                    // pixelIndexSlice++;
                    // if (pixelIndexSlice % size == 0) {
                    //     pixelIndexH++;
                    //     pixelIndexSlice = 0;
                    //     if (pixelIndexH % size == 0) {
                    //         pixelIndexW++;
                    //         pixelIndexH = 0;
                    //     }
                    // }
                    pixelIndexH++;
                    if (pixelIndexH % size == 0) {
                        pixelIndexSlice++;
                        pixelIndexH = 0;
                        if (pixelIndexSlice % size == 0) {
                            pixelIndexW++;
                            pixelIndexSlice = 0;
                        }
                    }
                }
            }
            if (tempData && data) {
                for (var i = 0; i < tempData.length; i++) {
                    if (i > 0 && (i + 1) % 4 === 0) {
                        data[i] = 255;
                    }
                    else {
                        var value = tempData[i];
                        data[i] = (value / maxColor * 255);
                    }
                }
            }
            if (texture.is3D) {
                texture.updateSize(size, size, size);
                engine.updateRawTexture3D(texture, data, Constants.TEXTUREFORMAT_RGBA, false);
            }
            else {
                texture.updateSize(size * size, size);
                engine.updateRawTexture(texture, data, Constants.TEXTUREFORMAT_RGBA, false);
            }
        };
        var scene = this.getScene();
        if (scene) {
            scene._loadFile(this.url, callback);
        }
        else {
            this._engine._loadFile(this.url, callback);
        }
        return this._texture;
    };
    /**
     * Starts the loading process of the texture.
     */
    ColorGradingTexture.prototype.loadTexture = function () {
        if (this.url && this.url.toLocaleLowerCase().indexOf(".3dl") == (this.url.length - 4)) {
            this.load3dlTexture();
        }
    };
    /**
     * Clones the color gradind texture.
     */
    ColorGradingTexture.prototype.clone = function () {
        var newTexture = new ColorGradingTexture(this.url, this.getScene());
        // Base texture
        newTexture.level = this.level;
        return newTexture;
    };
    /**
     * Called during delayed load for textures.
     */
    ColorGradingTexture.prototype.delayLoad = function () {
        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {
            return;
        }
        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;
        this._texture = this._getFromCache(this.url, true);
        if (!this._texture) {
            this.loadTexture();
        }
    };
    /**
     * Parses a color grading texture serialized by Babylon.
     * @param parsedTexture The texture information being parsedTexture
     * @param scene The scene to load the texture in
     * @param rootUrl The root url of the data assets to load
     * @return A color gradind texture
     */
    ColorGradingTexture.Parse = function (parsedTexture, scene) {
        var texture = null;
        if (parsedTexture.name && !parsedTexture.isRenderTarget) {
            texture = new ColorGradingTexture(parsedTexture.name, scene);
            texture.name = parsedTexture.name;
            texture.level = parsedTexture.level;
        }
        return texture;
    };
    /**
     * Serializes the LUT texture to json format.
     */
    ColorGradingTexture.prototype.serialize = function () {
        if (!this.name) {
            return null;
        }
        var serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.level = this.level;
        serializationObject.customType = "BABYLON.ColorGradingTexture";
        return serializationObject;
    };
    /**
     * Empty line regex stored for GC.
     */
    ColorGradingTexture._noneEmptyLineRegex = /\S+/;
    return ColorGradingTexture;
}(BaseTexture));
_TypeStore.RegisteredTypes["BABYLON.ColorGradingTexture"] = ColorGradingTexture;

/**
 * This represents a texture coming from an equirectangular image supported by the web browser canvas.
 */
var EquiRectangularCubeTexture = /** @class */ (function (_super) {
    __extends(EquiRectangularCubeTexture, _super);
    /**
     * Instantiates an EquiRectangularCubeTexture from the following parameters.
     * @param url The location of the image
     * @param scene The scene the texture will be used in
     * @param size The cubemap desired size (the more it increases the longer the generation will be)
     * @param noMipmap Forces to not generate the mipmap if true
     * @param gammaSpace Specifies if the texture will be used in gamma or linear space
     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)
     * @param onLoad  defines a callback called when texture is loaded
     * @param onError  defines a callback called if there is an error
     */
    function EquiRectangularCubeTexture(url, scene, size, noMipmap, gammaSpace, onLoad, onError) {
        if (noMipmap === void 0) { noMipmap = false; }
        if (gammaSpace === void 0) { gammaSpace = true; }
        if (onLoad === void 0) { onLoad = null; }
        if (onError === void 0) { onError = null; }
        var _this = _super.call(this, scene) || this;
        _this._onLoad = null;
        _this._onError = null;
        /** The texture coordinates mode. As this texture is stored in a cube format, please modify carefully. */
        _this.coordinatesMode = Texture.CUBIC_MODE;
        if (!url) {
            throw new Error('Image url is not set');
        }
        _this.name = url;
        _this.url = url;
        _this._size = size;
        _this._noMipmap = noMipmap;
        _this.gammaSpace = gammaSpace;
        _this._onLoad = onLoad;
        _this._onError = onError;
        _this.hasAlpha = false;
        _this.isCube = true;
        _this._texture = _this._getFromCache(url, _this._noMipmap);
        if (!_this._texture) {
            if (!scene.useDelayedTextureLoading) {
                _this.loadImage(_this.loadTexture.bind(_this), _this._onError);
            }
            else {
                _this.delayLoadState = Engine.DELAYLOADSTATE_NOTLOADED;
            }
        }
        else if (onLoad) {
            if (_this._texture.isReady) {
                Tools.SetImmediate(function () { return onLoad(); });
            }
            else {
                _this._texture.onLoadedObservable.add(onLoad);
            }
        }
        return _this;
    }
    /**
     * Load the image data, by putting the image on a canvas and extracting its buffer.
     */
    EquiRectangularCubeTexture.prototype.loadImage = function (loadTextureCallback, onError) {
        var _this = this;
        var canvas = document.createElement('canvas');
        var image = new Image();
        image.addEventListener('load', function () {
            _this._width = image.width;
            _this._height = image.height;
            canvas.width = _this._width;
            canvas.height = _this._height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0);
            var imageData = ctx.getImageData(0, 0, image.width, image.height);
            _this._buffer = imageData.data.buffer;
            canvas.remove();
            loadTextureCallback();
        });
        image.addEventListener('error', function (error) {
            if (onError) {
                onError(_this.getClassName() + " could not be loaded", error);
            }
        });
        image.src = this.url;
    };
    /**
     * Convert the image buffer into a cubemap and create a CubeTexture.
     */
    EquiRectangularCubeTexture.prototype.loadTexture = function () {
        var _this = this;
        var scene = this.getScene();
        var callback = function () {
            var imageData = _this.getFloat32ArrayFromArrayBuffer(_this._buffer);
            // Extract the raw linear data.
            var data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, _this._width, _this._height, _this._size);
            var results = [];
            // Push each faces.
            for (var i = 0; i < 6; i++) {
                var dataFace = data[EquiRectangularCubeTexture._FacesMapping[i]];
                results.push(dataFace);
            }
            return results;
        };
        if (!scene) {
            return;
        }
        this._texture = scene
            .getEngine()
            .createRawCubeTextureFromUrl(this.url, scene, this._size, Engine.TEXTUREFORMAT_RGB, scene.getEngine().getCaps().textureFloat
            ? Engine.TEXTURETYPE_FLOAT
            : Engine.TEXTURETYPE_UNSIGNED_INTEGER, this._noMipmap, callback, null, this._onLoad, this._onError);
    };
    /**
     * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.
     * @param buffer The ArrayBuffer that should be converted.
     * @returns The buffer as Float32Array.
     */
    EquiRectangularCubeTexture.prototype.getFloat32ArrayFromArrayBuffer = function (buffer) {
        var dataView = new DataView(buffer);
        var floatImageData = new Float32Array((buffer.byteLength * 3) / 4);
        var k = 0;
        for (var i = 0; i < buffer.byteLength; i++) {
            // We drop the transparency channel, because we do not need/want it
            if ((i + 1) % 4 !== 0) {
                floatImageData[k++] = dataView.getUint8(i) / 255;
            }
        }
        return floatImageData;
    };
    /**
     * Get the current class name of the texture useful for serialization or dynamic coding.
     * @returns "EquiRectangularCubeTexture"
     */
    EquiRectangularCubeTexture.prototype.getClassName = function () {
        return "EquiRectangularCubeTexture";
    };
    /**
     * Create a clone of the current EquiRectangularCubeTexture and return it.
     * @returns A clone of the current EquiRectangularCubeTexture.
     */
    EquiRectangularCubeTexture.prototype.clone = function () {
        var scene = this.getScene();
        if (!scene) {
            return this;
        }
        var newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);
        // Base texture
        newTexture.level = this.level;
        newTexture.wrapU = this.wrapU;
        newTexture.wrapV = this.wrapV;
        newTexture.coordinatesIndex = this.coordinatesIndex;
        newTexture.coordinatesMode = this.coordinatesMode;
        return newTexture;
    };
    /** The six faces of the cube. */
    EquiRectangularCubeTexture._FacesMapping = ['right', 'left', 'up', 'down', 'front', 'back'];
    return EquiRectangularCubeTexture;
}(BaseTexture));

/**
 * Based on jsTGALoader - Javascript loader for TGA file
 * By Vincent Thibault
 * @see http://blog.robrowser.com/javascript-tga-loader.html
 */
var TGATools = /** @class */ (function () {
    function TGATools() {
    }
    /**
     * Gets the header of a TGA file
     * @param data defines the TGA data
     * @returns the header
     */
    TGATools.GetTGAHeader = function (data) {
        var offset = 0;
        var header = {
            id_length: data[offset++],
            colormap_type: data[offset++],
            image_type: data[offset++],
            colormap_index: data[offset++] | data[offset++] << 8,
            colormap_length: data[offset++] | data[offset++] << 8,
            colormap_size: data[offset++],
            origin: [
                data[offset++] | data[offset++] << 8,
                data[offset++] | data[offset++] << 8
            ],
            width: data[offset++] | data[offset++] << 8,
            height: data[offset++] | data[offset++] << 8,
            pixel_size: data[offset++],
            flags: data[offset++]
        };
        return header;
    };
    /**
     * Uploads TGA content to a Babylon Texture
     * @hidden
     */
    TGATools.UploadContent = function (texture, data) {
        // Not enough data to contain header ?
        if (data.length < 19) {
            Logger.Error("Unable to load TGA file - Not enough data to contain header");
            return;
        }
        // Read Header
        var offset = 18;
        var header = TGATools.GetTGAHeader(data);
        // Assume it's a valid Targa file.
        if (header.id_length + offset > data.length) {
            Logger.Error("Unable to load TGA file - Not enough data");
            return;
        }
        // Skip not needed data
        offset += header.id_length;
        var use_rle = false;
        var use_pal = false;
        var use_grey = false;
        // Get some informations.
        switch (header.image_type) {
            case TGATools._TYPE_RLE_INDEXED:
                use_rle = true;
            case TGATools._TYPE_INDEXED:
                use_pal = true;
                break;
            case TGATools._TYPE_RLE_RGB:
                use_rle = true;
            case TGATools._TYPE_RGB:
                // use_rgb = true;
                break;
            case TGATools._TYPE_RLE_GREY:
                use_rle = true;
            case TGATools._TYPE_GREY:
                use_grey = true;
                break;
        }
        var pixel_data;
        // var numAlphaBits = header.flags & 0xf;
        var pixel_size = header.pixel_size >> 3;
        var pixel_total = header.width * header.height * pixel_size;
        // Read palettes
        var palettes;
        if (use_pal) {
            palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
        }
        // Read LRE
        if (use_rle) {
            pixel_data = new Uint8Array(pixel_total);
            var c, count, i;
            var localOffset = 0;
            var pixels = new Uint8Array(pixel_size);
            while (offset < pixel_total && localOffset < pixel_total) {
                c = data[offset++];
                count = (c & 0x7f) + 1;
                // RLE pixels
                if (c & 0x80) {
                    // Bind pixel tmp array
                    for (i = 0; i < pixel_size; ++i) {
                        pixels[i] = data[offset++];
                    }
                    // Copy pixel array
                    for (i = 0; i < count; ++i) {
                        pixel_data.set(pixels, localOffset + i * pixel_size);
                    }
                    localOffset += pixel_size * count;
                }
                // Raw pixels
                else {
                    count *= pixel_size;
                    for (i = 0; i < count; ++i) {
                        pixel_data[localOffset + i] = data[offset++];
                    }
                    localOffset += count;
                }
            }
        }
        // RAW Pixels
        else {
            pixel_data = data.subarray(offset, offset += (use_pal ? header.width * header.height : pixel_total));
        }
        // Load to texture
        var x_start, y_start, x_step, y_step, y_end, x_end;
        switch ((header.flags & TGATools._ORIGIN_MASK) >> TGATools._ORIGIN_SHIFT) {
            default:
            case TGATools._ORIGIN_UL:
                x_start = 0;
                x_step = 1;
                x_end = header.width;
                y_start = 0;
                y_step = 1;
                y_end = header.height;
                break;
            case TGATools._ORIGIN_BL:
                x_start = 0;
                x_step = 1;
                x_end = header.width;
                y_start = header.height - 1;
                y_step = -1;
                y_end = -1;
                break;
            case TGATools._ORIGIN_UR:
                x_start = header.width - 1;
                x_step = -1;
                x_end = -1;
                y_start = 0;
                y_step = 1;
                y_end = header.height;
                break;
            case TGATools._ORIGIN_BR:
                x_start = header.width - 1;
                x_step = -1;
                x_end = -1;
                y_start = header.height - 1;
                y_step = -1;
                y_end = -1;
                break;
        }
        // Load the specify method
        var func = '_getImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
        var imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);
        var engine = texture.getEngine();
        engine._uploadDataToTextureDirectly(texture, imageData);
    };
    /** @hidden */
    TGATools._getImageData8bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
        var image = pixel_data, colormap = palettes;
        var width = header.width, height = header.height;
        var color, i = 0, x, y;
        var imageData = new Uint8Array(width * height * 4);
        for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i++) {
                color = image[i];
                imageData[(x + width * y) * 4 + 3] = 255;
                imageData[(x + width * y) * 4 + 2] = colormap[(color * 3) + 0];
                imageData[(x + width * y) * 4 + 1] = colormap[(color * 3) + 1];
                imageData[(x + width * y) * 4 + 0] = colormap[(color * 3) + 2];
            }
        }
        return imageData;
    };
    /** @hidden */
    TGATools._getImageData16bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
        var image = pixel_data;
        var width = header.width, height = header.height;
        var color, i = 0, x, y;
        var imageData = new Uint8Array(width * height * 4);
        for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 2) {
                color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
                var r = (((color & 0x7C00) >> 10) * 255) / 0x1F | 0;
                var g = (((color & 0x03E0) >> 5) * 255) / 0x1F | 0;
                var b = ((color & 0x001F) * 255) / 0x1F | 0;
                imageData[(x + width * y) * 4 + 0] = r;
                imageData[(x + width * y) * 4 + 1] = g;
                imageData[(x + width * y) * 4 + 2] = b;
                imageData[(x + width * y) * 4 + 3] = (color & 0x8000) ? 0 : 255;
            }
        }
        return imageData;
    };
    /** @hidden */
    TGATools._getImageData24bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
        var image = pixel_data;
        var width = header.width, height = header.height;
        var i = 0, x, y;
        var imageData = new Uint8Array(width * height * 4);
        for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 3) {
                imageData[(x + width * y) * 4 + 3] = 255;
                imageData[(x + width * y) * 4 + 2] = image[i + 0];
                imageData[(x + width * y) * 4 + 1] = image[i + 1];
                imageData[(x + width * y) * 4 + 0] = image[i + 2];
            }
        }
        return imageData;
    };
    /** @hidden */
    TGATools._getImageData32bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
        var image = pixel_data;
        var width = header.width, height = header.height;
        var i = 0, x, y;
        var imageData = new Uint8Array(width * height * 4);
        for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 4) {
                imageData[(x + width * y) * 4 + 2] = image[i + 0];
                imageData[(x + width * y) * 4 + 1] = image[i + 1];
                imageData[(x + width * y) * 4 + 0] = image[i + 2];
                imageData[(x + width * y) * 4 + 3] = image[i + 3];
            }
        }
        return imageData;
    };
    /** @hidden */
    TGATools._getImageDataGrey8bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
        var image = pixel_data;
        var width = header.width, height = header.height;
        var color, i = 0, x, y;
        var imageData = new Uint8Array(width * height * 4);
        for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i++) {
                color = image[i];
                imageData[(x + width * y) * 4 + 0] = color;
                imageData[(x + width * y) * 4 + 1] = color;
                imageData[(x + width * y) * 4 + 2] = color;
                imageData[(x + width * y) * 4 + 3] = 255;
            }
        }
        return imageData;
    };
    /** @hidden */
    TGATools._getImageDataGrey16bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
        var image = pixel_data;
        var width = header.width, height = header.height;
        var i = 0, x, y;
        var imageData = new Uint8Array(width * height * 4);
        for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 2) {
                imageData[(x + width * y) * 4 + 0] = image[i + 0];
                imageData[(x + width * y) * 4 + 1] = image[i + 0];
                imageData[(x + width * y) * 4 + 2] = image[i + 0];
                imageData[(x + width * y) * 4 + 3] = image[i + 1];
            }
        }
        return imageData;
    };
    //private static _TYPE_NO_DATA = 0;
    TGATools._TYPE_INDEXED = 1;
    TGATools._TYPE_RGB = 2;
    TGATools._TYPE_GREY = 3;
    TGATools._TYPE_RLE_INDEXED = 9;
    TGATools._TYPE_RLE_RGB = 10;
    TGATools._TYPE_RLE_GREY = 11;
    TGATools._ORIGIN_MASK = 0x30;
    TGATools._ORIGIN_SHIFT = 0x04;
    TGATools._ORIGIN_BL = 0x00;
    TGATools._ORIGIN_BR = 0x01;
    TGATools._ORIGIN_UL = 0x02;
    TGATools._ORIGIN_UR = 0x03;
    return TGATools;
}());

/**
 * Implementation of the TGA Texture Loader.
 * @hidden
 */
var _TGATextureLoader = /** @class */ (function () {
    function _TGATextureLoader() {
        /**
         * Defines wether the loader supports cascade loading the different faces.
         */
        this.supportCascades = false;
    }
    /**
     * This returns if the loader support the current file information.
     * @param extension defines the file extension of the file being loaded
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @param fallback defines the fallback internal texture if any
     * @param isBase64 defines whether the texture is encoded as a base64
     * @param isBuffer defines whether the texture data are stored as a buffer
     * @returns true if the loader can load the specified file
     */
    _TGATextureLoader.prototype.canLoad = function (extension, textureFormatInUse, fallback, isBase64, isBuffer) {
        return extension.indexOf(".tga") === 0;
    };
    /**
     * Transform the url before loading if required.
     * @param rootUrl the url of the texture
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @returns the transformed texture
     */
    _TGATextureLoader.prototype.transformUrl = function (rootUrl, textureFormatInUse) {
        return rootUrl;
    };
    /**
     * Gets the fallback url in case the load fail. This can return null to allow the default fallback mecanism to work
     * @param rootUrl the url of the texture
     * @param textureFormatInUse defines the current compressed format in use iun the engine
     * @returns the fallback texture
     */
    _TGATextureLoader.prototype.getFallbackTextureUrl = function (rootUrl, textureFormatInUse) {
        return null;
    };
    /**
     * Uploads the cube texture data to the WebGl Texture. It has alreday been bound.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param createPolynomials will be true if polynomials have been requested
     * @param onLoad defines the callback to trigger once the texture is ready
     * @param onError defines the callback to trigger in case of error
     */
    _TGATextureLoader.prototype.loadCubeData = function (data, texture, createPolynomials, onLoad, onError) {
        throw ".env not supported in Cube.";
    };
    /**
     * Uploads the 2D texture data to the WebGl Texture. It has alreday been bound once in the callback.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param callback defines the method to call once ready to upload
     */
    _TGATextureLoader.prototype.loadData = function (data, texture, callback) {
        var uintData = new Uint8Array(data);
        var header = TGATools.GetTGAHeader(uintData);
        callback(header.width, header.height, texture.generateMipMaps, false, function () {
            TGATools.UploadContent(texture, uintData);
        });
    };
    return _TGATextureLoader;
}());
// Register the loader.
Engine._TextureLoaders.push(new _TGATextureLoader());

Engine.prototype.unBindMultiColorAttachmentFramebuffer = function (textures, disableGenerateMipMaps, onBeforeUnbind) {
    if (disableGenerateMipMaps === void 0) { disableGenerateMipMaps = false; }
    this._currentRenderTarget = null;
    // If MSAA, we need to bitblt back to main texture
    var gl = this._gl;
    if (textures[0]._MSAAFramebuffer) {
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, textures[0]._MSAAFramebuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, textures[0]._framebuffer);
        var attachments = textures[0]._attachments;
        if (!attachments) {
            attachments = new Array(textures.length);
            textures[0]._attachments = attachments;
        }
        for (var i = 0; i < textures.length; i++) {
            var texture = textures[i];
            for (var j = 0; j < attachments.length; j++) {
                attachments[j] = gl.NONE;
            }
            attachments[i] = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
            gl.readBuffer(attachments[i]);
            gl.drawBuffers(attachments);
            gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
        }
        for (var i = 0; i < attachments.length; i++) {
            attachments[i] = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
        }
        gl.drawBuffers(attachments);
    }
    for (var i = 0; i < textures.length; i++) {
        var texture = textures[i];
        if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {
            this._bindTextureDirectly(gl.TEXTURE_2D, texture);
            gl.generateMipmap(gl.TEXTURE_2D);
            this._bindTextureDirectly(gl.TEXTURE_2D, null);
        }
    }
    if (onBeforeUnbind) {
        if (textures[0]._MSAAFramebuffer) {
            // Bind the correct framebuffer
            this._bindUnboundFramebuffer(textures[0]._framebuffer);
        }
        onBeforeUnbind();
    }
    this._bindUnboundFramebuffer(null);
};
Engine.prototype.createMultipleRenderTarget = function (size, options) {
    var generateMipMaps = false;
    var generateDepthBuffer = true;
    var generateStencilBuffer = false;
    var generateDepthTexture = false;
    var textureCount = 1;
    var defaultType = Engine.TEXTURETYPE_UNSIGNED_INT;
    var defaultSamplingMode = Engine.TEXTURE_TRILINEAR_SAMPLINGMODE;
    var types = new Array();
    var samplingModes = new Array();
    if (options !== undefined) {
        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;
        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;
        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;
        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;
        textureCount = options.textureCount || 1;
        if (options.types) {
            types = options.types;
        }
        if (options.samplingModes) {
            samplingModes = options.samplingModes;
        }
    }
    var gl = this._gl;
    // Create the framebuffer
    var framebuffer = gl.createFramebuffer();
    this._bindUnboundFramebuffer(framebuffer);
    var width = size.width || size;
    var height = size.height || size;
    var textures = [];
    var attachments = [];
    var depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);
    for (var i = 0; i < textureCount; i++) {
        var samplingMode = samplingModes[i] || defaultSamplingMode;
        var type = types[i] || defaultType;
        if (type === Engine.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {
            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE
            samplingMode = Engine.TEXTURE_NEAREST_SAMPLINGMODE;
        }
        else if (type === Engine.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {
            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE
            samplingMode = Engine.TEXTURE_NEAREST_SAMPLINGMODE;
        }
        var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
        if (type === Engine.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {
            type = Engine.TEXTURETYPE_UNSIGNED_INT;
            Logger.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type");
        }
        var texture = new InternalTexture(this, InternalTexture.DATASOURCE_MULTIRENDERTARGET);
        var attachment = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
        textures.push(texture);
        attachments.push(attachment);
        gl.activeTexture(gl["TEXTURE" + i]);
        gl.bindTexture(gl.TEXTURE_2D, texture._webGLTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), width, height, 0, gl.RGBA, this._getWebGLTextureType(type), null);
        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._webGLTexture, 0);
        if (generateMipMaps) {
            this._gl.generateMipmap(this._gl.TEXTURE_2D);
        }
        // Unbind
        this._bindTextureDirectly(gl.TEXTURE_2D, null);
        texture._framebuffer = framebuffer;
        texture._depthStencilBuffer = depthStencilBuffer;
        texture.baseWidth = width;
        texture.baseHeight = height;
        texture.width = width;
        texture.height = height;
        texture.isReady = true;
        texture.samples = 1;
        texture.generateMipMaps = generateMipMaps;
        texture.samplingMode = samplingMode;
        texture.type = type;
        texture._generateDepthBuffer = generateDepthBuffer;
        texture._generateStencilBuffer = generateStencilBuffer;
        texture._attachments = attachments;
        this._internalTexturesCache.push(texture);
    }
    if (generateDepthTexture && this._caps.depthTextureExtension) {
        // Depth texture
        var depthTexture = new InternalTexture(this, InternalTexture.DATASOURCE_MULTIRENDERTARGET);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, depthTexture._webGLTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, this.webGLVersion < 2 ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT16, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._webGLTexture, 0);
        depthTexture._framebuffer = framebuffer;
        depthTexture.baseWidth = width;
        depthTexture.baseHeight = height;
        depthTexture.width = width;
        depthTexture.height = height;
        depthTexture.isReady = true;
        depthTexture.samples = 1;
        depthTexture.generateMipMaps = generateMipMaps;
        depthTexture.samplingMode = gl.NEAREST;
        depthTexture._generateDepthBuffer = generateDepthBuffer;
        depthTexture._generateStencilBuffer = generateStencilBuffer;
        textures.push(depthTexture);
        this._internalTexturesCache.push(depthTexture);
    }
    gl.drawBuffers(attachments);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    this._bindUnboundFramebuffer(null);
    this.resetTextureCache();
    return textures;
};
Engine.prototype.updateMultipleRenderTargetTextureSampleCount = function (textures, samples) {
    if (this.webGLVersion < 2 || !textures || textures.length == 0) {
        return 1;
    }
    if (textures[0].samples === samples) {
        return samples;
    }
    var gl = this._gl;
    samples = Math.min(samples, gl.getParameter(gl.MAX_SAMPLES));
    // Dispose previous render buffers
    if (textures[0]._depthStencilBuffer) {
        gl.deleteRenderbuffer(textures[0]._depthStencilBuffer);
        textures[0]._depthStencilBuffer = null;
    }
    if (textures[0]._MSAAFramebuffer) {
        gl.deleteFramebuffer(textures[0]._MSAAFramebuffer);
        textures[0]._MSAAFramebuffer = null;
    }
    for (var i = 0; i < textures.length; i++) {
        if (textures[i]._MSAARenderBuffer) {
            gl.deleteRenderbuffer(textures[i]._MSAARenderBuffer);
            textures[i]._MSAARenderBuffer = null;
        }
    }
    if (samples > 1) {
        var framebuffer = gl.createFramebuffer();
        if (!framebuffer) {
            throw new Error("Unable to create multi sampled framebuffer");
        }
        this._bindUnboundFramebuffer(framebuffer);
        var depthStencilBuffer = this._setupFramebufferDepthAttachments(textures[0]._generateStencilBuffer, textures[0]._generateDepthBuffer, textures[0].width, textures[0].height, samples);
        var attachments = [];
        for (var i = 0; i < textures.length; i++) {
            var texture = textures[i];
            var attachment = gl[this.webGLVersion > 1 ? "COLOR_ATTACHMENT" + i : "COLOR_ATTACHMENT" + i + "_WEBGL"];
            var colorRenderbuffer = gl.createRenderbuffer();
            if (!colorRenderbuffer) {
                throw new Error("Unable to create multi sampled framebuffer");
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, colorRenderbuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, this._getRGBAMultiSampleBufferFormat(texture.type), texture.width, texture.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, colorRenderbuffer);
            texture._MSAAFramebuffer = framebuffer;
            texture._MSAARenderBuffer = colorRenderbuffer;
            texture.samples = samples;
            texture._depthStencilBuffer = depthStencilBuffer;
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            attachments.push(attachment);
        }
        gl.drawBuffers(attachments);
    }
    else {
        this._bindUnboundFramebuffer(textures[0]._framebuffer);
    }
    this._bindUnboundFramebuffer(null);
    return samples;
};

/**
 * A multi render target, like a render target provides the ability to render to a texture.
 * Unlike the render target, it can render to several draw buffers in one draw.
 * This is specially interesting in deferred rendering or for any effects requiring more than
 * just one color from a single pass.
 */
var MultiRenderTarget = /** @class */ (function (_super) {
    __extends(MultiRenderTarget, _super);
    /**
     * Instantiate a new multi render target texture.
     * A multi render target, like a render target provides the ability to render to a texture.
     * Unlike the render target, it can render to several draw buffers in one draw.
     * This is specially interesting in deferred rendering or for any effects requiring more than
     * just one color from a single pass.
     * @param name Define the name of the texture
     * @param size Define the size of the buffers to render to
     * @param count Define the number of target we are rendering into
     * @param scene Define the scene the texture belongs to
     * @param options Define the options used to create the multi render target
     */
    function MultiRenderTarget(name, size, count, scene, options) {
        var _this = this;
        var generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;
        var generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;
        var doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;
        _this = _super.call(this, name, size, scene, generateMipMaps, doNotChangeAspectRatio) || this;
        _this._engine = scene.getEngine();
        if (!_this.isSupported) {
            _this.dispose();
            return;
        }
        var types = [];
        var samplingModes = [];
        for (var i = 0; i < count; i++) {
            if (options && options.types && options.types[i] !== undefined) {
                types.push(options.types[i]);
            }
            else {
                types.push(options && options.defaultType ? options.defaultType : Constants.TEXTURETYPE_UNSIGNED_INT);
            }
            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {
                samplingModes.push(options.samplingModes[i]);
            }
            else {
                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);
            }
        }
        var generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;
        var generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;
        _this._size = size;
        _this._multiRenderTargetOptions = {
            samplingModes: samplingModes,
            generateMipMaps: generateMipMaps,
            generateDepthBuffer: generateDepthBuffer,
            generateStencilBuffer: generateStencilBuffer,
            generateDepthTexture: generateDepthTexture,
            types: types,
            textureCount: count
        };
        _this._createInternalTextures();
        _this._createTextures();
        return _this;
    }
    Object.defineProperty(MultiRenderTarget.prototype, "isSupported", {
        /**
         * Get if draw buffers are currently supported by the used hardware and browser.
         */
        get: function () {
            return this._engine.webGLVersion > 1 || this._engine.getCaps().drawBuffersExtension;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiRenderTarget.prototype, "textures", {
        /**
         * Get the list of textures generated by the multi render target.
         */
        get: function () {
            return this._textures;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiRenderTarget.prototype, "depthTexture", {
        /**
         * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
         */
        get: function () {
            return this._textures[this._textures.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiRenderTarget.prototype, "wrapU", {
        /**
         * Set the wrapping mode on U of all the textures we are rendering to.
         * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
         */
        set: function (wrap) {
            if (this._textures) {
                for (var i = 0; i < this._textures.length; i++) {
                    this._textures[i].wrapU = wrap;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiRenderTarget.prototype, "wrapV", {
        /**
         * Set the wrapping mode on V of all the textures we are rendering to.
         * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
         */
        set: function (wrap) {
            if (this._textures) {
                for (var i = 0; i < this._textures.length; i++) {
                    this._textures[i].wrapV = wrap;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden */
    MultiRenderTarget.prototype._rebuild = function () {
        this.releaseInternalTextures();
        this._createInternalTextures();
        for (var i = 0; i < this._internalTextures.length; i++) {
            var texture = this._textures[i];
            texture._texture = this._internalTextures[i];
        }
        // Keeps references to frame buffer and stencil/depth buffer
        this._texture = this._internalTextures[0];
    };
    MultiRenderTarget.prototype._createInternalTextures = function () {
        this._internalTextures = this._engine.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions);
    };
    MultiRenderTarget.prototype._createTextures = function () {
        this._textures = [];
        for (var i = 0; i < this._internalTextures.length; i++) {
            var texture = new Texture(null, this.getScene());
            texture._texture = this._internalTextures[i];
            this._textures.push(texture);
        }
        // Keeps references to frame buffer and stencil/depth buffer
        this._texture = this._internalTextures[0];
    };
    Object.defineProperty(MultiRenderTarget.prototype, "samples", {
        /**
         * Define the number of samples used if MSAA is enabled.
         */
        get: function () {
            return this._samples;
        },
        set: function (value) {
            if (this._samples === value) {
                return;
            }
            this._samples = this._engine.updateMultipleRenderTargetTextureSampleCount(this._internalTextures, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resize all the textures in the multi render target.
     * Be carrefull as it will recreate all the data in the new texture.
     * @param size Define the new size
     */
    MultiRenderTarget.prototype.resize = function (size) {
        this.releaseInternalTextures();
        this._internalTextures = this._engine.createMultipleRenderTarget(size, this._multiRenderTargetOptions);
        this._createInternalTextures();
    };
    MultiRenderTarget.prototype.unbindFrameBuffer = function (engine, faceIndex) {
        var _this = this;
        engine.unBindMultiColorAttachmentFramebuffer(this._internalTextures, this.isCube, function () {
            _this.onAfterRenderObservable.notifyObservers(faceIndex);
        });
    };
    /**
     * Dispose the render targets and their associated resources
     */
    MultiRenderTarget.prototype.dispose = function () {
        this.releaseInternalTextures();
        _super.prototype.dispose.call(this);
    };
    /**
     * Release all the underlying texture used as draw buffers.
     */
    MultiRenderTarget.prototype.releaseInternalTextures = function () {
        if (!this._internalTextures) {
            return;
        }
        for (var i = this._internalTextures.length - 1; i >= 0; i--) {
            if (this._internalTextures[i] !== undefined) {
                this._internalTextures[i].dispose();
                this._internalTextures.splice(i, 1);
            }
        }
    };
    return MultiRenderTarget;
}(RenderTargetTexture));

/**
 * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
 * Custom Procedural textures are the easiest way to create your own procedural in your application.
 * @see http://doc.babylonjs.com/how_to/how_to_use_procedural_textures#creating-custom-procedural-textures
 */
var CustomProceduralTexture = /** @class */ (function (_super) {
    __extends(CustomProceduralTexture, _super);
    /**
     * Instantiates a new Custom Procedural Texture.
     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
     * Custom Procedural textures are the easiest way to create your own procedural in your application.
     * @see http://doc.babylonjs.com/how_to/how_to_use_procedural_textures#creating-custom-procedural-textures
     * @param name Define the name of the texture
     * @param texturePath Define the folder path containing all the cutom texture related files (config, shaders...)
     * @param size Define the size of the texture to create
     * @param scene Define the scene the texture belongs to
     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
     * @param generateMipMaps Define if the texture should creates mip maps or not
     */
    function CustomProceduralTexture(name, texturePath, size, scene, fallbackTexture, generateMipMaps) {
        var _this = _super.call(this, name, size, null, scene, fallbackTexture, generateMipMaps) || this;
        _this._animate = true;
        _this._time = 0;
        _this._texturePath = texturePath;
        //Try to load json
        _this._loadJson(texturePath);
        _this.refreshRate = 1;
        return _this;
    }
    CustomProceduralTexture.prototype._loadJson = function (jsonUrl) {
        var _this = this;
        var noConfigFile = function () {
            Logger.Log("No config file found in " + jsonUrl + " trying to use ShadersStore or DOM element");
            try {
                _this.setFragment(_this._texturePath);
            }
            catch (ex) {
                Logger.Error("No json or ShaderStore or DOM element found for CustomProceduralTexture");
            }
        };
        var configFileUrl = jsonUrl + "/config.json";
        var xhr = new WebRequest();
        xhr.open("GET", configFileUrl);
        xhr.addEventListener("load", function () {
            if (xhr.status === 200 || (xhr.responseText && xhr.responseText.length > 0)) {
                try {
                    _this._config = JSON.parse(xhr.response);
                    _this.updateShaderUniforms();
                    _this.updateTextures();
                    _this.setFragment(_this._texturePath + "/custom");
                    _this._animate = _this._config.animate;
                    _this.refreshRate = _this._config.refreshrate;
                }
                catch (ex) {
                    noConfigFile();
                }
            }
            else {
                noConfigFile();
            }
        }, false);
        xhr.addEventListener("error", function () {
            noConfigFile();
        }, false);
        try {
            xhr.send();
        }
        catch (ex) {
            Logger.Error("CustomProceduralTexture: Error on XHR send request.");
        }
    };
    /**
     * Is the texture ready to be used ? (rendered at least once)
     * @returns true if ready, otherwise, false.
     */
    CustomProceduralTexture.prototype.isReady = function () {
        if (!_super.prototype.isReady.call(this)) {
            return false;
        }
        for (var name in this._textures) {
            var texture = this._textures[name];
            if (!texture.isReady()) {
                return false;
            }
        }
        return true;
    };
    /**
     * Render the texture to its associated render target.
     * @param useCameraPostProcess Define if camera post process should be applied to the texture
     */
    CustomProceduralTexture.prototype.render = function (useCameraPostProcess) {
        var scene = this.getScene();
        if (this._animate && scene) {
            this._time += scene.getAnimationRatio() * 0.03;
            this.updateShaderUniforms();
        }
        _super.prototype.render.call(this, useCameraPostProcess);
    };
    /**
     * Update the list of dependant textures samplers in the shader.
     */
    CustomProceduralTexture.prototype.updateTextures = function () {
        for (var i = 0; i < this._config.sampler2Ds.length; i++) {
            this.setTexture(this._config.sampler2Ds[i].sample2Dname, new Texture(this._texturePath + "/" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));
        }
    };
    /**
     * Update the uniform values of the procedural texture in the shader.
     */
    CustomProceduralTexture.prototype.updateShaderUniforms = function () {
        if (this._config) {
            for (var j = 0; j < this._config.uniforms.length; j++) {
                var uniform = this._config.uniforms[j];
                switch (uniform.type) {
                    case "float":
                        this.setFloat(uniform.name, uniform.value);
                        break;
                    case "color3":
                        this.setColor3(uniform.name, new Color3(uniform.r, uniform.g, uniform.b));
                        break;
                    case "color4":
                        this.setColor4(uniform.name, new Color4(uniform.r, uniform.g, uniform.b, uniform.a));
                        break;
                    case "vector2":
                        this.setVector2(uniform.name, new Vector2(uniform.x, uniform.y));
                        break;
                    case "vector3":
                        this.setVector3(uniform.name, new Vector3(uniform.x, uniform.y, uniform.z));
                        break;
                }
            }
        }
        this.setFloat("time", this._time);
    };
    Object.defineProperty(CustomProceduralTexture.prototype, "animate", {
        /**
         * Define if the texture animates or not.
         */
        get: function () {
            return this._animate;
        },
        set: function (value) {
            this._animate = value;
        },
        enumerable: true,
        configurable: true
    });
    return CustomProceduralTexture;
}(ProceduralTexture));

var name$u = 'noisePixelShader';
var shader$u = "\n\nuniform float brightness;\nuniform float persistence;\nuniform float timeScale;\n\nvarying vec2 vUV;\n\nvec2 hash22(vec2 p)\n{\np=p*mat2(127.1,311.7,269.5,183.3);\np=-1.0+2.0*fract(sin(p)*43758.5453123);\nreturn sin(p*6.283+timeScale);\n}\nfloat interpolationNoise(vec2 p)\n{\nvec2 pi=floor(p);\nvec2 pf=p-pi;\nvec2 w=pf*pf*(3.-2.*pf);\nfloat f00=dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\nfloat f01=dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\nfloat f10=dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\nfloat f11=dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\nfloat xm1=mix(f00,f10,w.x);\nfloat xm2=mix(f01,f11,w.x);\nfloat ym=mix(xm1,xm2,w.y);\nreturn ym;\n}\nfloat perlinNoise2D(float x,float y)\n{\nfloat sum=0.0;\nfloat frequency=0.0;\nfloat amplitude=0.0;\nfor(int i=0; i<OCTAVES; i++)\n{\nfrequency=pow(2.0,float(i));\namplitude=pow(persistence,float(i));\nsum=sum+interpolationNoise(vec2(x*frequency,y*frequency))*amplitude;\n}\nreturn sum;\n}\n\nvoid main(void)\n{\nfloat x=abs(vUV.x);\nfloat y=abs(vUV.y);\nfloat noise=brightness+(1.0-brightness)*perlinNoise2D(x,y);\ngl_FragColor=vec4(noise,noise,noise,1.0);\n}\n";
Effect.ShadersStore[name$u] = shader$u;

/**
 * Class used to generate noise procedural textures
 */
var NoiseProceduralTexture = /** @class */ (function (_super) {
    __extends(NoiseProceduralTexture, _super);
    /**
     * Creates a new NoiseProceduralTexture
     * @param name defines the name fo the texture
     * @param size defines the size of the texture (default is 256)
     * @param scene defines the hosting scene
     * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created
     * @param generateMipMaps defines if mipmaps must be generated (true by default)
     */
    function NoiseProceduralTexture(name, size, scene, fallbackTexture, generateMipMaps) {
        if (size === void 0) { size = 256; }
        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }
        var _this = _super.call(this, name, size, "noise", scene, fallbackTexture, generateMipMaps) || this;
        _this._time = 0;
        /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */
        _this.brightness = 0.2;
        /** Defines the number of octaves to process */
        _this.octaves = 3;
        /** Defines the level of persistence (0.8 by default) */
        _this.persistence = 0.8;
        /** Gets or sets animation speed factor (default is 1) */
        _this.animationSpeedFactor = 1;
        _this.autoClear = false;
        _this._updateShaderUniforms();
        return _this;
    }
    NoiseProceduralTexture.prototype._updateShaderUniforms = function () {
        var scene = this.getScene();
        if (!scene) {
            return;
        }
        this._time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;
        this.setFloat("brightness", this.brightness);
        this.setFloat("persistence", this.persistence);
        this.setFloat("timeScale", this._time);
    };
    NoiseProceduralTexture.prototype._getDefines = function () {
        return "#define OCTAVES " + (this.octaves | 0);
    };
    /** Generate the current state of the procedural texture */
    NoiseProceduralTexture.prototype.render = function (useCameraPostProcess) {
        this._updateShaderUniforms();
        _super.prototype.render.call(this, useCameraPostProcess);
    };
    /**
     * Serializes this noise procedural texture
     * @returns a serialized noise procedural texture object
     */
    NoiseProceduralTexture.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.customType = "BABYLON.NoiseProceduralTexture";
        serializationObject.brightness = this.brightness;
        serializationObject.octaves = this.octaves;
        serializationObject.persistence = this.persistence;
        serializationObject.animationSpeedFactor = this.animationSpeedFactor;
        serializationObject.size = this.getSize().width;
        serializationObject.generateMipMaps = this._generateMipMaps;
        return serializationObject;
    };
    /**
     * Creates a NoiseProceduralTexture from parsed noise procedural texture data
     * @param parsedTexture defines parsed texture data
     * @param scene defines the current scene
     * @param rootUrl defines the root URL containing noise procedural texture information
     * @returns a parsed NoiseProceduralTexture
     */
    NoiseProceduralTexture.Parse = function (parsedTexture, scene) {
        var texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);
        texture.brightness = parsedTexture.brightness;
        texture.octaves = parsedTexture.octaves;
        texture.persistence = parsedTexture.persistence;
        texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;
        return texture;
    };
    return NoiseProceduralTexture;
}(ProceduralTexture));
_TypeStore.RegisteredTypes["BABYLON.NoiseProceduralTexture"] = NoiseProceduralTexture;

/**
 * Class used to store 3D textures containing user data
 */
var RawTexture3D = /** @class */ (function (_super) {
    __extends(RawTexture3D, _super);
    /**
     * Create a new RawTexture3D
     * @param data defines the data of the texture
     * @param width defines the width of the texture
     * @param height defines the height of the texture
     * @param depth defines the depth of the texture
     * @param format defines the texture format to use
     * @param scene defines the hosting scene
     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
     * @param invertY defines if texture must be stored with Y axis inverted
     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)
     */
    function RawTexture3D(data, width, height, depth, 
    /** Gets or sets the texture format to use */
    format, scene, generateMipMaps, invertY, samplingMode, textureType) {
        if (generateMipMaps === void 0) { generateMipMaps = true; }
        if (invertY === void 0) { invertY = false; }
        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;
        _this.format = format;
        _this._engine = scene.getEngine();
        _this._texture = scene.getEngine().createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, undefined, textureType);
        _this.is3D = true;
        return _this;
    }
    /**
     * Update the texture with new data
     * @param data defines the data to store in the texture
     */
    RawTexture3D.prototype.update = function (data) {
        if (!this._texture) {
            return;
        }
        this._engine.updateRawTexture3D(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
    };
    return RawTexture3D;
}(Texture));

/**
 * Creates a refraction texture used by refraction channel of the standard material.
 * It is like a mirror but to see through a material.
 * @see https://doc.babylonjs.com/how_to/reflect#refraction
 */
var RefractionTexture = /** @class */ (function (_super) {
    __extends(RefractionTexture, _super);
    /**
     * Creates a refraction texture used by refraction channel of the standard material.
     * It is like a mirror but to see through a material.
     * @see https://doc.babylonjs.com/how_to/reflect#refraction
     * @param name Define the texture name
     * @param size Define the size of the underlying texture
     * @param scene Define the scene the refraction belongs to
     * @param generateMipMaps Define if we need to generate mips level for the refraction
     */
    function RefractionTexture(name, size, scene, generateMipMaps) {
        var _this = _super.call(this, name, size, scene, generateMipMaps, true) || this;
        /**
         * Define the reflection plane we want to use. The refractionPlane is usually set to the constructed refractor.
         * It is possible to directly set the refractionPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the refractionPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the refractor as stated in the doc.
         * @see https://doc.babylonjs.com/how_to/reflect#refraction
         */
        _this.refractionPlane = new Plane$1(0, 1, 0, 1);
        /**
         * Define how deep under the surface we should see.
         */
        _this.depth = 2.0;
        _this.onBeforeRenderObservable.add(function () {
            scene.clipPlane = _this.refractionPlane;
        });
        _this.onAfterRenderObservable.add(function () {
            scene.clipPlane = null;
        });
        return _this;
    }
    /**
     * Clone the refraction texture.
     * @returns the cloned texture
     */
    RefractionTexture.prototype.clone = function () {
        var scene = this.getScene();
        if (!scene) {
            return this;
        }
        var textureSize = this.getSize();
        var newTexture = new RefractionTexture(this.name, textureSize.width, scene, this._generateMipMaps);
        // Base texture
        newTexture.hasAlpha = this.hasAlpha;
        newTexture.level = this.level;
        // Refraction Texture
        newTexture.refractionPlane = this.refractionPlane.clone();
        if (this.renderList) {
            newTexture.renderList = this.renderList.slice(0);
        }
        newTexture.depth = this.depth;
        return newTexture;
    };
    /**
     * Serialize the texture to a JSON representation you could use in Parse later on
     * @returns the serialized JSON representation
     */
    RefractionTexture.prototype.serialize = function () {
        if (!this.name) {
            return null;
        }
        var serializationObject = _super.prototype.serialize.call(this);
        serializationObject.mirrorPlane = this.refractionPlane.asArray();
        serializationObject.depth = this.depth;
        return serializationObject;
    };
    return RefractionTexture;
}(RenderTargetTexture));

/**
 * This represents the smallest workload to use an already existing element (Canvas or Video) as a texture.
 * To be as efficient as possible depending on your constraints nothing aside the first upload
 * is automatically managed.
 * It is a cheap VideoTexture or DynamicTexture if you prefer to keep full control of the elements
 * in your application.
 *
 * As the update is not automatic, you need to call them manually.
 */
var HtmlElementTexture = /** @class */ (function (_super) {
    __extends(HtmlElementTexture, _super);
    /**
     * Instantiates a HtmlElementTexture from the following parameters.
     *
     * @param name Defines the name of the texture
     * @param element Defines the video or canvas the texture is filled with
     * @param options Defines the other none mandatory texture creation options
     */
    function HtmlElementTexture(name, element, options) {
        var _this = _super.call(this, options.scene) || this;
        if (!element || (!options.engine && !options.scene)) {
            return _this;
        }
        options = __assign({}, HtmlElementTexture.DefaultOptions, options);
        _this._engine = options.engine || options.scene.getEngine();
        _this._generateMipMaps = options.generateMipMaps;
        _this._samplingMode = options.samplingMode;
        _this._textureMatrix = Matrix.Identity();
        _this.name = name;
        _this.element = element;
        _this._isVideo = (element instanceof HTMLVideoElement);
        _this.anisotropicFilteringLevel = 1;
        _this._createInternalTexture();
        return _this;
    }
    HtmlElementTexture.prototype._createInternalTexture = function () {
        var width = 0;
        var height = 0;
        if (this._isVideo) {
            width = this.element.videoWidth;
            height = this.element.videoHeight;
        }
        else {
            width = this.element.width;
            height = this.element.height;
        }
        this._texture = this._engine.createDynamicTexture(width, height, this._generateMipMaps, this._samplingMode);
        this.update();
    };
    /**
     * Returns the texture matrix used in most of the material.
     */
    HtmlElementTexture.prototype.getTextureMatrix = function () {
        return this._textureMatrix;
    };
    /**
     * Updates the content of the texture.
     * @param invertY Defines wether the texture should be inverted on Y (false by default on video and true on canvas)
     */
    HtmlElementTexture.prototype.update = function (invertY) {
        if (invertY === void 0) { invertY = null; }
        if (this._texture == null) {
            return;
        }
        if (this._isVideo) {
            var videoElement = this.element;
            if (videoElement.readyState < videoElement.HAVE_CURRENT_DATA) {
                return;
            }
            this._engine.updateVideoTexture(this._texture, videoElement, invertY === null ? true : invertY);
        }
        else {
            var canvasElement = this.element;
            this._engine.updateDynamicTexture(this._texture, canvasElement, invertY === null ? true : invertY, false);
        }
    };
    HtmlElementTexture.DefaultOptions = {
        generateMipMaps: false,
        samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,
        engine: null,
        scene: null
    };
    return HtmlElementTexture;
}(BaseTexture));

/**
 * Unique ID when we import meshes from Babylon to CSG
 */
var currentCSGMeshId = 0;
/**
 * Represents a vertex of a polygon. Use your own vertex class instead of this
 * one to provide additional features like texture coordinates and vertex
 * colors. Custom vertex classes need to provide a `pos` property and `clone()`,
 * `flip()`, and `interpolate()` methods that behave analogous to the ones
 * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience
 * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`
 * is not used anywhere else.
 * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes
 */
var Vertex = /** @class */ (function () {
    /**
     * Initializes the vertex
     * @param pos The position of the vertex
     * @param normal The normal of the vertex
     * @param uv The texture coordinate of the vertex
     */
    function Vertex(
    /**
     * The position of the vertex
     */
    pos, 
    /**
     * The normal of the vertex
     */
    normal, 
    /**
     * The texture coordinate of the vertex
     */
    uv) {
        this.pos = pos;
        this.normal = normal;
        this.uv = uv;
    }
    /**
     * Make a clone, or deep copy, of the vertex
     * @returns A new Vertex
     */
    Vertex.prototype.clone = function () {
        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv.clone());
    };
    /**
     * Invert all orientation-specific data (e.g. vertex normal). Called when the
     * orientation of a polygon is flipped.
     */
    Vertex.prototype.flip = function () {
        this.normal = this.normal.scale(-1);
    };
    /**
     * Create a new vertex between this vertex and `other` by linearly
     * interpolating all properties using a parameter of `t`. Subclasses should
     * override this to interpolate additional properties.
     * @param other the vertex to interpolate against
     * @param t The factor used to linearly interpolate between the vertices
     */
    Vertex.prototype.interpolate = function (other, t) {
        return new Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), Vector2.Lerp(this.uv, other.uv, t));
    };
    return Vertex;
}());
/**
 * Represents a plane in 3D space.
 */
var Plane = /** @class */ (function () {
    /**
     * Initializes the plane
     * @param normal The normal for the plane
     * @param w
     */
    function Plane(normal, w) {
        this.normal = normal;
        this.w = w;
    }
    /**
     * Construct a plane from three points
     * @param a Point a
     * @param b Point b
     * @param c Point c
     */
    Plane.FromPoints = function (a, b, c) {
        var v0 = c.subtract(a);
        var v1 = b.subtract(a);
        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {
            return null;
        }
        var n = Vector3.Normalize(Vector3.Cross(v0, v1));
        return new Plane(n, Vector3.Dot(n, a));
    };
    /**
     * Clone, or make a deep copy of the plane
     * @returns a new Plane
     */
    Plane.prototype.clone = function () {
        return new Plane(this.normal.clone(), this.w);
    };
    /**
     * Flip the face of the plane
     */
    Plane.prototype.flip = function () {
        this.normal.scaleInPlace(-1);
        this.w = -this.w;
    };
    /**
     * Split `polygon` by this plane if needed, then put the polygon or polygon
     * fragments in the appropriate lists. Coplanar polygons go into either
    `* coplanarFront` or `coplanarBack` depending on their orientation with
     * respect to this plane. Polygons in front or in back of this plane go into
     * either `front` or `back`
     * @param polygon The polygon to be split
     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane
     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane
     * @param front Will contain the polygons in front of the plane
     * @param back Will contain the polygons begind the plane
     */
    Plane.prototype.splitPolygon = function (polygon, coplanarFront, coplanarBack, front, back) {
        var COPLANAR = 0;
        var FRONT = 1;
        var BACK = 2;
        var SPANNING = 3;
        // Classify each point as well as the entire polygon into one of the above
        // four classes.
        var polygonType = 0;
        var types = [];
        var i;
        var t;
        for (i = 0; i < polygon.vertices.length; i++) {
            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;
            var type = (t < -Plane.EPSILON) ? BACK : (t > Plane.EPSILON) ? FRONT : COPLANAR;
            polygonType |= type;
            types.push(type);
        }
        // Put the polygon in the correct list, splitting it when necessary
        switch (polygonType) {
            case COPLANAR:
                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);
                break;
            case FRONT:
                front.push(polygon);
                break;
            case BACK:
                back.push(polygon);
                break;
            case SPANNING:
                var f = [], b = [];
                for (i = 0; i < polygon.vertices.length; i++) {
                    var j = (i + 1) % polygon.vertices.length;
                    var ti = types[i], tj = types[j];
                    var vi = polygon.vertices[i], vj = polygon.vertices[j];
                    if (ti !== BACK) {
                        f.push(vi);
                    }
                    if (ti !== FRONT) {
                        b.push(ti !== BACK ? vi.clone() : vi);
                    }
                    if ((ti | tj) === SPANNING) {
                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));
                        var v = vi.interpolate(vj, t);
                        f.push(v);
                        b.push(v.clone());
                    }
                }
                var poly;
                if (f.length >= 3) {
                    poly = new Polygon(f, polygon.shared);
                    if (poly.plane) {
                        front.push(poly);
                    }
                }
                if (b.length >= 3) {
                    poly = new Polygon(b, polygon.shared);
                    if (poly.plane) {
                        back.push(poly);
                    }
                }
                break;
        }
    };
    /**
     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a
     * point is on the plane
     */
    Plane.EPSILON = 1e-5;
    return Plane;
}());
/**
 * Represents a convex polygon. The vertices used to initialize a polygon must
 * be coplanar and form a convex loop.
 *
 * Each convex polygon has a `shared` property, which is shared between all
 * polygons that are clones of each other or were split from the same polygon.
 * This can be used to define per-polygon properties (such as surface color)
 */
var Polygon = /** @class */ (function () {
    /**
     * Initializes the polygon
     * @param vertices The vertices of the polygon
     * @param shared The properties shared across all polygons
     */
    function Polygon(vertices, shared) {
        this.vertices = vertices;
        this.shared = shared;
        this.plane = Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);
    }
    /**
     * Clones, or makes a deep copy, or the polygon
     */
    Polygon.prototype.clone = function () {
        var vertices = this.vertices.map(function (v) { return v.clone(); });
        return new Polygon(vertices, this.shared);
    };
    /**
     * Flips the faces of the polygon
     */
    Polygon.prototype.flip = function () {
        this.vertices.reverse().map(function (v) { v.flip(); });
        this.plane.flip();
    };
    return Polygon;
}());
/**
 * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons
 * by picking a polygon to split along. That polygon (and all other coplanar
 * polygons) are added directly to that node and the other polygons are added to
 * the front and/or back subtrees. This is not a leafy BSP tree since there is
 * no distinction between internal and leaf nodes
 */
var Node$1 = /** @class */ (function () {
    /**
     * Initializes the node
     * @param polygons A collection of polygons held in the node
     */
    function Node(polygons) {
        this.plane = null;
        this.front = null;
        this.back = null;
        this.polygons = new Array();
        if (polygons) {
            this.build(polygons);
        }
    }
    /**
     * Clones, or makes a deep copy, of the node
     * @returns The cloned node
     */
    Node.prototype.clone = function () {
        var node = new Node();
        node.plane = this.plane && this.plane.clone();
        node.front = this.front && this.front.clone();
        node.back = this.back && this.back.clone();
        node.polygons = this.polygons.map(function (p) { return p.clone(); });
        return node;
    };
    /**
     * Convert solid space to empty space and empty space to solid space
     */
    Node.prototype.invert = function () {
        for (var i = 0; i < this.polygons.length; i++) {
            this.polygons[i].flip();
        }
        if (this.plane) {
            this.plane.flip();
        }
        if (this.front) {
            this.front.invert();
        }
        if (this.back) {
            this.back.invert();
        }
        var temp = this.front;
        this.front = this.back;
        this.back = temp;
    };
    /**
     * Recursively remove all polygons in `polygons` that are inside this BSP
     * tree.
     * @param polygons Polygons to remove from the BSP
     * @returns Polygons clipped from the BSP
     */
    Node.prototype.clipPolygons = function (polygons) {
        if (!this.plane) {
            return polygons.slice();
        }
        var front = new Array(), back = new Array();
        for (var i = 0; i < polygons.length; i++) {
            this.plane.splitPolygon(polygons[i], front, back, front, back);
        }
        if (this.front) {
            front = this.front.clipPolygons(front);
        }
        if (this.back) {
            back = this.back.clipPolygons(back);
        }
        else {
            back = [];
        }
        return front.concat(back);
    };
    /**
     * Remove all polygons in this BSP tree that are inside the other BSP tree
     * `bsp`.
     * @param bsp BSP containing polygons to remove from this BSP
     */
    Node.prototype.clipTo = function (bsp) {
        this.polygons = bsp.clipPolygons(this.polygons);
        if (this.front) {
            this.front.clipTo(bsp);
        }
        if (this.back) {
            this.back.clipTo(bsp);
        }
    };
    /**
     * Return a list of all polygons in this BSP tree
     * @returns List of all polygons in this BSP tree
     */
    Node.prototype.allPolygons = function () {
        var polygons = this.polygons.slice();
        if (this.front) {
            polygons = polygons.concat(this.front.allPolygons());
        }
        if (this.back) {
            polygons = polygons.concat(this.back.allPolygons());
        }
        return polygons;
    };
    /**
     * Build a BSP tree out of `polygons`. When called on an existing tree, the
     * new polygons are filtered down to the bottom of the tree and become new
     * nodes there. Each set of polygons is partitioned using the first polygon
     * (no heuristic is used to pick a good split)
     * @param polygons Polygons used to construct the BSP tree
     */
    Node.prototype.build = function (polygons) {
        if (!polygons.length) {
            return;
        }
        if (!this.plane) {
            this.plane = polygons[0].plane.clone();
        }
        var front = new Array(), back = new Array();
        for (var i = 0; i < polygons.length; i++) {
            this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);
        }
        if (front.length) {
            if (!this.front) {
                this.front = new Node();
            }
            this.front.build(front);
        }
        if (back.length) {
            if (!this.back) {
                this.back = new Node();
            }
            this.back.build(back);
        }
    };
    return Node;
}());
/**
 * Class for building Constructive Solid Geometry
 */
var CSG = /** @class */ (function () {
    function CSG() {
        this.polygons = new Array();
    }
    /**
     * Convert the Mesh to CSG
     * @param mesh The Mesh to convert to CSG
     * @returns A new CSG from the Mesh
     */
    CSG.FromMesh = function (mesh) {
        var vertex, normal, uv, position, polygon, polygons = new Array(), vertices;
        var matrix, meshPosition, meshRotation, meshRotationQuaternion = null, meshScaling;
        if (mesh instanceof Mesh) {
            mesh.computeWorldMatrix(true);
            matrix = mesh.getWorldMatrix();
            meshPosition = mesh.position.clone();
            meshRotation = mesh.rotation.clone();
            if (mesh.rotationQuaternion) {
                meshRotationQuaternion = mesh.rotationQuaternion.clone();
            }
            meshScaling = mesh.scaling.clone();
        }
        else {
            throw 'BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh';
        }
        var indices = mesh.getIndices(), positions = mesh.getVerticesData(VertexBuffer.PositionKind), normals = mesh.getVerticesData(VertexBuffer.NormalKind), uvs = mesh.getVerticesData(VertexBuffer.UVKind);
        var subMeshes = mesh.subMeshes;
        for (var sm = 0, sml = subMeshes.length; sm < sml; sm++) {
            for (var i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {
                vertices = [];
                for (var j = 0; j < 3; j++) {
                    var sourceNormal = new Vector3(normals[indices[i + j] * 3], normals[indices[i + j] * 3 + 1], normals[indices[i + j] * 3 + 2]);
                    uv = new Vector2(uvs[indices[i + j] * 2], uvs[indices[i + j] * 2 + 1]);
                    var sourcePosition = new Vector3(positions[indices[i + j] * 3], positions[indices[i + j] * 3 + 1], positions[indices[i + j] * 3 + 2]);
                    position = Vector3.TransformCoordinates(sourcePosition, matrix);
                    normal = Vector3.TransformNormal(sourceNormal, matrix);
                    vertex = new Vertex(position, normal, uv);
                    vertices.push(vertex);
                }
                polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });
                // To handle the case of degenerated triangle
                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated
                if (polygon.plane) {
                    polygons.push(polygon);
                }
            }
        }
        var csg = CSG.FromPolygons(polygons);
        csg.matrix = matrix;
        csg.position = meshPosition;
        csg.rotation = meshRotation;
        csg.scaling = meshScaling;
        csg.rotationQuaternion = meshRotationQuaternion;
        currentCSGMeshId++;
        return csg;
    };
    /**
     * Construct a CSG solid from a list of `CSG.Polygon` instances.
     * @param polygons Polygons used to construct a CSG solid
     */
    CSG.FromPolygons = function (polygons) {
        var csg = new CSG();
        csg.polygons = polygons;
        return csg;
    };
    /**
     * Clones, or makes a deep copy, of the CSG
     * @returns A new CSG
     */
    CSG.prototype.clone = function () {
        var csg = new CSG();
        csg.polygons = this.polygons.map(function (p) { return p.clone(); });
        csg.copyTransformAttributes(this);
        return csg;
    };
    /**
     * Unions this CSG with another CSG
     * @param csg The CSG to union against this CSG
     * @returns The unioned CSG
     */
    CSG.prototype.union = function (csg) {
        var a = new Node$1(this.clone().polygons);
        var b = new Node$1(csg.clone().polygons);
        a.clipTo(b);
        b.clipTo(a);
        b.invert();
        b.clipTo(a);
        b.invert();
        a.build(b.allPolygons());
        return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);
    };
    /**
     * Unions this CSG with another CSG in place
     * @param csg The CSG to union against this CSG
     */
    CSG.prototype.unionInPlace = function (csg) {
        var a = new Node$1(this.polygons);
        var b = new Node$1(csg.polygons);
        a.clipTo(b);
        b.clipTo(a);
        b.invert();
        b.clipTo(a);
        b.invert();
        a.build(b.allPolygons());
        this.polygons = a.allPolygons();
    };
    /**
     * Subtracts this CSG with another CSG
     * @param csg The CSG to subtract against this CSG
     * @returns A new CSG
     */
    CSG.prototype.subtract = function (csg) {
        var a = new Node$1(this.clone().polygons);
        var b = new Node$1(csg.clone().polygons);
        a.invert();
        a.clipTo(b);
        b.clipTo(a);
        b.invert();
        b.clipTo(a);
        b.invert();
        a.build(b.allPolygons());
        a.invert();
        return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);
    };
    /**
     * Subtracts this CSG with another CSG in place
     * @param csg The CSG to subtact against this CSG
     */
    CSG.prototype.subtractInPlace = function (csg) {
        var a = new Node$1(this.polygons);
        var b = new Node$1(csg.polygons);
        a.invert();
        a.clipTo(b);
        b.clipTo(a);
        b.invert();
        b.clipTo(a);
        b.invert();
        a.build(b.allPolygons());
        a.invert();
        this.polygons = a.allPolygons();
    };
    /**
     * Intersect this CSG with another CSG
     * @param csg The CSG to intersect against this CSG
     * @returns A new CSG
     */
    CSG.prototype.intersect = function (csg) {
        var a = new Node$1(this.clone().polygons);
        var b = new Node$1(csg.clone().polygons);
        a.invert();
        b.clipTo(a);
        b.invert();
        a.clipTo(b);
        b.clipTo(a);
        a.build(b.allPolygons());
        a.invert();
        return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);
    };
    /**
     * Intersects this CSG with another CSG in place
     * @param csg The CSG to intersect against this CSG
     */
    CSG.prototype.intersectInPlace = function (csg) {
        var a = new Node$1(this.polygons);
        var b = new Node$1(csg.polygons);
        a.invert();
        b.clipTo(a);
        b.invert();
        a.clipTo(b);
        b.clipTo(a);
        a.build(b.allPolygons());
        a.invert();
        this.polygons = a.allPolygons();
    };
    /**
     * Return a new CSG solid with solid and empty space switched. This solid is
     * not modified.
     * @returns A new CSG solid with solid and empty space switched
     */
    CSG.prototype.inverse = function () {
        var csg = this.clone();
        csg.inverseInPlace();
        return csg;
    };
    /**
     * Inverses the CSG in place
     */
    CSG.prototype.inverseInPlace = function () {
        this.polygons.map(function (p) { p.flip(); });
    };
    /**
     * This is used to keep meshes transformations so they can be restored
     * when we build back a Babylon Mesh
     * NB : All CSG operations are performed in world coordinates
     * @param csg The CSG to copy the transform attributes from
     * @returns This CSG
     */
    CSG.prototype.copyTransformAttributes = function (csg) {
        this.matrix = csg.matrix;
        this.position = csg.position;
        this.rotation = csg.rotation;
        this.scaling = csg.scaling;
        this.rotationQuaternion = csg.rotationQuaternion;
        return this;
    };
    /**
     * Build Raw mesh from CSG
     * Coordinates here are in world space
     * @param name The name of the mesh geometry
     * @param scene The Scene
     * @param keepSubMeshes Specifies if the submeshes should be kept
     * @returns A new Mesh
     */
    CSG.prototype.buildMeshGeometry = function (name, scene, keepSubMeshes) {
        var matrix = this.matrix.clone();
        matrix.invert();
        var mesh = new Mesh(name, scene), vertices = [], indices = [], normals = [], uvs = [], vertex = Vector3.Zero(), normal = Vector3.Zero(), uv = Vector2.Zero(), polygons = this.polygons, polygonIndices = [0, 0, 0], polygon, vertice_dict = {}, vertex_idx, currentIndex = 0, subMesh_dict = {}, subMesh_obj;
        if (keepSubMeshes) {
            // Sort Polygons, since subMeshes are indices range
            polygons.sort(function (a, b) {
                if (a.shared.meshId === b.shared.meshId) {
                    return a.shared.subMeshId - b.shared.subMeshId;
                }
                else {
                    return a.shared.meshId - b.shared.meshId;
                }
            });
        }
        for (var i = 0, il = polygons.length; i < il; i++) {
            polygon = polygons[i];
            // Building SubMeshes
            if (!subMesh_dict[polygon.shared.meshId]) {
                subMesh_dict[polygon.shared.meshId] = {};
            }
            if (!subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId]) {
                subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId] = {
                    indexStart: +Infinity,
                    indexEnd: -Infinity,
                    materialIndex: polygon.shared.materialIndex
                };
            }
            subMesh_obj = subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId];
            for (var j = 2, jl = polygon.vertices.length; j < jl; j++) {
                polygonIndices[0] = 0;
                polygonIndices[1] = j - 1;
                polygonIndices[2] = j;
                for (var k = 0; k < 3; k++) {
                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);
                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);
                    uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);
                    var localVertex = Vector3.TransformCoordinates(vertex, matrix);
                    var localNormal = Vector3.TransformNormal(normal, matrix);
                    vertex_idx = vertice_dict[localVertex.x + ',' + localVertex.y + ',' + localVertex.z];
                    // Check if 2 points can be merged
                    if (!(typeof vertex_idx !== 'undefined' &&
                        normals[vertex_idx * 3] === localNormal.x &&
                        normals[vertex_idx * 3 + 1] === localNormal.y &&
                        normals[vertex_idx * 3 + 2] === localNormal.z &&
                        uvs[vertex_idx * 2] === uv.x &&
                        uvs[vertex_idx * 2 + 1] === uv.y)) {
                        vertices.push(localVertex.x, localVertex.y, localVertex.z);
                        uvs.push(uv.x, uv.y);
                        normals.push(normal.x, normal.y, normal.z);
                        vertex_idx = vertice_dict[localVertex.x + ',' + localVertex.y + ',' + localVertex.z] = (vertices.length / 3) - 1;
                    }
                    indices.push(vertex_idx);
                    subMesh_obj.indexStart = Math.min(currentIndex, subMesh_obj.indexStart);
                    subMesh_obj.indexEnd = Math.max(currentIndex, subMesh_obj.indexEnd);
                    currentIndex++;
                }
            }
        }
        mesh.setVerticesData(VertexBuffer.PositionKind, vertices);
        mesh.setVerticesData(VertexBuffer.NormalKind, normals);
        mesh.setVerticesData(VertexBuffer.UVKind, uvs);
        mesh.setIndices(indices, null);
        if (keepSubMeshes) {
            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes
            var materialIndexOffset = 0, materialMaxIndex;
            mesh.subMeshes = new Array();
            for (var m in subMesh_dict) {
                materialMaxIndex = -1;
                for (var sm in subMesh_dict[m]) {
                    subMesh_obj = subMesh_dict[m][sm];
                    SubMesh.CreateFromIndices(subMesh_obj.materialIndex + materialIndexOffset, subMesh_obj.indexStart, subMesh_obj.indexEnd - subMesh_obj.indexStart + 1, mesh);
                    materialMaxIndex = Math.max(subMesh_obj.materialIndex, materialMaxIndex);
                }
                materialIndexOffset += ++materialMaxIndex;
            }
        }
        return mesh;
    };
    /**
     * Build Mesh from CSG taking material and transforms into account
     * @param name The name of the Mesh
     * @param material The material of the Mesh
     * @param scene The Scene
     * @param keepSubMeshes Specifies if submeshes should be kept
     * @returns The new Mesh
     */
    CSG.prototype.toMesh = function (name, material, scene, keepSubMeshes) {
        var mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);
        mesh.material = material;
        mesh.position.copyFrom(this.position);
        mesh.rotation.copyFrom(this.rotation);
        if (this.rotationQuaternion) {
            mesh.rotationQuaternion = this.rotationQuaternion.clone();
        }
        mesh.scaling.copyFrom(this.scaling);
        mesh.computeWorldMatrix(true);
        return mesh;
    };
    return CSG;
}());

/**
 * Class used to create a trail following a mesh
 */
var TrailMesh = /** @class */ (function (_super) {
    __extends(TrailMesh, _super);
    /**
     * @constructor
     * @param name The value used by scene.getMeshByName() to do a lookup.
     * @param generator The mesh to generate a trail.
     * @param scene The scene to add this mesh to.
     * @param diameter Diameter of trailing mesh. Default is 1.
     * @param length Length of trailing mesh. Default is 60.
     * @param autoStart Automatically start trailing mesh. Default true.
     */
    function TrailMesh(name, generator, scene, diameter, length, autoStart) {
        if (diameter === void 0) { diameter = 1; }
        if (length === void 0) { length = 60; }
        if (autoStart === void 0) { autoStart = true; }
        var _this = _super.call(this, name, scene) || this;
        _this._sectionPolygonPointsCount = 4;
        _this._running = false;
        _this._autoStart = autoStart;
        _this._generator = generator;
        _this._diameter = diameter;
        _this._length = length;
        _this._sectionVectors = [];
        _this._sectionNormalVectors = [];
        for (var i = 0; i < _this._sectionPolygonPointsCount; i++) {
            _this._sectionVectors[i] = Vector3.Zero();
            _this._sectionNormalVectors[i] = Vector3.Zero();
        }
        _this._createMesh();
        return _this;
    }
    /**
     * "TrailMesh"
     * @returns "TrailMesh"
     */
    TrailMesh.prototype.getClassName = function () {
        return "TrailMesh";
    };
    TrailMesh.prototype._createMesh = function () {
        var data = new VertexData();
        var positions = [];
        var normals = [];
        var indices = [];
        var meshCenter = Vector3.Zero();
        if (this._generator._boundingInfo) {
            meshCenter = this._generator._boundingInfo.boundingBox.centerWorld;
        }
        var alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
        for (var i = 0; i < this._sectionPolygonPointsCount; i++) {
            positions.push(meshCenter.x + Math.cos(i * alpha) * this._diameter, meshCenter.y + Math.sin(i * alpha) * this._diameter, meshCenter.z);
        }
        for (var i = 1; i <= this._length; i++) {
            for (var j = 0; j < this._sectionPolygonPointsCount; j++) {
                positions.push(meshCenter.x + Math.cos(j * alpha) * this._diameter, meshCenter.y + Math.sin(j * alpha) * this._diameter, meshCenter.z);
            }
            var l = positions.length / 3 - 2 * this._sectionPolygonPointsCount;
            for (var j = 0; j < this._sectionPolygonPointsCount - 1; j++) {
                indices.push(l + j, l + j + this._sectionPolygonPointsCount, l + j + this._sectionPolygonPointsCount + 1);
                indices.push(l + j, l + j + this._sectionPolygonPointsCount + 1, l + j + 1);
            }
            indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount - 1 + this._sectionPolygonPointsCount, l + this._sectionPolygonPointsCount);
            indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount, l);
        }
        VertexData.ComputeNormals(positions, indices, normals);
        data.positions = positions;
        data.normals = normals;
        data.indices = indices;
        data.applyToMesh(this, true);
        if (this._autoStart) {
            this.start();
        }
    };
    /**
     * Start trailing mesh.
     */
    TrailMesh.prototype.start = function () {
        var _this = this;
        if (!this._running) {
            this._running = true;
            this._beforeRenderObserver = this.getScene().onBeforeRenderObservable.add(function () {
                _this.update();
            });
        }
    };
    /**
     * Stop trailing mesh.
     */
    TrailMesh.prototype.stop = function () {
        if (this._beforeRenderObserver && this._running) {
            this._running = false;
            this.getScene().onBeforeRenderObservable.remove(this._beforeRenderObserver);
        }
    };
    /**
     * Update trailing mesh geometry.
     */
    TrailMesh.prototype.update = function () {
        var positions = this.getVerticesData(VertexBuffer.PositionKind);
        var normals = this.getVerticesData(VertexBuffer.NormalKind);
        var wm = this._generator.getWorldMatrix();
        if (positions && normals) {
            for (var i = 3 * this._sectionPolygonPointsCount; i < positions.length; i++) {
                positions[i - 3 * this._sectionPolygonPointsCount] = positions[i] - normals[i] / this._length * this._diameter;
            }
            for (var i = 3 * this._sectionPolygonPointsCount; i < normals.length; i++) {
                normals[i - 3 * this._sectionPolygonPointsCount] = normals[i];
            }
            var l = positions.length - 3 * this._sectionPolygonPointsCount;
            var alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
            for (var i = 0; i < this._sectionPolygonPointsCount; i++) {
                this._sectionVectors[i].copyFromFloats(Math.cos(i * alpha) * this._diameter, Math.sin(i * alpha) * this._diameter, 0);
                this._sectionNormalVectors[i].copyFromFloats(Math.cos(i * alpha), Math.sin(i * alpha), 0);
                Vector3.TransformCoordinatesToRef(this._sectionVectors[i], wm, this._sectionVectors[i]);
                Vector3.TransformNormalToRef(this._sectionNormalVectors[i], wm, this._sectionNormalVectors[i]);
            }
            for (var i = 0; i < this._sectionPolygonPointsCount; i++) {
                positions[l + 3 * i] = this._sectionVectors[i].x;
                positions[l + 3 * i + 1] = this._sectionVectors[i].y;
                positions[l + 3 * i + 2] = this._sectionVectors[i].z;
                normals[l + 3 * i] = this._sectionNormalVectors[i].x;
                normals[l + 3 * i + 1] = this._sectionNormalVectors[i].y;
                normals[l + 3 * i + 2] = this._sectionNormalVectors[i].z;
            }
            this.updateVerticesData(VertexBuffer.PositionKind, positions, true, false);
            this.updateVerticesData(VertexBuffer.NormalKind, normals, true, false);
        }
    };
    /**
     * Returns a new TrailMesh object.
     * @param name is a string, the name given to the new mesh
     * @param newGenerator use new generator object for cloned trail mesh
     * @returns a new mesh
     */
    TrailMesh.prototype.clone = function (name, newGenerator) {
        if (name === void 0) { name = ""; }
        return new TrailMesh(name, (newGenerator === undefined ? this._generator : newGenerator), this.getScene(), this._diameter, this._length, this._autoStart);
    };
    /**
     * Serializes this trail mesh
     * @param serializationObject object to write serialization to
     */
    TrailMesh.prototype.serialize = function (serializationObject) {
        _super.prototype.serialize.call(this, serializationObject);
    };
    /**
     * Parses a serialized trail mesh
     * @param parsedMesh the serialized mesh
     * @param scene the scene to create the trail mesh in
     * @returns the created trail mesh
     */
    TrailMesh.Parse = function (parsedMesh, scene) {
        return new TrailMesh(parsedMesh.name, parsedMesh._generator, scene, parsedMesh._diameter, parsedMesh._length, parsedMesh._autoStart);
    };
    return TrailMesh;
}(Mesh));

VertexData.CreateDisc = function (options) {
    var positions = new Array();
    var indices = new Array();
    var normals = new Array();
    var uvs = new Array();
    var radius = options.radius || 0.5;
    var tessellation = options.tessellation || 64;
    var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;
    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
    // positions and uvs
    positions.push(0, 0, 0); // disc center first
    uvs.push(0.5, 0.5);
    var theta = Math.PI * 2 * arc;
    var step = theta / tessellation;
    for (var a = 0; a < theta; a += step) {
        var x = Math.cos(a);
        var y = Math.sin(a);
        var u = (x + 1) / 2;
        var v = (1 - y) / 2;
        positions.push(radius * x, radius * y, 0);
        uvs.push(u, v);
    }
    if (arc === 1) {
        positions.push(positions[3], positions[4], positions[5]); // close the circle
        uvs.push(uvs[2], uvs[3]);
    }
    //indices
    var vertexNb = positions.length / 3;
    for (var i = 1; i < vertexNb - 1; i++) {
        indices.push(i + 1, 0, i);
    }
    // result
    VertexData.ComputeNormals(positions, indices, normals);
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    return vertexData;
};
Mesh.CreateDisc = function (name, radius, tessellation, scene, updatable, sideOrientation) {
    if (scene === void 0) { scene = null; }
    var options = {
        radius: radius,
        tessellation: tessellation,
        sideOrientation: sideOrientation,
        updatable: updatable
    };
    return DiscBuilder.CreateDisc(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var DiscBuilder = /** @class */ (function () {
    function DiscBuilder() {
    }
    /**
     * Creates a plane polygonal mesh.  By default, this is a disc
     * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
     * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
     * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the plane polygonal mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
     */
    DiscBuilder.CreateDisc = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var disc = new Mesh(name, scene);
        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        disc._originalBuilderSideOrientation = options.sideOrientation;
        var vertexData = VertexData.CreateDisc(options);
        vertexData.applyToMesh(disc, options.updatable);
        return disc;
    };
    return DiscBuilder;
}());

VertexData.CreateTorusKnot = function (options) {
    var indices = new Array();
    var positions = new Array();
    var normals = new Array();
    var uvs = new Array();
    var radius = options.radius || 2;
    var tube = options.tube || 0.5;
    var radialSegments = options.radialSegments || 32;
    var tubularSegments = options.tubularSegments || 32;
    var p = options.p || 2;
    var q = options.q || 3;
    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
    // Helper
    var getPos = function (angle) {
        var cu = Math.cos(angle);
        var su = Math.sin(angle);
        var quOverP = q / p * angle;
        var cs = Math.cos(quOverP);
        var tx = radius * (2 + cs) * 0.5 * cu;
        var ty = radius * (2 + cs) * su * 0.5;
        var tz = radius * Math.sin(quOverP) * 0.5;
        return new Vector3(tx, ty, tz);
    };
    // Vertices
    var i;
    var j;
    for (i = 0; i <= radialSegments; i++) {
        var modI = i % radialSegments;
        var u = modI / radialSegments * 2 * p * Math.PI;
        var p1 = getPos(u);
        var p2 = getPos(u + 0.01);
        var tang = p2.subtract(p1);
        var n = p2.add(p1);
        var bitan = Vector3.Cross(tang, n);
        n = Vector3.Cross(bitan, tang);
        bitan.normalize();
        n.normalize();
        for (j = 0; j < tubularSegments; j++) {
            var modJ = j % tubularSegments;
            var v = modJ / tubularSegments * 2 * Math.PI;
            var cx = -tube * Math.cos(v);
            var cy = tube * Math.sin(v);
            positions.push(p1.x + cx * n.x + cy * bitan.x);
            positions.push(p1.y + cx * n.y + cy * bitan.y);
            positions.push(p1.z + cx * n.z + cy * bitan.z);
            uvs.push(i / radialSegments);
            uvs.push(j / tubularSegments);
        }
    }
    for (i = 0; i < radialSegments; i++) {
        for (j = 0; j < tubularSegments; j++) {
            var jNext = (j + 1) % tubularSegments;
            var a = i * tubularSegments + j;
            var b = (i + 1) * tubularSegments + j;
            var c = (i + 1) * tubularSegments + jNext;
            var d = i * tubularSegments + jNext;
            indices.push(d);
            indices.push(b);
            indices.push(a);
            indices.push(d);
            indices.push(c);
            indices.push(b);
        }
    }
    // Normals
    VertexData.ComputeNormals(positions, indices, normals);
    // Sides
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
    // Result
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    return vertexData;
};
Mesh.CreateTorusKnot = function (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {
    var options = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        sideOrientation: sideOrientation,
        updatable: updatable
    };
    return TorusKnotBuilder.CreateTorusKnot(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var TorusKnotBuilder = /** @class */ (function () {
    function TorusKnotBuilder() {
    }
    /**
     * Creates a torus knot mesh
     * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
     * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
     * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
     * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the torus knot mesh
     * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot
     */
    TorusKnotBuilder.CreateTorusKnot = function (name, options, scene) {
        var torusKnot = new Mesh(name, scene);
        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        torusKnot._originalBuilderSideOrientation = options.sideOrientation;
        var vertexData = VertexData.CreateTorusKnot(options);
        vertexData.applyToMesh(torusKnot, options.updatable);
        return torusKnot;
    };
    return TorusKnotBuilder;
}());

VertexData.CreatePolygon = function (polygon, sideOrientation, fUV, fColors, frontUVs, backUVs) {
    var faceUV = fUV || new Array(3);
    var faceColors = fColors;
    var colors = [];
    // default face colors and UV if undefined
    for (var f = 0; f < 3; f++) {
        if (faceUV[f] === undefined) {
            faceUV[f] = new Vector4(0, 0, 1, 1);
        }
        if (faceColors && faceColors[f] === undefined) {
            faceColors[f] = new Color4(1, 1, 1, 1);
        }
    }
    var positions = polygon.getVerticesData(VertexBuffer.PositionKind);
    var normals = polygon.getVerticesData(VertexBuffer.NormalKind);
    var uvs = polygon.getVerticesData(VertexBuffer.UVKind);
    var indices = polygon.getIndices();
    // set face colours and textures
    var idx = 0;
    var face = 0;
    for (var index = 0; index < normals.length; index += 3) {
        //Edge Face  no. 1
        if (Math.abs(normals[index + 1]) < 0.001) {
            face = 1;
        }
        //Top Face  no. 0
        if (Math.abs(normals[index + 1] - 1) < 0.001) {
            face = 0;
        }
        //Bottom Face  no. 2
        if (Math.abs(normals[index + 1] + 1) < 0.001) {
            face = 2;
        }
        idx = index / 3;
        uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;
        uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;
        if (faceColors) {
            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);
        }
    }
    // sides
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);
    // Result
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    if (faceColors) {
        var totalColors = (sideOrientation === VertexData.DOUBLESIDE) ? colors.concat(colors) : colors;
        vertexData.colors = totalColors;
    }
    return vertexData;
};
Mesh.CreatePolygon = function (name, shape, scene, holes, updatable, sideOrientation, earcutInjection) {
    if (earcutInjection === void 0) { earcutInjection = earcut; }
    var options = {
        shape: shape,
        holes: holes,
        updatable: updatable,
        sideOrientation: sideOrientation
    };
    return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);
};
Mesh.ExtrudePolygon = function (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {
    if (earcutInjection === void 0) { earcutInjection = earcut; }
    var options = {
        shape: shape,
        holes: holes,
        depth: depth,
        updatable: updatable,
        sideOrientation: sideOrientation
    };
    return PolygonBuilder.ExtrudePolygon(name, options, scene, earcutInjection);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var PolygonBuilder = /** @class */ (function () {
    function PolygonBuilder() {
    }
    /**
     * Creates a polygon mesh
     * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
     * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
     * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
     * * Remember you can only change the shape positions, not their number when updating a polygon
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @param earcutInjection can be used to inject your own earcut reference
     * @returns the polygon mesh
     */
    PolygonBuilder.CreatePolygon = function (name, options, scene, earcutInjection) {
        if (scene === void 0) { scene = null; }
        if (earcutInjection === void 0) { earcutInjection = earcut; }
        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        var shape = options.shape;
        var holes = options.holes || [];
        var depth = options.depth || 0;
        var contours = [];
        var hole = [];
        for (var i = 0; i < shape.length; i++) {
            contours[i] = new Vector2(shape[i].x, shape[i].z);
        }
        var epsilon = 0.00000001;
        if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {
            contours.pop();
        }
        var polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene, earcutInjection);
        for (var hNb = 0; hNb < holes.length; hNb++) {
            hole = [];
            for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {
                hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));
            }
            polygonTriangulation.addHole(hole);
        }
        var polygon = polygonTriangulation.build(options.updatable, depth);
        polygon._originalBuilderSideOrientation = options.sideOrientation;
        var vertexData = VertexData.CreatePolygon(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs);
        vertexData.applyToMesh(polygon, options.updatable);
        return polygon;
    };
    /**
     * Creates an extruded polygon mesh, with depth in the Y direction.
     * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)
     * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @param earcutInjection can be used to inject your own earcut reference
     * @returns the polygon mesh
     */
    PolygonBuilder.ExtrudePolygon = function (name, options, scene, earcutInjection) {
        if (scene === void 0) { scene = null; }
        if (earcutInjection === void 0) { earcutInjection = earcut; }
        return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);
    };
    return PolygonBuilder;
}());

Mesh.CreateLathe = function (name, shape, radius, tessellation, scene, updatable, sideOrientation) {
    var options = {
        shape: shape,
        radius: radius,
        tessellation: tessellation,
        sideOrientation: sideOrientation,
        updatable: updatable
    };
    return LatheBuilder.CreateLathe(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var LatheBuilder = /** @class */ (function () {
    function LatheBuilder() {
    }
    /**
     * Creates lathe mesh.
     * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
     * * The parameter `radius` (positive float, default 1) is the radius value of the lathe
     * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
     * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides
     * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
     * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the lathe mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe
     */
    LatheBuilder.CreateLathe = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var arc = options.arc ? ((options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc) : 1.0;
        var closed = (options.closed === undefined) ? true : options.closed;
        var shape = options.shape;
        var radius = options.radius || 1;
        var tessellation = options.tessellation || 64;
        var clip = options.clip || 0;
        var updatable = options.updatable;
        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        var cap = options.cap || Mesh.NO_CAP;
        var pi2 = Math.PI * 2;
        var paths = new Array();
        var invertUV = options.invertUV || false;
        var i = 0;
        var p = 0;
        var step = pi2 / tessellation * arc;
        var rotated;
        var path = new Array();
        for (i = 0; i <= tessellation - clip; i++) {
            var path = [];
            if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {
                path.push(new Vector3(0, shape[0].y, 0));
                path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));
            }
            for (p = 0; p < shape.length; p++) {
                rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);
                path.push(rotated);
            }
            if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {
                path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));
                path.push(new Vector3(0, shape[shape.length - 1].y, 0));
            }
            paths.push(path);
        }
        // lathe ribbon
        var lathe = RibbonBuilder.CreateRibbon(name, { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);
        return lathe;
    };
    return LatheBuilder;
}());

Mesh.CreateTube = function (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {
    var options = {
        path: path,
        radius: radius,
        tessellation: tessellation,
        radiusFunction: radiusFunction,
        arc: 1,
        cap: cap,
        updatable: updatable,
        sideOrientation: sideOrientation,
        instance: instance
    };
    return TubeBuilder.CreateTube(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var TubeBuilder = /** @class */ (function () {
    function TubeBuilder() {
    }
    /**
     * Creates a tube mesh.
     * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
     * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
     * * The parameter `radius` (positive float, default 1) sets the tube radius size
     * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
     * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
     * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
     * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
     * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the tube mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes
     * @see https://doc.babylonjs.com/how_to/set_shapes#tube
     */
    TubeBuilder.CreateTube = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var path = options.path;
        var instance = options.instance;
        var radius = 1.0;
        if (options.radius !== undefined) {
            radius = options.radius;
        }
        else if (instance) {
            radius = instance._creationDataStorage.radius;
        }
        var tessellation = options.tessellation || 64 | 0;
        var radiusFunction = options.radiusFunction || null;
        var cap = options.cap || Mesh.NO_CAP;
        var invertUV = options.invertUV || false;
        var updatable = options.updatable;
        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;
        // tube geometry
        var tubePathArray = function (path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) {
            var tangents = path3D.getTangents();
            var normals = path3D.getNormals();
            var distances = path3D.getDistances();
            var pi2 = Math.PI * 2;
            var step = pi2 / tessellation * arc;
            var returnRadius = function () { return radius; };
            var radiusFunctionFinal = radiusFunction || returnRadius;
            var circlePath;
            var rad;
            var normal;
            var rotated;
            var rotationMatrix = Tmp.Matrix[0];
            var index = (cap === Mesh.NO_CAP || cap === Mesh.CAP_END) ? 0 : 2;
            for (var i = 0; i < path.length; i++) {
                rad = radiusFunctionFinal(i, distances[i]); // current radius
                circlePath = Array(); // current circle array
                normal = normals[i]; // current normal
                for (var t = 0; t < tessellation; t++) {
                    Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);
                    rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();
                    Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);
                    rotated.scaleInPlace(rad).addInPlace(path[i]);
                    circlePath[t] = rotated;
                }
                circlePaths[index] = circlePath;
                index++;
            }
            // cap
            var capPath = function (nbPoints, pathIndex) {
                var pointCap = Array();
                for (var i = 0; i < nbPoints; i++) {
                    pointCap.push(path[pathIndex]);
                }
                return pointCap;
            };
            switch (cap) {
                case Mesh.NO_CAP:
                    break;
                case Mesh.CAP_START:
                    circlePaths[0] = capPath(tessellation, 0);
                    circlePaths[1] = circlePaths[2].slice(0);
                    break;
                case Mesh.CAP_END:
                    circlePaths[index] = circlePaths[index - 1].slice(0);
                    circlePaths[index + 1] = capPath(tessellation, path.length - 1);
                    break;
                case Mesh.CAP_ALL:
                    circlePaths[0] = capPath(tessellation, 0);
                    circlePaths[1] = circlePaths[2].slice(0);
                    circlePaths[index] = circlePaths[index - 1].slice(0);
                    circlePaths[index + 1] = capPath(tessellation, path.length - 1);
                    break;
            }
            return circlePaths;
        };
        var path3D;
        var pathArray;
        if (instance) { // tube update
            var storage = instance._creationDataStorage;
            var arc = options.arc || storage.arc;
            path3D = storage.path3D.update(path);
            pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);
            instance = RibbonBuilder.CreateRibbon("", { pathArray: pathArray, instance: instance });
            // Update mode, no need to recreate the storage.
            storage.path3D = path3D;
            storage.pathArray = pathArray;
            storage.arc = arc;
            storage.radius = radius;
            return instance;
        }
        // tube creation
        path3D = new Path3D(path);
        var newPathArray = new Array();
        cap = (cap < 0 || cap > 3) ? 0 : cap;
        pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);
        var tube = RibbonBuilder.CreateRibbon(name, { pathArray: pathArray, closePath: true, closeArray: false, updatable: updatable, sideOrientation: sideOrientation, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);
        tube._creationDataStorage.pathArray = pathArray;
        tube._creationDataStorage.path3D = path3D;
        tube._creationDataStorage.tessellation = tessellation;
        tube._creationDataStorage.cap = cap;
        tube._creationDataStorage.arc = options.arc;
        tube._creationDataStorage.radius = radius;
        return tube;
    };
    return TubeBuilder;
}());

VertexData.CreateIcoSphere = function (options) {
    var sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;
    var radius = options.radius || 1;
    var flat = (options.flat === undefined) ? true : options.flat;
    var subdivisions = options.subdivisions || 4;
    var radiusX = options.radiusX || radius;
    var radiusY = options.radiusY || radius;
    var radiusZ = options.radiusZ || radius;
    var t = (1 + Math.sqrt(5)) / 2;
    // 12 vertex x,y,z
    var ico_vertices = [
        -1, t, -0, 1, t, 0, -1, -t, 0, 1, -t, 0,
        0, -1, -t, 0, 1, -t, 0, -1, t, 0, 1, t,
        t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, -1 // v8-11
    ];
    // index of 3 vertex makes a face of icopshere
    var ico_indices = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23,
        1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8,
        14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9,
        4, 21, 5, 13, 17, 23, 6, 13, 22, 19, 6, 18, 9, 8, 1
    ];
    // vertex for uv have aliased position, not for UV
    var vertices_unalias_id = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
        // vertex alias
        0,
        2,
        3,
        3,
        3,
        4,
        7,
        8,
        9,
        9,
        10,
        11 // 23: B + 12
    ];
    // uv as integer step (not pixels !)
    var ico_vertexuv = [
        5, 1, 3, 1, 6, 4, 0, 0,
        5, 3, 4, 2, 2, 2, 4, 0,
        2, 0, 1, 1, 6, 0, 6, 2,
        // vertex alias (for same vertex on different faces)
        0, 4,
        3, 3,
        4, 4,
        3, 1,
        4, 2,
        4, 4,
        0, 2,
        1, 1,
        2, 2,
        3, 3,
        1, 3,
        2, 4 // 23: B + 12
    ];
    // Vertices[0, 1, ...9, A, B] : position on UV plane
    // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)
    // First island of uv mapping
    // v = 4h          3+  2
    // v = 3h        9+  4
    // v = 2h      9+  5   B
    // v = 1h    9   1   0
    // v = 0h  3   8   7   A
    //     u = 0 1 2 3 4 5 6  *a
    // Second island of uv mapping
    // v = 4h  0+  B+  4+
    // v = 3h    A+  2+
    // v = 2h  7+  6   3+
    // v = 1h    8+  3+
    // v = 0h
    //     u = 0 1 2 3 4 5 6  *a
    // Face layout on texture UV mapping
    // ============
    // \ 4  /\ 16 /   ======
    //  \  /  \  /   /\ 11 /
    //   \/ 7  \/   /  \  /
    //    =======  / 10 \/
    //   /\ 17 /\  =======
    //  /  \  /  \ \ 15 /\
    // / 8  \/ 12 \ \  /  \
    // ============  \/ 6  \
    // \ 18 /\  ============
    //  \  /  \ \ 5  /\ 0  /
    //   \/ 13 \ \  /  \  /
    //   =======  \/ 1  \/
    //       =============
    //      /\ 19 /\  2 /\
    //     /  \  /  \  /  \
    //    / 14 \/ 9  \/  3 \
    //   ===================
    // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97
    var ustep = 138 / 1024;
    var vstep = 239 / 1024;
    var uoffset = 60 / 1024;
    var voffset = 26 / 1024;
    // Second island should have margin, not to touch the first island
    // avoid any borderline artefact in pixel rounding
    var island_u_offset = -40 / 1024;
    var island_v_offset = +20 / 1024;
    // face is either island 0 or 1 :
    // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]
    var island = [
        0, 0, 0, 0, 1,
        0, 0, 1, 1, 0,
        0, 0, 1, 1, 0,
        0, 1, 1, 1, 0 //  15 - 19
    ];
    var indices = new Array();
    var positions = new Array();
    var normals = new Array();
    var uvs = new Array();
    var current_indice = 0;
    // prepare array of 3 vector (empty) (to be worked in place, shared for each face)
    var face_vertex_pos = new Array(3);
    var face_vertex_uv = new Array(3);
    var v012;
    for (v012 = 0; v012 < 3; v012++) {
        face_vertex_pos[v012] = Vector3.Zero();
        face_vertex_uv[v012] = Vector2.Zero();
    }
    // create all with normals
    for (var face = 0; face < 20; face++) {
        // 3 vertex per face
        for (v012 = 0; v012 < 3; v012++) {
            // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)
            var v_id = ico_indices[3 * face + v012];
            // vertex have 3D position (x,y,z)
            face_vertex_pos[v012].copyFromFloats(ico_vertices[3 * vertices_unalias_id[v_id]], ico_vertices[3 * vertices_unalias_id[v_id] + 1], ico_vertices[3 * vertices_unalias_id[v_id] + 2]);
            // Normalize to get normal, then scale to radius
            face_vertex_pos[v012].normalize().scaleInPlace(radius);
            // uv Coordinates from vertex ID
            face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);
        }
        // Subdivide the face (interpolate pos, norm, uv)
        // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)
        // - norm is linear interpolation of vertex corner normal
        //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )
        // - uv is linear interpolation
        //
        // Topology is as below for sub-divide by 2
        // vertex shown as v0,v1,v2
        // interp index is i1 to progress in range [v0,v1[
        // interp index is i2 to progress in range [v0,v2[
        // face index as  (i1,i2)  for /\  : (i1,i2),(i1+1,i2),(i1,i2+1)
        //            and (i1,i2)' for \/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)
        //
        //
        //                    i2    v2
        //                    ^    ^
        //                   /    / \
        //                  /    /   \
        //                 /    /     \
        //                /    / (0,1) \
        //               /    #---------\
        //              /    / \ (0,0)'/ \
        //             /    /   \     /   \
        //            /    /     \   /     \
        //           /    / (0,0) \ / (1,0) \
        //          /    #---------#---------\
        //              v0                    v1
        //
        //              --------------------> i1
        //
        // interp of (i1,i2):
        //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)
        //  along i1 :  lerp(x0,x1, i1/(S-i2))
        //
        // centroid of triangle is needed to get help normal computation
        //  (c1,c2) are used for centroid location
        var interp_vertex = function (i1, i2, c1, c2) {
            // vertex is interpolated from
            //   - face_vertex_pos[0..2]
            //   - face_vertex_uv[0..2]
            var pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);
            var pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);
            var pos_interp = (subdivisions === i2) ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));
            pos_interp.normalize();
            var vertex_normal;
            if (flat) {
                // in flat mode, recalculate normal as face centroid normal
                var centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);
                var centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);
                vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));
            }
            else {
                // in smooth mode, recalculate normal from each single vertex position
                vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);
            }
            // Vertex normal need correction due to X,Y,Z radius scaling
            vertex_normal.x /= radiusX;
            vertex_normal.y /= radiusY;
            vertex_normal.z /= radiusZ;
            vertex_normal.normalize();
            var uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);
            var uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);
            var uv_interp = (subdivisions === i2) ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));
            positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);
            normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);
            uvs.push(uv_interp.x, uv_interp.y);
            // push each vertex has member of a face
            // Same vertex can bleong to multiple face, it is pushed multiple time (duplicate vertex are present)
            indices.push(current_indice);
            current_indice++;
        };
        for (var i2 = 0; i2 < subdivisions; i2++) {
            for (var i1 = 0; i1 + i2 < subdivisions; i1++) {
                // face : (i1,i2)  for /\  :
                // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)
                interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);
                interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);
                interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);
                if (i1 + i2 + 1 < subdivisions) {
                    // face : (i1,i2)' for \/  :
                    // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)
                    interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);
                    interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);
                    interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);
                }
            }
        }
    }
    // Sides
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
    // Result
    var vertexData = new VertexData();
    vertexData.indices = indices;
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    return vertexData;
};
Mesh.CreateIcoSphere = function (name, options, scene) {
    return IcoSphereBuilder.CreateIcoSphere(name, options, scene);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var IcoSphereBuilder = /** @class */ (function () {
    function IcoSphereBuilder() {
    }
    /**
     * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
     * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
     * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)
     * * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
     * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the icosahedron mesh
     * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
     */
    IcoSphereBuilder.CreateIcoSphere = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        var sphere = new Mesh(name, scene);
        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
        sphere._originalBuilderSideOrientation = options.sideOrientation;
        var vertexData = VertexData.CreateIcoSphere(options);
        vertexData.applyToMesh(sphere, options.updatable);
        return sphere;
    };
    return IcoSphereBuilder;
}());

Mesh.CreateDecal = function (name, sourceMesh, position, normal, size, angle) {
    var options = {
        position: position,
        normal: normal,
        size: size,
        angle: angle
    };
    return DecalBuilder.CreateDecal(name, sourceMesh, options);
};
/**
 * Class containing static functions to help procedurally build meshes
 */
var DecalBuilder = /** @class */ (function () {
    function DecalBuilder() {
    }
    /**
     * Creates a decal mesh.
     * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
     * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
     * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
     * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
     * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal
     * @param name defines the name of the mesh
     * @param sourceMesh defines the mesh where the decal must be applied
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the decal mesh
     * @see https://doc.babylonjs.com/how_to/decals
     */
    DecalBuilder.CreateDecal = function (name, sourceMesh, options) {
        var indices = sourceMesh.getIndices();
        var positions = sourceMesh.getVerticesData(VertexBuffer.PositionKind);
        var normals = sourceMesh.getVerticesData(VertexBuffer.NormalKind);
        var position = options.position || Vector3.Zero();
        var normal = options.normal || Vector3.Up();
        var size = options.size || Vector3.One();
        var angle = options.angle || 0;
        // Getting correct rotation
        if (!normal) {
            var target = new Vector3(0, 0, 1);
            var camera = sourceMesh.getScene().activeCamera;
            var cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());
            normal = camera.globalPosition.subtract(cameraWorldTarget);
        }
        var yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;
        var len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);
        var pitch = Math.atan2(normal.y, len);
        // Matrix
        var decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));
        var inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);
        var meshWorldMatrix = sourceMesh.getWorldMatrix();
        var transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);
        var vertexData = new VertexData();
        vertexData.indices = [];
        vertexData.positions = [];
        vertexData.normals = [];
        vertexData.uvs = [];
        var currentVertexDataIndex = 0;
        var extractDecalVector3 = function (indexId) {
            var result = new PositionNormalVertex();
            if (!indices || !positions || !normals) {
                return result;
            }
            var vertexId = indices[indexId];
            result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);
            // Send vector to decal local world
            result.position = Vector3.TransformCoordinates(result.position, transformMatrix);
            // Get normal
            result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);
            result.normal = Vector3.TransformNormal(result.normal, transformMatrix);
            return result;
        }; // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js
        var clip = function (vertices, axis) {
            if (vertices.length === 0) {
                return vertices;
            }
            var clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));
            var clipVertices = function (v0, v1) {
                var clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);
                return new PositionNormalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor));
            };
            var result = new Array();
            for (var index = 0; index < vertices.length; index += 3) {
                var v1Out;
                var v2Out;
                var v3Out;
                var total = 0;
                var nV1 = null;
                var nV2 = null;
                var nV3 = null;
                var nV4 = null;
                var d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;
                var d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;
                var d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;
                v1Out = d1 > 0;
                v2Out = d2 > 0;
                v3Out = d3 > 0;
                total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
                switch (total) {
                    case 0:
                        result.push(vertices[index]);
                        result.push(vertices[index + 1]);
                        result.push(vertices[index + 2]);
                        break;
                    case 1:
                        if (v1Out) {
                            nV1 = vertices[index + 1];
                            nV2 = vertices[index + 2];
                            nV3 = clipVertices(vertices[index], nV1);
                            nV4 = clipVertices(vertices[index], nV2);
                        }
                        if (v2Out) {
                            nV1 = vertices[index];
                            nV2 = vertices[index + 2];
                            nV3 = clipVertices(vertices[index + 1], nV1);
                            nV4 = clipVertices(vertices[index + 1], nV2);
                            result.push(nV3);
                            result.push(nV2.clone());
                            result.push(nV1.clone());
                            result.push(nV2.clone());
                            result.push(nV3.clone());
                            result.push(nV4);
                            break;
                        }
                        if (v3Out) {
                            nV1 = vertices[index];
                            nV2 = vertices[index + 1];
                            nV3 = clipVertices(vertices[index + 2], nV1);
                            nV4 = clipVertices(vertices[index + 2], nV2);
                        }
                        if (nV1 && nV2 && nV3 && nV4) {
                            result.push(nV1.clone());
                            result.push(nV2.clone());
                            result.push(nV3);
                            result.push(nV4);
                            result.push(nV3.clone());
                            result.push(nV2.clone());
                        }
                        break;
                    case 2:
                        if (!v1Out) {
                            nV1 = vertices[index].clone();
                            nV2 = clipVertices(nV1, vertices[index + 1]);
                            nV3 = clipVertices(nV1, vertices[index + 2]);
                            result.push(nV1);
                            result.push(nV2);
                            result.push(nV3);
                        }
                        if (!v2Out) {
                            nV1 = vertices[index + 1].clone();
                            nV2 = clipVertices(nV1, vertices[index + 2]);
                            nV3 = clipVertices(nV1, vertices[index]);
                            result.push(nV1);
                            result.push(nV2);
                            result.push(nV3);
                        }
                        if (!v3Out) {
                            nV1 = vertices[index + 2].clone();
                            nV2 = clipVertices(nV1, vertices[index]);
                            nV3 = clipVertices(nV1, vertices[index + 1]);
                            result.push(nV1);
                            result.push(nV2);
                            result.push(nV3);
                        }
                        break;
                }
            }
            return result;
        };
        for (var index = 0; index < indices.length; index += 3) {
            var faceVertices = new Array();
            faceVertices.push(extractDecalVector3(index));
            faceVertices.push(extractDecalVector3(index + 1));
            faceVertices.push(extractDecalVector3(index + 2));
            // Clip
            faceVertices = clip(faceVertices, new Vector3(1, 0, 0));
            faceVertices = clip(faceVertices, new Vector3(-1, 0, 0));
            faceVertices = clip(faceVertices, new Vector3(0, 1, 0));
            faceVertices = clip(faceVertices, new Vector3(0, -1, 0));
            faceVertices = clip(faceVertices, new Vector3(0, 0, 1));
            faceVertices = clip(faceVertices, new Vector3(0, 0, -1));
            if (faceVertices.length === 0) {
                continue;
            }
            // Add UVs and get back to world
            for (var vIndex = 0; vIndex < faceVertices.length; vIndex++) {
                var vertex = faceVertices[vIndex];
                //TODO check for Int32Array | Uint32Array | Uint16Array
                vertexData.indices.push(currentVertexDataIndex);
                vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);
                vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);
                vertexData.uvs.push(0.5 + vertex.position.x / size.x);
                vertexData.uvs.push(0.5 + vertex.position.y / size.y);
                currentVertexDataIndex++;
            }
        }
        // Return mesh
        var decal = new Mesh(name, sourceMesh.getScene());
        vertexData.applyToMesh(decal);
        decal.position = position.clone();
        decal.rotation = new Vector3(pitch, yaw, angle);
        return decal;
    };
    return DecalBuilder;
}());

/**
 * Class containing static functions to help procedurally build meshes
 */
var MeshBuilder = /** @class */ (function () {
    function MeshBuilder() {
    }
    /**
     * Creates a box mesh
     * * The parameter `size` sets the size (float) of each box side (default 1)
     * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)
     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
     * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @see https://doc.babylonjs.com/how_to/set_shapes#box
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the box mesh
     */
    MeshBuilder.CreateBox = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return BoxBuilder.CreateBox(name, options, scene);
    };
    /**
     * Creates a sphere mesh
     * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
     * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)
     * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
     * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
     * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the sphere mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#sphere
     */
    MeshBuilder.CreateSphere = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return SphereBuilder.CreateSphere(name, options, scene);
    };
    /**
     * Creates a plane polygonal mesh.  By default, this is a disc
     * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
     * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
     * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the plane polygonal mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
     */
    MeshBuilder.CreateDisc = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return DiscBuilder.CreateDisc(name, options, scene);
    };
    /**
     * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
     * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
     * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)
     * * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
     * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the icosahedron mesh
     * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
     */
    MeshBuilder.CreateIcoSphere = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return IcoSphereBuilder.CreateIcoSphere(name, options, scene);
    };
    /**
     * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
     * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
     * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
     * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
     * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
     * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
     * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
     * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
     * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
     * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
     * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the ribbon mesh
     * @see https://doc.babylonjs.com/how_to/ribbon_tutorial
     * @see https://doc.babylonjs.com/how_to/parametric_shapes
     */
    MeshBuilder.CreateRibbon = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return RibbonBuilder.CreateRibbon(name, options, scene);
    };
    /**
     * Creates a cylinder or a cone mesh
     * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
     * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
     * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
     * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
     * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
     * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
     * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
     * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
     * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
     * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
     * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
     * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
     * * If `enclose` is false, a ring surface is one element.
     * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
     * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the cylinder mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone
     */
    MeshBuilder.CreateCylinder = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return CylinderBuilder.CreateCylinder(name, options, scene);
    };
    /**
     * Creates a torus mesh
     * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
     * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
     * * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the torus mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#torus
     */
    MeshBuilder.CreateTorus = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return TorusBuilder.CreateTorus(name, options, scene);
    };
    /**
     * Creates a torus knot mesh
     * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
     * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
     * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
     * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the torus knot mesh
     * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot
     */
    MeshBuilder.CreateTorusKnot = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return TorusKnotBuilder.CreateTorusKnot(name, options, scene);
    };
    /**
     * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
     * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
     * * The parameter `lines` is an array of lines, each line being an array of successive Vector3
     * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
     * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
     * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
     * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system
     * @param name defines the name of the new line system
     * @param options defines the options used to create the line system
     * @param scene defines the hosting scene
     * @returns a new line system mesh
     */
    MeshBuilder.CreateLineSystem = function (name, options, scene) {
        return LinesBuilder.CreateLineSystem(name, options, scene);
    };
    /**
     * Creates a line mesh
     * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
     * * The parameter `points` is an array successive Vector3
     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
     * * The optional parameter `colors` is an array of successive Color4, one per line point
     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
     * * When updating an instance, remember that only point positions can change, not the number of points
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines
     * @param name defines the name of the new line system
     * @param options defines the options used to create the line system
     * @param scene defines the hosting scene
     * @returns a new line mesh
     */
    MeshBuilder.CreateLines = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return LinesBuilder.CreateLines(name, options, scene);
    };
    /**
     * Creates a dashed line mesh
     * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
     * * The parameter `points` is an array successive Vector3
     * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
     * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
     * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
     * * When updating an instance, remember that only point positions can change, not the number of points
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the dashed line mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines
     */
    MeshBuilder.CreateDashedLines = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return LinesBuilder.CreateDashedLines(name, options, scene);
    };
    /**
     * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
     * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
     * * The parameter `scale` (float, default 1) is the value to scale the shape.
     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the extruded shape mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
     */
    MeshBuilder.ExtrudeShape = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return ShapeBuilder.ExtrudeShape(name, options, scene);
    };
    /**
     * Creates an custom extruded shape mesh.
     * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
     * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
     * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
     * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
     * * It must returns a float value that will be the scale value applied to the shape on each path point
     * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
     * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the custom extruded shape mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes
     * @see https://doc.babylonjs.com/how_to/parametric_shapes
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
     */
    MeshBuilder.ExtrudeShapeCustom = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return ShapeBuilder.ExtrudeShapeCustom(name, options, scene);
    };
    /**
     * Creates lathe mesh.
     * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
     * * The parameter `radius` (positive float, default 1) is the radius value of the lathe
     * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
     * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides
     * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
     * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the lathe mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe
     */
    MeshBuilder.CreateLathe = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return LatheBuilder.CreateLathe(name, options, scene);
    };
    /**
     * Creates a plane mesh
     * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
     * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)
     * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the plane mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#plane
     */
    MeshBuilder.CreatePlane = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return PlaneBuilder.CreatePlane(name, options, scene);
    };
    /**
     * Creates a ground mesh
     * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
     * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the ground mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#ground
     */
    MeshBuilder.CreateGround = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return GroundBuilder.CreateGround(name, options, scene);
    };
    /**
     * Creates a tiled ground mesh
     * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
     * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
     * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
     * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the tiled ground mesh
     * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground
     */
    MeshBuilder.CreateTiledGround = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return GroundBuilder.CreateTiledGround(name, options, scene);
    };
    /**
     * Creates a ground mesh from a height map
     * * The parameter `url` sets the URL of the height map image resource.
     * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
     * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
     * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
     * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
     * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
     * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
     * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
     * @param name defines the name of the mesh
     * @param url defines the url to the height map
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the ground mesh
     * @see https://doc.babylonjs.com/babylon101/height_map
     * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map
     */
    MeshBuilder.CreateGroundFromHeightMap = function (name, url, options, scene) {
        if (scene === void 0) { scene = null; }
        return GroundBuilder.CreateGroundFromHeightMap(name, url, options, scene);
    };
    /**
     * Creates a polygon mesh
     * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
     * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
     * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
     * * Remember you can only change the shape positions, not their number when updating a polygon
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @param earcutInjection can be used to inject your own earcut reference
     * @returns the polygon mesh
     */
    MeshBuilder.CreatePolygon = function (name, options, scene, earcutInjection) {
        if (scene === void 0) { scene = null; }
        if (earcutInjection === void 0) { earcutInjection = earcut; }
        return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);
    };
    /**
     * Creates an extruded polygon mesh, with depth in the Y direction.
     * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)
     * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @param earcutInjection can be used to inject your own earcut reference
     * @returns the polygon mesh
     */
    MeshBuilder.ExtrudePolygon = function (name, options, scene, earcutInjection) {
        if (scene === void 0) { scene = null; }
        if (earcutInjection === void 0) { earcutInjection = earcut; }
        return PolygonBuilder.ExtrudePolygon(name, options, scene, earcutInjection);
    };
    /**
     * Creates a tube mesh.
     * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
     * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
     * * The parameter `radius` (positive float, default 1) sets the tube radius size
     * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
     * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
     * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
     * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
     * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the tube mesh
     * @see https://doc.babylonjs.com/how_to/parametric_shapes
     * @see https://doc.babylonjs.com/how_to/set_shapes#tube
     */
    MeshBuilder.CreateTube = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return TubeBuilder.CreateTube(name, options, scene);
    };
    /**
     * Creates a polyhedron mesh
     * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
     * * The parameter `size` (positive float, default 1) sets the polygon size
     * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
     * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
     * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
     * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
     * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
     * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
     * @param name defines the name of the mesh
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the polyhedron mesh
     * @see https://doc.babylonjs.com/how_to/polyhedra_shapes
     */
    MeshBuilder.CreatePolyhedron = function (name, options, scene) {
        if (scene === void 0) { scene = null; }
        return PolyhedronBuilder.CreatePolyhedron(name, options, scene);
    };
    /**
     * Creates a decal mesh.
     * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
     * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
     * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
     * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
     * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal
     * @param name defines the name of the mesh
     * @param sourceMesh defines the mesh where the decal must be applied
     * @param options defines the options used to create the mesh
     * @param scene defines the hosting scene
     * @returns the decal mesh
     * @see https://doc.babylonjs.com/how_to/decals
     */
    MeshBuilder.CreateDecal = function (name, sourceMesh, options) {
        return DecalBuilder.CreateDecal(name, sourceMesh, options);
    };
    return MeshBuilder;
}());

/**
 * Class used to specify simplification options
 * @see http://doc.babylonjs.com/how_to/in-browser_mesh_simplification
 */
var SimplificationSettings = /** @class */ (function () {
    /**
     * Creates a SimplificationSettings
     * @param quality expected quality
     * @param distance distance when this optimized version should be used
     * @param optimizeMesh already optimized mesh
     */
    function SimplificationSettings(
    /** expected quality */
    quality, 
    /** distance when this optimized version should be used */
    distance, 
    /** already optimized mesh  */
    optimizeMesh) {
        this.quality = quality;
        this.distance = distance;
        this.optimizeMesh = optimizeMesh;
    }
    return SimplificationSettings;
}());
/**
 * Queue used to order the simplification tasks
 * @see http://doc.babylonjs.com/how_to/in-browser_mesh_simplification
 */
var SimplificationQueue = /** @class */ (function () {
    /**
     * Creates a new queue
     */
    function SimplificationQueue() {
        this.running = false;
        this._simplificationArray = [];
    }
    /**
     * Adds a new simplification task
     * @param task defines a task to add
     */
    SimplificationQueue.prototype.addTask = function (task) {
        this._simplificationArray.push(task);
    };
    /**
     * Execute next task
     */
    SimplificationQueue.prototype.executeNext = function () {
        var task = this._simplificationArray.pop();
        if (task) {
            this.running = true;
            this.runSimplification(task);
        }
        else {
            this.running = false;
        }
    };
    /**
     * Execute a simplification task
     * @param task defines the task to run
     */
    SimplificationQueue.prototype.runSimplification = function (task) {
        var _this = this;
        if (task.parallelProcessing) {
            //parallel simplifier
            task.settings.forEach(function (setting) {
                var simplifier = _this.getSimplifier(task);
                simplifier.simplify(setting, function (newMesh) {
                    task.mesh.addLODLevel(setting.distance, newMesh);
                    newMesh.isVisible = true;
                    //check if it is the last
                    if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {
                        //all done, run the success callback.
                        task.successCallback();
                    }
                    _this.executeNext();
                });
            });
        }
        else {
            //single simplifier.
            var simplifier = this.getSimplifier(task);
            var runDecimation = function (setting, callback) {
                simplifier.simplify(setting, function (newMesh) {
                    task.mesh.addLODLevel(setting.distance, newMesh);
                    newMesh.isVisible = true;
                    //run the next quality level
                    callback();
                });
            };
            AsyncLoop.Run(task.settings.length, function (loop) {
                runDecimation(task.settings[loop.index], function () {
                    loop.executeNext();
                });
            }, function () {
                //execution ended, run the success callback.
                if (task.successCallback) {
                    task.successCallback();
                }
                _this.executeNext();
            });
        }
    };
    SimplificationQueue.prototype.getSimplifier = function (task) {
        switch (task.simplificationType) {
            case SimplificationType.QUADRATIC:
            default:
                return new QuadraticErrorSimplification(task.mesh);
        }
    };
    return SimplificationQueue;
}());
/**
 * The implemented types of simplification
 * At the moment only Quadratic Error Decimation is implemented
 * @see http://doc.babylonjs.com/how_to/in-browser_mesh_simplification
 */
var SimplificationType;
(function (SimplificationType) {
    /** Quadratic error decimation */
    SimplificationType[SimplificationType["QUADRATIC"] = 0] = "QUADRATIC";
})(SimplificationType || (SimplificationType = {}));
var DecimationTriangle = /** @class */ (function () {
    function DecimationTriangle(vertices) {
        this.vertices = vertices;
        this.error = new Array(4);
        this.deleted = false;
        this.isDirty = false;
        this.deletePending = false;
        this.borderFactor = 0;
    }
    return DecimationTriangle;
}());
var DecimationVertex = /** @class */ (function () {
    function DecimationVertex(position, id) {
        this.position = position;
        this.id = id;
        this.isBorder = true;
        this.q = new QuadraticMatrix();
        this.triangleCount = 0;
        this.triangleStart = 0;
        this.originalOffsets = [];
    }
    DecimationVertex.prototype.updatePosition = function (newPosition) {
        this.position.copyFrom(newPosition);
    };
    return DecimationVertex;
}());
var QuadraticMatrix = /** @class */ (function () {
    function QuadraticMatrix(data) {
        this.data = new Array(10);
        for (var i = 0; i < 10; ++i) {
            if (data && data[i]) {
                this.data[i] = data[i];
            }
            else {
                this.data[i] = 0;
            }
        }
    }
    QuadraticMatrix.prototype.det = function (a11, a12, a13, a21, a22, a23, a31, a32, a33) {
        var det = this.data[a11] * this.data[a22] * this.data[a33] + this.data[a13] * this.data[a21] * this.data[a32] +
            this.data[a12] * this.data[a23] * this.data[a31] - this.data[a13] * this.data[a22] * this.data[a31] -
            this.data[a11] * this.data[a23] * this.data[a32] - this.data[a12] * this.data[a21] * this.data[a33];
        return det;
    };
    QuadraticMatrix.prototype.addInPlace = function (matrix) {
        for (var i = 0; i < 10; ++i) {
            this.data[i] += matrix.data[i];
        }
    };
    QuadraticMatrix.prototype.addArrayInPlace = function (data) {
        for (var i = 0; i < 10; ++i) {
            this.data[i] += data[i];
        }
    };
    QuadraticMatrix.prototype.add = function (matrix) {
        var m = new QuadraticMatrix();
        for (var i = 0; i < 10; ++i) {
            m.data[i] = this.data[i] + matrix.data[i];
        }
        return m;
    };
    QuadraticMatrix.FromData = function (a, b, c, d) {
        return new QuadraticMatrix(QuadraticMatrix.DataFromNumbers(a, b, c, d));
    };
    //returning an array to avoid garbage collection
    QuadraticMatrix.DataFromNumbers = function (a, b, c, d) {
        return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];
    };
    return QuadraticMatrix;
}());
var Reference = /** @class */ (function () {
    function Reference(vertexId, triangleId) {
        this.vertexId = vertexId;
        this.triangleId = triangleId;
    }
    return Reference;
}());
/**
 * An implementation of the Quadratic Error simplification algorithm.
 * Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf
 * Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS
 * @author RaananW
 * @see http://doc.babylonjs.com/how_to/in-browser_mesh_simplification
 */
var QuadraticErrorSimplification = /** @class */ (function () {
    function QuadraticErrorSimplification(_mesh) {
        this._mesh = _mesh;
        this.syncIterations = 5000;
        this.aggressiveness = 7;
        this.decimationIterations = 100;
        this.boundingBoxEpsilon = Epsilon;
    }
    QuadraticErrorSimplification.prototype.simplify = function (settings, successCallback) {
        var _this = this;
        this.initDecimatedMesh();
        //iterating through the submeshes array, one after the other.
        AsyncLoop.Run(this._mesh.subMeshes.length, function (loop) {
            _this.initWithMesh(loop.index, function () {
                _this.runDecimation(settings, loop.index, function () {
                    loop.executeNext();
                });
            }, settings.optimizeMesh);
        }, function () {
            setTimeout(function () {
                successCallback(_this._reconstructedMesh);
            }, 0);
        });
    };
    QuadraticErrorSimplification.prototype.runDecimation = function (settings, submeshIndex, successCallback) {
        var _this = this;
        var targetCount = ~~(this.triangles.length * settings.quality);
        var deletedTriangles = 0;
        var triangleCount = this.triangles.length;
        var iterationFunction = function (iteration, callback) {
            setTimeout(function () {
                if (iteration % 5 === 0) {
                    _this.updateMesh(iteration === 0);
                }
                for (var i = 0; i < _this.triangles.length; ++i) {
                    _this.triangles[i].isDirty = false;
                }
                var threshold = 0.000000001 * Math.pow((iteration + 3), _this.aggressiveness);
                var trianglesIterator = function (i) {
                    var tIdx = ~~(((_this.triangles.length / 2) + i) % _this.triangles.length);
                    var t = _this.triangles[tIdx];
                    if (!t) {
                        return;
                    }
                    if (t.error[3] > threshold || t.deleted || t.isDirty) {
                        return;
                    }
                    for (var j = 0; j < 3; ++j) {
                        if (t.error[j] < threshold) {
                            var deleted0 = [];
                            var deleted1 = [];
                            var v0 = t.vertices[j];
                            var v1 = t.vertices[(j + 1) % 3];
                            if (v0.isBorder || v1.isBorder) {
                                continue;
                            }
                            var p = Vector3.Zero();
                            // var n = Vector3.Zero();
                            // var uv = Vector2.Zero();
                            // var color = new Color4(0, 0, 0, 1);
                            _this.calculateError(v0, v1, p);
                            var delTr = new Array();
                            if (_this.isFlipped(v0, v1, p, deleted0, delTr)) {
                                continue;
                            }
                            if (_this.isFlipped(v1, v0, p, deleted1, delTr)) {
                                continue;
                            }
                            if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {
                                continue;
                            }
                            var uniqueArray = new Array();
                            delTr.forEach(function (deletedT) {
                                if (uniqueArray.indexOf(deletedT) === -1) {
                                    deletedT.deletePending = true;
                                    uniqueArray.push(deletedT);
                                }
                            });
                            if (uniqueArray.length % 2 !== 0) {
                                continue;
                            }
                            v0.q = v1.q.add(v0.q);
                            v0.updatePosition(p);
                            var tStart = _this.references.length;
                            deletedTriangles = _this.updateTriangles(v0, v0, deleted0, deletedTriangles);
                            deletedTriangles = _this.updateTriangles(v0, v1, deleted1, deletedTriangles);
                            var tCount = _this.references.length - tStart;
                            if (tCount <= v0.triangleCount) {
                                if (tCount) {
                                    for (var c = 0; c < tCount; c++) {
                                        _this.references[v0.triangleStart + c] = _this.references[tStart + c];
                                    }
                                }
                            }
                            else {
                                v0.triangleStart = tStart;
                            }
                            v0.triangleCount = tCount;
                            break;
                        }
                    }
                };
                AsyncLoop.SyncAsyncForLoop(_this.triangles.length, _this.syncIterations, trianglesIterator, callback, function () { return (triangleCount - deletedTriangles <= targetCount); });
            }, 0);
        };
        AsyncLoop.Run(this.decimationIterations, function (loop) {
            if (triangleCount - deletedTriangles <= targetCount) {
                loop.breakLoop();
            }
            else {
                iterationFunction(loop.index, function () {
                    loop.executeNext();
                });
            }
        }, function () {
            setTimeout(function () {
                //reconstruct this part of the mesh
                _this.reconstructMesh(submeshIndex);
                successCallback();
            }, 0);
        });
    };
    QuadraticErrorSimplification.prototype.initWithMesh = function (submeshIndex, callback, optimizeMesh) {
        var _this = this;
        this.vertices = [];
        this.triangles = [];
        var positionData = this._mesh.getVerticesData(VertexBuffer.PositionKind);
        var indices = this._mesh.getIndices();
        var submesh = this._mesh.subMeshes[submeshIndex];
        var findInVertices = function (positionToSearch) {
            if (optimizeMesh) {
                for (var ii = 0; ii < _this.vertices.length; ++ii) {
                    if (_this.vertices[ii].position.equals(positionToSearch)) {
                        return _this.vertices[ii];
                    }
                }
            }
            return null;
        };
        var vertexReferences = [];
        var vertexInit = function (i) {
            if (!positionData) {
                return;
            }
            var offset = i + submesh.verticesStart;
            var position = Vector3.FromArray(positionData, offset * 3);
            var vertex = findInVertices(position) || new DecimationVertex(position, _this.vertices.length);
            vertex.originalOffsets.push(offset);
            if (vertex.id === _this.vertices.length) {
                _this.vertices.push(vertex);
            }
            vertexReferences.push(vertex.id);
        };
        //var totalVertices = mesh.getTotalVertices();
        var totalVertices = submesh.verticesCount;
        AsyncLoop.SyncAsyncForLoop(totalVertices, (this.syncIterations / 4) >> 0, vertexInit, function () {
            var indicesInit = function (i) {
                if (!indices) {
                    return;
                }
                var offset = (submesh.indexStart / 3) + i;
                var pos = (offset * 3);
                var i0 = indices[pos + 0];
                var i1 = indices[pos + 1];
                var i2 = indices[pos + 2];
                var v0 = _this.vertices[vertexReferences[i0 - submesh.verticesStart]];
                var v1 = _this.vertices[vertexReferences[i1 - submesh.verticesStart]];
                var v2 = _this.vertices[vertexReferences[i2 - submesh.verticesStart]];
                var triangle = new DecimationTriangle([v0, v1, v2]);
                triangle.originalOffset = pos;
                _this.triangles.push(triangle);
            };
            AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, _this.syncIterations, indicesInit, function () {
                _this.init(callback);
            });
        });
    };
    QuadraticErrorSimplification.prototype.init = function (callback) {
        var _this = this;
        var triangleInit1 = function (i) {
            var t = _this.triangles[i];
            t.normal = Vector3.Cross(t.vertices[1].position.subtract(t.vertices[0].position), t.vertices[2].position.subtract(t.vertices[0].position)).normalize();
            for (var j = 0; j < 3; j++) {
                t.vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -(Vector3.Dot(t.normal, t.vertices[0].position))));
            }
        };
        AsyncLoop.SyncAsyncForLoop(this.triangles.length, this.syncIterations, triangleInit1, function () {
            var triangleInit2 = function (i) {
                var t = _this.triangles[i];
                for (var j = 0; j < 3; ++j) {
                    t.error[j] = _this.calculateError(t.vertices[j], t.vertices[(j + 1) % 3]);
                }
                t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
            };
            AsyncLoop.SyncAsyncForLoop(_this.triangles.length, _this.syncIterations, triangleInit2, function () {
                callback();
            });
        });
    };
    QuadraticErrorSimplification.prototype.reconstructMesh = function (submeshIndex) {
        var newTriangles = [];
        var i;
        for (i = 0; i < this.vertices.length; ++i) {
            this.vertices[i].triangleCount = 0;
        }
        var t;
        var j;
        for (i = 0; i < this.triangles.length; ++i) {
            if (!this.triangles[i].deleted) {
                t = this.triangles[i];
                for (j = 0; j < 3; ++j) {
                    t.vertices[j].triangleCount = 1;
                }
                newTriangles.push(t);
            }
        }
        var newPositionData = (this._reconstructedMesh.getVerticesData(VertexBuffer.PositionKind) || []);
        var newNormalData = (this._reconstructedMesh.getVerticesData(VertexBuffer.NormalKind) || []);
        var newUVsData = (this._reconstructedMesh.getVerticesData(VertexBuffer.UVKind) || []);
        var newColorsData = (this._reconstructedMesh.getVerticesData(VertexBuffer.ColorKind) || []);
        var normalData = this._mesh.getVerticesData(VertexBuffer.NormalKind);
        var uvs = this._mesh.getVerticesData(VertexBuffer.UVKind);
        var colorsData = this._mesh.getVerticesData(VertexBuffer.ColorKind);
        var vertexCount = 0;
        for (i = 0; i < this.vertices.length; ++i) {
            var vertex = this.vertices[i];
            vertex.id = vertexCount;
            if (vertex.triangleCount) {
                vertex.originalOffsets.forEach(function (originalOffset) {
                    if (!normalData) {
                        return;
                    }
                    newPositionData.push(vertex.position.x);
                    newPositionData.push(vertex.position.y);
                    newPositionData.push(vertex.position.z);
                    newNormalData.push(normalData[originalOffset * 3]);
                    newNormalData.push(normalData[(originalOffset * 3) + 1]);
                    newNormalData.push(normalData[(originalOffset * 3) + 2]);
                    if (uvs && uvs.length) {
                        newUVsData.push(uvs[(originalOffset * 2)]);
                        newUVsData.push(uvs[(originalOffset * 2) + 1]);
                    }
                    if (colorsData && colorsData.length) {
                        newColorsData.push(colorsData[(originalOffset * 4)]);
                        newColorsData.push(colorsData[(originalOffset * 4) + 1]);
                        newColorsData.push(colorsData[(originalOffset * 4) + 2]);
                        newColorsData.push(colorsData[(originalOffset * 4) + 3]);
                    }
                    ++vertexCount;
                });
            }
        }
        var startingIndex = this._reconstructedMesh.getTotalIndices();
        var startingVertex = this._reconstructedMesh.getTotalVertices();
        var submeshesArray = this._reconstructedMesh.subMeshes;
        this._reconstructedMesh.subMeshes = [];
        var newIndicesArray = this._reconstructedMesh.getIndices(); //[];
        var originalIndices = this._mesh.getIndices();
        for (i = 0; i < newTriangles.length; ++i) {
            t = newTriangles[i]; //now get the new referencing point for each vertex
            [0, 1, 2].forEach(function (idx) {
                var id = originalIndices[t.originalOffset + idx];
                var offset = t.vertices[idx].originalOffsets.indexOf(id);
                if (offset < 0) {
                    offset = 0;
                }
                newIndicesArray.push(t.vertices[idx].id + offset + startingVertex);
            });
        }
        //overwriting the old vertex buffers and indices.
        this._reconstructedMesh.setIndices(newIndicesArray);
        this._reconstructedMesh.setVerticesData(VertexBuffer.PositionKind, newPositionData);
        this._reconstructedMesh.setVerticesData(VertexBuffer.NormalKind, newNormalData);
        if (newUVsData.length > 0) {
            this._reconstructedMesh.setVerticesData(VertexBuffer.UVKind, newUVsData);
        }
        if (newColorsData.length > 0) {
            this._reconstructedMesh.setVerticesData(VertexBuffer.ColorKind, newColorsData);
        }
        //create submesh
        var originalSubmesh = this._mesh.subMeshes[submeshIndex];
        if (submeshIndex > 0) {
            this._reconstructedMesh.subMeshes = [];
            submeshesArray.forEach(function (submesh) {
                SubMesh.AddToMesh(submesh.materialIndex, submesh.verticesStart, submesh.verticesCount, /* 0, newPositionData.length/3, */ submesh.indexStart, submesh.indexCount, submesh.getMesh());
            });
            SubMesh.AddToMesh(originalSubmesh.materialIndex, startingVertex, vertexCount, /* 0, newPositionData.length / 3, */ startingIndex, newTriangles.length * 3, this._reconstructedMesh);
        }
    };
    QuadraticErrorSimplification.prototype.initDecimatedMesh = function () {
        this._reconstructedMesh = new Mesh(this._mesh.name + "Decimated", this._mesh.getScene());
        this._reconstructedMesh.material = this._mesh.material;
        this._reconstructedMesh.parent = this._mesh.parent;
        this._reconstructedMesh.isVisible = false;
        this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;
    };
    QuadraticErrorSimplification.prototype.isFlipped = function (vertex1, vertex2, point, deletedArray, delTr) {
        for (var i = 0; i < vertex1.triangleCount; ++i) {
            var t = this.triangles[this.references[vertex1.triangleStart + i].triangleId];
            if (t.deleted) {
                continue;
            }
            var s = this.references[vertex1.triangleStart + i].vertexId;
            var v1 = t.vertices[(s + 1) % 3];
            var v2 = t.vertices[(s + 2) % 3];
            if ((v1 === vertex2 || v2 === vertex2)) {
                deletedArray[i] = true;
                delTr.push(t);
                continue;
            }
            var d1 = v1.position.subtract(point);
            d1 = d1.normalize();
            var d2 = v2.position.subtract(point);
            d2 = d2.normalize();
            if (Math.abs(Vector3.Dot(d1, d2)) > 0.999) {
                return true;
            }
            var normal = Vector3.Cross(d1, d2).normalize();
            deletedArray[i] = false;
            if (Vector3.Dot(normal, t.normal) < 0.2) {
                return true;
            }
        }
        return false;
    };
    QuadraticErrorSimplification.prototype.updateTriangles = function (origVertex, vertex, deletedArray, deletedTriangles) {
        var newDeleted = deletedTriangles;
        for (var i = 0; i < vertex.triangleCount; ++i) {
            var ref = this.references[vertex.triangleStart + i];
            var t = this.triangles[ref.triangleId];
            if (t.deleted) {
                continue;
            }
            if (deletedArray[i] && t.deletePending) {
                t.deleted = true;
                newDeleted++;
                continue;
            }
            t.vertices[ref.vertexId] = origVertex;
            t.isDirty = true;
            t.error[0] = this.calculateError(t.vertices[0], t.vertices[1]) + (t.borderFactor / 2);
            t.error[1] = this.calculateError(t.vertices[1], t.vertices[2]) + (t.borderFactor / 2);
            t.error[2] = this.calculateError(t.vertices[2], t.vertices[0]) + (t.borderFactor / 2);
            t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
            this.references.push(ref);
        }
        return newDeleted;
    };
    QuadraticErrorSimplification.prototype.identifyBorder = function () {
        for (var i = 0; i < this.vertices.length; ++i) {
            var vCount = [];
            var vId = [];
            var v = this.vertices[i];
            var j;
            for (j = 0; j < v.triangleCount; ++j) {
                var triangle = this.triangles[this.references[v.triangleStart + j].triangleId];
                for (var ii = 0; ii < 3; ii++) {
                    var ofs = 0;
                    var vv = triangle.vertices[ii];
                    while (ofs < vCount.length) {
                        if (vId[ofs] === vv.id) {
                            break;
                        }
                        ++ofs;
                    }
                    if (ofs === vCount.length) {
                        vCount.push(1);
                        vId.push(vv.id);
                    }
                    else {
                        vCount[ofs]++;
                    }
                }
            }
            for (j = 0; j < vCount.length; ++j) {
                if (vCount[j] === 1) {
                    this.vertices[vId[j]].isBorder = true;
                }
                else {
                    this.vertices[vId[j]].isBorder = false;
                }
            }
        }
    };
    QuadraticErrorSimplification.prototype.updateMesh = function (identifyBorders) {
        if (identifyBorders === void 0) { identifyBorders = false; }
        var i;
        if (!identifyBorders) {
            var newTrianglesVector = [];
            for (i = 0; i < this.triangles.length; ++i) {
                if (!this.triangles[i].deleted) {
                    newTrianglesVector.push(this.triangles[i]);
                }
            }
            this.triangles = newTrianglesVector;
        }
        for (i = 0; i < this.vertices.length; ++i) {
            this.vertices[i].triangleCount = 0;
            this.vertices[i].triangleStart = 0;
        }
        var t;
        var j;
        var v;
        for (i = 0; i < this.triangles.length; ++i) {
            t = this.triangles[i];
            for (j = 0; j < 3; ++j) {
                v = t.vertices[j];
                v.triangleCount++;
            }
        }
        var tStart = 0;
        for (i = 0; i < this.vertices.length; ++i) {
            this.vertices[i].triangleStart = tStart;
            tStart += this.vertices[i].triangleCount;
            this.vertices[i].triangleCount = 0;
        }
        var newReferences = new Array(this.triangles.length * 3);
        for (i = 0; i < this.triangles.length; ++i) {
            t = this.triangles[i];
            for (j = 0; j < 3; ++j) {
                v = t.vertices[j];
                newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);
                v.triangleCount++;
            }
        }
        this.references = newReferences;
        if (identifyBorders) {
            this.identifyBorder();
        }
    };
    QuadraticErrorSimplification.prototype.vertexError = function (q, point) {
        var x = point.x;
        var y = point.y;
        var z = point.z;
        return q.data[0] * x * x + 2 * q.data[1] * x * y + 2 * q.data[2] * x * z + 2 * q.data[3] * x + q.data[4] * y * y
            + 2 * q.data[5] * y * z + 2 * q.data[6] * y + q.data[7] * z * z + 2 * q.data[8] * z + q.data[9];
    };
    QuadraticErrorSimplification.prototype.calculateError = function (vertex1, vertex2, pointResult) {
        var q = vertex1.q.add(vertex2.q);
        var border = vertex1.isBorder && vertex2.isBorder;
        var error = 0;
        var qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);
        if (qDet !== 0 && !border) {
            if (!pointResult) {
                pointResult = Vector3.Zero();
            }
            pointResult.x = -1 / qDet * (q.det(1, 2, 3, 4, 5, 6, 5, 7, 8));
            pointResult.y = 1 / qDet * (q.det(0, 2, 3, 1, 5, 6, 2, 7, 8));
            pointResult.z = -1 / qDet * (q.det(0, 1, 3, 1, 4, 6, 2, 5, 8));
            error = this.vertexError(q, pointResult);
        }
        else {
            var p3 = (vertex1.position.add(vertex2.position)).divide(new Vector3(2, 2, 2));
            //var norm3 = (vertex1.normal.add(vertex2.normal)).divide(new Vector3(2, 2, 2)).normalize();
            var error1 = this.vertexError(q, vertex1.position);
            var error2 = this.vertexError(q, vertex2.position);
            var error3 = this.vertexError(q, p3);
            error = Math.min(error1, error2, error3);
            if (error === error1) {
                if (pointResult) {
                    pointResult.copyFrom(vertex1.position);
                }
            }
            else if (error === error2) {
                if (pointResult) {
                    pointResult.copyFrom(vertex2.position);
                }
            }
            else {
                if (pointResult) {
                    pointResult.copyFrom(p3);
                }
            }
        }
        return error;
    };
    return QuadraticErrorSimplification;
}());

Object.defineProperty(Scene.prototype, "simplificationQueue", {
    get: function () {
        if (!this._simplificationQueue) {
            this._simplificationQueue = new SimplificationQueue();
            var component = this._getComponent(SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE);
            if (!component) {
                component = new SimplicationQueueSceneComponent(this);
                this._addComponent(component);
            }
        }
        return this._simplificationQueue;
    },
    set: function (value) {
        this._simplificationQueue = value;
    },
    enumerable: true,
    configurable: true
});
Mesh.prototype.simplify = function (settings, parallelProcessing, simplificationType, successCallback) {
    if (parallelProcessing === void 0) { parallelProcessing = true; }
    if (simplificationType === void 0) { simplificationType = SimplificationType.QUADRATIC; }
    this.getScene().simplificationQueue.addTask({
        settings: settings,
        parallelProcessing: parallelProcessing,
        mesh: this,
        simplificationType: simplificationType,
        successCallback: successCallback
    });
    return this;
};
/**
 * Defines the simplification queue scene component responsible to help scheduling the various simplification task
 * created in a scene
 */
var SimplicationQueueSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function SimplicationQueueSceneComponent(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE;
        this.scene = scene;
    }
    /**
     * Registers the component in a given scene
     */
    SimplicationQueueSceneComponent.prototype.register = function () {
        this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE, this, this._beforeCameraUpdate);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    SimplicationQueueSceneComponent.prototype.rebuild = function () {
        // Nothing to do for this component
    };
    /**
     * Disposes the component and the associated ressources
     */
    SimplicationQueueSceneComponent.prototype.dispose = function () {
        // Nothing to do for this component
    };
    SimplicationQueueSceneComponent.prototype._beforeCameraUpdate = function () {
        if (this.scene._simplificationQueue && !this.scene._simplificationQueue.running) {
            this.scene._simplificationQueue.executeNext();
        }
    };
    return SimplicationQueueSceneComponent;
}());

// Sets the default offline provider to Babylon.js
Engine.OfflineProviderFactory = function (urlToScene, callbackManifestChecked, disableManifestCheck) {
    if (disableManifestCheck === void 0) { disableManifestCheck = false; }
    return new Database(urlToScene, callbackManifestChecked, disableManifestCheck);
};
/**
 * Class used to enable access to IndexedDB
 * @see http://doc.babylonjs.com/how_to/caching_resources_in_indexeddb
 */
var Database = /** @class */ (function () {
    /**
     * Creates a new Database
     * @param urlToScene defines the url to load the scene
     * @param callbackManifestChecked defines the callback to use when manifest is checked
     * @param disableManifestCheck defines a boolean indicating that we want to skip the manifest validation (it will be considered validated and up to date)
     */
    function Database(urlToScene, callbackManifestChecked, disableManifestCheck) {
        var _this = this;
        if (disableManifestCheck === void 0) { disableManifestCheck = false; }
        // Handling various flavors of prefixed version of IndexedDB
        this._idbFactory = (window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB);
        this._callbackManifestChecked = callbackManifestChecked;
        this._currentSceneUrl = Database._ReturnFullUrlLocation(urlToScene);
        this._db = null;
        this._enableSceneOffline = false;
        this._enableTexturesOffline = false;
        this._manifestVersionFound = 0;
        this._mustUpdateRessources = false;
        this._hasReachedQuota = false;
        if (!Database.IDBStorageEnabled) {
            this._callbackManifestChecked(true);
        }
        else {
            if (disableManifestCheck) {
                this._enableSceneOffline = true;
                this._enableTexturesOffline = true;
                this._manifestVersionFound = 1;
                Tools.SetImmediate(function () {
                    _this._callbackManifestChecked(true);
                });
            }
            else {
                this._checkManifestFile();
            }
        }
    }
    Object.defineProperty(Database.prototype, "enableSceneOffline", {
        /**
         * Gets a boolean indicating if scene must be saved in the database
         */
        get: function () {
            return this._enableSceneOffline;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Database.prototype, "enableTexturesOffline", {
        /**
         * Gets a boolean indicating if textures must be saved in the database
         */
        get: function () {
            return this._enableTexturesOffline;
        },
        enumerable: true,
        configurable: true
    });
    Database.prototype._checkManifestFile = function () {
        var _this = this;
        var noManifestFile = function () {
            _this._enableSceneOffline = false;
            _this._enableTexturesOffline = false;
            _this._callbackManifestChecked(false);
        };
        var timeStampUsed = false;
        var manifestURL = this._currentSceneUrl + ".manifest";
        var xhr = new WebRequest();
        if (navigator.onLine) {
            // Adding a timestamp to by-pass browsers' cache
            timeStampUsed = true;
            manifestURL = manifestURL + (manifestURL.match(/\?/) == null ? "?" : "&") + Date.now();
        }
        xhr.open("GET", manifestURL);
        xhr.addEventListener("load", function () {
            if (xhr.status === 200 || Database._ValidateXHRData(xhr, 1)) {
                try {
                    var manifestFile = JSON.parse(xhr.response);
                    _this._enableSceneOffline = manifestFile.enableSceneOffline;
                    _this._enableTexturesOffline = manifestFile.enableTexturesOffline && Database.IsUASupportingBlobStorage;
                    if (manifestFile.version && !isNaN(parseInt(manifestFile.version))) {
                        _this._manifestVersionFound = manifestFile.version;
                    }
                    if (_this._callbackManifestChecked) {
                        _this._callbackManifestChecked(true);
                    }
                }
                catch (ex) {
                    noManifestFile();
                }
            }
            else {
                noManifestFile();
            }
        }, false);
        xhr.addEventListener("error", function () {
            if (timeStampUsed) {
                timeStampUsed = false;
                // Let's retry without the timeStamp
                // It could fail when coupled with HTML5 Offline API
                var retryManifestURL = _this._currentSceneUrl + ".manifest";
                xhr.open("GET", retryManifestURL);
                xhr.send();
            }
            else {
                noManifestFile();
            }
        }, false);
        try {
            xhr.send();
        }
        catch (ex) {
            Logger.Error("Error on XHR send request.");
            this._callbackManifestChecked(false);
        }
    };
    /**
     * Open the database and make it available
     * @param successCallback defines the callback to call on success
     * @param errorCallback defines the callback to call on error
     */
    Database.prototype.open = function (successCallback, errorCallback) {
        var _this = this;
        var handleError = function () {
            _this._isSupported = false;
            if (errorCallback) {
                errorCallback();
            }
        };
        if (!this._idbFactory || !(this._enableSceneOffline || this._enableTexturesOffline)) {
            // Your browser doesn't support IndexedDB
            this._isSupported = false;
            if (errorCallback) {
                errorCallback();
            }
        }
        else {
            // If the DB hasn't been opened or created yet
            if (!this._db) {
                this._hasReachedQuota = false;
                this._isSupported = true;
                var request = this._idbFactory.open("babylonjs", 1);
                // Could occur if user is blocking the quota for the DB and/or doesn't grant access to IndexedDB
                request.onerror = function () {
                    handleError();
                };
                // executes when a version change transaction cannot complete due to other active transactions
                request.onblocked = function () {
                    Logger.Error("IDB request blocked. Please reload the page.");
                    handleError();
                };
                // DB has been opened successfully
                request.onsuccess = function () {
                    _this._db = request.result;
                    successCallback();
                };
                // Initialization of the DB. Creating Scenes & Textures stores
                request.onupgradeneeded = function (event) {
                    _this._db = (event.target).result;
                    if (_this._db) {
                        try {
                            _this._db.createObjectStore("scenes", { keyPath: "sceneUrl" });
                            _this._db.createObjectStore("versions", { keyPath: "sceneUrl" });
                            _this._db.createObjectStore("textures", { keyPath: "textureUrl" });
                        }
                        catch (ex) {
                            Logger.Error("Error while creating object stores. Exception: " + ex.message);
                            handleError();
                        }
                    }
                };
            }
            // DB has already been created and opened
            else {
                if (successCallback) {
                    successCallback();
                }
            }
        }
    };
    /**
     * Loads an image from the database
     * @param url defines the url to load from
     * @param image defines the target DOM image
     */
    Database.prototype.loadImage = function (url, image) {
        var _this = this;
        var completeURL = Database._ReturnFullUrlLocation(url);
        var saveAndLoadImage = function () {
            if (!_this._hasReachedQuota && _this._db !== null) {
                // the texture is not yet in the DB, let's try to save it
                _this._saveImageIntoDBAsync(completeURL, image);
            }
            // If the texture is not in the DB and we've reached the DB quota limit
            // let's load it directly from the web
            else {
                image.src = url;
            }
        };
        if (!this._mustUpdateRessources) {
            this._loadImageFromDBAsync(completeURL, image, saveAndLoadImage);
        }
        // First time we're download the images or update requested in the manifest file by a version change
        else {
            saveAndLoadImage();
        }
    };
    Database.prototype._loadImageFromDBAsync = function (url, image, notInDBCallback) {
        if (this._isSupported && this._db !== null) {
            var texture;
            var transaction = this._db.transaction(["textures"]);
            transaction.onabort = function () {
                image.src = url;
            };
            transaction.oncomplete = function () {
                var blobTextureURL;
                if (texture) {
                    var URL = window.URL || window.webkitURL;
                    blobTextureURL = URL.createObjectURL(texture.data);
                    image.onerror = function () {
                        Logger.Error("Error loading image from blob URL: " + blobTextureURL + " switching back to web url: " + url);
                        image.src = url;
                    };
                    image.src = blobTextureURL;
                }
                else {
                    notInDBCallback();
                }
            };
            var getRequest = transaction.objectStore("textures").get(url);
            getRequest.onsuccess = function (event) {
                texture = (event.target).result;
            };
            getRequest.onerror = function () {
                Logger.Error("Error loading texture " + url + " from DB.");
                image.src = url;
            };
        }
        else {
            Logger.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open.");
            image.src = url;
        }
    };
    Database.prototype._saveImageIntoDBAsync = function (url, image) {
        var _this = this;
        if (this._isSupported) {
            // In case of error (type not supported or quota exceeded), we're at least sending back XHR data to allow texture loading later on
            var generateBlobUrl = function () {
                var blobTextureURL;
                if (blob) {
                    var URL = window.URL || window.webkitURL;
                    try {
                        blobTextureURL = URL.createObjectURL(blob);
                    }
                    // Chrome is raising a type error if we're setting the oneTimeOnly parameter
                    catch (ex) {
                        blobTextureURL = URL.createObjectURL(blob);
                    }
                }
                if (blobTextureURL) {
                    image.src = blobTextureURL;
                }
            };
            if (Database.IsUASupportingBlobStorage) { // Create XHR
                var xhr = new WebRequest(), blob;
                xhr.open("GET", url);
                xhr.responseType = "blob";
                xhr.addEventListener("load", function () {
                    if (xhr.status === 200 && _this._db) {
                        // Blob as response (XHR2)
                        blob = xhr.response;
                        var transaction = _this._db.transaction(["textures"], "readwrite");
                        // the transaction could abort because of a QuotaExceededError error
                        transaction.onabort = function (event) {
                            try {
                                //backwards compatibility with ts 1.0, srcElement doesn't have an "error" according to ts 1.3
                                var srcElement = (event.srcElement || event.target);
                                var error = srcElement.error;
                                if (error && error.name === "QuotaExceededError") {
                                    _this._hasReachedQuota = true;
                                }
                            }
                            catch (ex) { }
                            generateBlobUrl();
                        };
                        transaction.oncomplete = function () {
                            generateBlobUrl();
                        };
                        var newTexture = { textureUrl: url, data: blob };
                        try {
                            // Put the blob into the dabase
                            var addRequest = transaction.objectStore("textures").put(newTexture);
                            addRequest.onsuccess = function () {
                            };
                            addRequest.onerror = function () {
                                generateBlobUrl();
                            };
                        }
                        catch (ex) {
                            // "DataCloneError" generated by Chrome when you try to inject blob into IndexedDB
                            if (ex.code === 25) {
                                Database.IsUASupportingBlobStorage = false;
                                _this._enableTexturesOffline = false;
                            }
                            image.src = url;
                        }
                    }
                    else {
                        image.src = url;
                    }
                }, false);
                xhr.addEventListener("error", function () {
                    Logger.Error("Error in XHR request in BABYLON.Database.");
                    image.src = url;
                }, false);
                xhr.send();
            }
            else {
                image.src = url;
            }
        }
        else {
            Logger.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open.");
            image.src = url;
        }
    };
    Database.prototype._checkVersionFromDB = function (url, versionLoaded) {
        var _this = this;
        var updateVersion = function () {
            // the version is not yet in the DB or we need to update it
            _this._saveVersionIntoDBAsync(url, versionLoaded);
        };
        this._loadVersionFromDBAsync(url, versionLoaded, updateVersion);
    };
    Database.prototype._loadVersionFromDBAsync = function (url, callback, updateInDBCallback) {
        var _this = this;
        if (this._isSupported && this._db) {
            var version;
            try {
                var transaction = this._db.transaction(["versions"]);
                transaction.oncomplete = function () {
                    if (version) {
                        // If the version in the JSON file is different from the version in DB
                        if (_this._manifestVersionFound !== version.data) {
                            _this._mustUpdateRessources = true;
                            updateInDBCallback();
                        }
                        else {
                            callback(version.data);
                        }
                    }
                    // version was not found in DB
                    else {
                        _this._mustUpdateRessources = true;
                        updateInDBCallback();
                    }
                };
                transaction.onabort = function () {
                    callback(-1);
                };
                var getRequest = transaction.objectStore("versions").get(url);
                getRequest.onsuccess = function (event) {
                    version = (event.target).result;
                };
                getRequest.onerror = function () {
                    Logger.Error("Error loading version for scene " + url + " from DB.");
                    callback(-1);
                };
            }
            catch (ex) {
                Logger.Error("Error while accessing 'versions' object store (READ OP). Exception: " + ex.message);
                callback(-1);
            }
        }
        else {
            Logger.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open.");
            callback(-1);
        }
    };
    Database.prototype._saveVersionIntoDBAsync = function (url, callback) {
        var _this = this;
        if (this._isSupported && !this._hasReachedQuota && this._db) {
            try {
                // Open a transaction to the database
                var transaction = this._db.transaction(["versions"], "readwrite");
                // the transaction could abort because of a QuotaExceededError error
                transaction.onabort = function (event) {
                    try { //backwards compatibility with ts 1.0, srcElement doesn't have an "error" according to ts 1.3
                        var error = event.srcElement['error'];
                        if (error && error.name === "QuotaExceededError") {
                            _this._hasReachedQuota = true;
                        }
                    }
                    catch (ex) { }
                    callback(-1);
                };
                transaction.oncomplete = function () {
                    callback(_this._manifestVersionFound);
                };
                var newVersion = { sceneUrl: url, data: this._manifestVersionFound };
                // Put the scene into the database
                var addRequest = transaction.objectStore("versions").put(newVersion);
                addRequest.onsuccess = function () {
                };
                addRequest.onerror = function () {
                    Logger.Error("Error in DB add version request in BABYLON.Database.");
                };
            }
            catch (ex) {
                Logger.Error("Error while accessing 'versions' object store (WRITE OP). Exception: " + ex.message);
                callback(-1);
            }
        }
        else {
            callback(-1);
        }
    };
    /**
     * Loads a file from database
     * @param url defines the URL to load from
     * @param sceneLoaded defines a callback to call on success
     * @param progressCallBack defines a callback to call when progress changed
     * @param errorCallback defines a callback to call on error
     * @param useArrayBuffer defines a boolean to use array buffer instead of text string
     */
    Database.prototype.loadFile = function (url, sceneLoaded, progressCallBack, errorCallback, useArrayBuffer) {
        var _this = this;
        var completeUrl = Database._ReturnFullUrlLocation(url);
        var saveAndLoadFile = function () {
            // the scene is not yet in the DB, let's try to save it
            _this._saveFileAsync(completeUrl, sceneLoaded, progressCallBack, useArrayBuffer, errorCallback);
        };
        this._checkVersionFromDB(completeUrl, function (version) {
            if (version !== -1) {
                if (!_this._mustUpdateRessources) {
                    _this._loadFileAsync(completeUrl, sceneLoaded, saveAndLoadFile);
                }
                else {
                    _this._saveFileAsync(completeUrl, sceneLoaded, progressCallBack, useArrayBuffer, errorCallback);
                }
            }
            else {
                if (errorCallback) {
                    errorCallback();
                }
            }
        });
    };
    Database.prototype._loadFileAsync = function (url, callback, notInDBCallback) {
        if (this._isSupported && this._db) {
            var targetStore;
            if (url.indexOf(".babylon") !== -1) {
                targetStore = "scenes";
            }
            else {
                targetStore = "textures";
            }
            var file;
            var transaction = this._db.transaction([targetStore]);
            transaction.oncomplete = function () {
                if (file) {
                    callback(file.data);
                }
                // file was not found in DB
                else {
                    notInDBCallback();
                }
            };
            transaction.onabort = function () {
                notInDBCallback();
            };
            var getRequest = transaction.objectStore(targetStore).get(url);
            getRequest.onsuccess = function (event) {
                file = (event.target).result;
            };
            getRequest.onerror = function () {
                Logger.Error("Error loading file " + url + " from DB.");
                notInDBCallback();
            };
        }
        else {
            Logger.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open.");
            callback();
        }
    };
    Database.prototype._saveFileAsync = function (url, callback, progressCallback, useArrayBuffer, errorCallback) {
        var _this = this;
        if (this._isSupported) {
            var targetStore;
            if (url.indexOf(".babylon") !== -1) {
                targetStore = "scenes";
            }
            else {
                targetStore = "textures";
            }
            // Create XHR
            var xhr = new WebRequest();
            var fileData;
            xhr.open("GET", url + "?" + Date.now());
            if (useArrayBuffer) {
                xhr.responseType = "arraybuffer";
            }
            if (progressCallback) {
                xhr.onprogress = progressCallback;
            }
            xhr.addEventListener("load", function () {
                if (xhr.status === 200 || (xhr.status < 400 && Database._ValidateXHRData(xhr, !useArrayBuffer ? 1 : 6))) {
                    // Blob as response (XHR2)
                    fileData = !useArrayBuffer ? xhr.responseText : xhr.response;
                    if (!_this._hasReachedQuota && _this._db) {
                        // Open a transaction to the database
                        var transaction = _this._db.transaction([targetStore], "readwrite");
                        // the transaction could abort because of a QuotaExceededError error
                        transaction.onabort = function (event) {
                            try {
                                //backwards compatibility with ts 1.0, srcElement doesn't have an "error" according to ts 1.3
                                var error = event.srcElement['error'];
                                if (error && error.name === "QuotaExceededError") {
                                    _this._hasReachedQuota = true;
                                }
                            }
                            catch (ex) { }
                            callback(fileData);
                        };
                        transaction.oncomplete = function () {
                            callback(fileData);
                        };
                        var newFile;
                        if (targetStore === "scenes") {
                            newFile = { sceneUrl: url, data: fileData, version: _this._manifestVersionFound };
                        }
                        else {
                            newFile = { textureUrl: url, data: fileData };
                        }
                        try {
                            // Put the scene into the database
                            var addRequest = transaction.objectStore(targetStore).put(newFile);
                            addRequest.onsuccess = function () {
                            };
                            addRequest.onerror = function () {
                                Logger.Error("Error in DB add file request in BABYLON.Database.");
                            };
                        }
                        catch (ex) {
                            callback(fileData);
                        }
                    }
                    else {
                        callback(fileData);
                    }
                }
                else {
                    if (xhr.status >= 400 && errorCallback) {
                        errorCallback(xhr);
                    }
                    else {
                        callback();
                    }
                }
            }, false);
            xhr.addEventListener("error", function () {
                Logger.Error("error on XHR request.");
                callback();
            }, false);
            xhr.send();
        }
        else {
            Logger.Error("Error: IndexedDB not supported by your browser or Babylon.js Database is not open.");
            callback();
        }
    };
    /**
     * Validates if xhr data is correct
     * @param xhr defines the request to validate
     * @param dataType defines the expected data type
     * @returns true if data is correct
     */
    Database._ValidateXHRData = function (xhr, dataType) {
        // 1 for text (.babylon, manifest and shaders), 2 for TGA, 4 for DDS, 7 for all
        if (dataType === void 0) { dataType = 7; }
        try {
            if (dataType & 1) {
                if (xhr.responseText && xhr.responseText.length > 0) {
                    return true;
                }
                else if (dataType === 1) {
                    return false;
                }
            }
            if (dataType & 2) {
                // Check header width and height since there is no "TGA" magic number
                var tgaHeader = TGATools.GetTGAHeader(xhr.response);
                if (tgaHeader.width && tgaHeader.height && tgaHeader.width > 0 && tgaHeader.height > 0) {
                    return true;
                }
                else if (dataType === 2) {
                    return false;
                }
            }
            if (dataType & 4) {
                // Check for the "DDS" magic number
                var ddsHeader = new Uint8Array(xhr.response, 0, 3);
                if (ddsHeader[0] === 68 && ddsHeader[1] === 68 && ddsHeader[2] === 83) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        catch (e) {
            // Global protection
        }
        return false;
    };
    /** Gets a boolean indicating if the user agent supports blob storage (this value will be updated after creating the first Database object) */
    Database.IsUASupportingBlobStorage = true;
    /**
     * Gets a boolean indicating if Database storate is enabled (off by default)
     */
    Database.IDBStorageEnabled = false;
    Database._ParseURL = function (url) {
        var a = document.createElement('a');
        a.href = url;
        var urlWithoutHash = url.substring(0, url.lastIndexOf("#"));
        var fileName = url.substring(urlWithoutHash.lastIndexOf("/") + 1, url.length);
        var absLocation = url.substring(0, url.indexOf(fileName, 0));
        return absLocation;
    };
    Database._ReturnFullUrlLocation = function (url) {
        if (url.indexOf("http:/") === -1 && url.indexOf("https:/") === -1) {
            return (Database._ParseURL(window.location.href) + url);
        }
        else {
            return url;
        }
    };
    return Database;
}());

/**
 * Particle emitter emitting particles from the inside of a box.
 * It emits the particles randomly between 2 given directions.
 */
var BoxParticleEmitter = /** @class */ (function () {
    /**
     * Creates a new instance BoxParticleEmitter
     */
    function BoxParticleEmitter() {
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        this.direction1 = new Vector3(0, 1.0, 0);
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        this.direction2 = new Vector3(0, 1.0, 0);
        /**
         * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         */
        this.minEmitBox = new Vector3(-0.5, -0.5, -0.5);
        /**
         * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         */
        this.maxEmitBox = new Vector3(0.5, 0.5, 0.5);
    }
    /**
     * Called by the particle System when the direction is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param directionToUpdate is the direction vector to update with the result
     * @param particle is the particle we are computed the direction for
     */
    BoxParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {
        var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
        var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
        var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
    };
    /**
     * Called by the particle System when the position is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param positionToUpdate is the position vector to update with the result
     * @param particle is the particle we are computed the position for
     */
    BoxParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle) {
        var randX = Scalar.RandomRange(this.minEmitBox.x, this.maxEmitBox.x);
        var randY = Scalar.RandomRange(this.minEmitBox.y, this.maxEmitBox.y);
        var randZ = Scalar.RandomRange(this.minEmitBox.z, this.maxEmitBox.z);
        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
    };
    /**
     * Clones the current emitter and returns a copy of it
     * @returns the new emitter
     */
    BoxParticleEmitter.prototype.clone = function () {
        var newOne = new BoxParticleEmitter();
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
    };
    /**
     * Called by the GPUParticleSystem to setup the update shader
     * @param effect defines the update shader
     */
    BoxParticleEmitter.prototype.applyToShader = function (effect) {
        effect.setVector3("direction1", this.direction1);
        effect.setVector3("direction2", this.direction2);
        effect.setVector3("minEmitBox", this.minEmitBox);
        effect.setVector3("maxEmitBox", this.maxEmitBox);
    };
    /**
     * Returns a string to use to update the GPU particles update shader
     * @returns a string containng the defines string
     */
    BoxParticleEmitter.prototype.getEffectDefines = function () {
        return "#define BOXEMITTER";
    };
    /**
     * Returns the string "BoxParticleEmitter"
     * @returns a string containing the class name
     */
    BoxParticleEmitter.prototype.getClassName = function () {
        return "BoxParticleEmitter";
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    BoxParticleEmitter.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        serializationObject.minEmitBox = this.minEmitBox.asArray();
        serializationObject.maxEmitBox = this.maxEmitBox.asArray();
        return serializationObject;
    };
    /**
     * Parse properties from a JSON object
     * @param serializationObject defines the JSON object
     */
    BoxParticleEmitter.prototype.parse = function (serializationObject) {
        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
        Vector3.FromArrayToRef(serializationObject.minEmitBox, 0, this.minEmitBox);
        Vector3.FromArrayToRef(serializationObject.maxEmitBox, 0, this.maxEmitBox);
    };
    return BoxParticleEmitter;
}());

/**
 * Particle emitter emitting particles from the inside of a cone.
 * It emits the particles alongside the cone volume from the base to the particle.
 * The emission direction might be randomized.
 */
var ConeParticleEmitter = /** @class */ (function () {
    /**
     * Creates a new instance ConeParticleEmitter
     * @param radius the radius of the emission cone (1 by default)
     * @param angle the cone base angle (PI by default)
     * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)
     */
    function ConeParticleEmitter(radius, angle, 
    /** defines how much to randomize the particle direction [0-1] (default is 0) */
    directionRandomizer) {
        if (radius === void 0) { radius = 1; }
        if (angle === void 0) { angle = Math.PI; }
        if (directionRandomizer === void 0) { directionRandomizer = 0; }
        this.directionRandomizer = directionRandomizer;
        /**
         * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)
         */
        this.radiusRange = 1;
        /**
         * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)
         */
        this.heightRange = 1;
        /**
         * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)
         */
        this.emitFromSpawnPointOnly = false;
        this.angle = angle;
        this.radius = radius;
    }
    Object.defineProperty(ConeParticleEmitter.prototype, "radius", {
        /**
         * Gets or sets the radius of the emission cone
         */
        get: function () {
            return this._radius;
        },
        set: function (value) {
            this._radius = value;
            this._buildHeight();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConeParticleEmitter.prototype, "angle", {
        /**
         * Gets or sets the angle of the emission cone
         */
        get: function () {
            return this._angle;
        },
        set: function (value) {
            this._angle = value;
            this._buildHeight();
        },
        enumerable: true,
        configurable: true
    });
    ConeParticleEmitter.prototype._buildHeight = function () {
        if (this._angle !== 0) {
            this._height = this._radius / Math.tan(this._angle / 2);
        }
        else {
            this._height = 1;
        }
    };
    /**
     * Called by the particle System when the direction is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param directionToUpdate is the direction vector to update with the result
     * @param particle is the particle we are computed the direction for
     */
    ConeParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {
        if (Math.abs(Math.cos(this._angle)) === 1.0) {
            Vector3.TransformNormalFromFloatsToRef(0, 1.0, 0, worldMatrix, directionToUpdate);
        }
        else {
            // measure the direction Vector from the emitter to the particle.
            var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
            var randX = Scalar.RandomRange(0, this.directionRandomizer);
            var randY = Scalar.RandomRange(0, this.directionRandomizer);
            var randZ = Scalar.RandomRange(0, this.directionRandomizer);
            direction.x += randX;
            direction.y += randY;
            direction.z += randZ;
            direction.normalize();
            Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
        }
    };
    /**
     * Called by the particle System when the position is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param positionToUpdate is the position vector to update with the result
     * @param particle is the particle we are computed the position for
     */
    ConeParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle) {
        var s = Scalar.RandomRange(0, Math.PI * 2);
        var h;
        if (!this.emitFromSpawnPointOnly) {
            h = Scalar.RandomRange(0, this.heightRange);
            // Better distribution in a cone at normal angles.
            h = 1 - h * h;
        }
        else {
            h = 0.0001;
        }
        var radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);
        radius = radius * h;
        var randX = radius * Math.sin(s);
        var randZ = radius * Math.cos(s);
        var randY = h * this._height;
        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
    };
    /**
     * Clones the current emitter and returns a copy of it
     * @returns the new emitter
     */
    ConeParticleEmitter.prototype.clone = function () {
        var newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
    };
    /**
     * Called by the GPUParticleSystem to setup the update shader
     * @param effect defines the update shader
     */
    ConeParticleEmitter.prototype.applyToShader = function (effect) {
        effect.setFloat2("radius", this._radius, this.radiusRange);
        effect.setFloat("coneAngle", this._angle);
        effect.setFloat2("height", this._height, this.heightRange);
        effect.setFloat("directionRandomizer", this.directionRandomizer);
    };
    /**
     * Returns a string to use to update the GPU particles update shader
     * @returns a string containng the defines string
     */
    ConeParticleEmitter.prototype.getEffectDefines = function () {
        var defines = "#define CONEEMITTER";
        if (this.emitFromSpawnPointOnly) {
            defines += "\n#define CONEEMITTERSPAWNPOINT";
        }
        return defines;
    };
    /**
     * Returns the string "ConeParticleEmitter"
     * @returns a string containing the class name
     */
    ConeParticleEmitter.prototype.getClassName = function () {
        return "ConeParticleEmitter";
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    ConeParticleEmitter.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.radius = this._radius;
        serializationObject.angle = this._angle;
        serializationObject.directionRandomizer = this.directionRandomizer;
        return serializationObject;
    };
    /**
     * Parse properties from a JSON object
     * @param serializationObject defines the JSON object
     */
    ConeParticleEmitter.prototype.parse = function (serializationObject) {
        this.radius = serializationObject.radius;
        this.angle = serializationObject.angle;
        this.directionRandomizer = serializationObject.directionRandomizer;
    };
    return ConeParticleEmitter;
}());

/**
 * Particle emitter emitting particles from the inside of a cylinder.
 * It emits the particles alongside the cylinder radius. The emission direction might be randomized.
 */
var CylinderParticleEmitter = /** @class */ (function () {
    /**
    * Creates a new instance CylinderParticleEmitter
    * @param radius the radius of the emission cylinder (1 by default)
    * @param height the height of the emission cylinder (1 by default)
    * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
    * @param directionRandomizer defines how much to randomize the particle direction [0-1]
    */
    function CylinderParticleEmitter(
    /**
     * The radius of the emission cylinder.
     */
    radius, 
    /**
     * The height of the emission cylinder.
     */
    height, 
    /**
     * The range of emission [0-1] 0 Surface only, 1 Entire Radius.
     */
    radiusRange, 
    /**
     * How much to randomize the particle direction [0-1].
     */
    directionRandomizer) {
        if (radius === void 0) { radius = 1; }
        if (height === void 0) { height = 1; }
        if (radiusRange === void 0) { radiusRange = 1; }
        if (directionRandomizer === void 0) { directionRandomizer = 0; }
        this.radius = radius;
        this.height = height;
        this.radiusRange = radiusRange;
        this.directionRandomizer = directionRandomizer;
    }
    /**
     * Called by the particle System when the direction is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param directionToUpdate is the direction vector to update with the result
     * @param particle is the particle we are computed the direction for
     */
    CylinderParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {
        var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
        var randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);
        var angle = Math.atan2(direction.x, direction.z);
        angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;
        direction.y = randY; // set direction y to rand y to mirror normal of cylinder surface
        direction.x = Math.sin(angle);
        direction.z = Math.cos(angle);
        direction.normalize();
        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
    };
    /**
     * Called by the particle System when the position is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param positionToUpdate is the position vector to update with the result
     * @param particle is the particle we are computed the position for
     */
    CylinderParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle) {
        var yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);
        var angle = Scalar.RandomRange(0, 2 * Math.PI);
        // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html
        var radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);
        var positionRadius = Math.sqrt(radiusDistribution) * this.radius;
        var xPos = positionRadius * Math.cos(angle);
        var zPos = positionRadius * Math.sin(angle);
        Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);
    };
    /**
     * Clones the current emitter and returns a copy of it
     * @returns the new emitter
     */
    CylinderParticleEmitter.prototype.clone = function () {
        var newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
    };
    /**
     * Called by the GPUParticleSystem to setup the update shader
     * @param effect defines the update shader
     */
    CylinderParticleEmitter.prototype.applyToShader = function (effect) {
        effect.setFloat("radius", this.radius);
        effect.setFloat("height", this.height);
        effect.setFloat("radiusRange", this.radiusRange);
        effect.setFloat("directionRandomizer", this.directionRandomizer);
    };
    /**
     * Returns a string to use to update the GPU particles update shader
     * @returns a string containng the defines string
     */
    CylinderParticleEmitter.prototype.getEffectDefines = function () {
        return "#define CYLINDEREMITTER";
    };
    /**
     * Returns the string "CylinderParticleEmitter"
     * @returns a string containing the class name
     */
    CylinderParticleEmitter.prototype.getClassName = function () {
        return "CylinderParticleEmitter";
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    CylinderParticleEmitter.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.radius = this.radius;
        serializationObject.height = this.height;
        serializationObject.radiusRange = this.radiusRange;
        serializationObject.directionRandomizer = this.directionRandomizer;
        return serializationObject;
    };
    /**
     * Parse properties from a JSON object
     * @param serializationObject defines the JSON object
     */
    CylinderParticleEmitter.prototype.parse = function (serializationObject) {
        this.radius = serializationObject.radius;
        this.height = serializationObject.height;
        this.radiusRange = serializationObject.radiusRange;
        this.directionRandomizer = serializationObject.directionRandomizer;
    };
    return CylinderParticleEmitter;
}());
/**
 * Particle emitter emitting particles from the inside of a cylinder.
 * It emits the particles randomly between two vectors.
 */
var CylinderDirectedParticleEmitter = /** @class */ (function (_super) {
    __extends(CylinderDirectedParticleEmitter, _super);
    /**
     * Creates a new instance CylinderDirectedParticleEmitter
     * @param radius the radius of the emission cylinder (1 by default)
     * @param height the height of the emission cylinder (1 by default)
     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
     * @param direction1 the min limit of the emission direction (up vector by default)
     * @param direction2 the max limit of the emission direction (up vector by default)
     */
    function CylinderDirectedParticleEmitter(radius, height, radiusRange, 
    /**
     * The min limit of the emission direction.
     */
    direction1, 
    /**
     * The max limit of the emission direction.
     */
    direction2) {
        if (radius === void 0) { radius = 1; }
        if (height === void 0) { height = 1; }
        if (radiusRange === void 0) { radiusRange = 1; }
        if (direction1 === void 0) { direction1 = new Vector3(0, 1, 0); }
        if (direction2 === void 0) { direction2 = new Vector3(0, 1, 0); }
        var _this = _super.call(this, radius, height, radiusRange) || this;
        _this.direction1 = direction1;
        _this.direction2 = direction2;
        return _this;
    }
    /**
     * Called by the particle System when the direction is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param directionToUpdate is the direction vector to update with the result
     * @param particle is the particle we are computed the direction for
     */
    CylinderDirectedParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {
        var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
        var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
        var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
    };
    /**
     * Clones the current emitter and returns a copy of it
     * @returns the new emitter
     */
    CylinderDirectedParticleEmitter.prototype.clone = function () {
        var newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
    };
    /**
     * Called by the GPUParticleSystem to setup the update shader
     * @param effect defines the update shader
     */
    CylinderDirectedParticleEmitter.prototype.applyToShader = function (effect) {
        effect.setFloat("radius", this.radius);
        effect.setFloat("height", this.height);
        effect.setFloat("radiusRange", this.radiusRange);
        effect.setVector3("direction1", this.direction1);
        effect.setVector3("direction2", this.direction2);
    };
    /**
     * Returns a string to use to update the GPU particles update shader
     * @returns a string containng the defines string
     */
    CylinderDirectedParticleEmitter.prototype.getEffectDefines = function () {
        return "#define CYLINDEREMITTER\n#define DIRECTEDCYLINDEREMITTER";
    };
    /**
     * Returns the string "CylinderDirectedParticleEmitter"
     * @returns a string containing the class name
     */
    CylinderDirectedParticleEmitter.prototype.getClassName = function () {
        return "CylinderDirectedParticleEmitter";
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    CylinderDirectedParticleEmitter.prototype.serialize = function () {
        var serializationObject = _super.prototype.serialize.call(this);
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        return serializationObject;
    };
    /**
     * Parse properties from a JSON object
     * @param serializationObject defines the JSON object
     */
    CylinderDirectedParticleEmitter.prototype.parse = function (serializationObject) {
        _super.prototype.parse.call(this, serializationObject);
        this.direction1.copyFrom(serializationObject.direction1);
        this.direction2.copyFrom(serializationObject.direction2);
    };
    return CylinderDirectedParticleEmitter;
}(CylinderParticleEmitter));

/**
 * Particle emitter emitting particles from the inside of a hemisphere.
 * It emits the particles alongside the hemisphere radius. The emission direction might be randomized.
 */
var HemisphericParticleEmitter = /** @class */ (function () {
    /**
    * Creates a new instance HemisphericParticleEmitter
    * @param radius the radius of the emission hemisphere (1 by default)
    * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
    * @param directionRandomizer defines how much to randomize the particle direction [0-1]
    */
    function HemisphericParticleEmitter(
    /**
     * The radius of the emission hemisphere.
     */
    radius, 
    /**
     * The range of emission [0-1] 0 Surface only, 1 Entire Radius.
     */
    radiusRange, 
    /**
     * How much to randomize the particle direction [0-1].
     */
    directionRandomizer) {
        if (radius === void 0) { radius = 1; }
        if (radiusRange === void 0) { radiusRange = 1; }
        if (directionRandomizer === void 0) { directionRandomizer = 0; }
        this.radius = radius;
        this.radiusRange = radiusRange;
        this.directionRandomizer = directionRandomizer;
    }
    /**
     * Called by the particle System when the direction is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param directionToUpdate is the direction vector to update with the result
     * @param particle is the particle we are computed the direction for
     */
    HemisphericParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {
        var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
        var randX = Scalar.RandomRange(0, this.directionRandomizer);
        var randY = Scalar.RandomRange(0, this.directionRandomizer);
        var randZ = Scalar.RandomRange(0, this.directionRandomizer);
        direction.x += randX;
        direction.y += randY;
        direction.z += randZ;
        direction.normalize();
        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
    };
    /**
     * Called by the particle System when the position is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param positionToUpdate is the position vector to update with the result
     * @param particle is the particle we are computed the position for
     */
    HemisphericParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle) {
        var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);
        var v = Scalar.RandomRange(0, 1.0);
        var phi = Scalar.RandomRange(0, 2 * Math.PI);
        var theta = Math.acos(2 * v - 1);
        var randX = randRadius * Math.cos(phi) * Math.sin(theta);
        var randY = randRadius * Math.cos(theta);
        var randZ = randRadius * Math.sin(phi) * Math.sin(theta);
        Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);
    };
    /**
     * Clones the current emitter and returns a copy of it
     * @returns the new emitter
     */
    HemisphericParticleEmitter.prototype.clone = function () {
        var newOne = new HemisphericParticleEmitter(this.radius, this.directionRandomizer);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
    };
    /**
     * Called by the GPUParticleSystem to setup the update shader
     * @param effect defines the update shader
     */
    HemisphericParticleEmitter.prototype.applyToShader = function (effect) {
        effect.setFloat("radius", this.radius);
        effect.setFloat("radiusRange", this.radiusRange);
        effect.setFloat("directionRandomizer", this.directionRandomizer);
    };
    /**
     * Returns a string to use to update the GPU particles update shader
     * @returns a string containng the defines string
     */
    HemisphericParticleEmitter.prototype.getEffectDefines = function () {
        return "#define HEMISPHERICEMITTER";
    };
    /**
     * Returns the string "HemisphericParticleEmitter"
     * @returns a string containing the class name
     */
    HemisphericParticleEmitter.prototype.getClassName = function () {
        return "HemisphericParticleEmitter";
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    HemisphericParticleEmitter.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.radius = this.radius;
        serializationObject.radiusRange = this.radiusRange;
        serializationObject.directionRandomizer = this.directionRandomizer;
        return serializationObject;
    };
    /**
     * Parse properties from a JSON object
     * @param serializationObject defines the JSON object
     */
    HemisphericParticleEmitter.prototype.parse = function (serializationObject) {
        this.radius = serializationObject.radius;
        this.radiusRange = serializationObject.radiusRange;
        this.directionRandomizer = serializationObject.directionRandomizer;
    };
    return HemisphericParticleEmitter;
}());

/**
 * Particle emitter emitting particles from a point.
 * It emits the particles randomly between 2 given directions.
 */
var PointParticleEmitter = /** @class */ (function () {
    /**
     * Creates a new instance PointParticleEmitter
     */
    function PointParticleEmitter() {
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        this.direction1 = new Vector3(0, 1.0, 0);
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        this.direction2 = new Vector3(0, 1.0, 0);
    }
    /**
     * Called by the particle System when the direction is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param directionToUpdate is the direction vector to update with the result
     * @param particle is the particle we are computed the direction for
     */
    PointParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {
        var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
        var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
        var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
    };
    /**
     * Called by the particle System when the position is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param positionToUpdate is the position vector to update with the result
     * @param particle is the particle we are computed the position for
     */
    PointParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle) {
        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);
    };
    /**
     * Clones the current emitter and returns a copy of it
     * @returns the new emitter
     */
    PointParticleEmitter.prototype.clone = function () {
        var newOne = new PointParticleEmitter();
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
    };
    /**
     * Called by the GPUParticleSystem to setup the update shader
     * @param effect defines the update shader
     */
    PointParticleEmitter.prototype.applyToShader = function (effect) {
        effect.setVector3("direction1", this.direction1);
        effect.setVector3("direction2", this.direction2);
    };
    /**
     * Returns a string to use to update the GPU particles update shader
     * @returns a string containng the defines string
     */
    PointParticleEmitter.prototype.getEffectDefines = function () {
        return "#define POINTEMITTER";
    };
    /**
     * Returns the string "PointParticleEmitter"
     * @returns a string containing the class name
     */
    PointParticleEmitter.prototype.getClassName = function () {
        return "PointParticleEmitter";
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    PointParticleEmitter.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        return serializationObject;
    };
    /**
     * Parse properties from a JSON object
     * @param serializationObject defines the JSON object
     */
    PointParticleEmitter.prototype.parse = function (serializationObject) {
        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
    };
    return PointParticleEmitter;
}());

/**
 * Particle emitter emitting particles from the inside of a sphere.
 * It emits the particles alongside the sphere radius. The emission direction might be randomized.
 */
var SphereParticleEmitter = /** @class */ (function () {
    /**
    * Creates a new instance SphereParticleEmitter
    * @param radius the radius of the emission sphere (1 by default)
    * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
    * @param directionRandomizer defines how much to randomize the particle direction [0-1]
    */
    function SphereParticleEmitter(
    /**
     * The radius of the emission sphere.
     */
    radius, 
    /**
     * The range of emission [0-1] 0 Surface only, 1 Entire Radius.
     */
    radiusRange, 
    /**
     * How much to randomize the particle direction [0-1].
     */
    directionRandomizer) {
        if (radius === void 0) { radius = 1; }
        if (radiusRange === void 0) { radiusRange = 1; }
        if (directionRandomizer === void 0) { directionRandomizer = 0; }
        this.radius = radius;
        this.radiusRange = radiusRange;
        this.directionRandomizer = directionRandomizer;
    }
    /**
     * Called by the particle System when the direction is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param directionToUpdate is the direction vector to update with the result
     * @param particle is the particle we are computed the direction for
     */
    SphereParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {
        var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
        var randX = Scalar.RandomRange(0, this.directionRandomizer);
        var randY = Scalar.RandomRange(0, this.directionRandomizer);
        var randZ = Scalar.RandomRange(0, this.directionRandomizer);
        direction.x += randX;
        direction.y += randY;
        direction.z += randZ;
        direction.normalize();
        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
    };
    /**
     * Called by the particle System when the position is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param positionToUpdate is the position vector to update with the result
     * @param particle is the particle we are computed the position for
     */
    SphereParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle) {
        var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);
        var v = Scalar.RandomRange(0, 1.0);
        var phi = Scalar.RandomRange(0, 2 * Math.PI);
        var theta = Math.acos(2 * v - 1);
        var randX = randRadius * Math.cos(phi) * Math.sin(theta);
        var randY = randRadius * Math.cos(theta);
        var randZ = randRadius * Math.sin(phi) * Math.sin(theta);
        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
    };
    /**
     * Clones the current emitter and returns a copy of it
     * @returns the new emitter
     */
    SphereParticleEmitter.prototype.clone = function () {
        var newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
    };
    /**
     * Called by the GPUParticleSystem to setup the update shader
     * @param effect defines the update shader
     */
    SphereParticleEmitter.prototype.applyToShader = function (effect) {
        effect.setFloat("radius", this.radius);
        effect.setFloat("radiusRange", this.radiusRange);
        effect.setFloat("directionRandomizer", this.directionRandomizer);
    };
    /**
     * Returns a string to use to update the GPU particles update shader
     * @returns a string containng the defines string
     */
    SphereParticleEmitter.prototype.getEffectDefines = function () {
        return "#define SPHEREEMITTER";
    };
    /**
     * Returns the string "SphereParticleEmitter"
     * @returns a string containing the class name
     */
    SphereParticleEmitter.prototype.getClassName = function () {
        return "SphereParticleEmitter";
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    SphereParticleEmitter.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.radius = this.radius;
        serializationObject.radiusRange = this.radiusRange;
        serializationObject.directionRandomizer = this.directionRandomizer;
        return serializationObject;
    };
    /**
     * Parse properties from a JSON object
     * @param serializationObject defines the JSON object
     */
    SphereParticleEmitter.prototype.parse = function (serializationObject) {
        this.radius = serializationObject.radius;
        this.radiusRange = serializationObject.radiusRange;
        this.directionRandomizer = serializationObject.directionRandomizer;
    };
    return SphereParticleEmitter;
}());
/**
 * Particle emitter emitting particles from the inside of a sphere.
 * It emits the particles randomly between two vectors.
 */
var SphereDirectedParticleEmitter = /** @class */ (function (_super) {
    __extends(SphereDirectedParticleEmitter, _super);
    /**
     * Creates a new instance SphereDirectedParticleEmitter
     * @param radius the radius of the emission sphere (1 by default)
     * @param direction1 the min limit of the emission direction (up vector by default)
     * @param direction2 the max limit of the emission direction (up vector by default)
     */
    function SphereDirectedParticleEmitter(radius, 
    /**
     * The min limit of the emission direction.
     */
    direction1, 
    /**
     * The max limit of the emission direction.
     */
    direction2) {
        if (radius === void 0) { radius = 1; }
        if (direction1 === void 0) { direction1 = new Vector3(0, 1, 0); }
        if (direction2 === void 0) { direction2 = new Vector3(0, 1, 0); }
        var _this = _super.call(this, radius) || this;
        _this.direction1 = direction1;
        _this.direction2 = direction2;
        return _this;
    }
    /**
     * Called by the particle System when the direction is computed for the created particle.
     * @param worldMatrix is the world matrix of the particle system
     * @param directionToUpdate is the direction vector to update with the result
     * @param particle is the particle we are computed the direction for
     */
    SphereDirectedParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {
        var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
        var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
        var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
    };
    /**
     * Clones the current emitter and returns a copy of it
     * @returns the new emitter
     */
    SphereDirectedParticleEmitter.prototype.clone = function () {
        var newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
    };
    /**
     * Called by the GPUParticleSystem to setup the update shader
     * @param effect defines the update shader
     */
    SphereDirectedParticleEmitter.prototype.applyToShader = function (effect) {
        effect.setFloat("radius", this.radius);
        effect.setFloat("radiusRange", this.radiusRange);
        effect.setVector3("direction1", this.direction1);
        effect.setVector3("direction2", this.direction2);
    };
    /**
     * Returns a string to use to update the GPU particles update shader
     * @returns a string containng the defines string
     */
    SphereDirectedParticleEmitter.prototype.getEffectDefines = function () {
        return "#define SPHEREEMITTER\n#define DIRECTEDSPHEREEMITTER";
    };
    /**
     * Returns the string "SphereDirectedParticleEmitter"
     * @returns a string containing the class name
     */
    SphereDirectedParticleEmitter.prototype.getClassName = function () {
        return "SphereDirectedParticleEmitter";
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    SphereDirectedParticleEmitter.prototype.serialize = function () {
        var serializationObject = _super.prototype.serialize.call(this);
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        return serializationObject;
    };
    /**
     * Parse properties from a JSON object
     * @param serializationObject defines the JSON object
     */
    SphereDirectedParticleEmitter.prototype.parse = function (serializationObject) {
        _super.prototype.parse.call(this, serializationObject);
        this.direction1.copyFrom(serializationObject.direction1);
        this.direction2.copyFrom(serializationObject.direction2);
    };
    return SphereDirectedParticleEmitter;
}(SphereParticleEmitter));

/**
 * This represents the base class for particle system in Babylon.
 * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
 * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
 * @example https://doc.babylonjs.com/babylon101/particles
 */
var BaseParticleSystem = /** @class */ (function () {
    /**
     * Instantiates a particle system.
     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
     * @param name The name of the particle system
     */
    function BaseParticleSystem(name) {
        /**
         * List of animations used by the particle system.
         */
        this.animations = [];
        /**
         * The rendering group used by the Particle system to chose when to render.
         */
        this.renderingGroupId = 0;
        /**
         * The emitter represents the Mesh or position we are attaching the particle system to.
         */
        this.emitter = null;
        /**
         * The maximum number of particles to emit per frame
         */
        this.emitRate = 10;
        /**
         * If you want to launch only a few particles at once, that can be done, as well.
         */
        this.manualEmitCount = -1;
        /**
         * The overall motion speed (0.01 is default update speed, faster updates = faster animation)
         */
        this.updateSpeed = 0.01;
        /**
         * The amount of time the particle system is running (depends of the overall update speed).
         */
        this.targetStopDuration = 0;
        /**
         * Specifies whether the particle system will be disposed once it reaches the end of the animation.
         */
        this.disposeOnStop = false;
        /**
         * Minimum power of emitting particles.
         */
        this.minEmitPower = 1;
        /**
         * Maximum power of emitting particles.
         */
        this.maxEmitPower = 1;
        /**
         * Minimum life time of emitting particles.
         */
        this.minLifeTime = 1;
        /**
         * Maximum life time of emitting particles.
         */
        this.maxLifeTime = 1;
        /**
         * Minimum Size of emitting particles.
         */
        this.minSize = 1;
        /**
         * Maximum Size of emitting particles.
         */
        this.maxSize = 1;
        /**
         * Minimum scale of emitting particles on X axis.
         */
        this.minScaleX = 1;
        /**
         * Maximum scale of emitting particles on X axis.
         */
        this.maxScaleX = 1;
        /**
         * Minimum scale of emitting particles on Y axis.
         */
        this.minScaleY = 1;
        /**
         * Maximum scale of emitting particles on Y axis.
         */
        this.maxScaleY = 1;
        /**
         * Gets or sets the minimal initial rotation in radians.
         */
        this.minInitialRotation = 0;
        /**
         * Gets or sets the maximal initial rotation in radians.
         */
        this.maxInitialRotation = 0;
        /**
         * Minimum angular speed of emitting particles (Z-axis rotation for each particle).
         */
        this.minAngularSpeed = 0;
        /**
         * Maximum angular speed of emitting particles (Z-axis rotation for each particle).
         */
        this.maxAngularSpeed = 0;
        /**
         * The layer mask we are rendering the particles through.
         */
        this.layerMask = 0x0FFFFFFF;
        /**
         * This can help using your own shader to render the particle system.
         * The according effect will be created
         */
        this.customShader = null;
        /**
         * By default particle system starts as soon as they are created. This prevents the
         * automatic start to happen and let you decide when to start emitting particles.
         */
        this.preventAutoStart = false;
        /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */
        this.noiseStrength = new Vector3(10, 10, 10);
        /**
         * Callback triggered when the particle animation is ending.
         */
        this.onAnimationEnd = null;
        /**
         * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
         */
        this.blendMode = BaseParticleSystem.BLENDMODE_ONEONE;
        /**
         * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
         * to override the particles.
         */
        this.forceDepthWrite = false;
        /** Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 */
        this.preWarmCycles = 0;
        /** Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) */
        this.preWarmStepOffset = 1;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)
         */
        this.spriteCellChangeSpeed = 1;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display
         */
        this.startSpriteCellID = 0;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display
         */
        this.endSpriteCellID = 0;
        /**
         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use
         */
        this.spriteCellWidth = 0;
        /**
         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use
         */
        this.spriteCellHeight = 0;
        /**
         * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID
         */
        this.spriteRandomStartCell = false;
        /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */
        this.translationPivot = new Vector2(0, 0);
        /**
         * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called
         */
        this.beginAnimationOnStart = false;
        /**
         * Gets or sets the frame to start the animation from when beginAnimationOnStart is true
         */
        this.beginAnimationFrom = 0;
        /**
         * Gets or sets the frame to end the animation on when beginAnimationOnStart is true
         */
        this.beginAnimationTo = 60;
        /**
         * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true
         */
        this.beginAnimationLoop = false;
        /**
         * Gets or sets a world offset applied to all particles
         */
        this.worldOffset = new Vector3(0, 0, 0);
        /**
         * You can use gravity if you want to give an orientation to your particles.
         */
        this.gravity = Vector3.Zero();
        this._colorGradients = null;
        this._sizeGradients = null;
        this._lifeTimeGradients = null;
        this._angularSpeedGradients = null;
        this._velocityGradients = null;
        this._limitVelocityGradients = null;
        this._dragGradients = null;
        this._emitRateGradients = null;
        this._startSizeGradients = null;
        this._rampGradients = null;
        this._colorRemapGradients = null;
        this._alphaRemapGradients = null;
        /**
         * Defines the delay in milliseconds before starting the system (0 by default)
         */
        this.startDelay = 0;
        /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */
        this.limitVelocityDamping = 0.4;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors
         */
        this.color1 = new Color4(1.0, 1.0, 1.0, 1.0);
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors
         */
        this.color2 = new Color4(1.0, 1.0, 1.0, 1.0);
        /**
         * Color the particle will have at the end of its lifetime
         */
        this.colorDead = new Color4(0, 0, 0, 1.0);
        /**
         * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel
         */
        this.textureMask = new Color4(1.0, 1.0, 1.0, 1.0);
        /** @hidden */
        this._isSubEmitter = false;
        /**
         * Gets or sets the billboard mode to use when isBillboardBased = true.
         * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
         */
        this.billboardMode = Constants.PARTICLES_BILLBOARDMODE_ALL;
        this._isBillboardBased = true;
        /**
         * Local cache of defines for image processing.
         */
        this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();
        this.id = name;
        this.name = name;
    }
    Object.defineProperty(BaseParticleSystem.prototype, "noiseTexture", {
        /**
         * Gets or sets a texture used to add random noise to particle positions
         */
        get: function () {
            return this._noiseTexture;
        },
        set: function (value) {
            if (this._noiseTexture === value) {
                return;
            }
            this._noiseTexture = value;
            this._reset();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseParticleSystem.prototype, "isAnimationSheetEnabled", {
        /**
         * Gets or sets whether an animation sprite sheet is enabled or not on the particle system
         */
        get: function () {
            return this._isAnimationSheetEnabled;
        },
        set: function (value) {
            if (this._isAnimationSheetEnabled == value) {
                return;
            }
            this._isAnimationSheetEnabled = value;
            this._reset();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get hosting scene
     * @returns the scene
     */
    BaseParticleSystem.prototype.getScene = function () {
        return this._scene;
    };
    BaseParticleSystem.prototype._hasTargetStopDurationDependantGradient = function () {
        return (this._startSizeGradients && this._startSizeGradients.length > 0)
            || (this._emitRateGradients && this._emitRateGradients.length > 0)
            || (this._lifeTimeGradients && this._lifeTimeGradients.length > 0);
    };
    /**
     * Gets the current list of drag gradients.
     * You must use addDragGradient and removeDragGradient to udpate this list
     * @returns the list of drag gradients
     */
    BaseParticleSystem.prototype.getDragGradients = function () {
        return this._dragGradients;
    };
    /**
     * Gets the current list of limit velocity gradients.
     * You must use addLimitVelocityGradient and removeLimitVelocityGradient to udpate this list
     * @returns the list of limit velocity gradients
     */
    BaseParticleSystem.prototype.getLimitVelocityGradients = function () {
        return this._limitVelocityGradients;
    };
    /**
     * Gets the current list of color gradients.
     * You must use addColorGradient and removeColorGradient to udpate this list
     * @returns the list of color gradients
     */
    BaseParticleSystem.prototype.getColorGradients = function () {
        return this._colorGradients;
    };
    /**
     * Gets the current list of size gradients.
     * You must use addSizeGradient and removeSizeGradient to udpate this list
     * @returns the list of size gradients
     */
    BaseParticleSystem.prototype.getSizeGradients = function () {
        return this._sizeGradients;
    };
    /**
     * Gets the current list of color remap gradients.
     * You must use addColorRemapGradient and removeColorRemapGradient to udpate this list
     * @returns the list of color remap gradients
     */
    BaseParticleSystem.prototype.getColorRemapGradients = function () {
        return this._colorRemapGradients;
    };
    /**
     * Gets the current list of alpha remap gradients.
     * You must use addAlphaRemapGradient and removeAlphaRemapGradient to udpate this list
     * @returns the list of alpha remap gradients
     */
    BaseParticleSystem.prototype.getAlphaRemapGradients = function () {
        return this._alphaRemapGradients;
    };
    /**
     * Gets the current list of life time gradients.
     * You must use addLifeTimeGradient and removeLifeTimeGradient to udpate this list
     * @returns the list of life time gradients
     */
    BaseParticleSystem.prototype.getLifeTimeGradients = function () {
        return this._lifeTimeGradients;
    };
    /**
     * Gets the current list of angular speed gradients.
     * You must use addAngularSpeedGradient and removeAngularSpeedGradient to udpate this list
     * @returns the list of angular speed gradients
     */
    BaseParticleSystem.prototype.getAngularSpeedGradients = function () {
        return this._angularSpeedGradients;
    };
    /**
     * Gets the current list of velocity gradients.
     * You must use addVelocityGradient and removeVelocityGradient to udpate this list
     * @returns the list of velocity gradients
     */
    BaseParticleSystem.prototype.getVelocityGradients = function () {
        return this._velocityGradients;
    };
    /**
     * Gets the current list of start size gradients.
     * You must use addStartSizeGradient and removeStartSizeGradient to udpate this list
     * @returns the list of start size gradients
     */
    BaseParticleSystem.prototype.getStartSizeGradients = function () {
        return this._startSizeGradients;
    };
    /**
     * Gets the current list of emit rate gradients.
     * You must use addEmitRateGradient and removeEmitRateGradient to udpate this list
     * @returns the list of emit rate gradients
     */
    BaseParticleSystem.prototype.getEmitRateGradients = function () {
        return this._emitRateGradients;
    };
    Object.defineProperty(BaseParticleSystem.prototype, "direction1", {
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        get: function () {
            if (this.particleEmitterType.direction1) {
                return this.particleEmitterType.direction1;
            }
            return Vector3.Zero();
        },
        set: function (value) {
            if (this.particleEmitterType.direction1) {
                this.particleEmitterType.direction1 = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseParticleSystem.prototype, "direction2", {
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        get: function () {
            if (this.particleEmitterType.direction2) {
                return this.particleEmitterType.direction2;
            }
            return Vector3.Zero();
        },
        set: function (value) {
            if (this.particleEmitterType.direction2) {
                this.particleEmitterType.direction2 = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseParticleSystem.prototype, "minEmitBox", {
        /**
         * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        get: function () {
            if (this.particleEmitterType.minEmitBox) {
                return this.particleEmitterType.minEmitBox;
            }
            return Vector3.Zero();
        },
        set: function (value) {
            if (this.particleEmitterType.minEmitBox) {
                this.particleEmitterType.minEmitBox = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseParticleSystem.prototype, "maxEmitBox", {
        /**
         * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        get: function () {
            if (this.particleEmitterType.maxEmitBox) {
                return this.particleEmitterType.maxEmitBox;
            }
            return Vector3.Zero();
        },
        set: function (value) {
            if (this.particleEmitterType.maxEmitBox) {
                this.particleEmitterType.maxEmitBox = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseParticleSystem.prototype, "isBillboardBased", {
        /**
         * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
         */
        get: function () {
            return this._isBillboardBased;
        },
        set: function (value) {
            if (this._isBillboardBased === value) {
                return;
            }
            this._isBillboardBased = value;
            this._reset();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseParticleSystem.prototype, "imageProcessingConfiguration", {
        /**
         * Gets the image processing configuration used either in this material.
         */
        get: function () {
            return this._imageProcessingConfiguration;
        },
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        set: function (value) {
            this._attachImageProcessingConfiguration(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attaches a new image processing configuration to the Standard Material.
     * @param configuration
     */
    BaseParticleSystem.prototype._attachImageProcessingConfiguration = function (configuration) {
        if (configuration === this._imageProcessingConfiguration) {
            return;
        }
        // Pick the scene configuration if needed.
        if (!configuration) {
            this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;
        }
        else {
            this._imageProcessingConfiguration = configuration;
        }
    };
    /** @hidden */
    BaseParticleSystem.prototype._reset = function () {
    };
    /** @hidden */
    BaseParticleSystem.prototype._removeGradientAndTexture = function (gradient, gradients, texture) {
        if (!gradients) {
            return this;
        }
        var index = 0;
        for (var _i = 0, gradients_1 = gradients; _i < gradients_1.length; _i++) {
            var valueGradient = gradients_1[_i];
            if (valueGradient.gradient === gradient) {
                gradients.splice(index, 1);
                break;
            }
            index++;
        }
        if (texture) {
            texture.dispose();
        }
        return this;
    };
    /**
     * Creates a Point Emitter for the particle system (emits directly from the emitter position)
     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
     * @returns the emitter
     */
    BaseParticleSystem.prototype.createPointEmitter = function (direction1, direction2) {
        var particleEmitter = new PointParticleEmitter();
        particleEmitter.direction1 = direction1;
        particleEmitter.direction2 = direction2;
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
    };
    /**
     * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
     * @param radius The radius of the hemisphere to emit from
     * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
     * @returns the emitter
     */
    BaseParticleSystem.prototype.createHemisphericEmitter = function (radius, radiusRange) {
        if (radius === void 0) { radius = 1; }
        if (radiusRange === void 0) { radiusRange = 1; }
        var particleEmitter = new HemisphericParticleEmitter(radius, radiusRange);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
    };
    /**
     * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
     * @param radius The radius of the sphere to emit from
     * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
     * @returns the emitter
     */
    BaseParticleSystem.prototype.createSphereEmitter = function (radius, radiusRange) {
        if (radius === void 0) { radius = 1; }
        if (radiusRange === void 0) { radiusRange = 1; }
        var particleEmitter = new SphereParticleEmitter(radius, radiusRange);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
    };
    /**
     * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
     * @param radius The radius of the sphere to emit from
     * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
     * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
     * @returns the emitter
     */
    BaseParticleSystem.prototype.createDirectedSphereEmitter = function (radius, direction1, direction2) {
        if (radius === void 0) { radius = 1; }
        if (direction1 === void 0) { direction1 = new Vector3(0, 1.0, 0); }
        if (direction2 === void 0) { direction2 = new Vector3(0, 1.0, 0); }
        var particleEmitter = new SphereDirectedParticleEmitter(radius, direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
    };
    /**
     * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
     * @param radius The radius of the emission cylinder
     * @param height The height of the emission cylinder
     * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
     * @param directionRandomizer How much to randomize the particle direction [0-1]
     * @returns the emitter
     */
    BaseParticleSystem.prototype.createCylinderEmitter = function (radius, height, radiusRange, directionRandomizer) {
        if (radius === void 0) { radius = 1; }
        if (height === void 0) { height = 1; }
        if (radiusRange === void 0) { radiusRange = 1; }
        if (directionRandomizer === void 0) { directionRandomizer = 0; }
        var particleEmitter = new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
    };
    /**
     * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
     * @param radius The radius of the cylinder to emit from
     * @param height The height of the emission cylinder
     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
     * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
     * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
     * @returns the emitter
     */
    BaseParticleSystem.prototype.createDirectedCylinderEmitter = function (radius, height, radiusRange, direction1, direction2) {
        if (radius === void 0) { radius = 1; }
        if (height === void 0) { height = 1; }
        if (radiusRange === void 0) { radiusRange = 1; }
        if (direction1 === void 0) { direction1 = new Vector3(0, 1.0, 0); }
        if (direction2 === void 0) { direction2 = new Vector3(0, 1.0, 0); }
        var particleEmitter = new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
    };
    /**
     * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
     * @param radius The radius of the cone to emit from
     * @param angle The base angle of the cone
     * @returns the emitter
     */
    BaseParticleSystem.prototype.createConeEmitter = function (radius, angle) {
        if (radius === void 0) { radius = 1; }
        if (angle === void 0) { angle = Math.PI / 4; }
        var particleEmitter = new ConeParticleEmitter(radius, angle);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
    };
    /**
     * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
     * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
     * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
     * @returns the emitter
     */
    BaseParticleSystem.prototype.createBoxEmitter = function (direction1, direction2, minEmitBox, maxEmitBox) {
        var particleEmitter = new BoxParticleEmitter();
        this.particleEmitterType = particleEmitter;
        this.direction1 = direction1;
        this.direction2 = direction2;
        this.minEmitBox = minEmitBox;
        this.maxEmitBox = maxEmitBox;
        return particleEmitter;
    };
    /**
     * Source color is added to the destination color without alpha affecting the result
     */
    BaseParticleSystem.BLENDMODE_ONEONE = 0;
    /**
     * Blend current color and particle color using particles alpha
     */
    BaseParticleSystem.BLENDMODE_STANDARD = 1;
    /**
     * Add current color and particle color multiplied by particles alpha
     */
    BaseParticleSystem.BLENDMODE_ADD = 2;
    /**
     * Multiply current color with particle color
     */
    BaseParticleSystem.BLENDMODE_MULTIPLY = 3;
    /**
     * Multiply current color with particle color then add current color and particle color multiplied by particles alpha
     */
    BaseParticleSystem.BLENDMODE_MULTIPLYADD = 4;
    return BaseParticleSystem;
}());

/**
 * A particle represents one of the element emitted by a particle system.
 * This is mainly define by its coordinates, direction, velocity and age.
 */
var Particle = /** @class */ (function () {
    /**
     * Creates a new instance Particle
     * @param particleSystem the particle system the particle belongs to
     */
    function Particle(
    /**
     * The particle system the particle belongs to.
     */
    particleSystem) {
        this.particleSystem = particleSystem;
        /**
         * The world position of the particle in the scene.
         */
        this.position = Vector3.Zero();
        /**
         * The world direction of the particle in the scene.
         */
        this.direction = Vector3.Zero();
        /**
         * The color of the particle.
         */
        this.color = new Color4(0, 0, 0, 0);
        /**
         * The color change of the particle per step.
         */
        this.colorStep = new Color4(0, 0, 0, 0);
        /**
         * Defines how long will the life of the particle be.
         */
        this.lifeTime = 1.0;
        /**
         * The current age of the particle.
         */
        this.age = 0;
        /**
         * The current size of the particle.
         */
        this.size = 0;
        /**
         * The current scale of the particle.
         */
        this.scale = new Vector2(1, 1);
        /**
         * The current angle of the particle.
         */
        this.angle = 0;
        /**
         * Defines how fast is the angle changing.
         */
        this.angularSpeed = 0;
        /**
         * Defines the cell index used by the particle to be rendered from a sprite.
         */
        this.cellIndex = 0;
        /** @hidden */
        this._attachedSubEmitters = null;
        /** @hidden */
        this._currentColor1 = new Color4(0, 0, 0, 0);
        /** @hidden */
        this._currentColor2 = new Color4(0, 0, 0, 0);
        /** @hidden */
        this._currentSize1 = 0;
        /** @hidden */
        this._currentSize2 = 0;
        /** @hidden */
        this._currentAngularSpeed1 = 0;
        /** @hidden */
        this._currentAngularSpeed2 = 0;
        /** @hidden */
        this._currentVelocity1 = 0;
        /** @hidden */
        this._currentVelocity2 = 0;
        /** @hidden */
        this._currentLimitVelocity1 = 0;
        /** @hidden */
        this._currentLimitVelocity2 = 0;
        /** @hidden */
        this._currentDrag1 = 0;
        /** @hidden */
        this._currentDrag2 = 0;
        this.id = Particle._Count++;
        if (!this.particleSystem.isAnimationSheetEnabled) {
            return;
        }
        this.updateCellInfoFromSystem();
    }
    Particle.prototype.updateCellInfoFromSystem = function () {
        this.cellIndex = this.particleSystem.startSpriteCellID;
    };
    /**
     * Defines how the sprite cell index is updated for the particle
     */
    Particle.prototype.updateCellIndex = function () {
        var offsetAge = this.age;
        var changeSpeed = this.particleSystem.spriteCellChangeSpeed;
        if (this.particleSystem.spriteRandomStartCell) {
            if (this._randomCellOffset === undefined) {
                this._randomCellOffset = Math.random() * this.lifeTime;
            }
            if (changeSpeed === 0) { // Special case when speed = 0 meaning we want to stay on initial cell
                changeSpeed = 1;
                offsetAge = this._randomCellOffset;
            }
            else {
                offsetAge += this._randomCellOffset;
            }
        }
        var dist = (this._initialEndSpriteCellID - this._initialStartSpriteCellID);
        var ratio = Scalar.Clamp(((offsetAge * changeSpeed) % this.lifeTime) / this.lifeTime);
        this.cellIndex = this._initialStartSpriteCellID + (ratio * dist) | 0;
    };
    /** @hidden */
    Particle.prototype._inheritParticleInfoToSubEmitter = function (subEmitter) {
        if (subEmitter.particleSystem.emitter.position) {
            var emitterMesh = subEmitter.particleSystem.emitter;
            emitterMesh.position.copyFrom(this.position);
            if (subEmitter.inheritDirection) {
                emitterMesh.position.subtractToRef(this.direction, Tmp.Vector3[0]);
                // Look at using Y as forward
                emitterMesh.lookAt(Tmp.Vector3[0], 0, Math.PI / 2);
            }
        }
        else {
            var emitterPosition = subEmitter.particleSystem.emitter;
            emitterPosition.copyFrom(this.position);
        }
        // Set inheritedVelocityOffset to be used when new particles are created
        this.direction.scaleToRef(subEmitter.inheritedVelocityAmount / 2, Tmp.Vector3[0]);
        subEmitter.particleSystem._inheritedVelocityOffset.copyFrom(Tmp.Vector3[0]);
    };
    /** @hidden */
    Particle.prototype._inheritParticleInfoToSubEmitters = function () {
        var _this = this;
        if (this._attachedSubEmitters && this._attachedSubEmitters.length > 0) {
            this._attachedSubEmitters.forEach(function (subEmitter) {
                _this._inheritParticleInfoToSubEmitter(subEmitter);
            });
        }
    };
    /** @hidden */
    Particle.prototype._reset = function () {
        this.age = 0;
        this._currentColorGradient = null;
        this._currentSizeGradient = null;
        this._currentAngularSpeedGradient = null;
        this._currentVelocityGradient = null;
        this._currentLimitVelocityGradient = null;
        this._currentDragGradient = null;
        this.cellIndex = this.particleSystem.startSpriteCellID;
        this._randomCellOffset = undefined;
    };
    /**
     * Copy the properties of particle to another one.
     * @param other the particle to copy the information to.
     */
    Particle.prototype.copyTo = function (other) {
        other.position.copyFrom(this.position);
        if (this._initialDirection) {
            if (other._initialDirection) {
                other._initialDirection.copyFrom(this._initialDirection);
            }
            else {
                other._initialDirection = this._initialDirection.clone();
            }
        }
        else {
            other._initialDirection = null;
        }
        other.direction.copyFrom(this.direction);
        other.color.copyFrom(this.color);
        other.colorStep.copyFrom(this.colorStep);
        other.lifeTime = this.lifeTime;
        other.age = this.age;
        other._randomCellOffset = this._randomCellOffset;
        other.size = this.size;
        other.scale.copyFrom(this.scale);
        other.angle = this.angle;
        other.angularSpeed = this.angularSpeed;
        other.particleSystem = this.particleSystem;
        other.cellIndex = this.cellIndex;
        other.id = this.id;
        other._attachedSubEmitters = this._attachedSubEmitters;
        if (this._currentColorGradient) {
            other._currentColorGradient = this._currentColorGradient;
            other._currentColor1.copyFrom(this._currentColor1);
            other._currentColor2.copyFrom(this._currentColor2);
        }
        if (this._currentSizeGradient) {
            other._currentSizeGradient = this._currentSizeGradient;
            other._currentSize1 = this._currentSize1;
            other._currentSize2 = this._currentSize2;
        }
        if (this._currentAngularSpeedGradient) {
            other._currentAngularSpeedGradient = this._currentAngularSpeedGradient;
            other._currentAngularSpeed1 = this._currentAngularSpeed1;
            other._currentAngularSpeed2 = this._currentAngularSpeed2;
        }
        if (this._currentVelocityGradient) {
            other._currentVelocityGradient = this._currentVelocityGradient;
            other._currentVelocity1 = this._currentVelocity1;
            other._currentVelocity2 = this._currentVelocity2;
        }
        if (this._currentLimitVelocityGradient) {
            other._currentLimitVelocityGradient = this._currentLimitVelocityGradient;
            other._currentLimitVelocity1 = this._currentLimitVelocity1;
            other._currentLimitVelocity2 = this._currentLimitVelocity2;
        }
        if (this._currentDragGradient) {
            other._currentDragGradient = this._currentDragGradient;
            other._currentDrag1 = this._currentDrag1;
            other._currentDrag2 = this._currentDrag2;
        }
        if (this.particleSystem.isAnimationSheetEnabled) {
            other._initialStartSpriteCellID = this._initialStartSpriteCellID;
            other._initialEndSpriteCellID = this._initialEndSpriteCellID;
        }
        if (this.particleSystem.useRampGradients) {
            other.remapData.copyFrom(this.remapData);
        }
        if (this._randomNoiseCoordinates1) {
            if (other._randomNoiseCoordinates1) {
                other._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1);
                other._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2);
            }
            else {
                other._randomNoiseCoordinates1 = this._randomNoiseCoordinates1.clone();
                other._randomNoiseCoordinates2 = this._randomNoiseCoordinates2.clone();
            }
        }
    };
    Particle._Count = 0;
    return Particle;
}());

/**
     * Type of sub emitter
     */
var SubEmitterType;
(function (SubEmitterType) {
    /**
     * Attached to the particle over it's lifetime
     */
    SubEmitterType[SubEmitterType["ATTACHED"] = 0] = "ATTACHED";
    /**
     * Created when the particle dies
     */
    SubEmitterType[SubEmitterType["END"] = 1] = "END";
})(SubEmitterType || (SubEmitterType = {}));
/**
 * Sub emitter class used to emit particles from an existing particle
 */
var SubEmitter = /** @class */ (function () {
    /**
     * Creates a sub emitter
     * @param particleSystem the particle system to be used by the sub emitter
     */
    function SubEmitter(
    /**
     * the particle system to be used by the sub emitter
     */
    particleSystem) {
        this.particleSystem = particleSystem;
        /**
         * Type of the submitter (Default: END)
         */
        this.type = SubEmitterType.END;
        /**
         * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)
         * Note: This only is supported when using an emitter of type Mesh
         */
        this.inheritDirection = false;
        /**
         * How much of the attached particles speed should be added to the sub emitted particle (default: 0)
         */
        this.inheritedVelocityAmount = 0;
        // Create mesh as emitter to support rotation
        if (!particleSystem.emitter || !particleSystem.emitter.dispose) {
            particleSystem.emitter = new AbstractMesh("SubemitterSystemEmitter", particleSystem.getScene());
        }
        // Automatically dispose of subemitter when system is disposed
        particleSystem.onDisposeObservable.add(function () {
            if (particleSystem.emitter && particleSystem.emitter.dispose) {
                particleSystem.emitter.dispose();
            }
        });
    }
    /**
     * Clones the sub emitter
     * @returns the cloned sub emitter
     */
    SubEmitter.prototype.clone = function () {
        // Clone particle system
        var emitter = this.particleSystem.emitter;
        if (!emitter) {
            emitter = new Vector3();
        }
        else if (emitter instanceof Vector3) {
            emitter = emitter.clone();
        }
        else if (emitter instanceof AbstractMesh) {
            emitter = new Mesh("", emitter.getScene());
            emitter.isVisible = false;
        }
        var clone = new SubEmitter(this.particleSystem.clone("", emitter));
        // Clone properties
        clone.type = this.type;
        clone.inheritDirection = this.inheritDirection;
        clone.inheritedVelocityAmount = this.inheritedVelocityAmount;
        clone.particleSystem._disposeEmitterOnDispose = true;
        clone.particleSystem.disposeOnStop = true;
        return clone;
    };
    /**
     * Serialize current object to a JSON object
     * @returns the serialized object
     */
    SubEmitter.prototype.serialize = function () {
        var serializationObject = {};
        serializationObject.type = this.type;
        serializationObject.inheritDirection = this.inheritDirection;
        serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;
        serializationObject.particleSystem = this.particleSystem.serialize();
        return serializationObject;
    };
    /** @hidden */
    SubEmitter._ParseParticleSystem = function (system, scene, rootUrl) {
        throw _DevTools.WarnImport("ParseParticle");
    };
    /**
     * Creates a new SubEmitter from a serialized JSON version
     * @param serializationObject defines the JSON object to read from
     * @param scene defines the hosting scene
     * @param rootUrl defines the rootUrl for data loading
     * @returns a new SubEmitter
     */
    SubEmitter.Parse = function (serializationObject, scene, rootUrl) {
        var system = serializationObject.particleSystem;
        var subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, scene, rootUrl));
        subEmitter.type = serializationObject.type;
        subEmitter.inheritDirection = serializationObject.inheritDirection;
        subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;
        subEmitter.particleSystem._isSubEmitter = true;
        return subEmitter;
    };
    /** Release associated resources */
    SubEmitter.prototype.dispose = function () {
        this.particleSystem.dispose();
    };
    return SubEmitter;
}());

var name$v = 'particlesPixelShader';
var shader$v = "\nvarying vec2 vUV;\nvarying vec4 vColor;\nuniform vec4 textureMask;\nuniform sampler2D diffuseSampler;\n#include<clipPlaneFragmentDeclaration>\n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\nuniform sampler2D rampSampler;\n#endif\nvoid main(void) {\n#include<clipPlaneFragment>\nvec4 textureColor=texture2D(diffuseSampler,vUV);\nvec4 baseColor=(textureColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;\n#ifdef RAMPGRADIENT\nfloat alpha=baseColor.a;\nfloat remappedColorIndex=clamp((alpha-remapRanges.x)/remapRanges.y,0.0,1.0);\nvec4 rampColor=texture2D(rampSampler,vec2(1.0-remappedColorIndex,0.));\nbaseColor.rgb*=rampColor.rgb;\n\nfloat finalAlpha=baseColor.a;\nbaseColor.a=clamp((alpha*rampColor.a-remapRanges.z)/remapRanges.w,0.0,1.0);\n#endif\n#ifdef BLENDMULTIPLYMODE\nfloat sourceAlpha=vColor.a*textureColor.a;\nbaseColor.rgb=baseColor.rgb*sourceAlpha+vec3(1.0)*(1.0-sourceAlpha);\n#endif\n\n\n#ifdef IMAGEPROCESSINGPOSTPROCESS\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\n#else\n#ifdef IMAGEPROCESSING\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\nbaseColor=applyImageProcessing(baseColor);\n#endif\n#endif\ngl_FragColor=baseColor;\n}";
Effect.ShadersStore[name$v] = shader$v;

var name$w = 'particlesVertexShader';
var shader$w = "\nattribute vec3 position;\nattribute vec4 color;\nattribute float angle;\nattribute vec2 size;\n#ifdef ANIMATESHEET\nattribute float cellIndex;\n#endif\n#ifndef BILLBOARD\nattribute vec3 direction;\n#endif\n#ifdef BILLBOARDSTRETCHED\nattribute vec3 direction;\n#endif\n#ifdef RAMPGRADIENT\nattribute vec4 remapData;\n#endif\nattribute vec2 offset;\n\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec2 translationPivot;\n#ifdef ANIMATESHEET\nuniform vec3 particlesInfos;\n#endif\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\n#endif\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4)\nuniform mat4 invView;\n#endif\n#include<clipPlaneVertexDeclaration>\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\n#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\nvec3 zaxis=normalize(cross(yaxis,xaxis));\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\nmat3 rotMatrix=mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\nreturn position+alignedCorner;\n}\n#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\nvec3 normalizedToCamera=normalize(toCamera);\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\nmat3 rotMatrix=mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\nreturn position+alignedCorner;\n}\n#endif\nvoid main(void) {\nvec2 cornerPos;\ncornerPos=(vec2(offset.x-0.5,offset.y-0.5)-translationPivot)*size+translationPivot;\n#ifdef BILLBOARD\n\nvec3 rotatedCorner;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.y=0.;\nvec3 yaxis=position-eyePosition;\nyaxis.y=0.;\nvec3 worldPos=rotate(normalize(yaxis),rotatedCorner);\nvec3 viewPos=(view*vec4(worldPos,1.0)).xyz;\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\nvec3 toCamera=position-eyePosition;\nvec3 worldPos=rotateAlign(toCamera,rotatedCorner);\nvec3 viewPos=(view*vec4(worldPos,1.0)).xyz;\n#else\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\nvec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;\n#endif\n#ifdef RAMPGRADIENT\nremapRanges=remapData;\n#endif\n\ngl_Position=projection*vec4(viewPos,1.0);\n#else\n\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.y=0.;\nvec3 yaxis=normalize(direction);\nvec3 worldPos=rotate(yaxis,rotatedCorner);\ngl_Position=projection*view*vec4(worldPos,1.0);\n#endif\nvColor=color;\n#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex/particlesInfos.z);\nfloat columnOffset=cellIndex-rowOffset*particlesInfos.z;\nvec2 uvScale=particlesInfos.xy;\nvec2 uvOffset=vec2(offset.x ,1.0-offset.y);\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\n#else\nvUV=offset;\n#endif\n\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4)\nvec4 worldPos=invView*vec4(viewPos,1.0);\n#endif\n#include<clipPlaneVertex>\n}";
Effect.ShadersStore[name$w] = shader$w;

/**
 * This represents a particle system in Babylon.
 * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
 * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
 * @example https://doc.babylonjs.com/babylon101/particles
 */
var ParticleSystem = /** @class */ (function (_super) {
    __extends(ParticleSystem, _super);
    /**
     * Instantiates a particle system.
     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
     * @param name The name of the particle system
     * @param capacity The max number of particles alive at the same time
     * @param scene The scene the particle system belongs to
     * @param customEffect a custom effect used to change the way particles are rendered by default
     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
     * @param epsilon Offset used to render the particles
     */
    function ParticleSystem(name, capacity, scene, customEffect, isAnimationSheetEnabled, epsilon) {
        if (customEffect === void 0) { customEffect = null; }
        if (isAnimationSheetEnabled === void 0) { isAnimationSheetEnabled = false; }
        if (epsilon === void 0) { epsilon = 0.01; }
        var _this = _super.call(this, name) || this;
        /**
         * @hidden
         */
        _this._inheritedVelocityOffset = new Vector3();
        /**
        * An event triggered when the system is disposed
        */
        _this.onDisposeObservable = new Observable();
        _this._particles = new Array();
        _this._stockParticles = new Array();
        _this._newPartsExcess = 0;
        _this._vertexBuffers = {};
        _this._scaledColorStep = new Color4(0, 0, 0, 0);
        _this._colorDiff = new Color4(0, 0, 0, 0);
        _this._scaledDirection = Vector3.Zero();
        _this._scaledGravity = Vector3.Zero();
        _this._currentRenderId = -1;
        _this._useInstancing = false;
        _this._started = false;
        _this._stopped = false;
        _this._actualFrame = 0;
        /** @hidden */
        _this._currentEmitRate1 = 0;
        /** @hidden */
        _this._currentEmitRate2 = 0;
        /** @hidden */
        _this._currentStartSize1 = 0;
        /** @hidden */
        _this._currentStartSize2 = 0;
        _this._rawTextureWidth = 256;
        _this._useRampGradients = false;
        /**
         * @hidden
         * If the particle systems emitter should be disposed when the particle system is disposed
         */
        _this._disposeEmitterOnDispose = false;
        // start of sub system methods
        /**
         * "Recycles" one of the particle by copying it back to the "stock" of particles and removing it from the active list.
         * Its lifetime will start back at 0.
         */
        _this.recycleParticle = function (particle) {
            // move particle from activeParticle list to stock particles
            var lastParticle = _this._particles.pop();
            if (lastParticle !== particle) {
                lastParticle.copyTo(particle);
            }
            _this._stockParticles.push(lastParticle);
        };
        _this._createParticle = function () {
            var particle;
            if (_this._stockParticles.length !== 0) {
                particle = _this._stockParticles.pop();
                particle._reset();
            }
            else {
                particle = new Particle(_this);
            }
            // Attach emitters
            if (_this._subEmitters && _this._subEmitters.length > 0) {
                var subEmitters = _this._subEmitters[Math.floor(Math.random() * _this._subEmitters.length)];
                particle._attachedSubEmitters = [];
                subEmitters.forEach(function (subEmitter) {
                    if (subEmitter.type === SubEmitterType.ATTACHED) {
                        var newEmitter = subEmitter.clone();
                        particle._attachedSubEmitters.push(newEmitter);
                        newEmitter.particleSystem.start();
                    }
                });
            }
            return particle;
        };
        _this._emitFromParticle = function (particle) {
            if (!_this._subEmitters || _this._subEmitters.length === 0) {
                return;
            }
            var templateIndex = Math.floor(Math.random() * _this._subEmitters.length);
            _this._subEmitters[templateIndex].forEach(function (subEmitter) {
                if (subEmitter.type === SubEmitterType.END) {
                    var subSystem = subEmitter.clone();
                    particle._inheritParticleInfoToSubEmitter(subSystem);
                    subSystem.particleSystem._rootParticleSystem = _this;
                    _this.activeSubSystems.push(subSystem.particleSystem);
                    subSystem.particleSystem.start();
                }
            });
        };
        _this._capacity = capacity;
        _this._epsilon = epsilon;
        _this._isAnimationSheetEnabled = isAnimationSheetEnabled;
        _this._scene = scene || EngineStore.LastCreatedScene;
        // Setup the default processing configuration to the scene.
        _this._attachImageProcessingConfiguration(null);
        _this._customEffect = customEffect;
        _this._scene.particleSystems.push(_this);
        _this._useInstancing = _this._scene.getEngine().getCaps().instancedArrays;
        _this._createIndexBuffer();
        _this._createVertexBuffers();
        // Default emitter type
        _this.particleEmitterType = new BoxParticleEmitter();
        // Update
        _this.updateFunction = function (particles) {
            var noiseTextureSize = null;
            var noiseTextureData = null;
            if (_this.noiseTexture) { // We need to get texture data back to CPU
                noiseTextureSize = _this.noiseTexture.getSize();
                noiseTextureData = (_this.noiseTexture.getContent());
            }
            var _loop_1 = function () {
                particle = particles[index];
                var scaledUpdateSpeed = _this._scaledUpdateSpeed;
                var previousAge = particle.age;
                particle.age += scaledUpdateSpeed;
                // Evaluate step to death
                if (particle.age > particle.lifeTime) {
                    var diff = particle.age - previousAge;
                    var oldDiff = particle.lifeTime - previousAge;
                    scaledUpdateSpeed = (oldDiff * scaledUpdateSpeed) / diff;
                    particle.age = particle.lifeTime;
                }
                var ratio = particle.age / particle.lifeTime;
                // Color
                if (_this._colorGradients && _this._colorGradients.length > 0) {
                    Tools.GetCurrentGradient(ratio, _this._colorGradients, function (currentGradient, nextGradient, scale) {
                        if (currentGradient !== particle._currentColorGradient) {
                            particle._currentColor1.copyFrom(particle._currentColor2);
                            nextGradient.getColorToRef(particle._currentColor2);
                            particle._currentColorGradient = currentGradient;
                        }
                        Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);
                    });
                }
                else {
                    particle.colorStep.scaleToRef(scaledUpdateSpeed, _this._scaledColorStep);
                    particle.color.addInPlace(_this._scaledColorStep);
                    if (particle.color.a < 0) {
                        particle.color.a = 0;
                    }
                }
                // Angular speed
                if (_this._angularSpeedGradients && _this._angularSpeedGradients.length > 0) {
                    Tools.GetCurrentGradient(ratio, _this._angularSpeedGradients, function (currentGradient, nextGradient, scale) {
                        if (currentGradient !== particle._currentAngularSpeedGradient) {
                            particle._currentAngularSpeed1 = particle._currentAngularSpeed2;
                            particle._currentAngularSpeed2 = nextGradient.getFactor();
                            particle._currentAngularSpeedGradient = currentGradient;
                        }
                        particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);
                    });
                }
                particle.angle += particle.angularSpeed * scaledUpdateSpeed;
                // Direction
                var directionScale = scaledUpdateSpeed;
                /// Velocity
                if (_this._velocityGradients && _this._velocityGradients.length > 0) {
                    Tools.GetCurrentGradient(ratio, _this._velocityGradients, function (currentGradient, nextGradient, scale) {
                        if (currentGradient !== particle._currentVelocityGradient) {
                            particle._currentVelocity1 = particle._currentVelocity2;
                            particle._currentVelocity2 = nextGradient.getFactor();
                            particle._currentVelocityGradient = currentGradient;
                        }
                        directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);
                    });
                }
                particle.direction.scaleToRef(directionScale, _this._scaledDirection);
                /// Limit velocity
                if (_this._limitVelocityGradients && _this._limitVelocityGradients.length > 0) {
                    Tools.GetCurrentGradient(ratio, _this._limitVelocityGradients, function (currentGradient, nextGradient, scale) {
                        if (currentGradient !== particle._currentLimitVelocityGradient) {
                            particle._currentLimitVelocity1 = particle._currentLimitVelocity2;
                            particle._currentLimitVelocity2 = nextGradient.getFactor();
                            particle._currentLimitVelocityGradient = currentGradient;
                        }
                        var limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);
                        var currentVelocity = particle.direction.length();
                        if (currentVelocity > limitVelocity) {
                            particle.direction.scaleInPlace(_this.limitVelocityDamping);
                        }
                    });
                }
                /// Drag
                if (_this._dragGradients && _this._dragGradients.length > 0) {
                    Tools.GetCurrentGradient(ratio, _this._dragGradients, function (currentGradient, nextGradient, scale) {
                        if (currentGradient !== particle._currentDragGradient) {
                            particle._currentDrag1 = particle._currentDrag2;
                            particle._currentDrag2 = nextGradient.getFactor();
                            particle._currentDragGradient = currentGradient;
                        }
                        var drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);
                        _this._scaledDirection.scaleInPlace(1.0 - drag);
                    });
                }
                particle.position.addInPlace(_this._scaledDirection);
                // Noise
                if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {
                    var fetchedColorR = _this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
                    var fetchedColorG = _this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
                    var fetchedColorB = _this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
                    var force = Tmp.Vector3[0];
                    var scaledForce = Tmp.Vector3[1];
                    force.copyFromFloats((2 * fetchedColorR - 1) * _this.noiseStrength.x, (2 * fetchedColorG - 1) * _this.noiseStrength.y, (2 * fetchedColorB - 1) * _this.noiseStrength.z);
                    force.scaleToRef(scaledUpdateSpeed, scaledForce);
                    particle.direction.addInPlace(scaledForce);
                }
                // Gravity
                _this.gravity.scaleToRef(scaledUpdateSpeed, _this._scaledGravity);
                particle.direction.addInPlace(_this._scaledGravity);
                // Size
                if (_this._sizeGradients && _this._sizeGradients.length > 0) {
                    Tools.GetCurrentGradient(ratio, _this._sizeGradients, function (currentGradient, nextGradient, scale) {
                        if (currentGradient !== particle._currentSizeGradient) {
                            particle._currentSize1 = particle._currentSize2;
                            particle._currentSize2 = nextGradient.getFactor();
                            particle._currentSizeGradient = currentGradient;
                        }
                        particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);
                    });
                }
                // Remap data
                if (_this._useRampGradients) {
                    if (_this._colorRemapGradients && _this._colorRemapGradients.length > 0) {
                        Tools.GetCurrentGradient(ratio, _this._colorRemapGradients, function (currentGradient, nextGradient, scale) {
                            var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
                            var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);
                            particle.remapData.x = min;
                            particle.remapData.y = max - min;
                        });
                    }
                    if (_this._alphaRemapGradients && _this._alphaRemapGradients.length > 0) {
                        Tools.GetCurrentGradient(ratio, _this._alphaRemapGradients, function (currentGradient, nextGradient, scale) {
                            var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
                            var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);
                            particle.remapData.z = min;
                            particle.remapData.w = max - min;
                        });
                    }
                }
                if (_this._isAnimationSheetEnabled) {
                    particle.updateCellIndex();
                }
                // Update the position of the attached sub-emitters to match their attached particle
                particle._inheritParticleInfoToSubEmitters();
                if (particle.age >= particle.lifeTime) { // Recycle by swapping with last particle
                    _this._emitFromParticle(particle);
                    if (particle._attachedSubEmitters) {
                        particle._attachedSubEmitters.forEach(function (subEmitter) {
                            subEmitter.particleSystem.disposeOnStop = true;
                            subEmitter.particleSystem.stop();
                        });
                        particle._attachedSubEmitters = null;
                    }
                    _this.recycleParticle(particle);
                    index--;
                    return "continue";
                }
            };
            var particle;
            for (var index = 0; index < particles.length; index++) {
                _loop_1();
            }
        };
        return _this;
    }
    Object.defineProperty(ParticleSystem.prototype, "onDispose", {
        /**
         * Sets a callback that will be triggered when the system is disposed
         */
        set: function (callback) {
            if (this._onDisposeObserver) {
                this.onDisposeObservable.remove(this._onDisposeObserver);
            }
            this._onDisposeObserver = this.onDisposeObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSystem.prototype, "useRampGradients", {
        /** Gets or sets a boolean indicating that ramp gradients must be used
         * @see http://doc.babylonjs.com/babylon101/particles#ramp-gradients
         */
        get: function () {
            return this._useRampGradients;
        },
        set: function (value) {
            if (this._useRampGradients === value) {
                return;
            }
            this._useRampGradients = value;
            this._resetEffect();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSystem.prototype, "particles", {
        //end of Sub-emitter
        /**
         * Gets the current list of active particles
         */
        get: function () {
            return this._particles;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the string "ParticleSystem"
     * @returns a string containing the class name
     */
    ParticleSystem.prototype.getClassName = function () {
        return "ParticleSystem";
    };
    ParticleSystem.prototype._addFactorGradient = function (factorGradients, gradient, factor, factor2) {
        var newGradient = new FactorGradient();
        newGradient.gradient = gradient;
        newGradient.factor1 = factor;
        newGradient.factor2 = factor2;
        factorGradients.push(newGradient);
        factorGradients.sort(function (a, b) {
            if (a.gradient < b.gradient) {
                return -1;
            }
            else if (a.gradient > b.gradient) {
                return 1;
            }
            return 0;
        });
    };
    ParticleSystem.prototype._removeFactorGradient = function (factorGradients, gradient) {
        if (!factorGradients) {
            return;
        }
        var index = 0;
        for (var _i = 0, factorGradients_1 = factorGradients; _i < factorGradients_1.length; _i++) {
            var factorGradient = factorGradients_1[_i];
            if (factorGradient.gradient === gradient) {
                factorGradients.splice(index, 1);
                break;
            }
            index++;
        }
    };
    /**
     * Adds a new life time gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the life time factor to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    ParticleSystem.prototype.addLifeTimeGradient = function (gradient, factor, factor2) {
        if (!this._lifeTimeGradients) {
            this._lifeTimeGradients = [];
        }
        this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);
        return this;
    };
    /**
     * Remove a specific life time gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeLifeTimeGradient = function (gradient) {
        this._removeFactorGradient(this._lifeTimeGradients, gradient);
        return this;
    };
    /**
     * Adds a new size gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the size factor to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    ParticleSystem.prototype.addSizeGradient = function (gradient, factor, factor2) {
        if (!this._sizeGradients) {
            this._sizeGradients = [];
        }
        this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);
        return this;
    };
    /**
     * Remove a specific size gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeSizeGradient = function (gradient) {
        this._removeFactorGradient(this._sizeGradients, gradient);
        return this;
    };
    /**
     * Adds a new color remap gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param min defines the color remap minimal range
     * @param max defines the color remap maximal range
     * @returns the current particle system
     */
    ParticleSystem.prototype.addColorRemapGradient = function (gradient, min, max) {
        if (!this._colorRemapGradients) {
            this._colorRemapGradients = [];
        }
        this._addFactorGradient(this._colorRemapGradients, gradient, min, max);
        return this;
    };
    /**
     * Remove a specific color remap gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeColorRemapGradient = function (gradient) {
        this._removeFactorGradient(this._colorRemapGradients, gradient);
        return this;
    };
    /**
     * Adds a new alpha remap gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param min defines the alpha remap minimal range
     * @param max defines the alpha remap maximal range
     * @returns the current particle system
     */
    ParticleSystem.prototype.addAlphaRemapGradient = function (gradient, min, max) {
        if (!this._alphaRemapGradients) {
            this._alphaRemapGradients = [];
        }
        this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);
        return this;
    };
    /**
     * Remove a specific alpha remap gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeAlphaRemapGradient = function (gradient) {
        this._removeFactorGradient(this._alphaRemapGradients, gradient);
        return this;
    };
    /**
     * Adds a new angular speed gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the angular speed  to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    ParticleSystem.prototype.addAngularSpeedGradient = function (gradient, factor, factor2) {
        if (!this._angularSpeedGradients) {
            this._angularSpeedGradients = [];
        }
        this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);
        return this;
    };
    /**
     * Remove a specific angular speed gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeAngularSpeedGradient = function (gradient) {
        this._removeFactorGradient(this._angularSpeedGradients, gradient);
        return this;
    };
    /**
     * Adds a new velocity gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the velocity to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    ParticleSystem.prototype.addVelocityGradient = function (gradient, factor, factor2) {
        if (!this._velocityGradients) {
            this._velocityGradients = [];
        }
        this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);
        return this;
    };
    /**
     * Remove a specific velocity gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeVelocityGradient = function (gradient) {
        this._removeFactorGradient(this._velocityGradients, gradient);
        return this;
    };
    /**
     * Adds a new limit velocity gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the limit velocity value to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    ParticleSystem.prototype.addLimitVelocityGradient = function (gradient, factor, factor2) {
        if (!this._limitVelocityGradients) {
            this._limitVelocityGradients = [];
        }
        this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);
        return this;
    };
    /**
     * Remove a specific limit velocity gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeLimitVelocityGradient = function (gradient) {
        this._removeFactorGradient(this._limitVelocityGradients, gradient);
        return this;
    };
    /**
     * Adds a new drag gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the drag value to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    ParticleSystem.prototype.addDragGradient = function (gradient, factor, factor2) {
        if (!this._dragGradients) {
            this._dragGradients = [];
        }
        this._addFactorGradient(this._dragGradients, gradient, factor, factor2);
        return this;
    };
    /**
     * Remove a specific drag gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeDragGradient = function (gradient) {
        this._removeFactorGradient(this._dragGradients, gradient);
        return this;
    };
    /**
     * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the emit rate value to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    ParticleSystem.prototype.addEmitRateGradient = function (gradient, factor, factor2) {
        if (!this._emitRateGradients) {
            this._emitRateGradients = [];
        }
        this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);
        return this;
    };
    /**
     * Remove a specific emit rate gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeEmitRateGradient = function (gradient) {
        this._removeFactorGradient(this._emitRateGradients, gradient);
        return this;
    };
    /**
     * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the start size value to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    ParticleSystem.prototype.addStartSizeGradient = function (gradient, factor, factor2) {
        if (!this._startSizeGradients) {
            this._startSizeGradients = [];
        }
        this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);
        return this;
    };
    /**
     * Remove a specific start size gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeStartSizeGradient = function (gradient) {
        this._removeFactorGradient(this._emitRateGradients, gradient);
        return this;
    };
    ParticleSystem.prototype._createRampGradientTexture = function () {
        if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture) {
            return;
        }
        var data = new Uint8Array(this._rawTextureWidth * 4);
        var tmpColor = Tmp.Color3[0];
        for (var x = 0; x < this._rawTextureWidth; x++) {
            var ratio = x / this._rawTextureWidth;
            Tools.GetCurrentGradient(ratio, this._rampGradients, function (currentGradient, nextGradient, scale) {
                Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);
                data[x * 4] = tmpColor.r * 255;
                data[x * 4 + 1] = tmpColor.g * 255;
                data[x * 4 + 2] = tmpColor.b * 255;
                data[x * 4 + 3] = 255;
            });
        }
        this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Texture.NEAREST_SAMPLINGMODE);
    };
    /**
     * Gets the current list of ramp gradients.
     * You must use addRampGradient and removeRampGradient to udpate this list
     * @returns the list of ramp gradients
     */
    ParticleSystem.prototype.getRampGradients = function () {
        return this._rampGradients;
    };
    /**
     * Adds a new ramp gradient used to remap particle colors
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param color defines the color to affect to the specified gradient
     * @returns the current particle system
     */
    ParticleSystem.prototype.addRampGradient = function (gradient, color) {
        if (!this._rampGradients) {
            this._rampGradients = [];
        }
        var rampGradient = new Color3Gradient();
        rampGradient.gradient = gradient;
        rampGradient.color = color;
        this._rampGradients.push(rampGradient);
        this._rampGradients.sort(function (a, b) {
            if (a.gradient < b.gradient) {
                return -1;
            }
            else if (a.gradient > b.gradient) {
                return 1;
            }
            return 0;
        });
        if (this._rampGradientsTexture) {
            this._rampGradientsTexture.dispose();
            this._rampGradientsTexture = null;
        }
        this._createRampGradientTexture();
        return this;
    };
    /**
     * Remove a specific ramp gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    ParticleSystem.prototype.removeRampGradient = function (gradient) {
        this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);
        this._rampGradientsTexture = null;
        if (this._rampGradients && this._rampGradients.length > 0) {
            this._createRampGradientTexture();
        }
        return this;
    };
    /**
     * Adds a new color gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param color1 defines the color to affect to the specified gradient
     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
     * @returns this particle system
     */
    ParticleSystem.prototype.addColorGradient = function (gradient, color1, color2) {
        if (!this._colorGradients) {
            this._colorGradients = [];
        }
        var colorGradient = new ColorGradient();
        colorGradient.gradient = gradient;
        colorGradient.color1 = color1;
        colorGradient.color2 = color2;
        this._colorGradients.push(colorGradient);
        this._colorGradients.sort(function (a, b) {
            if (a.gradient < b.gradient) {
                return -1;
            }
            else if (a.gradient > b.gradient) {
                return 1;
            }
            return 0;
        });
        return this;
    };
    /**
     * Remove a specific color gradient
     * @param gradient defines the gradient to remove
     * @returns this particle system
     */
    ParticleSystem.prototype.removeColorGradient = function (gradient) {
        if (!this._colorGradients) {
            return this;
        }
        var index = 0;
        for (var _i = 0, _a = this._colorGradients; _i < _a.length; _i++) {
            var colorGradient = _a[_i];
            if (colorGradient.gradient === gradient) {
                this._colorGradients.splice(index, 1);
                break;
            }
            index++;
        }
        return this;
    };
    ParticleSystem.prototype._fetchR = function (u, v, width, height, pixels) {
        u = Math.abs(u) * 0.5 + 0.5;
        v = Math.abs(v) * 0.5 + 0.5;
        var wrappedU = ((u * width) % width) | 0;
        var wrappedV = ((v * height) % height) | 0;
        var position = (wrappedU + wrappedV * width) * 4;
        return pixels[position] / 255;
    };
    ParticleSystem.prototype._reset = function () {
        this._resetEffect();
    };
    ParticleSystem.prototype._resetEffect = function () {
        if (this._vertexBuffer) {
            this._vertexBuffer.dispose();
            this._vertexBuffer = null;
        }
        if (this._spriteBuffer) {
            this._spriteBuffer.dispose();
            this._spriteBuffer = null;
        }
        this._createVertexBuffers();
    };
    ParticleSystem.prototype._createVertexBuffers = function () {
        this._vertexBufferSize = this._useInstancing ? 10 : 12;
        if (this._isAnimationSheetEnabled) {
            this._vertexBufferSize += 1;
        }
        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {
            this._vertexBufferSize += 3;
        }
        if (this._useRampGradients) {
            this._vertexBufferSize += 4;
        }
        var engine = this._scene.getEngine();
        this._vertexData = new Float32Array(this._capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));
        this._vertexBuffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);
        var dataOffset = 0;
        var positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);
        this._vertexBuffers[VertexBuffer.PositionKind] = positions;
        dataOffset += 3;
        var colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);
        this._vertexBuffers[VertexBuffer.ColorKind] = colors;
        dataOffset += 4;
        var options = this._vertexBuffer.createVertexBuffer("angle", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
        this._vertexBuffers["angle"] = options;
        dataOffset += 1;
        var size = this._vertexBuffer.createVertexBuffer("size", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
        this._vertexBuffers["size"] = size;
        dataOffset += 2;
        if (this._isAnimationSheetEnabled) {
            var cellIndexBuffer = this._vertexBuffer.createVertexBuffer("cellIndex", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
            this._vertexBuffers["cellIndex"] = cellIndexBuffer;
            dataOffset += 1;
        }
        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {
            var directionBuffer = this._vertexBuffer.createVertexBuffer("direction", dataOffset, 3, this._vertexBufferSize, this._useInstancing);
            this._vertexBuffers["direction"] = directionBuffer;
            dataOffset += 3;
        }
        if (this._useRampGradients) {
            var rampDataBuffer = this._vertexBuffer.createVertexBuffer("remapData", dataOffset, 4, this._vertexBufferSize, this._useInstancing);
            this._vertexBuffers["remapData"] = rampDataBuffer;
            dataOffset += 4;
        }
        var offsets;
        if (this._useInstancing) {
            var spriteData = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);
            offsets = this._spriteBuffer.createVertexBuffer("offset", 0, 2);
        }
        else {
            offsets = this._vertexBuffer.createVertexBuffer("offset", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
            dataOffset += 2;
        }
        this._vertexBuffers["offset"] = offsets;
    };
    ParticleSystem.prototype._createIndexBuffer = function () {
        if (this._useInstancing) {
            return;
        }
        var indices = [];
        var index = 0;
        for (var count = 0; count < this._capacity; count++) {
            indices.push(index);
            indices.push(index + 1);
            indices.push(index + 2);
            indices.push(index);
            indices.push(index + 2);
            indices.push(index + 3);
            index += 4;
        }
        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);
    };
    /**
     * Gets the maximum number of particles active at the same time.
     * @returns The max number of active particles.
     */
    ParticleSystem.prototype.getCapacity = function () {
        return this._capacity;
    };
    /**
     * Gets whether there are still active particles in the system.
     * @returns True if it is alive, otherwise false.
     */
    ParticleSystem.prototype.isAlive = function () {
        return this._alive;
    };
    /**
     * Gets if the system has been started. (Note: this will still be true after stop is called)
     * @returns True if it has been started, otherwise false.
     */
    ParticleSystem.prototype.isStarted = function () {
        return this._started;
    };
    ParticleSystem.prototype._prepareSubEmitterInternalArray = function () {
        var _this = this;
        this._subEmitters = new Array();
        if (this.subEmitters) {
            this.subEmitters.forEach(function (subEmitter) {
                if (subEmitter instanceof ParticleSystem) {
                    _this._subEmitters.push([new SubEmitter(subEmitter)]);
                }
                else if (subEmitter instanceof SubEmitter) {
                    _this._subEmitters.push([subEmitter]);
                }
                else if (subEmitter instanceof Array) {
                    _this._subEmitters.push(subEmitter);
                }
            });
        }
    };
    /**
     * Starts the particle system and begins to emit
     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
     */
    ParticleSystem.prototype.start = function (delay) {
        var _this = this;
        if (delay === void 0) { delay = this.startDelay; }
        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
            throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
        }
        if (delay) {
            setTimeout(function () {
                _this.start(0);
            }, delay);
            return;
        }
        // Convert the subEmitters field to the constant type field _subEmitters
        this._prepareSubEmitterInternalArray();
        this._started = true;
        this._stopped = false;
        this._actualFrame = 0;
        if (this._subEmitters && this._subEmitters.length != 0) {
            this.activeSubSystems = new Array();
        }
        // Reset emit gradient so it acts the same on every start
        if (this._emitRateGradients) {
            if (this._emitRateGradients.length > 0) {
                this._currentEmitRateGradient = this._emitRateGradients[0];
                this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();
                this._currentEmitRate2 = this._currentEmitRate1;
            }
            if (this._emitRateGradients.length > 1) {
                this._currentEmitRate2 = this._emitRateGradients[1].getFactor();
            }
        }
        // Reset start size gradient so it acts the same on every start
        if (this._startSizeGradients) {
            if (this._startSizeGradients.length > 0) {
                this._currentStartSizeGradient = this._startSizeGradients[0];
                this._currentStartSize1 = this._currentStartSizeGradient.getFactor();
                this._currentStartSize2 = this._currentStartSize1;
            }
            if (this._startSizeGradients.length > 1) {
                this._currentStartSize2 = this._startSizeGradients[1].getFactor();
            }
        }
        if (this.preWarmCycles) {
            if (this.emitter instanceof AbstractMesh) {
                this.emitter.computeWorldMatrix(true);
            }
            var noiseTextureAsProcedural_1 = this.noiseTexture;
            if (noiseTextureAsProcedural_1 && noiseTextureAsProcedural_1.onGeneratedObservable) {
                noiseTextureAsProcedural_1.onGeneratedObservable.addOnce(function () {
                    setTimeout(function () {
                        for (var index = 0; index < _this.preWarmCycles; index++) {
                            _this.animate(true);
                            noiseTextureAsProcedural_1.render();
                        }
                    });
                });
            }
            else {
                for (var index = 0; index < this.preWarmCycles; index++) {
                    this.animate(true);
                }
            }
        }
        // Animations
        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0) {
            this.getScene().beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
        }
    };
    /**
     * Stops the particle system.
     * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.
     */
    ParticleSystem.prototype.stop = function (stopSubEmitters) {
        if (stopSubEmitters === void 0) { stopSubEmitters = true; }
        this._stopped = true;
        if (stopSubEmitters) {
            this._stopSubEmitters();
        }
    };
    // animation sheet
    /**
     * Remove all active particles
     */
    ParticleSystem.prototype.reset = function () {
        this._stockParticles = [];
        this._particles = [];
    };
    /**
     * @hidden (for internal use only)
     */
    ParticleSystem.prototype._appendParticleVertex = function (index, particle, offsetX, offsetY) {
        var offset = index * this._vertexBufferSize;
        this._vertexData[offset++] = particle.position.x + this.worldOffset.x;
        this._vertexData[offset++] = particle.position.y + this.worldOffset.y;
        this._vertexData[offset++] = particle.position.z + this.worldOffset.z;
        this._vertexData[offset++] = particle.color.r;
        this._vertexData[offset++] = particle.color.g;
        this._vertexData[offset++] = particle.color.b;
        this._vertexData[offset++] = particle.color.a;
        this._vertexData[offset++] = particle.angle;
        this._vertexData[offset++] = particle.scale.x * particle.size;
        this._vertexData[offset++] = particle.scale.y * particle.size;
        if (this._isAnimationSheetEnabled) {
            this._vertexData[offset++] = particle.cellIndex;
        }
        if (!this._isBillboardBased) {
            if (particle._initialDirection) {
                this._vertexData[offset++] = particle._initialDirection.x;
                this._vertexData[offset++] = particle._initialDirection.y;
                this._vertexData[offset++] = particle._initialDirection.z;
            }
            else {
                this._vertexData[offset++] = particle.direction.x;
                this._vertexData[offset++] = particle.direction.y;
                this._vertexData[offset++] = particle.direction.z;
            }
        }
        else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {
            this._vertexData[offset++] = particle.direction.x;
            this._vertexData[offset++] = particle.direction.y;
            this._vertexData[offset++] = particle.direction.z;
        }
        if (this._useRampGradients) {
            this._vertexData[offset++] = particle.remapData.x;
            this._vertexData[offset++] = particle.remapData.y;
            this._vertexData[offset++] = particle.remapData.z;
            this._vertexData[offset++] = particle.remapData.w;
        }
        if (!this._useInstancing) {
            if (this._isAnimationSheetEnabled) {
                if (offsetX === 0) {
                    offsetX = this._epsilon;
                }
                else if (offsetX === 1) {
                    offsetX = 1 - this._epsilon;
                }
                if (offsetY === 0) {
                    offsetY = this._epsilon;
                }
                else if (offsetY === 1) {
                    offsetY = 1 - this._epsilon;
                }
            }
            this._vertexData[offset++] = offsetX;
            this._vertexData[offset++] = offsetY;
        }
    };
    ParticleSystem.prototype._stopSubEmitters = function () {
        if (!this.activeSubSystems) {
            return;
        }
        this.activeSubSystems.forEach(function (subSystem) {
            subSystem.stop(true);
        });
        this.activeSubSystems = new Array();
    };
    ParticleSystem.prototype._removeFromRoot = function () {
        if (!this._rootParticleSystem) {
            return;
        }
        var index = this._rootParticleSystem.activeSubSystems.indexOf(this);
        if (index !== -1) {
            this._rootParticleSystem.activeSubSystems.splice(index, 1);
        }
        this._rootParticleSystem = null;
    };
    // End of sub system methods
    ParticleSystem.prototype._update = function (newParticles) {
        var _this = this;
        // Update current
        this._alive = this._particles.length > 0;
        if (this.emitter.position) {
            var emitterMesh = this.emitter;
            this._emitterWorldMatrix = emitterMesh.getWorldMatrix();
        }
        else {
            var emitterPosition = this.emitter;
            this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);
        }
        this.updateFunction(this._particles);
        // Add new ones
        var particle;
        var _loop_2 = function () {
            if (this_1._particles.length === this_1._capacity) {
                return "break";
            }
            particle = this_1._createParticle();
            this_1._particles.push(particle);
            // Emitter
            var emitPower = Scalar.RandomRange(this_1.minEmitPower, this_1.maxEmitPower);
            if (this_1.startPositionFunction) {
                this_1.startPositionFunction(this_1._emitterWorldMatrix, particle.position, particle);
            }
            else {
                this_1.particleEmitterType.startPositionFunction(this_1._emitterWorldMatrix, particle.position, particle);
            }
            if (this_1.startDirectionFunction) {
                this_1.startDirectionFunction(this_1._emitterWorldMatrix, particle.direction, particle);
            }
            else {
                this_1.particleEmitterType.startDirectionFunction(this_1._emitterWorldMatrix, particle.direction, particle);
            }
            if (emitPower === 0) {
                if (!particle._initialDirection) {
                    particle._initialDirection = particle.direction.clone();
                }
                else {
                    particle._initialDirection.copyFrom(particle.direction);
                }
            }
            else {
                particle._initialDirection = null;
            }
            particle.direction.scaleInPlace(emitPower);
            // Life time
            if (this_1.targetStopDuration && this_1._lifeTimeGradients && this_1._lifeTimeGradients.length > 0) {
                var ratio_1 = Scalar.Clamp(this_1._actualFrame / this_1.targetStopDuration);
                Tools.GetCurrentGradient(ratio_1, this_1._lifeTimeGradients, function (currentGradient, nextGradient) {
                    var factorGradient1 = currentGradient;
                    var factorGradient2 = nextGradient;
                    var lifeTime1 = factorGradient1.getFactor();
                    var lifeTime2 = factorGradient2.getFactor();
                    var gradient = (ratio_1 - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);
                    particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);
                });
            }
            else {
                particle.lifeTime = Scalar.RandomRange(this_1.minLifeTime, this_1.maxLifeTime);
            }
            // Size
            if (!this_1._sizeGradients || this_1._sizeGradients.length === 0) {
                particle.size = Scalar.RandomRange(this_1.minSize, this_1.maxSize);
            }
            else {
                particle._currentSizeGradient = this_1._sizeGradients[0];
                particle._currentSize1 = particle._currentSizeGradient.getFactor();
                particle.size = particle._currentSize1;
                if (this_1._sizeGradients.length > 1) {
                    particle._currentSize2 = this_1._sizeGradients[1].getFactor();
                }
                else {
                    particle._currentSize2 = particle._currentSize1;
                }
            }
            // Size and scale
            particle.scale.copyFromFloats(Scalar.RandomRange(this_1.minScaleX, this_1.maxScaleX), Scalar.RandomRange(this_1.minScaleY, this_1.maxScaleY));
            // Adjust scale by start size
            if (this_1._startSizeGradients && this_1._startSizeGradients[0] && this_1.targetStopDuration) {
                var ratio = this_1._actualFrame / this_1.targetStopDuration;
                Tools.GetCurrentGradient(ratio, this_1._startSizeGradients, function (currentGradient, nextGradient, scale) {
                    if (currentGradient !== _this._currentStartSizeGradient) {
                        _this._currentStartSize1 = _this._currentStartSize2;
                        _this._currentStartSize2 = nextGradient.getFactor();
                        _this._currentStartSizeGradient = currentGradient;
                    }
                    var value = Scalar.Lerp(_this._currentStartSize1, _this._currentStartSize2, scale);
                    particle.scale.scaleInPlace(value);
                });
            }
            // Angle
            if (!this_1._angularSpeedGradients || this_1._angularSpeedGradients.length === 0) {
                particle.angularSpeed = Scalar.RandomRange(this_1.minAngularSpeed, this_1.maxAngularSpeed);
            }
            else {
                particle._currentAngularSpeedGradient = this_1._angularSpeedGradients[0];
                particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();
                particle._currentAngularSpeed1 = particle.angularSpeed;
                if (this_1._angularSpeedGradients.length > 1) {
                    particle._currentAngularSpeed2 = this_1._angularSpeedGradients[1].getFactor();
                }
                else {
                    particle._currentAngularSpeed2 = particle._currentAngularSpeed1;
                }
            }
            particle.angle = Scalar.RandomRange(this_1.minInitialRotation, this_1.maxInitialRotation);
            // Velocity
            if (this_1._velocityGradients && this_1._velocityGradients.length > 0) {
                particle._currentVelocityGradient = this_1._velocityGradients[0];
                particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();
                if (this_1._velocityGradients.length > 1) {
                    particle._currentVelocity2 = this_1._velocityGradients[1].getFactor();
                }
                else {
                    particle._currentVelocity2 = particle._currentVelocity1;
                }
            }
            // Limit velocity
            if (this_1._limitVelocityGradients && this_1._limitVelocityGradients.length > 0) {
                particle._currentLimitVelocityGradient = this_1._limitVelocityGradients[0];
                particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();
                if (this_1._limitVelocityGradients.length > 1) {
                    particle._currentLimitVelocity2 = this_1._limitVelocityGradients[1].getFactor();
                }
                else {
                    particle._currentLimitVelocity2 = particle._currentLimitVelocity1;
                }
            }
            // Drag
            if (this_1._dragGradients && this_1._dragGradients.length > 0) {
                particle._currentDragGradient = this_1._dragGradients[0];
                particle._currentDrag1 = particle._currentDragGradient.getFactor();
                if (this_1._dragGradients.length > 1) {
                    particle._currentDrag2 = this_1._dragGradients[1].getFactor();
                }
                else {
                    particle._currentDrag2 = particle._currentDrag1;
                }
            }
            // Color
            if (!this_1._colorGradients || this_1._colorGradients.length === 0) {
                step = Scalar.RandomRange(0, 1.0);
                Color4.LerpToRef(this_1.color1, this_1.color2, step, particle.color);
                this_1.colorDead.subtractToRef(particle.color, this_1._colorDiff);
                this_1._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);
            }
            else {
                particle._currentColorGradient = this_1._colorGradients[0];
                particle._currentColorGradient.getColorToRef(particle.color);
                particle._currentColor1.copyFrom(particle.color);
                if (this_1._colorGradients.length > 1) {
                    this_1._colorGradients[1].getColorToRef(particle._currentColor2);
                }
                else {
                    particle._currentColor2.copyFrom(particle.color);
                }
            }
            // Sheet
            if (this_1._isAnimationSheetEnabled) {
                particle._initialStartSpriteCellID = this_1.startSpriteCellID;
                particle._initialEndSpriteCellID = this_1.endSpriteCellID;
            }
            // Inherited Velocity
            particle.direction.addInPlace(this_1._inheritedVelocityOffset);
            // Ramp
            if (this_1._useRampGradients) {
                particle.remapData = new Vector4(0, 1, 0, 1);
            }
            // Noise texture coordinates
            if (this_1.noiseTexture) {
                if (particle._randomNoiseCoordinates1) {
                    particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());
                    particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());
                }
                else {
                    particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());
                    particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());
                }
            }
            // Update the position of the attached sub-emitters to match their attached particle
            particle._inheritParticleInfoToSubEmitters();
        };
        var this_1 = this, step;
        for (var index = 0; index < newParticles; index++) {
            var state_1 = _loop_2();
            if (state_1 === "break")
                break;
        }
    };
    /** @hidden */
    ParticleSystem._GetAttributeNamesOrOptions = function (isAnimationSheetEnabled, isBillboardBased, useRampGradients) {
        if (isAnimationSheetEnabled === void 0) { isAnimationSheetEnabled = false; }
        if (isBillboardBased === void 0) { isBillboardBased = false; }
        if (useRampGradients === void 0) { useRampGradients = false; }
        var attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, "angle", "offset", "size"];
        if (isAnimationSheetEnabled) {
            attributeNamesOrOptions.push("cellIndex");
        }
        if (!isBillboardBased) {
            attributeNamesOrOptions.push("direction");
        }
        if (useRampGradients) {
            attributeNamesOrOptions.push("remapData");
        }
        return attributeNamesOrOptions;
    };
    /** @hidden */
    ParticleSystem._GetEffectCreationOptions = function (isAnimationSheetEnabled) {
        if (isAnimationSheetEnabled === void 0) { isAnimationSheetEnabled = false; }
        var effectCreationOption = ["invView", "view", "projection", "vClipPlane", "vClipPlane2", "vClipPlane3", "vClipPlane4", "textureMask", "translationPivot", "eyePosition"];
        if (isAnimationSheetEnabled) {
            effectCreationOption.push("particlesInfos");
        }
        return effectCreationOption;
    };
    /** @hidden */
    ParticleSystem.prototype._getEffect = function (blendMode) {
        if (this._customEffect) {
            return this._customEffect;
        }
        var defines = [];
        if (this._scene.clipPlane) {
            defines.push("#define CLIPPLANE");
        }
        if (this._scene.clipPlane2) {
            defines.push("#define CLIPPLANE2");
        }
        if (this._scene.clipPlane3) {
            defines.push("#define CLIPPLANE3");
        }
        if (this._scene.clipPlane4) {
            defines.push("#define CLIPPLANE4");
        }
        if (this._isAnimationSheetEnabled) {
            defines.push("#define ANIMATESHEET");
        }
        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {
            defines.push("#define BLENDMULTIPLYMODE");
        }
        if (this._useRampGradients) {
            defines.push("#define RAMPGRADIENT");
        }
        if (this._isBillboardBased) {
            defines.push("#define BILLBOARD");
            switch (this.billboardMode) {
                case ParticleSystem.BILLBOARDMODE_Y:
                    defines.push("#define BILLBOARDY");
                    break;
                case ParticleSystem.BILLBOARDMODE_STRETCHED:
                    defines.push("#define BILLBOARDSTRETCHED");
                    break;
            }
        }
        if (this._imageProcessingConfiguration) {
            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
            defines.push(this._imageProcessingConfigurationDefines.toString());
        }
        // Effect
        var join = defines.join("\n");
        if (this._cachedDefines !== join) {
            this._cachedDefines = join;
            var attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED, this._useRampGradients);
            var effectCreationOption = ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled);
            var samplers = ["diffuseSampler", "rampSampler"];
            if (ImageProcessingConfiguration) {
                ImageProcessingConfiguration.PrepareUniforms(effectCreationOption, this._imageProcessingConfigurationDefines);
                ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);
            }
            this._effect = this._scene.getEngine().createEffect("particles", attributesNamesOrOptions, effectCreationOption, samplers, join);
        }
        return this._effect;
    };
    /**
     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.
     * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)
     */
    ParticleSystem.prototype.animate = function (preWarmOnly) {
        var _this = this;
        if (preWarmOnly === void 0) { preWarmOnly = false; }
        if (!this._started) {
            return;
        }
        if (!preWarmOnly) {
            // Check
            if (!this.isReady()) {
                return;
            }
            if (this._currentRenderId === this._scene.getFrameId()) {
                return;
            }
            this._currentRenderId = this._scene.getFrameId();
        }
        this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : this._scene.getAnimationRatio());
        // Determine the number of particles we need to create
        var newParticles;
        if (this.manualEmitCount > -1) {
            newParticles = this.manualEmitCount;
            this._newPartsExcess = 0;
            this.manualEmitCount = 0;
        }
        else {
            var rate_1 = this.emitRate;
            if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {
                var ratio = this._actualFrame / this.targetStopDuration;
                Tools.GetCurrentGradient(ratio, this._emitRateGradients, function (currentGradient, nextGradient, scale) {
                    if (currentGradient !== _this._currentEmitRateGradient) {
                        _this._currentEmitRate1 = _this._currentEmitRate2;
                        _this._currentEmitRate2 = nextGradient.getFactor();
                        _this._currentEmitRateGradient = currentGradient;
                    }
                    rate_1 = Scalar.Lerp(_this._currentEmitRate1, _this._currentEmitRate2, scale);
                });
            }
            newParticles = ((rate_1 * this._scaledUpdateSpeed) >> 0);
            this._newPartsExcess += rate_1 * this._scaledUpdateSpeed - newParticles;
        }
        if (this._newPartsExcess > 1.0) {
            newParticles += this._newPartsExcess >> 0;
            this._newPartsExcess -= this._newPartsExcess >> 0;
        }
        this._alive = false;
        if (!this._stopped) {
            this._actualFrame += this._scaledUpdateSpeed;
            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
                this.stop();
            }
        }
        else {
            newParticles = 0;
        }
        this._update(newParticles);
        // Stopped?
        if (this._stopped) {
            if (!this._alive) {
                this._started = false;
                if (this.onAnimationEnd) {
                    this.onAnimationEnd();
                }
                if (this.disposeOnStop) {
                    this._scene._toBeDisposed.push(this);
                }
            }
        }
        if (!preWarmOnly) {
            // Update VBO
            var offset = 0;
            for (var index = 0; index < this._particles.length; index++) {
                var particle = this._particles[index];
                this._appendParticleVertices(offset, particle);
                offset += this._useInstancing ? 1 : 4;
            }
            if (this._vertexBuffer) {
                this._vertexBuffer.update(this._vertexData);
            }
        }
        if (this.manualEmitCount === 0 && this.disposeOnStop) {
            this.stop();
        }
    };
    ParticleSystem.prototype._appendParticleVertices = function (offset, particle) {
        this._appendParticleVertex(offset++, particle, 0, 0);
        if (!this._useInstancing) {
            this._appendParticleVertex(offset++, particle, 1, 0);
            this._appendParticleVertex(offset++, particle, 1, 1);
            this._appendParticleVertex(offset++, particle, 0, 1);
        }
    };
    /**
     * Rebuilds the particle system.
     */
    ParticleSystem.prototype.rebuild = function () {
        this._createIndexBuffer();
        if (this._vertexBuffer) {
            this._vertexBuffer._rebuild();
        }
    };
    /**
     * Is this system ready to be used/rendered
     * @return true if the system is ready
     */
    ParticleSystem.prototype.isReady = function () {
        if (!this.emitter || !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
            return false;
        }
        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {
            if (!this._getEffect(this.blendMode).isReady()) {
                return false;
            }
        }
        else {
            if (!this._getEffect(ParticleSystem.BLENDMODE_MULTIPLY).isReady()) {
                return false;
            }
            if (!this._getEffect(ParticleSystem.BLENDMODE_ADD).isReady()) {
                return false;
            }
        }
        return true;
    };
    ParticleSystem.prototype._render = function (blendMode) {
        var effect = this._getEffect(blendMode);
        var engine = this._scene.getEngine();
        // Render
        engine.enableEffect(effect);
        var viewMatrix = this._scene.getViewMatrix();
        effect.setTexture("diffuseSampler", this.particleTexture);
        effect.setMatrix("view", viewMatrix);
        effect.setMatrix("projection", this._scene.getProjectionMatrix());
        if (this._isAnimationSheetEnabled && this.particleTexture) {
            var baseSize = this.particleTexture.getBaseSize();
            effect.setFloat3("particlesInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);
        }
        effect.setVector2("translationPivot", this.translationPivot);
        effect.setFloat4("textureMask", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);
        if (this._isBillboardBased) {
            var camera = this._scene.activeCamera;
            effect.setVector3("eyePosition", camera.globalPosition);
        }
        if (this._rampGradientsTexture) {
            effect.setTexture("rampSampler", this._rampGradientsTexture);
        }
        if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4) {
            var invView = viewMatrix.clone();
            invView.invert();
            effect.setMatrix("invView", invView);
            MaterialHelper.BindClipPlane(effect, this._scene);
        }
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        // image processing
        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
            this._imageProcessingConfiguration.bind(effect);
        }
        // Draw order
        switch (blendMode) {
            case ParticleSystem.BLENDMODE_ADD:
                engine.setAlphaMode(Constants.ALPHA_ADD);
                break;
            case ParticleSystem.BLENDMODE_ONEONE:
                engine.setAlphaMode(Constants.ALPHA_ONEONE);
                break;
            case ParticleSystem.BLENDMODE_STANDARD:
                engine.setAlphaMode(Constants.ALPHA_COMBINE);
                break;
            case ParticleSystem.BLENDMODE_MULTIPLY:
                engine.setAlphaMode(Constants.ALPHA_MULTIPLY);
                break;
        }
        if (this._useInstancing) {
            engine.drawArraysType(Material.TriangleFanDrawMode, 0, 4, this._particles.length);
        }
        else {
            engine.drawElementsType(Material.TriangleFillMode, 0, this._particles.length * 6);
        }
        return this._particles.length;
    };
    /**
     * Renders the particle system in its current state.
     * @returns the current number of particles
     */
    ParticleSystem.prototype.render = function () {
        // Check
        if (!this.isReady() || !this._particles.length) {
            return 0;
        }
        var engine = this._scene.getEngine();
        engine.setState(false);
        if (this.forceDepthWrite) {
            engine.setDepthWrite(true);
        }
        var outparticles = 0;
        if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {
            outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);
        }
        outparticles = this._render(this.blendMode);
        engine.unbindInstanceAttributes();
        engine.setAlphaMode(Constants.ALPHA_DISABLE);
        return outparticles;
    };
    /**
     * Disposes the particle system and free the associated resources
     * @param disposeTexture defines if the particule texture must be disposed as well (true by default)
     */
    ParticleSystem.prototype.dispose = function (disposeTexture) {
        if (disposeTexture === void 0) { disposeTexture = true; }
        if (this._vertexBuffer) {
            this._vertexBuffer.dispose();
            this._vertexBuffer = null;
        }
        if (this._spriteBuffer) {
            this._spriteBuffer.dispose();
            this._spriteBuffer = null;
        }
        if (this._indexBuffer) {
            this._scene.getEngine()._releaseBuffer(this._indexBuffer);
            this._indexBuffer = null;
        }
        if (disposeTexture && this.particleTexture) {
            this.particleTexture.dispose();
            this.particleTexture = null;
        }
        if (disposeTexture && this.noiseTexture) {
            this.noiseTexture.dispose();
            this.noiseTexture = null;
        }
        if (this._rampGradientsTexture) {
            this._rampGradientsTexture.dispose();
            this._rampGradientsTexture = null;
        }
        this._removeFromRoot();
        if (this._subEmitters && this._subEmitters.length) {
            for (var index = 0; index < this._subEmitters.length; index++) {
                for (var _i = 0, _a = this._subEmitters[index]; _i < _a.length; _i++) {
                    var subEmitter = _a[_i];
                    subEmitter.dispose();
                }
            }
            this._subEmitters = [];
            this.subEmitters = [];
        }
        if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {
            this.emitter.dispose(true);
        }
        // Remove from scene
        var index = this._scene.particleSystems.indexOf(this);
        if (index > -1) {
            this._scene.particleSystems.splice(index, 1);
        }
        this._scene._activeParticleSystems.dispose();
        // Callback
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.reset();
    };
    // Clone
    /**
     * Clones the particle system.
     * @param name The name of the cloned object
     * @param newEmitter The new emitter to use
     * @returns the cloned particle system
     */
    ParticleSystem.prototype.clone = function (name, newEmitter) {
        var custom = null;
        var program = null;
        if (this.customShader != null) {
            program = this.customShader;
            var defines = (program.shaderOptions.defines.length > 0) ? program.shaderOptions.defines.join("\n") : "";
            custom = this._scene.getEngine().createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
        }
        else if (this._customEffect) {
            custom = this._customEffect;
        }
        var result = new ParticleSystem(name, this._capacity, this._scene, custom);
        result.customShader = program;
        DeepCopier.DeepCopy(this, result, ["particles", "customShader", "noiseTexture"]);
        if (newEmitter === undefined) {
            newEmitter = this.emitter;
        }
        result.noiseTexture = this.noiseTexture;
        result.emitter = newEmitter;
        if (this.particleTexture) {
            result.particleTexture = new Texture(this.particleTexture.url, this._scene);
        }
        // Clone gradients
        if (this._colorGradients) {
            this._colorGradients.forEach(function (v) {
                result.addColorGradient(v.gradient, v.color1, v.color2);
            });
        }
        if (this._dragGradients) {
            this._dragGradients.forEach(function (v) {
                result.addDragGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (this._angularSpeedGradients) {
            this._angularSpeedGradients.forEach(function (v) {
                result.addAngularSpeedGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (this._emitRateGradients) {
            this._emitRateGradients.forEach(function (v) {
                result.addEmitRateGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (this._lifeTimeGradients) {
            this._lifeTimeGradients.forEach(function (v) {
                result.addLifeTimeGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (this._limitVelocityGradients) {
            this._limitVelocityGradients.forEach(function (v) {
                result.addLimitVelocityGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (this._sizeGradients) {
            this._sizeGradients.forEach(function (v) {
                result.addSizeGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (this._startSizeGradients) {
            this._startSizeGradients.forEach(function (v) {
                result.addStartSizeGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (this._velocityGradients) {
            this._velocityGradients.forEach(function (v) {
                result.addVelocityGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (this._rampGradients) {
            this._rampGradients.forEach(function (v) {
                result.addRampGradient(v.gradient, v.color);
            });
        }
        if (this._colorRemapGradients) {
            this._colorRemapGradients.forEach(function (v) {
                result.addColorRemapGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (this._alphaRemapGradients) {
            this._alphaRemapGradients.forEach(function (v) {
                result.addAlphaRemapGradient(v.gradient, v.factor1, v.factor2);
            });
        }
        if (!this.preventAutoStart) {
            result.start();
        }
        return result;
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    ParticleSystem.prototype.serialize = function () {
        var serializationObject = {};
        ParticleSystem._Serialize(serializationObject, this);
        serializationObject.textureMask = this.textureMask.asArray();
        serializationObject.customShader = this.customShader;
        serializationObject.preventAutoStart = this.preventAutoStart;
        // SubEmitters
        if (this.subEmitters) {
            serializationObject.subEmitters = [];
            if (!this._subEmitters) {
                this._prepareSubEmitterInternalArray();
            }
            for (var _i = 0, _a = this._subEmitters; _i < _a.length; _i++) {
                var subs = _a[_i];
                var cell = [];
                for (var _b = 0, subs_1 = subs; _b < subs_1.length; _b++) {
                    var sub = subs_1[_b];
                    cell.push(sub.serialize());
                }
                serializationObject.subEmitters.push(cell);
            }
        }
        return serializationObject;
    };
    /** @hidden */
    ParticleSystem._Serialize = function (serializationObject, particleSystem) {
        serializationObject.name = particleSystem.name;
        serializationObject.id = particleSystem.id;
        serializationObject.capacity = particleSystem.getCapacity();
        // Emitter
        if (particleSystem.emitter.position) {
            var emitterMesh = particleSystem.emitter;
            serializationObject.emitterId = emitterMesh.id;
        }
        else {
            var emitterPosition = particleSystem.emitter;
            serializationObject.emitter = emitterPosition.asArray();
        }
        // Emitter
        if (particleSystem.particleEmitterType) {
            serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();
        }
        if (particleSystem.particleTexture) {
            serializationObject.textureName = particleSystem.particleTexture.name;
            serializationObject.invertY = particleSystem.particleTexture._invertY;
        }
        // Animations
        SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);
        serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;
        serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;
        serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;
        serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;
        // Particle system
        serializationObject.startDelay = particleSystem.startDelay;
        serializationObject.renderingGroupId = particleSystem.renderingGroupId;
        serializationObject.isBillboardBased = particleSystem.isBillboardBased;
        serializationObject.billboardMode = particleSystem.billboardMode;
        serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;
        serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;
        serializationObject.minSize = particleSystem.minSize;
        serializationObject.maxSize = particleSystem.maxSize;
        serializationObject.minScaleX = particleSystem.minScaleX;
        serializationObject.maxScaleX = particleSystem.maxScaleX;
        serializationObject.minScaleY = particleSystem.minScaleY;
        serializationObject.maxScaleY = particleSystem.maxScaleY;
        serializationObject.minEmitPower = particleSystem.minEmitPower;
        serializationObject.maxEmitPower = particleSystem.maxEmitPower;
        serializationObject.minLifeTime = particleSystem.minLifeTime;
        serializationObject.maxLifeTime = particleSystem.maxLifeTime;
        serializationObject.emitRate = particleSystem.emitRate;
        serializationObject.gravity = particleSystem.gravity.asArray();
        serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();
        serializationObject.color1 = particleSystem.color1.asArray();
        serializationObject.color2 = particleSystem.color2.asArray();
        serializationObject.colorDead = particleSystem.colorDead.asArray();
        serializationObject.updateSpeed = particleSystem.updateSpeed;
        serializationObject.targetStopDuration = particleSystem.targetStopDuration;
        serializationObject.blendMode = particleSystem.blendMode;
        serializationObject.preWarmCycles = particleSystem.preWarmCycles;
        serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;
        serializationObject.minInitialRotation = particleSystem.minInitialRotation;
        serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;
        serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;
        serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;
        serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;
        serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;
        serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;
        serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;
        serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;
        var colorGradients = particleSystem.getColorGradients();
        if (colorGradients) {
            serializationObject.colorGradients = [];
            for (var _i = 0, colorGradients_1 = colorGradients; _i < colorGradients_1.length; _i++) {
                var colorGradient = colorGradients_1[_i];
                var serializedGradient = {
                    gradient: colorGradient.gradient,
                    color1: colorGradient.color1.asArray()
                };
                if (colorGradient.color2) {
                    serializedGradient.color2 = colorGradient.color2.asArray();
                }
                serializationObject.colorGradients.push(serializedGradient);
            }
        }
        var rampGradients = particleSystem.getRampGradients();
        if (rampGradients) {
            serializationObject.rampGradients = [];
            for (var _a = 0, rampGradients_1 = rampGradients; _a < rampGradients_1.length; _a++) {
                var rampGradient = rampGradients_1[_a];
                var serializedGradient = {
                    gradient: rampGradient.gradient,
                    color: rampGradient.color.asArray()
                };
                serializationObject.rampGradients.push(serializedGradient);
            }
            serializationObject.useRampGradients = particleSystem.useRampGradients;
        }
        var colorRemapGradients = particleSystem.getColorRemapGradients();
        if (colorRemapGradients) {
            serializationObject.colorRemapGradients = [];
            for (var _b = 0, colorRemapGradients_1 = colorRemapGradients; _b < colorRemapGradients_1.length; _b++) {
                var colorRemapGradient = colorRemapGradients_1[_b];
                var serializedGradient = {
                    gradient: colorRemapGradient.gradient,
                    factor1: colorRemapGradient.factor1
                };
                if (colorRemapGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = colorRemapGradient.factor2;
                }
                serializationObject.colorRemapGradients.push(serializedGradient);
            }
        }
        var alphaRemapGradients = particleSystem.getAlphaRemapGradients();
        if (alphaRemapGradients) {
            serializationObject.alphaRemapGradients = [];
            for (var _c = 0, alphaRemapGradients_1 = alphaRemapGradients; _c < alphaRemapGradients_1.length; _c++) {
                var alphaRemapGradient = alphaRemapGradients_1[_c];
                var serializedGradient = {
                    gradient: alphaRemapGradient.gradient,
                    factor1: alphaRemapGradient.factor1
                };
                if (alphaRemapGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = alphaRemapGradient.factor2;
                }
                serializationObject.alphaRemapGradients.push(serializedGradient);
            }
        }
        var sizeGradients = particleSystem.getSizeGradients();
        if (sizeGradients) {
            serializationObject.sizeGradients = [];
            for (var _d = 0, sizeGradients_1 = sizeGradients; _d < sizeGradients_1.length; _d++) {
                var sizeGradient = sizeGradients_1[_d];
                var serializedGradient = {
                    gradient: sizeGradient.gradient,
                    factor1: sizeGradient.factor1
                };
                if (sizeGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = sizeGradient.factor2;
                }
                serializationObject.sizeGradients.push(serializedGradient);
            }
        }
        var angularSpeedGradients = particleSystem.getAngularSpeedGradients();
        if (angularSpeedGradients) {
            serializationObject.angularSpeedGradients = [];
            for (var _e = 0, angularSpeedGradients_1 = angularSpeedGradients; _e < angularSpeedGradients_1.length; _e++) {
                var angularSpeedGradient = angularSpeedGradients_1[_e];
                var serializedGradient = {
                    gradient: angularSpeedGradient.gradient,
                    factor1: angularSpeedGradient.factor1
                };
                if (angularSpeedGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = angularSpeedGradient.factor2;
                }
                serializationObject.angularSpeedGradients.push(serializedGradient);
            }
        }
        var velocityGradients = particleSystem.getVelocityGradients();
        if (velocityGradients) {
            serializationObject.velocityGradients = [];
            for (var _f = 0, velocityGradients_1 = velocityGradients; _f < velocityGradients_1.length; _f++) {
                var velocityGradient = velocityGradients_1[_f];
                var serializedGradient = {
                    gradient: velocityGradient.gradient,
                    factor1: velocityGradient.factor1
                };
                if (velocityGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = velocityGradient.factor2;
                }
                serializationObject.velocityGradients.push(serializedGradient);
            }
        }
        var dragGradients = particleSystem.getDragGradients();
        if (dragGradients) {
            serializationObject.dragyGradients = [];
            for (var _g = 0, dragGradients_1 = dragGradients; _g < dragGradients_1.length; _g++) {
                var dragGradient = dragGradients_1[_g];
                var serializedGradient = {
                    gradient: dragGradient.gradient,
                    factor1: dragGradient.factor1
                };
                if (dragGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = dragGradient.factor2;
                }
                serializationObject.dragGradients.push(serializedGradient);
            }
        }
        var emitRateGradients = particleSystem.getEmitRateGradients();
        if (emitRateGradients) {
            serializationObject.emitRateGradients = [];
            for (var _h = 0, emitRateGradients_1 = emitRateGradients; _h < emitRateGradients_1.length; _h++) {
                var emitRateGradient = emitRateGradients_1[_h];
                var serializedGradient = {
                    gradient: emitRateGradient.gradient,
                    factor1: emitRateGradient.factor1
                };
                if (emitRateGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = emitRateGradient.factor2;
                }
                serializationObject.emitRateGradients.push(serializedGradient);
            }
        }
        var startSizeGradients = particleSystem.getStartSizeGradients();
        if (startSizeGradients) {
            serializationObject.startSizeGradients = [];
            for (var _j = 0, startSizeGradients_1 = startSizeGradients; _j < startSizeGradients_1.length; _j++) {
                var startSizeGradient = startSizeGradients_1[_j];
                var serializedGradient = {
                    gradient: startSizeGradient.gradient,
                    factor1: startSizeGradient.factor1
                };
                if (startSizeGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = startSizeGradient.factor2;
                }
                serializationObject.startSizeGradients.push(serializedGradient);
            }
        }
        var lifeTimeGradients = particleSystem.getLifeTimeGradients();
        if (lifeTimeGradients) {
            serializationObject.lifeTimeGradients = [];
            for (var _k = 0, lifeTimeGradients_1 = lifeTimeGradients; _k < lifeTimeGradients_1.length; _k++) {
                var lifeTimeGradient = lifeTimeGradients_1[_k];
                var serializedGradient = {
                    gradient: lifeTimeGradient.gradient,
                    factor1: lifeTimeGradient.factor1
                };
                if (lifeTimeGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = lifeTimeGradient.factor2;
                }
                serializationObject.lifeTimeGradients.push(serializedGradient);
            }
        }
        var limitVelocityGradients = particleSystem.getLimitVelocityGradients();
        if (limitVelocityGradients) {
            serializationObject.limitVelocityGradients = [];
            for (var _l = 0, limitVelocityGradients_1 = limitVelocityGradients; _l < limitVelocityGradients_1.length; _l++) {
                var limitVelocityGradient = limitVelocityGradients_1[_l];
                var serializedGradient = {
                    gradient: limitVelocityGradient.gradient,
                    factor1: limitVelocityGradient.factor1
                };
                if (limitVelocityGradient.factor2 !== undefined) {
                    serializedGradient.factor2 = limitVelocityGradient.factor2;
                }
                serializationObject.limitVelocityGradients.push(serializedGradient);
            }
            serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;
        }
        if (particleSystem.noiseTexture) {
            serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();
        }
    };
    /** @hidden */
    ParticleSystem._Parse = function (parsedParticleSystem, particleSystem, scene, rootUrl) {
        // Texture
        if (parsedParticleSystem.textureName) {
            particleSystem.particleTexture = new Texture(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true);
            particleSystem.particleTexture.name = parsedParticleSystem.textureName;
        }
        // Emitter
        if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {
            particleSystem.emitter = Vector3.Zero();
        }
        else if (parsedParticleSystem.emitterId) {
            particleSystem.emitter = scene.getLastMeshByID(parsedParticleSystem.emitterId);
        }
        else {
            particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);
        }
        // Misc.
        if (parsedParticleSystem.renderingGroupId !== undefined) {
            particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;
        }
        if (parsedParticleSystem.isBillboardBased !== undefined) {
            particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;
        }
        if (parsedParticleSystem.billboardMode !== undefined) {
            particleSystem.billboardMode = parsedParticleSystem.billboardMode;
        }
        // Animations
        if (parsedParticleSystem.animations) {
            for (var animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {
                var parsedAnimation = parsedParticleSystem.animations[animationIndex];
                var internalClass = _TypeStore.GetClass("BABYLON.Animation");
                if (internalClass) {
                    particleSystem.animations.push(internalClass.Parse(parsedAnimation));
                }
            }
            particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;
            particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;
            particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;
            particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;
        }
        if (parsedParticleSystem.autoAnimate) {
            scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);
        }
        // Particle system
        particleSystem.startDelay = parsedParticleSystem.startDelay | 0;
        particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;
        particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;
        particleSystem.minSize = parsedParticleSystem.minSize;
        particleSystem.maxSize = parsedParticleSystem.maxSize;
        if (parsedParticleSystem.minScaleX) {
            particleSystem.minScaleX = parsedParticleSystem.minScaleX;
            particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;
            particleSystem.minScaleY = parsedParticleSystem.minScaleY;
            particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;
        }
        if (parsedParticleSystem.preWarmCycles !== undefined) {
            particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;
            particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;
        }
        if (parsedParticleSystem.minInitialRotation !== undefined) {
            particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;
            particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;
        }
        particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;
        particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;
        particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;
        particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;
        particleSystem.emitRate = parsedParticleSystem.emitRate;
        particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);
        if (parsedParticleSystem.noiseStrength) {
            particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);
        }
        particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);
        particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);
        particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);
        particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;
        particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;
        particleSystem.blendMode = parsedParticleSystem.blendMode;
        if (parsedParticleSystem.colorGradients) {
            for (var _i = 0, _a = parsedParticleSystem.colorGradients; _i < _a.length; _i++) {
                var colorGradient = _a[_i];
                particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined);
            }
        }
        if (parsedParticleSystem.rampGradients) {
            for (var _b = 0, _c = parsedParticleSystem.rampGradients; _b < _c.length; _b++) {
                var rampGradient = _c[_b];
                particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));
            }
            particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;
        }
        if (parsedParticleSystem.colorRemapGradients) {
            for (var _d = 0, _e = parsedParticleSystem.colorRemapGradients; _d < _e.length; _d++) {
                var colorRemapGradient = _e[_d];
                particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);
            }
        }
        if (parsedParticleSystem.alphaRemapGradients) {
            for (var _f = 0, _g = parsedParticleSystem.alphaRemapGradients; _f < _g.length; _f++) {
                var alphaRemapGradient = _g[_f];
                particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);
            }
        }
        if (parsedParticleSystem.sizeGradients) {
            for (var _h = 0, _j = parsedParticleSystem.sizeGradients; _h < _j.length; _h++) {
                var sizeGradient = _j[_h];
                particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);
            }
        }
        if (parsedParticleSystem.sizeGradients) {
            for (var _k = 0, _l = parsedParticleSystem.sizeGradients; _k < _l.length; _k++) {
                var sizeGradient = _l[_k];
                particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);
            }
        }
        if (parsedParticleSystem.angularSpeedGradients) {
            for (var _m = 0, _o = parsedParticleSystem.angularSpeedGradients; _m < _o.length; _m++) {
                var angularSpeedGradient = _o[_m];
                particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);
            }
        }
        if (parsedParticleSystem.velocityGradients) {
            for (var _p = 0, _q = parsedParticleSystem.velocityGradients; _p < _q.length; _p++) {
                var velocityGradient = _q[_p];
                particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);
            }
        }
        if (parsedParticleSystem.dragGradients) {
            for (var _r = 0, _s = parsedParticleSystem.dragGradients; _r < _s.length; _r++) {
                var dragGradient = _s[_r];
                particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);
            }
        }
        if (parsedParticleSystem.emitRateGradients) {
            for (var _t = 0, _u = parsedParticleSystem.emitRateGradients; _t < _u.length; _t++) {
                var emitRateGradient = _u[_t];
                particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);
            }
        }
        if (parsedParticleSystem.startSizeGradients) {
            for (var _v = 0, _w = parsedParticleSystem.startSizeGradients; _v < _w.length; _v++) {
                var startSizeGradient = _w[_v];
                particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);
            }
        }
        if (parsedParticleSystem.lifeTimeGradients) {
            for (var _x = 0, _y = parsedParticleSystem.lifeTimeGradients; _x < _y.length; _x++) {
                var lifeTimeGradient = _y[_x];
                particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);
            }
        }
        if (parsedParticleSystem.limitVelocityGradients) {
            for (var _z = 0, _0 = parsedParticleSystem.limitVelocityGradients; _z < _0.length; _z++) {
                var limitVelocityGradient = _0[_z];
                particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);
            }
            particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;
        }
        if (parsedParticleSystem.noiseTexture) {
            particleSystem.noiseTexture = ProceduralTexture.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);
        }
        // Emitter
        var emitterType;
        if (parsedParticleSystem.particleEmitterType) {
            switch (parsedParticleSystem.particleEmitterType.type) {
                case "SphereParticleEmitter":
                    emitterType = new SphereParticleEmitter();
                    break;
                case "SphereDirectedParticleEmitter":
                    emitterType = new SphereDirectedParticleEmitter();
                    break;
                case "ConeEmitter":
                case "ConeParticleEmitter":
                    emitterType = new ConeParticleEmitter();
                    break;
                case "CylinderParticleEmitter":
                    emitterType = new CylinderParticleEmitter();
                    break;
                case "HemisphericParticleEmitter":
                    emitterType = new HemisphericParticleEmitter();
                    break;
                case "BoxEmitter":
                case "BoxParticleEmitter":
                default:
                    emitterType = new BoxParticleEmitter();
                    break;
            }
            emitterType.parse(parsedParticleSystem.particleEmitterType);
        }
        else {
            emitterType = new BoxParticleEmitter();
            emitterType.parse(parsedParticleSystem);
        }
        particleSystem.particleEmitterType = emitterType;
        // Animation sheet
        particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;
        particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;
        particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;
        particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;
        particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;
        particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;
    };
    /**
     * Parses a JSON object to create a particle system.
     * @param parsedParticleSystem The JSON object to parse
     * @param scene The scene to create the particle system in
     * @param rootUrl The root url to use to load external dependencies like texture
     * @param doNotStart Ignore the preventAutoStart attribute and does not start
     * @returns the Parsed particle system
     */
    ParticleSystem.Parse = function (parsedParticleSystem, scene, rootUrl, doNotStart) {
        if (doNotStart === void 0) { doNotStart = false; }
        var name = parsedParticleSystem.name;
        var custom = null;
        var program = null;
        if (parsedParticleSystem.customShader) {
            program = parsedParticleSystem.customShader;
            var defines = (program.shaderOptions.defines.length > 0) ? program.shaderOptions.defines.join("\n") : "";
            custom = scene.getEngine().createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
        }
        var particleSystem = new ParticleSystem(name, parsedParticleSystem.capacity, scene, custom, parsedParticleSystem.isAnimationSheetEnabled);
        particleSystem.customShader = program;
        if (parsedParticleSystem.id) {
            particleSystem.id = parsedParticleSystem.id;
        }
        // SubEmitters
        if (parsedParticleSystem.subEmitters) {
            particleSystem.subEmitters = [];
            for (var _i = 0, _a = parsedParticleSystem.subEmitters; _i < _a.length; _i++) {
                var cell = _a[_i];
                var cellArray = [];
                for (var _b = 0, cell_1 = cell; _b < cell_1.length; _b++) {
                    var sub = cell_1[_b];
                    cellArray.push(SubEmitter.Parse(sub, scene, rootUrl));
                }
                particleSystem.subEmitters.push(cellArray);
            }
        }
        ParticleSystem._Parse(parsedParticleSystem, particleSystem, scene, rootUrl);
        particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);
        // Auto start
        if (parsedParticleSystem.preventAutoStart) {
            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
        }
        if (!doNotStart && !particleSystem.preventAutoStart) {
            particleSystem.start();
        }
        return particleSystem;
    };
    /**
     * Billboard mode will only apply to Y axis
     */
    ParticleSystem.BILLBOARDMODE_Y = Constants.PARTICLES_BILLBOARDMODE_Y;
    /**
     * Billboard mode will apply to all axes
     */
    ParticleSystem.BILLBOARDMODE_ALL = Constants.PARTICLES_BILLBOARDMODE_ALL;
    /**
     * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction
     */
    ParticleSystem.BILLBOARDMODE_STRETCHED = Constants.PARTICLES_BILLBOARDMODE_STRETCHED;
    return ParticleSystem;
}(BaseParticleSystem));
SubEmitter._ParseParticleSystem = ParticleSystem.Parse;

var name$x = 'gpuUpdateParticlesPixelShader';
var shader$x = "#version 300 es\nvoid main() {\ndiscard;\n}\n";
Effect.ShadersStore[name$x] = shader$x;

var name$y = 'gpuUpdateParticlesVertexShader';
var shader$y = "#version 300 es\n#define PI 3.14159\nuniform float currentCount;\nuniform float timeDelta;\nuniform float stopFactor;\nuniform mat4 emitterWM;\nuniform vec2 lifeTime;\nuniform vec2 emitPower;\nuniform vec2 sizeRange;\nuniform vec4 scaleRange;\n#ifndef COLORGRADIENTS\nuniform vec4 color1;\nuniform vec4 color2;\n#endif\nuniform vec3 gravity;\nuniform sampler2D randomSampler;\nuniform sampler2D randomSampler2;\nuniform vec4 angleRange;\n#ifdef BOXEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\nuniform vec3 minEmitBox;\nuniform vec3 maxEmitBox;\n#endif\n#ifdef POINTEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#endif\n#ifdef HEMISPHERICEMITTER\nuniform float radius;\nuniform float radiusRange;\nuniform float directionRandomizer;\n#endif\n#ifdef SPHEREEMITTER\nuniform float radius;\nuniform float radiusRange;\n#ifdef DIRECTEDSPHEREEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CYLINDEREMITTER\nuniform float radius;\nuniform float height;\nuniform float radiusRange;\n#ifdef DIRECTEDCYLINDEREMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CONEEMITTER\nuniform vec2 radius;\nuniform float coneAngle;\nuniform vec2 height;\nuniform float directionRandomizer;\n#endif\n\nin vec3 position;\nin float age;\nin float life;\nin vec4 seed;\nin vec3 size;\n#ifndef COLORGRADIENTS\nin vec4 color;\n#endif\nin vec3 direction;\n#ifndef BILLBOARD\nin vec3 initialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nin float angle;\n#else\nin vec2 angle;\n#endif\n#ifdef ANIMATESHEET\nin float cellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nin float cellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nin vec3 noiseCoordinates1;\nin vec3 noiseCoordinates2;\n#endif\n\nout vec3 outPosition;\nout float outAge;\nout float outLife;\nout vec4 outSeed;\nout vec3 outSize;\n#ifndef COLORGRADIENTS\nout vec4 outColor;\n#endif\nout vec3 outDirection;\n#ifndef BILLBOARD\nout vec3 outInitialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nout float outAngle;\n#else\nout vec2 outAngle;\n#endif\n#ifdef ANIMATESHEET\nout float outCellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nout float outCellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nout vec3 outNoiseCoordinates1;\nout vec3 outNoiseCoordinates2;\n#endif\n#ifdef SIZEGRADIENTS\nuniform sampler2D sizeGradientSampler;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nuniform sampler2D angularSpeedGradientSampler;\n#endif\n#ifdef VELOCITYGRADIENTS\nuniform sampler2D velocityGradientSampler;\n#endif\n#ifdef LIMITVELOCITYGRADIENTS\nuniform sampler2D limitVelocityGradientSampler;\nuniform float limitVelocityDamping;\n#endif\n#ifdef DRAGGRADIENTS\nuniform sampler2D dragGradientSampler;\n#endif\n#ifdef NOISE\nuniform vec3 noiseStrength;\nuniform sampler2D noiseSampler;\n#endif\n#ifdef ANIMATESHEET\nuniform vec3 cellInfos;\n#endif\nvec3 getRandomVec3(float offset) {\nreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\n}\nvec4 getRandomVec4(float offset) {\nreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\n}\nvoid main() {\nfloat newAge=age+timeDelta;\n\nif (newAge>=life && stopFactor != 0.) {\nvec3 position;\nvec3 direction;\n\nvec4 randoms=getRandomVec4(seed.x);\n\noutLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\noutAge=mod(newAge,outLife);\n\noutSeed=seed;\n\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\n#else\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\n#endif\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\noutSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a;\n#ifndef COLORGRADIENTS\n\noutColor=color1+(color2-color1)*randoms.b;\n#endif\n\n#ifndef ANGULARSPEEDGRADIENTS\noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\noutAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#else\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#endif\n\n#ifdef POINTEMITTER\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nposition=vec3(0,0,0);\ndirection=direction1+(direction2-direction1)*randoms3;\n#elif defined(BOXEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nposition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\ndirection=direction1+(direction2-direction1)*randoms3;\n#elif defined(HEMISPHERICEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\n\nfloat phi=2.0*PI*randoms2.x;\nfloat theta=acos(2.0*randoms2.y-1.0);\nfloat randX=cos(phi)*sin(theta);\nfloat randY=cos(theta);\nfloat randZ=sin(phi)*sin(theta);\nposition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\ndirection=position+directionRandomizer*randoms3;\n#elif defined(SPHEREEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\n\nfloat phi=2.0*PI*randoms2.x;\nfloat theta=acos(2.0*randoms2.y-1.0);\nfloat randX=cos(phi)*sin(theta);\nfloat randY=cos(theta);\nfloat randZ=sin(phi)*sin(theta);\nposition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\n#ifdef DIRECTEDSPHEREEMITTER\ndirection=direction1+(direction2-direction1)*randoms3;\n#else\n\ndirection=position+directionRandomizer*randoms3;\n#endif\n#elif defined(CYLINDEREMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\n\nfloat yPos=(randoms2.x-0.5)*height;\nfloat angle=randoms2.y*PI*2.;\nfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\nfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\nfloat xPos=positionRadius*cos(angle);\nfloat zPos=positionRadius*sin(angle);\nposition=vec3(xPos,yPos,zPos);\n#ifdef DIRECTEDCYLINDEREMITTER\ndirection=direction1+(direction2-direction1)*randoms3;\n#else\n\nangle=angle+((randoms3.x-0.5)*PI);\ndirection=vec3(cos(angle),randoms3.y-0.5,sin(angle));\ndirection=normalize(direction);\n#endif\n#elif defined(CONEEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nfloat s=2.0*PI*randoms2.x;\n#ifdef CONEEMITTERSPAWNPOINT\nfloat h=0.00001;\n#else\nfloat h=randoms2.y*height.y;\n\nh=1.-h*h;\n#endif\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\nlRadius=lRadius*h;\nfloat randX=lRadius*sin(s);\nfloat randZ=lRadius*cos(s);\nfloat randY=h*height.x;\nposition=vec3(randX,randY,randZ);\n\nif (abs(cos(coneAngle)) == 1.0) {\ndirection=vec3(0.,1.0,0.);\n} else {\nvec3 randoms3=getRandomVec3(seed.z);\ndirection=position+directionRandomizer*randoms3;\n}\n#else\n\nposition=vec3(0.,0.,0.);\n\ndirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\n#endif\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\noutPosition=(emitterWM*vec4(position,1.)).xyz;\nvec3 initial=(emitterWM*vec4(direction,0.)).xyz;\noutDirection=initial*power;\n#ifndef BILLBOARD\noutInitialDirection=initial;\n#endif\n#ifdef ANIMATESHEET\noutCellIndex=cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=randoms.a*outLife;\n#endif\n#endif\n#ifdef NOISE\noutNoiseCoordinates1=noiseCoordinates1;\noutNoiseCoordinates2=noiseCoordinates2;\n#endif\n} else {\nfloat directionScale=timeDelta;\noutAge=newAge;\nfloat ageGradient=newAge/life;\n#ifdef VELOCITYGRADIENTS\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\n#endif\n#ifdef DRAGGRADIENTS\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\n#endif\noutPosition=position+direction*directionScale;\noutLife=life;\noutSeed=seed;\n#ifndef COLORGRADIENTS\noutColor=color;\n#endif\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\noutSize.yz=size.yz;\n#else\noutSize=size;\n#endif\n#ifndef BILLBOARD\noutInitialDirection=initialDirection;\n#endif\nvec3 updatedDirection=direction+gravity*timeDelta;\n#ifdef LIMITVELOCITYGRADIENTS\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\nfloat currentVelocity=length(updatedDirection);\nif (currentVelocity>limitVelocity) {\nupdatedDirection=updatedDirection*limitVelocityDamping;\n}\n#endif\noutDirection=updatedDirection;\n#ifdef NOISE\nvec3 localPosition=outPosition-emitterWM[3].xyz;\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\nfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\nfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\nvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\noutDirection=outDirection+force*timeDelta;\noutNoiseCoordinates1=noiseCoordinates1;\noutNoiseCoordinates2=noiseCoordinates2;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\noutAngle=angle+angularSpeed*timeDelta;\n#else\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\n#endif\n#ifdef ANIMATESHEET\nfloat offsetAge=outAge;\nfloat dist=cellInfos.y-cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=cellStartOffset;\noffsetAge+=cellStartOffset;\n#endif\nfloat ratio=clamp(mod(offsetAge*cellInfos.z,life)/life,0.,1.0);\noutCellIndex=float(int(cellInfos.x+ratio*dist));\n#endif\n}\n}";
Effect.ShadersStore[name$y] = shader$y;

var name$z = 'clipPlaneFragmentDeclaration2';
var shader$z = "#ifdef CLIPPLANE\nin float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nin float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nin float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nin float fClipDistance4;\n#endif";
Effect.IncludesShadersStore[name$z] = shader$z;

var name$A = 'gpuRenderParticlesPixelShader';
var shader$A = "#version 300 es\nuniform sampler2D textureSampler;\nin vec2 vUV;\nin vec4 vColor;\nout vec4 outFragColor;\n#include<clipPlaneFragmentDeclaration2>\n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\nvoid main() {\n#include<clipPlaneFragment>\nvec4 textureColor=texture(textureSampler,vUV);\noutFragColor=textureColor*vColor;\n#ifdef BLENDMULTIPLYMODE\nfloat alpha=vColor.a*textureColor.a;\noutFragColor.rgb=outFragColor.rgb*alpha+vec3(1.0)*(1.0-alpha);\n#endif\n\n\n#ifdef IMAGEPROCESSINGPOSTPROCESS\noutFragColor.rgb=toLinearSpace(outFragColor.rgb);\n#else\n#ifdef IMAGEPROCESSING\noutFragColor.rgb=toLinearSpace(outFragColor.rgb);\noutFragColor=applyImageProcessing(outFragColor);\n#endif\n#endif\n}\n";
Effect.ShadersStore[name$A] = shader$A;

var name$B = 'clipPlaneVertexDeclaration2';
var shader$B = "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nout float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\nout float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\nout float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\nout float fClipDistance4;\n#endif";
Effect.IncludesShadersStore[name$B] = shader$B;

var name$C = 'gpuRenderParticlesVertexShader';
var shader$C = "#version 300 es\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec2 translationPivot;\nuniform vec3 worldOffset;\n\nin vec3 position;\nin float age;\nin float life;\nin vec3 size;\n#ifndef BILLBOARD\nin vec3 initialDirection;\n#endif\n#ifdef BILLBOARDSTRETCHED\nin vec3 direction;\n#endif\nin float angle;\n#ifdef ANIMATESHEET\nin float cellIndex;\n#endif\nin vec2 offset;\nin vec2 uv;\nout vec2 vUV;\nout vec4 vColor;\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4)\nuniform mat4 invView;\n#endif\n#include<clipPlaneVertexDeclaration2>\n#ifdef COLORGRADIENTS\nuniform sampler2D colorGradientSampler;\n#else\nuniform vec4 colorDead;\nin vec4 color;\n#endif\n#ifdef ANIMATESHEET\nuniform vec3 sheetInfos;\n#endif\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\n#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\nvec3 zaxis=normalize(cross(yaxis,xaxis));\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\nmat3 rotMatrix=mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\nreturn (position+worldOffset)+alignedCorner;\n}\n#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\nvec3 normalizedToCamera=normalize(toCamera);\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\nmat3 rotMatrix=mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\nreturn (position+worldOffset)+alignedCorner;\n}\n#endif\nvoid main() {\n#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex/sheetInfos.z);\nfloat columnOffset=cellIndex-rowOffset*sheetInfos.z;\nvec2 uvScale=sheetInfos.xy;\nvec2 uvOffset=vec2(uv.x ,1.0-uv.y);\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\n#else\nvUV=uv;\n#endif\nfloat ratio=age/life;\n#ifdef COLORGRADIENTS\nvColor=texture(colorGradientSampler,vec2(ratio,0));\n#else\nvColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);\n#endif\nvec2 cornerPos=(offset-translationPivot)*size.yz*size.x+translationPivot;\n#ifdef BILLBOARD\nvec4 rotatedCorner;\nrotatedCorner.w=0.;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.y=0.;\nvec3 yaxis=(position+worldOffset)-eyePosition;\nyaxis.y=0.;\nvec3 worldPos=rotate(normalize(yaxis),rotatedCorner.xyz);\nvec4 viewPosition=(view*vec4(worldPos,1.0));\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\nvec3 toCamera=(position+worldOffset)-eyePosition;\nvec3 worldPos=rotateAlign(toCamera,rotatedCorner.xyz);\nvec4 viewPosition=(view*vec4(worldPos,1.0));\n#else\n\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\n\nvec4 viewPosition=view*vec4((position+worldOffset),1.0)+rotatedCorner;\n#endif\n#else\n\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=0.;\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nvec3 yaxis=normalize(initialDirection);\nvec3 worldPos=rotate(yaxis,rotatedCorner);\n\nvec4 viewPosition=view*vec4(worldPos,1.0);\n#endif\ngl_Position=projection*viewPosition;\n\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4)\nvec4 worldPos=invView*viewPosition;\n#endif\n#include<clipPlaneVertex>\n}";
Effect.ShadersStore[name$C] = shader$C;

/**
 * This represents a GPU particle system in Babylon
 * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
 * @see https://www.babylonjs-playground.com/#PU4WYI#4
 */
var GPUParticleSystem = /** @class */ (function (_super) {
    __extends(GPUParticleSystem, _super);
    /**
     * Instantiates a GPU particle system.
     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
     * @param name The name of the particle system
     * @param options The options used to create the system
     * @param scene The scene the particle system belongs to
     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
     */
    function GPUParticleSystem(name, options, scene, isAnimationSheetEnabled) {
        if (isAnimationSheetEnabled === void 0) { isAnimationSheetEnabled = false; }
        var _this = _super.call(this, name) || this;
        /**
         * The layer mask we are rendering the particles through.
         */
        _this.layerMask = 0x0FFFFFFF;
        _this._accumulatedCount = 0;
        _this._targetIndex = 0;
        _this._currentRenderId = -1;
        _this._started = false;
        _this._stopped = false;
        _this._timeDelta = 0;
        _this._actualFrame = 0;
        _this._rawTextureWidth = 256;
        /**
        * An event triggered when the system is disposed.
        */
        _this.onDisposeObservable = new Observable();
        /**
         * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
         * to override the particles.
         */
        _this.forceDepthWrite = false;
        _this._preWarmDone = false;
        _this._scene = scene || EngineStore.LastCreatedScene;
        // Setup the default processing configuration to the scene.
        _this._attachImageProcessingConfiguration(null);
        _this._engine = _this._scene.getEngine();
        if (!options.randomTextureSize) {
            delete options.randomTextureSize;
        }
        var fullOptions = __assign({ capacity: 50000, randomTextureSize: _this._engine.getCaps().maxTextureSize }, options);
        var optionsAsNumber = options;
        if (isFinite(optionsAsNumber)) {
            fullOptions.capacity = optionsAsNumber;
        }
        _this._capacity = fullOptions.capacity;
        _this._activeCount = fullOptions.capacity;
        _this._currentActiveCount = 0;
        _this._isAnimationSheetEnabled = isAnimationSheetEnabled;
        _this._scene.particleSystems.push(_this);
        _this._updateEffectOptions = {
            attributes: ["position", "age", "life", "seed", "size", "color", "direction", "initialDirection", "angle", "cellIndex", "cellStartOffset", "noiseCoordinates1", "noiseCoordinates2"],
            uniformsNames: ["currentCount", "timeDelta", "emitterWM", "lifeTime", "color1", "color2", "sizeRange", "scaleRange", "gravity", "emitPower",
                "direction1", "direction2", "minEmitBox", "maxEmitBox", "radius", "directionRandomizer", "height", "coneAngle", "stopFactor",
                "angleRange", "radiusRange", "cellInfos", "noiseStrength", "limitVelocityDamping"],
            uniformBuffersNames: [],
            samplers: ["randomSampler", "randomSampler2", "sizeGradientSampler", "angularSpeedGradientSampler", "velocityGradientSampler", "limitVelocityGradientSampler", "noiseSampler", "dragGradientSampler"],
            defines: "",
            fallbacks: null,
            onCompiled: null,
            onError: null,
            indexParameters: null,
            maxSimultaneousLights: 0,
            transformFeedbackVaryings: []
        };
        _this.particleEmitterType = new BoxParticleEmitter();
        // Random data
        var maxTextureSize = Math.min(_this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);
        var d = [];
        for (var i = 0; i < maxTextureSize; ++i) {
            d.push(Math.random());
            d.push(Math.random());
            d.push(Math.random());
            d.push(Math.random());
        }
        _this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, Constants.TEXTUREFORMAT_RGBA, _this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);
        _this._randomTexture.wrapU = Texture.WRAP_ADDRESSMODE;
        _this._randomTexture.wrapV = Texture.WRAP_ADDRESSMODE;
        d = [];
        for (var i = 0; i < maxTextureSize; ++i) {
            d.push(Math.random());
            d.push(Math.random());
            d.push(Math.random());
            d.push(Math.random());
        }
        _this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, Constants.TEXTUREFORMAT_RGBA, _this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);
        _this._randomTexture2.wrapU = Texture.WRAP_ADDRESSMODE;
        _this._randomTexture2.wrapV = Texture.WRAP_ADDRESSMODE;
        _this._randomTextureSize = maxTextureSize;
        return _this;
    }
    Object.defineProperty(GPUParticleSystem, "IsSupported", {
        /**
         * Gets a boolean indicating if the GPU particles can be rendered on current browser
         */
        get: function () {
            if (!EngineStore.LastCreatedEngine) {
                return false;
            }
            return EngineStore.LastCreatedEngine.webGLVersion > 1;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the maximum number of particles active at the same time.
     * @returns The max number of active particles.
     */
    GPUParticleSystem.prototype.getCapacity = function () {
        return this._capacity;
    };
    Object.defineProperty(GPUParticleSystem.prototype, "activeParticleCount", {
        /**
         * Gets or set the number of active particles
         */
        get: function () {
            return this._activeCount;
        },
        set: function (value) {
            this._activeCount = Math.min(value, this._capacity);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Is this system ready to be used/rendered
     * @return true if the system is ready
     */
    GPUParticleSystem.prototype.isReady = function () {
        if (!this._updateEffect) {
            this._recreateUpdateEffect();
            this._recreateRenderEffect();
            return false;
        }
        if (!this.emitter || !this._updateEffect.isReady() || !this._imageProcessingConfiguration.isReady() || !this._renderEffect.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
            return false;
        }
        return true;
    };
    /**
     * Gets if the system has been started. (Note: this will still be true after stop is called)
     * @returns True if it has been started, otherwise false.
     */
    GPUParticleSystem.prototype.isStarted = function () {
        return this._started;
    };
    /**
     * Starts the particle system and begins to emit
     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
     */
    GPUParticleSystem.prototype.start = function (delay) {
        var _this = this;
        if (delay === void 0) { delay = this.startDelay; }
        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
            throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
        }
        if (delay) {
            setTimeout(function () {
                _this.start(0);
            }, delay);
            return;
        }
        this._started = true;
        this._stopped = false;
        this._preWarmDone = false;
        // Animations
        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0) {
            this.getScene().beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
        }
    };
    /**
     * Stops the particle system.
     */
    GPUParticleSystem.prototype.stop = function () {
        this._stopped = true;
    };
    /**
     * Remove all active particles
     */
    GPUParticleSystem.prototype.reset = function () {
        this._releaseBuffers();
        this._releaseVAOs();
        this._currentActiveCount = 0;
        this._targetIndex = 0;
    };
    /**
     * Returns the string "GPUParticleSystem"
     * @returns a string containing the class name
     */
    GPUParticleSystem.prototype.getClassName = function () {
        return "GPUParticleSystem";
    };
    GPUParticleSystem.prototype._removeGradientAndTexture = function (gradient, gradients, texture) {
        _super.prototype._removeGradientAndTexture.call(this, gradient, gradients, texture);
        this._releaseBuffers();
        return this;
    };
    /**
     * Adds a new color gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param color1 defines the color to affect to the specified gradient
     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addColorGradient = function (gradient, color1, color2) {
        if (!this._colorGradients) {
            this._colorGradients = [];
        }
        var colorGradient = new ColorGradient();
        colorGradient.gradient = gradient;
        colorGradient.color1 = color1;
        this._colorGradients.push(colorGradient);
        this._colorGradients.sort(function (a, b) {
            if (a.gradient < b.gradient) {
                return -1;
            }
            else if (a.gradient > b.gradient) {
                return 1;
            }
            return 0;
        });
        if (this._colorGradientsTexture) {
            this._colorGradientsTexture.dispose();
            this._colorGradientsTexture = null;
        }
        this._releaseBuffers();
        return this;
    };
    /**
     * Remove a specific color gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeColorGradient = function (gradient) {
        this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);
        this._colorGradientsTexture = null;
        return this;
    };
    GPUParticleSystem.prototype._addFactorGradient = function (factorGradients, gradient, factor) {
        var valueGradient = new FactorGradient();
        valueGradient.gradient = gradient;
        valueGradient.factor1 = factor;
        factorGradients.push(valueGradient);
        factorGradients.sort(function (a, b) {
            if (a.gradient < b.gradient) {
                return -1;
            }
            else if (a.gradient > b.gradient) {
                return 1;
            }
            return 0;
        });
        this._releaseBuffers();
    };
    /**
     * Adds a new size gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the size factor to affect to the specified gradient
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addSizeGradient = function (gradient, factor) {
        if (!this._sizeGradients) {
            this._sizeGradients = [];
        }
        this._addFactorGradient(this._sizeGradients, gradient, factor);
        if (this._sizeGradientsTexture) {
            this._sizeGradientsTexture.dispose();
            this._sizeGradientsTexture = null;
        }
        this._releaseBuffers();
        return this;
    };
    /**
     * Remove a specific size gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeSizeGradient = function (gradient) {
        this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);
        this._sizeGradientsTexture = null;
        return this;
    };
    /**
     * Adds a new angular speed gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the angular speed to affect to the specified gradient
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addAngularSpeedGradient = function (gradient, factor) {
        if (!this._angularSpeedGradients) {
            this._angularSpeedGradients = [];
        }
        this._addFactorGradient(this._angularSpeedGradients, gradient, factor);
        if (this._angularSpeedGradientsTexture) {
            this._angularSpeedGradientsTexture.dispose();
            this._angularSpeedGradientsTexture = null;
        }
        this._releaseBuffers();
        return this;
    };
    /**
     * Remove a specific angular speed gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeAngularSpeedGradient = function (gradient) {
        this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);
        this._angularSpeedGradientsTexture = null;
        return this;
    };
    /**
     * Adds a new velocity gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the velocity to affect to the specified gradient
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addVelocityGradient = function (gradient, factor) {
        if (!this._velocityGradients) {
            this._velocityGradients = [];
        }
        this._addFactorGradient(this._velocityGradients, gradient, factor);
        if (this._velocityGradientsTexture) {
            this._velocityGradientsTexture.dispose();
            this._velocityGradientsTexture = null;
        }
        this._releaseBuffers();
        return this;
    };
    /**
     * Remove a specific velocity gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeVelocityGradient = function (gradient) {
        this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);
        this._velocityGradientsTexture = null;
        return this;
    };
    /**
     * Adds a new limit velocity gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the limit velocity value to affect to the specified gradient
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addLimitVelocityGradient = function (gradient, factor) {
        if (!this._limitVelocityGradients) {
            this._limitVelocityGradients = [];
        }
        this._addFactorGradient(this._limitVelocityGradients, gradient, factor);
        if (this._limitVelocityGradientsTexture) {
            this._limitVelocityGradientsTexture.dispose();
            this._limitVelocityGradientsTexture = null;
        }
        this._releaseBuffers();
        return this;
    };
    /**
     * Remove a specific limit velocity gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeLimitVelocityGradient = function (gradient) {
        this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);
        this._limitVelocityGradientsTexture = null;
        return this;
    };
    /**
     * Adds a new drag gradient
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the drag value to affect to the specified gradient
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addDragGradient = function (gradient, factor) {
        if (!this._dragGradients) {
            this._dragGradients = [];
        }
        this._addFactorGradient(this._dragGradients, gradient, factor);
        if (this._dragGradientsTexture) {
            this._dragGradientsTexture.dispose();
            this._dragGradientsTexture = null;
        }
        this._releaseBuffers();
        return this;
    };
    /**
     * Remove a specific drag gradient
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeDragGradient = function (gradient) {
        this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);
        this._dragGradientsTexture = null;
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the emit rate value to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addEmitRateGradient = function (gradient, factor, factor2) {
        // Do nothing as emit rate is not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeEmitRateGradient = function (gradient) {
        // Do nothing as emit rate is not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the start size value to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addStartSizeGradient = function (gradient, factor, factor2) {
        // Do nothing as start size is not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeStartSizeGradient = function (gradient) {
        // Do nothing as start size is not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param min defines the color remap minimal range
     * @param max defines the color remap maximal range
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addColorRemapGradient = function (gradient, min, max) {
        // Do nothing as start size is not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeColorRemapGradient = function () {
        // Do nothing as start size is not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param min defines the alpha remap minimal range
     * @param max defines the alpha remap maximal range
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addAlphaRemapGradient = function (gradient, min, max) {
        // Do nothing as start size is not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeAlphaRemapGradient = function () {
        // Do nothing as start size is not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param color defines the color to affect to the specified gradient
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addRampGradient = function (gradient, color) {
        //Not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeRampGradient = function () {
        //Not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @returns the list of ramp gradients
     */
    GPUParticleSystem.prototype.getRampGradients = function () {
        return null;
    };
    Object.defineProperty(GPUParticleSystem.prototype, "useRampGradients", {
        /**
         * Not supported by GPUParticleSystem
         * Gets or sets a boolean indicating that ramp gradients must be used
         * @see http://doc.babylonjs.com/babylon101/particles#ramp-gradients
         */
        get: function () {
            //Not supported by GPUParticleSystem
            return false;
        },
        set: function (value) {
            //Not supported by GPUParticleSystem
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to use (between 0 and 1)
     * @param factor defines the life time factor to affect to the specified gradient
     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.addLifeTimeGradient = function (gradient, factor, factor2) {
        //Not supported by GPUParticleSystem
        return this;
    };
    /**
     * Not supported by GPUParticleSystem
     * @param gradient defines the gradient to remove
     * @returns the current particle system
     */
    GPUParticleSystem.prototype.removeLifeTimeGradient = function (gradient) {
        //Not supported by GPUParticleSystem
        return this;
    };
    GPUParticleSystem.prototype._reset = function () {
        this._releaseBuffers();
    };
    GPUParticleSystem.prototype._createUpdateVAO = function (source) {
        var updateVertexBuffers = {};
        updateVertexBuffers["position"] = source.createVertexBuffer("position", 0, 3);
        updateVertexBuffers["age"] = source.createVertexBuffer("age", 3, 1);
        updateVertexBuffers["life"] = source.createVertexBuffer("life", 4, 1);
        updateVertexBuffers["seed"] = source.createVertexBuffer("seed", 5, 4);
        updateVertexBuffers["size"] = source.createVertexBuffer("size", 9, 3);
        var offset = 12;
        if (!this._colorGradientsTexture) {
            updateVertexBuffers["color"] = source.createVertexBuffer("color", offset, 4);
            offset += 4;
        }
        updateVertexBuffers["direction"] = source.createVertexBuffer("direction", offset, 3);
        offset += 3;
        if (!this._isBillboardBased) {
            updateVertexBuffers["initialDirection"] = source.createVertexBuffer("initialDirection", offset, 3);
            offset += 3;
        }
        if (this._angularSpeedGradientsTexture) {
            updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 1);
            offset += 1;
        }
        else {
            updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 2);
            offset += 2;
        }
        if (this._isAnimationSheetEnabled) {
            updateVertexBuffers["cellIndex"] = source.createVertexBuffer("cellIndex", offset, 1);
            offset += 1;
            if (this.spriteRandomStartCell) {
                updateVertexBuffers["cellStartOffset"] = source.createVertexBuffer("cellStartOffset", offset, 1);
                offset += 1;
            }
        }
        if (this.noiseTexture) {
            updateVertexBuffers["noiseCoordinates1"] = source.createVertexBuffer("noiseCoordinates1", offset, 3);
            offset += 3;
            updateVertexBuffers["noiseCoordinates2"] = source.createVertexBuffer("noiseCoordinates2", offset, 3);
            offset += 3;
        }
        var vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);
        this._engine.bindArrayBuffer(null);
        return vao;
    };
    GPUParticleSystem.prototype._createRenderVAO = function (source, spriteSource) {
        var renderVertexBuffers = {};
        renderVertexBuffers["position"] = source.createVertexBuffer("position", 0, 3, this._attributesStrideSize, true);
        renderVertexBuffers["age"] = source.createVertexBuffer("age", 3, 1, this._attributesStrideSize, true);
        renderVertexBuffers["life"] = source.createVertexBuffer("life", 4, 1, this._attributesStrideSize, true);
        renderVertexBuffers["size"] = source.createVertexBuffer("size", 9, 3, this._attributesStrideSize, true);
        var offset = 12;
        if (!this._colorGradientsTexture) {
            renderVertexBuffers["color"] = source.createVertexBuffer("color", offset, 4, this._attributesStrideSize, true);
            offset += 4;
        }
        if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {
            renderVertexBuffers["direction"] = source.createVertexBuffer("direction", offset, 3, this._attributesStrideSize, true);
        }
        offset += 3; // Direction
        if (!this._isBillboardBased) {
            renderVertexBuffers["initialDirection"] = source.createVertexBuffer("initialDirection", offset, 3, this._attributesStrideSize, true);
            offset += 3;
        }
        renderVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 1, this._attributesStrideSize, true);
        if (this._angularSpeedGradientsTexture) {
            offset++;
        }
        else {
            offset += 2;
        }
        if (this._isAnimationSheetEnabled) {
            renderVertexBuffers["cellIndex"] = source.createVertexBuffer("cellIndex", offset, 1, this._attributesStrideSize, true);
            offset += 1;
            if (this.spriteRandomStartCell) {
                renderVertexBuffers["cellStartOffset"] = source.createVertexBuffer("cellStartOffset", offset, 1, this._attributesStrideSize, true);
                offset += 1;
            }
        }
        if (this.noiseTexture) {
            renderVertexBuffers["noiseCoordinates1"] = source.createVertexBuffer("noiseCoordinates1", offset, 3, this._attributesStrideSize, true);
            offset += 3;
            renderVertexBuffers["noiseCoordinates2"] = source.createVertexBuffer("noiseCoordinates2", offset, 3, this._attributesStrideSize, true);
            offset += 3;
        }
        renderVertexBuffers["offset"] = spriteSource.createVertexBuffer("offset", 0, 2);
        renderVertexBuffers["uv"] = spriteSource.createVertexBuffer("uv", 2, 2);
        var vao = this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._renderEffect);
        this._engine.bindArrayBuffer(null);
        return vao;
    };
    GPUParticleSystem.prototype._initialize = function (force) {
        if (force === void 0) { force = false; }
        if (this._buffer0 && !force) {
            return;
        }
        var engine = this._scene.getEngine();
        var data = new Array();
        this._attributesStrideSize = 21;
        this._targetIndex = 0;
        if (!this.isBillboardBased) {
            this._attributesStrideSize += 3;
        }
        if (this._colorGradientsTexture) {
            this._attributesStrideSize -= 4;
        }
        if (this._angularSpeedGradientsTexture) {
            this._attributesStrideSize -= 1;
        }
        if (this._isAnimationSheetEnabled) {
            this._attributesStrideSize += 1;
            if (this.spriteRandomStartCell) {
                this._attributesStrideSize += 1;
            }
        }
        if (this.noiseTexture) {
            this._attributesStrideSize += 6;
        }
        for (var particleIndex = 0; particleIndex < this._capacity; particleIndex++) {
            // position
            data.push(0.0);
            data.push(0.0);
            data.push(0.0);
            // Age and life
            data.push(0.0); // create the particle as a dead one to create a new one at start
            data.push(0.0);
            // Seed
            data.push(Math.random());
            data.push(Math.random());
            data.push(Math.random());
            data.push(Math.random());
            // Size
            data.push(0.0);
            data.push(0.0);
            data.push(0.0);
            if (!this._colorGradientsTexture) {
                // color
                data.push(0.0);
                data.push(0.0);
                data.push(0.0);
                data.push(0.0);
            }
            // direction
            data.push(0.0);
            data.push(0.0);
            data.push(0.0);
            if (!this.isBillboardBased) {
                // initialDirection
                data.push(0.0);
                data.push(0.0);
                data.push(0.0);
            }
            // angle
            data.push(0.0);
            if (!this._angularSpeedGradientsTexture) {
                data.push(0.0);
            }
            if (this._isAnimationSheetEnabled) {
                data.push(0.0);
                if (this.spriteRandomStartCell) {
                    data.push(0.0);
                }
            }
            if (this.noiseTexture) { // Random coordinates for reading into noise texture
                data.push(Math.random());
                data.push(Math.random());
                data.push(Math.random());
                data.push(Math.random());
                data.push(Math.random());
                data.push(Math.random());
            }
        }
        // Sprite data
        var spriteData = new Float32Array([0.5, 0.5, 1, 1,
            -0.5, 0.5, 0, 1,
            -0.5, -0.5, 0, 0,
            0.5, -0.5, 1, 0]);
        // Buffers
        this._buffer0 = new Buffer(engine, data, false, this._attributesStrideSize);
        this._buffer1 = new Buffer(engine, data, false, this._attributesStrideSize);
        this._spriteBuffer = new Buffer(engine, spriteData, false, 4);
        // Update VAO
        this._updateVAO = [];
        this._updateVAO.push(this._createUpdateVAO(this._buffer0));
        this._updateVAO.push(this._createUpdateVAO(this._buffer1));
        // Render VAO
        this._renderVAO = [];
        this._renderVAO.push(this._createRenderVAO(this._buffer1, this._spriteBuffer));
        this._renderVAO.push(this._createRenderVAO(this._buffer0, this._spriteBuffer));
        // Links
        this._sourceBuffer = this._buffer0;
        this._targetBuffer = this._buffer1;
    };
    /** @hidden */
    GPUParticleSystem.prototype._recreateUpdateEffect = function () {
        var defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : "";
        if (this._isBillboardBased) {
            defines += "\n#define BILLBOARD";
        }
        if (this._colorGradientsTexture) {
            defines += "\n#define COLORGRADIENTS";
        }
        if (this._sizeGradientsTexture) {
            defines += "\n#define SIZEGRADIENTS";
        }
        if (this._angularSpeedGradientsTexture) {
            defines += "\n#define ANGULARSPEEDGRADIENTS";
        }
        if (this._velocityGradientsTexture) {
            defines += "\n#define VELOCITYGRADIENTS";
        }
        if (this._limitVelocityGradientsTexture) {
            defines += "\n#define LIMITVELOCITYGRADIENTS";
        }
        if (this._dragGradientsTexture) {
            defines += "\n#define DRAGGRADIENTS";
        }
        if (this.isAnimationSheetEnabled) {
            defines += "\n#define ANIMATESHEET";
            if (this.spriteRandomStartCell) {
                defines += "\n#define ANIMATESHEETRANDOMSTART";
            }
        }
        if (this.noiseTexture) {
            defines += "\n#define NOISE";
        }
        if (this._updateEffect && this._updateEffectOptions.defines === defines) {
            return;
        }
        this._updateEffectOptions.transformFeedbackVaryings = ["outPosition", "outAge", "outLife", "outSeed", "outSize"];
        if (!this._colorGradientsTexture) {
            this._updateEffectOptions.transformFeedbackVaryings.push("outColor");
        }
        this._updateEffectOptions.transformFeedbackVaryings.push("outDirection");
        if (!this._isBillboardBased) {
            this._updateEffectOptions.transformFeedbackVaryings.push("outInitialDirection");
        }
        this._updateEffectOptions.transformFeedbackVaryings.push("outAngle");
        if (this.isAnimationSheetEnabled) {
            this._updateEffectOptions.transformFeedbackVaryings.push("outCellIndex");
            if (this.spriteRandomStartCell) {
                this._updateEffectOptions.transformFeedbackVaryings.push("outCellStartOffset");
            }
        }
        if (this.noiseTexture) {
            this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates1");
            this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates2");
        }
        this._updateEffectOptions.defines = defines;
        this._updateEffect = new Effect("gpuUpdateParticles", this._updateEffectOptions, this._scene.getEngine());
    };
    /** @hidden */
    GPUParticleSystem.prototype._recreateRenderEffect = function () {
        var defines = "";
        if (this._scene.clipPlane) {
            defines = "\n#define CLIPPLANE";
        }
        if (this._scene.clipPlane2) {
            defines = "\n#define CLIPPLANE2";
        }
        if (this._scene.clipPlane3) {
            defines = "\n#define CLIPPLANE3";
        }
        if (this._scene.clipPlane4) {
            defines = "\n#define CLIPPLANE4";
        }
        if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {
            defines = "\n#define BLENDMULTIPLYMODE";
        }
        if (this._isBillboardBased) {
            defines += "\n#define BILLBOARD";
            switch (this.billboardMode) {
                case ParticleSystem.BILLBOARDMODE_Y:
                    defines += "\n#define BILLBOARDY";
                    break;
                case ParticleSystem.BILLBOARDMODE_STRETCHED:
                    defines += "\n#define BILLBOARDSTRETCHED";
                    break;
            }
        }
        if (this._colorGradientsTexture) {
            defines += "\n#define COLORGRADIENTS";
        }
        if (this.isAnimationSheetEnabled) {
            defines += "\n#define ANIMATESHEET";
        }
        if (this._imageProcessingConfiguration) {
            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
            defines += "\n" + this._imageProcessingConfigurationDefines.toString();
        }
        if (this._renderEffect && this._renderEffect.defines === defines) {
            return;
        }
        var uniforms = ["worldOffset", "view", "projection", "colorDead", "invView", "vClipPlane", "vClipPlane2", "vClipPlane3", "vClipPlane4", "sheetInfos", "translationPivot", "eyePosition"];
        var samplers = ["textureSampler", "colorGradientSampler"];
        if (ImageProcessingConfiguration) {
            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);
            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);
        }
        this._renderEffect = new Effect("gpuRenderParticles", ["position", "age", "life", "size", "color", "offset", "uv", "direction", "initialDirection", "angle", "cellIndex"], uniforms, samplers, this._scene.getEngine(), defines);
    };
    /**
     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.
     * @param preWarm defines if we are in the pre-warmimg phase
     */
    GPUParticleSystem.prototype.animate = function (preWarm) {
        if (preWarm === void 0) { preWarm = false; }
        this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : this._scene.getAnimationRatio());
        this._actualFrame += this._timeDelta;
        if (!this._stopped) {
            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
                this.stop();
            }
        }
    };
    GPUParticleSystem.prototype._createFactorGradientTexture = function (factorGradients, textureName) {
        var texture = this[textureName];
        if (!factorGradients || !factorGradients.length || texture) {
            return;
        }
        var data = new Float32Array(this._rawTextureWidth);
        for (var x = 0; x < this._rawTextureWidth; x++) {
            var ratio = x / this._rawTextureWidth;
            Tools.GetCurrentGradient(ratio, factorGradients, function (currentGradient, nextGradient, scale) {
                data[x] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
            });
        }
        this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene, false, false, Texture.NEAREST_SAMPLINGMODE);
    };
    GPUParticleSystem.prototype._createSizeGradientTexture = function () {
        this._createFactorGradientTexture(this._sizeGradients, "_sizeGradientsTexture");
    };
    GPUParticleSystem.prototype._createAngularSpeedGradientTexture = function () {
        this._createFactorGradientTexture(this._angularSpeedGradients, "_angularSpeedGradientsTexture");
    };
    GPUParticleSystem.prototype._createVelocityGradientTexture = function () {
        this._createFactorGradientTexture(this._velocityGradients, "_velocityGradientsTexture");
    };
    GPUParticleSystem.prototype._createLimitVelocityGradientTexture = function () {
        this._createFactorGradientTexture(this._limitVelocityGradients, "_limitVelocityGradientsTexture");
    };
    GPUParticleSystem.prototype._createDragGradientTexture = function () {
        this._createFactorGradientTexture(this._dragGradients, "_dragGradientsTexture");
    };
    GPUParticleSystem.prototype._createColorGradientTexture = function () {
        if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {
            return;
        }
        var data = new Uint8Array(this._rawTextureWidth * 4);
        var tmpColor = Tmp.Color4[0];
        for (var x = 0; x < this._rawTextureWidth; x++) {
            var ratio = x / this._rawTextureWidth;
            Tools.GetCurrentGradient(ratio, this._colorGradients, function (currentGradient, nextGradient, scale) {
                Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);
                data[x * 4] = tmpColor.r * 255;
                data[x * 4 + 1] = tmpColor.g * 255;
                data[x * 4 + 2] = tmpColor.b * 255;
                data[x * 4 + 3] = tmpColor.a * 255;
            });
        }
        this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Texture.NEAREST_SAMPLINGMODE);
    };
    /**
     * Renders the particle system in its current state
     * @param preWarm defines if the system should only update the particles but not render them
     * @returns the current number of particles
     */
    GPUParticleSystem.prototype.render = function (preWarm) {
        if (preWarm === void 0) { preWarm = false; }
        if (!this._started) {
            return 0;
        }
        this._createColorGradientTexture();
        this._createSizeGradientTexture();
        this._createAngularSpeedGradientTexture();
        this._createVelocityGradientTexture();
        this._createLimitVelocityGradientTexture();
        this._createDragGradientTexture();
        this._recreateUpdateEffect();
        this._recreateRenderEffect();
        if (!this.isReady()) {
            return 0;
        }
        if (!preWarm) {
            if (!this._preWarmDone && this.preWarmCycles) {
                for (var index = 0; index < this.preWarmCycles; index++) {
                    this.animate(true);
                    this.render(true);
                }
                this._preWarmDone = true;
            }
            if (this._currentRenderId === this._scene.getFrameId()) {
                return 0;
            }
            this._currentRenderId = this._scene.getFrameId();
        }
        // Get everything ready to render
        this._initialize();
        this._accumulatedCount += this.emitRate * this._timeDelta;
        if (this._accumulatedCount > 1) {
            var intPart = this._accumulatedCount | 0;
            this._accumulatedCount -= intPart;
            this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);
        }
        if (!this._currentActiveCount) {
            return 0;
        }
        // Enable update effect
        this._engine.enableEffect(this._updateEffect);
        this._engine.setState(false);
        this._updateEffect.setFloat("currentCount", this._currentActiveCount);
        this._updateEffect.setFloat("timeDelta", this._timeDelta);
        this._updateEffect.setFloat("stopFactor", this._stopped ? 0 : 1);
        this._updateEffect.setTexture("randomSampler", this._randomTexture);
        this._updateEffect.setTexture("randomSampler2", this._randomTexture2);
        this._updateEffect.setFloat2("lifeTime", this.minLifeTime, this.maxLifeTime);
        this._updateEffect.setFloat2("emitPower", this.minEmitPower, this.maxEmitPower);
        if (!this._colorGradientsTexture) {
            this._updateEffect.setDirectColor4("color1", this.color1);
            this._updateEffect.setDirectColor4("color2", this.color2);
        }
        this._updateEffect.setFloat2("sizeRange", this.minSize, this.maxSize);
        this._updateEffect.setFloat4("scaleRange", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);
        this._updateEffect.setFloat4("angleRange", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);
        this._updateEffect.setVector3("gravity", this.gravity);
        if (this._sizeGradientsTexture) {
            this._updateEffect.setTexture("sizeGradientSampler", this._sizeGradientsTexture);
        }
        if (this._angularSpeedGradientsTexture) {
            this._updateEffect.setTexture("angularSpeedGradientSampler", this._angularSpeedGradientsTexture);
        }
        if (this._velocityGradientsTexture) {
            this._updateEffect.setTexture("velocityGradientSampler", this._velocityGradientsTexture);
        }
        if (this._limitVelocityGradientsTexture) {
            this._updateEffect.setTexture("limitVelocityGradientSampler", this._limitVelocityGradientsTexture);
            this._updateEffect.setFloat("limitVelocityDamping", this.limitVelocityDamping);
        }
        if (this._dragGradientsTexture) {
            this._updateEffect.setTexture("dragGradientSampler", this._dragGradientsTexture);
        }
        if (this.particleEmitterType) {
            this.particleEmitterType.applyToShader(this._updateEffect);
        }
        if (this._isAnimationSheetEnabled) {
            this._updateEffect.setFloat3("cellInfos", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed);
        }
        if (this.noiseTexture) {
            this._updateEffect.setTexture("noiseSampler", this.noiseTexture);
            this._updateEffect.setVector3("noiseStrength", this.noiseStrength);
        }
        var emitterWM;
        if (this.emitter.position) {
            var emitterMesh = this.emitter;
            emitterWM = emitterMesh.getWorldMatrix();
        }
        else {
            var emitterPosition = this.emitter;
            emitterWM = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);
        }
        this._updateEffect.setMatrix("emitterWM", emitterWM);
        // Bind source VAO
        this._engine.bindVertexArrayObject(this._updateVAO[this._targetIndex], null);
        // Update
        this._engine.bindTransformFeedbackBuffer(this._targetBuffer.getBuffer());
        this._engine.setRasterizerState(false);
        this._engine.beginTransformFeedback(true);
        this._engine.drawArraysType(Material.PointListDrawMode, 0, this._currentActiveCount);
        this._engine.endTransformFeedback();
        this._engine.setRasterizerState(true);
        this._engine.bindTransformFeedbackBuffer(null);
        if (!preWarm) {
            // Enable render effect
            this._engine.enableEffect(this._renderEffect);
            var viewMatrix = this._scene.getViewMatrix();
            this._renderEffect.setMatrix("view", viewMatrix);
            this._renderEffect.setMatrix("projection", this._scene.getProjectionMatrix());
            this._renderEffect.setTexture("textureSampler", this.particleTexture);
            this._renderEffect.setVector2("translationPivot", this.translationPivot);
            this._renderEffect.setVector3("worldOffset", this.worldOffset);
            if (this._colorGradientsTexture) {
                this._renderEffect.setTexture("colorGradientSampler", this._colorGradientsTexture);
            }
            else {
                this._renderEffect.setDirectColor4("colorDead", this.colorDead);
            }
            if (this._isAnimationSheetEnabled && this.particleTexture) {
                var baseSize = this.particleTexture.getBaseSize();
                this._renderEffect.setFloat3("sheetInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);
            }
            if (this._isBillboardBased) {
                var camera = this._scene.activeCamera;
                this._renderEffect.setVector3("eyePosition", camera.globalPosition);
            }
            if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4) {
                var invView = viewMatrix.clone();
                invView.invert();
                this._renderEffect.setMatrix("invView", invView);
                MaterialHelper.BindClipPlane(this._renderEffect, this._scene);
            }
            // image processing
            if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
                this._imageProcessingConfiguration.bind(this._renderEffect);
            }
            // Draw order
            switch (this.blendMode) {
                case ParticleSystem.BLENDMODE_ADD:
                    this._engine.setAlphaMode(Constants.ALPHA_ADD);
                    break;
                case ParticleSystem.BLENDMODE_ONEONE:
                    this._engine.setAlphaMode(Constants.ALPHA_ONEONE);
                    break;
                case ParticleSystem.BLENDMODE_STANDARD:
                    this._engine.setAlphaMode(Constants.ALPHA_COMBINE);
                    break;
                case ParticleSystem.BLENDMODE_MULTIPLY:
                    this._engine.setAlphaMode(Constants.ALPHA_MULTIPLY);
                    break;
            }
            if (this.forceDepthWrite) {
                this._engine.setDepthWrite(true);
            }
            // Bind source VAO
            this._engine.bindVertexArrayObject(this._renderVAO[this._targetIndex], null);
            // Render
            this._engine.drawArraysType(Material.TriangleFanDrawMode, 0, 4, this._currentActiveCount);
            this._engine.setAlphaMode(Constants.ALPHA_DISABLE);
        }
        // Switch VAOs
        this._targetIndex++;
        if (this._targetIndex === 2) {
            this._targetIndex = 0;
        }
        // Switch buffers
        var tmpBuffer = this._sourceBuffer;
        this._sourceBuffer = this._targetBuffer;
        this._targetBuffer = tmpBuffer;
        return this._currentActiveCount;
    };
    /**
     * Rebuilds the particle system
     */
    GPUParticleSystem.prototype.rebuild = function () {
        this._initialize(true);
    };
    GPUParticleSystem.prototype._releaseBuffers = function () {
        if (this._buffer0) {
            this._buffer0.dispose();
            this._buffer0 = null;
        }
        if (this._buffer1) {
            this._buffer1.dispose();
            this._buffer1 = null;
        }
        if (this._spriteBuffer) {
            this._spriteBuffer.dispose();
            this._spriteBuffer = null;
        }
    };
    GPUParticleSystem.prototype._releaseVAOs = function () {
        if (!this._updateVAO) {
            return;
        }
        for (var index = 0; index < this._updateVAO.length; index++) {
            this._engine.releaseVertexArrayObject(this._updateVAO[index]);
        }
        this._updateVAO = [];
        for (var index = 0; index < this._renderVAO.length; index++) {
            this._engine.releaseVertexArrayObject(this._renderVAO[index]);
        }
        this._renderVAO = [];
    };
    /**
     * Disposes the particle system and free the associated resources
     * @param disposeTexture defines if the particule texture must be disposed as well (true by default)
     */
    GPUParticleSystem.prototype.dispose = function (disposeTexture) {
        if (disposeTexture === void 0) { disposeTexture = true; }
        var index = this._scene.particleSystems.indexOf(this);
        if (index > -1) {
            this._scene.particleSystems.splice(index, 1);
        }
        this._releaseBuffers();
        this._releaseVAOs();
        if (this._colorGradientsTexture) {
            this._colorGradientsTexture.dispose();
            this._colorGradientsTexture = null;
        }
        if (this._sizeGradientsTexture) {
            this._sizeGradientsTexture.dispose();
            this._sizeGradientsTexture = null;
        }
        if (this._angularSpeedGradientsTexture) {
            this._angularSpeedGradientsTexture.dispose();
            this._angularSpeedGradientsTexture = null;
        }
        if (this._velocityGradientsTexture) {
            this._velocityGradientsTexture.dispose();
            this._velocityGradientsTexture = null;
        }
        if (this._limitVelocityGradientsTexture) {
            this._limitVelocityGradientsTexture.dispose();
            this._limitVelocityGradientsTexture = null;
        }
        if (this._dragGradientsTexture) {
            this._dragGradientsTexture.dispose();
            this._dragGradientsTexture = null;
        }
        if (this._randomTexture) {
            this._randomTexture.dispose();
            this._randomTexture = null;
        }
        if (this._randomTexture2) {
            this._randomTexture2.dispose();
            this._randomTexture2 = null;
        }
        if (disposeTexture && this.particleTexture) {
            this.particleTexture.dispose();
            this.particleTexture = null;
        }
        if (disposeTexture && this.noiseTexture) {
            this.noiseTexture.dispose();
            this.noiseTexture = null;
        }
        // Callback
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
    };
    /**
     * Clones the particle system.
     * @param name The name of the cloned object
     * @param newEmitter The new emitter to use
     * @returns the cloned particle system
     */
    GPUParticleSystem.prototype.clone = function (name, newEmitter) {
        var result = new GPUParticleSystem(name, { capacity: this._capacity, randomTextureSize: this._randomTextureSize }, this._scene);
        DeepCopier.DeepCopy(this, result);
        if (newEmitter === undefined) {
            newEmitter = this.emitter;
        }
        result.emitter = newEmitter;
        if (this.particleTexture) {
            result.particleTexture = new Texture(this.particleTexture.url, this._scene);
        }
        return result;
    };
    /**
     * Serializes the particle system to a JSON object.
     * @returns the JSON object
     */
    GPUParticleSystem.prototype.serialize = function () {
        var serializationObject = {};
        ParticleSystem._Serialize(serializationObject, this);
        serializationObject.activeParticleCount = this.activeParticleCount;
        return serializationObject;
    };
    /**
     * Parses a JSON object to create a GPU particle system.
     * @param parsedParticleSystem The JSON object to parse
     * @param scene The scene to create the particle system in
     * @param rootUrl The root url to use to load external dependencies like texture
     * @param doNotStart Ignore the preventAutoStart attribute and does not start
     * @returns the parsed GPU particle system
     */
    GPUParticleSystem.Parse = function (parsedParticleSystem, scene, rootUrl, doNotStart) {
        if (doNotStart === void 0) { doNotStart = false; }
        var name = parsedParticleSystem.name;
        var particleSystem = new GPUParticleSystem(name, { capacity: parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize }, scene);
        if (parsedParticleSystem.activeParticleCount) {
            particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;
        }
        ParticleSystem._Parse(parsedParticleSystem, particleSystem, scene, rootUrl);
        // Auto start
        if (parsedParticleSystem.preventAutoStart) {
            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
        }
        if (!doNotStart && !particleSystem.preventAutoStart) {
            particleSystem.start();
        }
        return particleSystem;
    };
    return GPUParticleSystem;
}(BaseParticleSystem));

/**
 * Represents a set of particle systems working together to create a specific effect
 */
var ParticleSystemSet = /** @class */ (function () {
    function ParticleSystemSet() {
        /**
         * Gets the particle system list
         */
        this.systems = new Array();
    }
    Object.defineProperty(ParticleSystemSet.prototype, "emitterNode", {
        /**
         * Gets the emitter node used with this set
         */
        get: function () {
            return this._emitterNode;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new emitter mesh as a sphere
     * @param options defines the options used to create the sphere
     * @param renderingGroupId defines the renderingGroupId to use for the sphere
     * @param scene defines the hosting scene
     */
    ParticleSystemSet.prototype.setEmitterAsSphere = function (options, renderingGroupId, scene) {
        if (this._emitterNode) {
            this._emitterNode.dispose();
        }
        this._emitterCreationOptions = {
            kind: "Sphere",
            options: options,
            renderingGroupId: renderingGroupId
        };
        var emitterMesh = SphereBuilder.CreateSphere("emitterSphere", { diameter: options.diameter, segments: options.segments }, scene);
        emitterMesh.renderingGroupId = renderingGroupId;
        var material = new StandardMaterial("emitterSphereMaterial", scene);
        material.emissiveColor = options.color;
        emitterMesh.material = material;
        for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {
            var system = _a[_i];
            system.emitter = emitterMesh;
        }
        this._emitterNode = emitterMesh;
    };
    /**
     * Starts all particle systems of the set
     * @param emitter defines an optional mesh to use as emitter for the particle systems
     */
    ParticleSystemSet.prototype.start = function (emitter) {
        for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {
            var system = _a[_i];
            if (emitter) {
                system.emitter = emitter;
            }
            system.start();
        }
    };
    /**
     * Release all associated resources
     */
    ParticleSystemSet.prototype.dispose = function () {
        for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {
            var system = _a[_i];
            system.dispose();
        }
        this.systems = [];
        if (this._emitterNode) {
            this._emitterNode.dispose();
            this._emitterNode = null;
        }
    };
    /**
     * Serialize the set into a JSON compatible object
     * @returns a JSON compatible representation of the set
     */
    ParticleSystemSet.prototype.serialize = function () {
        var result = {};
        result.systems = [];
        for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {
            var system = _a[_i];
            result.systems.push(system.serialize());
        }
        if (this._emitterNode) {
            result.emitter = this._emitterCreationOptions;
        }
        return result;
    };
    /**
     * Parse a new ParticleSystemSet from a serialized source
     * @param data defines a JSON compatible representation of the set
     * @param scene defines the hosting scene
     * @param gpu defines if we want GPU particles or CPU particles
     * @returns a new ParticleSystemSet
     */
    ParticleSystemSet.Parse = function (data, scene, gpu) {
        if (gpu === void 0) { gpu = false; }
        var result = new ParticleSystemSet();
        var rootUrl = Constants.PARTICLES_BaseAssetsUrl + "/textures/";
        scene = scene || EngineStore.LastCreatedScene;
        for (var _i = 0, _a = data.systems; _i < _a.length; _i++) {
            var system = _a[_i];
            result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true) : ParticleSystem.Parse(system, scene, rootUrl, true));
        }
        if (data.emitter) {
            var options = data.emitter.options;
            switch (data.emitter.kind) {
                case "Sphere":
                    result.setEmitterAsSphere({
                        diameter: options.diameter,
                        segments: options.segments,
                        color: Color3.FromArray(options.color)
                    }, data.emitter.renderingGroupId, scene);
                    break;
            }
        }
        return result;
    };
    return ParticleSystemSet;
}());

/**
 * This class is made for on one-liner static method to help creating particle system set.
 */
var ParticleHelper = /** @class */ (function () {
    function ParticleHelper() {
    }
    /**
     * Create a default particle system that you can tweak
     * @param emitter defines the emitter to use
     * @param capacity defines the system capacity (default is 500 particles)
     * @param scene defines the hosting scene
     * @param useGPU defines if a GPUParticleSystem must be created (default is false)
     * @returns the new Particle system
     */
    ParticleHelper.CreateDefault = function (emitter, capacity, scene, useGPU) {
        if (capacity === void 0) { capacity = 500; }
        if (useGPU === void 0) { useGPU = false; }
        var system;
        if (useGPU) {
            system = new GPUParticleSystem("default system", { capacity: capacity }, scene);
        }
        else {
            system = new ParticleSystem("default system", capacity, scene);
        }
        system.emitter = emitter;
        system.particleTexture = new Texture("https://www.babylonjs.com/assets/Flare.png", system.getScene());
        system.createConeEmitter(0.1, Math.PI / 4);
        // Particle color
        system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);
        system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);
        system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0);
        // Particle Size
        system.minSize = 0.1;
        system.maxSize = 0.1;
        // Emission speed
        system.minEmitPower = 2;
        system.maxEmitPower = 2;
        // Update speed
        system.updateSpeed = 1 / 60;
        system.emitRate = 30;
        return system;
    };
    /**
     * This is the main static method (one-liner) of this helper to create different particle systems
     * @param type This string represents the type to the particle system to create
     * @param scene The scene where the particle system should live
     * @param gpu If the system will use gpu
     * @returns the ParticleSystemSet created
     */
    ParticleHelper.CreateAsync = function (type, scene, gpu) {
        if (gpu === void 0) { gpu = false; }
        if (!scene) {
            scene = EngineStore.LastCreatedScene;
        }
        var token = {};
        scene._addPendingData(token);
        return new Promise(function (resolve, reject) {
            if (gpu && !GPUParticleSystem.IsSupported) {
                scene._removePendingData(token);
                return reject("Particle system with GPU is not supported.");
            }
            Tools.LoadFile(ParticleHelper.BaseAssetsUrl + "/systems/" + type + ".json", function (data) {
                scene._removePendingData(token);
                var newData = JSON.parse(data.toString());
                return resolve(ParticleSystemSet.Parse(newData, scene, gpu));
            }, undefined, undefined, undefined, function () {
                scene._removePendingData(token);
                return reject("An error occured while the creation of your particle system. Check if your type '" + type + "' exists.");
            });
        });
    };
    /**
     * Static function used to export a particle system to a ParticleSystemSet variable.
     * Please note that the emitter shape is not exported
     * @param systems defines the particle systems to export
     * @returns the created particle system set
     */
    ParticleHelper.ExportSet = function (systems) {
        var set = new ParticleSystemSet();
        for (var _i = 0, systems_1 = systems; _i < systems_1.length; _i++) {
            var system = systems_1[_i];
            set.systems.push(system);
        }
        return set;
    };
    /**
     * Gets or sets base Assets URL
     */
    ParticleHelper.BaseAssetsUrl = Constants.PARTICLES_BaseAssetsUrl;
    return ParticleHelper;
}());

// Adds the parsers to the scene parsers.
AbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedData, scene, container, rootUrl) {
    var individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);
    if (!individualParser) {
        return;
    }
    // Particles Systems
    if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {
        for (var index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {
            var parsedParticleSystem = parsedData.particleSystems[index];
            container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));
        }
    }
});
AbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedParticleSystem, scene, rootUrl) {
    if (parsedParticleSystem.activeParticleCount) {
        var ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
        return ps;
    }
    else {
        var ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
        return ps;
    }
});
Engine.prototype.createEffectForParticles = function (fragmentName, uniformsNames, samplers, defines, fallbacks, onCompiled, onError) {
    if (uniformsNames === void 0) { uniformsNames = []; }
    if (samplers === void 0) { samplers = []; }
    if (defines === void 0) { defines = ""; }
    var attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();
    var effectCreationOption = ParticleSystem._GetEffectCreationOptions();
    if (defines.indexOf(" BILLBOARD") === -1) {
        defines += "\n#define BILLBOARD\n";
    }
    if (samplers.indexOf("diffuseSampler") === -1) {
        samplers.push("diffuseSampler");
    }
    return this.createEffect({
        vertex: "particles",
        fragmentElement: fragmentName
    }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), samplers, defines, fallbacks, onCompiled, onError);
};
Mesh.prototype.getEmittedParticleSystems = function () {
    var results = new Array();
    for (var index = 0; index < this.getScene().particleSystems.length; index++) {
        var particleSystem = this.getScene().particleSystems[index];
        if (particleSystem.emitter === this) {
            results.push(particleSystem);
        }
    }
    return results;
};
Mesh.prototype.getHierarchyEmittedParticleSystems = function () {
    var results = new Array();
    var descendants = this.getDescendants();
    descendants.push(this);
    for (var index = 0; index < this.getScene().particleSystems.length; index++) {
        var particleSystem = this.getScene().particleSystems[index];
        var emitter = particleSystem.emitter;
        if (emitter.position && descendants.indexOf(emitter) !== -1) {
            results.push(particleSystem);
        }
    }
    return results;
};
/**
 * @hidden
 */
var _IDoNeedToBeInTheBuild = 42;

/**
 * Represents one particle of a solid particle system.
 */
var SolidParticle = /** @class */ (function () {
    /**
     * Creates a Solid Particle object.
     * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()
     * @param particleIndex (integer) is the particle index in the Solid Particle System pool. It's also the particle identifier.
     * @param positionIndex (integer) is the starting index of the particle vertices in the SPS "positions" array.
     * @param indiceIndex (integer) is the starting index of the particle indices in the SPS "indices" array.
     * @param model (ModelShape) is a reference to the model shape on what the particle is designed.
     * @param shapeId (integer) is the model shape identifier in the SPS.
     * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))
     * @param sps defines the sps it is associated to
     * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.
     */
    function SolidParticle(particleIndex, positionIndex, indiceIndex, model, shapeId, idxInShape, sps, modelBoundingInfo) {
        if (modelBoundingInfo === void 0) { modelBoundingInfo = null; }
        /**
         * particle global index
         */
        this.idx = 0;
        /**
         * The color of the particle
         */
        this.color = new Color4(1.0, 1.0, 1.0, 1.0);
        /**
         * The world space position of the particle.
         */
        this.position = Vector3.Zero();
        /**
         * The world space rotation of the particle. (Not use if rotationQuaternion is set)
         */
        this.rotation = Vector3.Zero();
        /**
         * The scaling of the particle.
         */
        this.scaling = Vector3.One();
        /**
         * The uvs of the particle.
         */
        this.uvs = new Vector4(0.0, 0.0, 1.0, 1.0);
        /**
         * The current speed of the particle.
         */
        this.velocity = Vector3.Zero();
        /**
         * The pivot point in the particle local space.
         */
        this.pivot = Vector3.Zero();
        /**
         * Must the particle be translated from its pivot point in its local space ?
         * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.
         * Default : false
         */
        this.translateFromPivot = false;
        /**
         * Is the particle active or not ?
         */
        this.alive = true;
        /**
         * Is the particle visible or not ?
         */
        this.isVisible = true;
        /**
         * Index of this particle in the global "positions" array (Internal use)
         * @hidden
         */
        this._pos = 0;
        /**
         * @hidden Index of this particle in the global "indices" array (Internal use)
         */
        this._ind = 0;
        /**
         * ModelShape id of this particle
         */
        this.shapeId = 0;
        /**
         * Index of the particle in its shape id (Internal use)
         */
        this.idxInShape = 0;
        /**
         * @hidden Still set as invisible in order to skip useless computations (Internal use)
         */
        this._stillInvisible = false;
        /**
         * @hidden Last computed particle rotation matrix
         */
        this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
        /**
         * Parent particle Id, if any.
         * Default null.
         */
        this.parentId = null;
        /**
         * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().
         * The possible values are :
         * - AbstractMesh.CULLINGSTRATEGY_STANDARD
         * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION
         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY
         * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
         * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.
         * */
        this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
        /**
         * @hidden Internal global position in the SPS.
         */
        this._globalPosition = Vector3.Zero();
        this.idx = particleIndex;
        this._pos = positionIndex;
        this._ind = indiceIndex;
        this._model = model;
        this.shapeId = shapeId;
        this.idxInShape = idxInShape;
        this._sps = sps;
        if (modelBoundingInfo) {
            this._modelBoundingInfo = modelBoundingInfo;
            this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);
        }
    }
    Object.defineProperty(SolidParticle.prototype, "scale", {
        /**
         * Legacy support, changed scale to scaling
         */
        get: function () {
            return this.scaling;
        },
        /**
         * Legacy support, changed scale to scaling
         */
        set: function (scale) {
            this.scaling = scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SolidParticle.prototype, "quaternion", {
        /**
         * Legacy support, changed quaternion to rotationQuaternion
         */
        get: function () {
            return this.rotationQuaternion;
        },
        /**
         * Legacy support, changed quaternion to rotationQuaternion
         */
        set: function (q) {
            this.rotationQuaternion = q;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a boolean. True if the particle intersects another particle or another mesh, else false.
     * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)
     * @param target is the object (solid particle or mesh) what the intersection is computed against.
     * @returns true if it intersects
     */
    SolidParticle.prototype.intersectsMesh = function (target) {
        if (!this._boundingInfo || !target._boundingInfo) {
            return false;
        }
        if (this._sps._bSphereOnly) {
            return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target._boundingInfo.boundingSphere);
        }
        return this._boundingInfo.intersects(target._boundingInfo, false);
    };
    /**
     * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.
     * A particle is in the frustum if its bounding box intersects the frustum
     * @param frustumPlanes defines the frustum to test
     * @returns true if the particle is in the frustum planes
     */
    SolidParticle.prototype.isInFrustum = function (frustumPlanes) {
        return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);
    };
    /**
     * get the rotation matrix of the particle
     * @hidden
     */
    SolidParticle.prototype.getRotationMatrix = function (m) {
        var quaternion;
        if (this.rotationQuaternion) {
            quaternion = this.rotationQuaternion;
        }
        else {
            quaternion = Tmp.Quaternion[0];
            var rotation = this.rotation;
            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);
        }
        quaternion.toRotationMatrix(m);
    };
    return SolidParticle;
}());
/**
 * Represents the shape of the model used by one particle of a solid particle system.
 * SPS internal tool, don't use it manually.
 */
var ModelShape = /** @class */ (function () {
    /**
     * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.
     * SPS internal tool, don't use it manually.
     * @hidden
     */
    function ModelShape(id, shape, indicesLength, shapeUV, posFunction, vtxFunction) {
        /**
         * length of the shape in the model indices array (internal use)
         * @hidden
         */
        this._indicesLength = 0;
        this.shapeID = id;
        this._shape = shape;
        this._indicesLength = indicesLength;
        this._shapeUV = shapeUV;
        this._positionFunction = posFunction;
        this._vertexFunction = vtxFunction;
    }
    return ModelShape;
}());
/**
 * Represents a Depth Sorted Particle in the solid particle system.
 */
var DepthSortedParticle = /** @class */ (function () {
    function DepthSortedParticle() {
        /**
         * Index of the particle in the "indices" array
         */
        this.ind = 0;
        /**
         * Length of the particle shape in the "indices" array
         */
        this.indicesLength = 0;
        /**
         * Squared distance from the particle to the camera
         */
        this.sqDistance = 0.0;
    }
    return DepthSortedParticle;
}());

var depthSortFunction = function (p1, p2) { return p2.sqDistance - p1.sqDistance; };
/**
 * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
 *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.

 * The SPS is also a particle system. It provides some methods to manage the particles.
 * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
 *
 * Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System
 */
var SolidParticleSystem = /** @class */ (function () {
    /**
     * Creates a SPS (Solid Particle System) object.
     * @param name (String) is the SPS name, this will be the underlying mesh name.
     * @param scene (Scene) is the scene in which the SPS is added.
     * @param options defines the options of the sps e.g.
     * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.
     * * isPickable (optional boolean, default false) : if the solid particles must be pickable.
     * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.
     * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.
     * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).
     * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.
     * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.
     */
    function SolidParticleSystem(name, scene, options) {
        /**
         *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.
         *  Example : var p = SPS.particles[i];
         */
        this.particles = new Array();
        /**
         * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.
         */
        this.nbParticles = 0;
        /**
         * If the particles must ever face the camera (default false). Useful for planar particles.
         */
        this.billboard = false;
        /**
         * Recompute normals when adding a shape
         */
        this.recomputeNormals = true;
        /**
         * This a counter ofr your own usage. It's not set by any SPS functions.
         */
        this.counter = 0;
        /**
         * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.
         * Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#garbage-collector-concerns
         */
        this.vars = {};
        /**
         * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)
         * @hidden
         */
        this._bSphereOnly = false;
        /**
         * A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)
         * @hidden
         */
        this._bSphereRadiusFactor = 1.0;
        this._positions = new Array();
        this._indices = new Array();
        this._normals = new Array();
        this._colors = new Array();
        this._uvs = new Array();
        this._index = 0; // indices index
        this._updatable = true;
        this._pickable = false;
        this._isVisibilityBoxLocked = false;
        this._alwaysVisible = false;
        this._depthSort = false;
        this._shapeCounter = 0;
        this._copy = new SolidParticle(0, 0, 0, null, 0, 0, this);
        this._color = new Color4(0, 0, 0, 0);
        this._computeParticleColor = true;
        this._computeParticleTexture = true;
        this._computeParticleRotation = true;
        this._computeParticleVertex = false;
        this._computeBoundingBox = false;
        this._depthSortParticles = true;
        this._mustUnrotateFixedNormals = false;
        this._particlesIntersect = false;
        this._needs32Bits = false;
        this.name = name;
        this._scene = scene || EngineStore.LastCreatedScene;
        this._camera = scene.activeCamera;
        this._pickable = options ? options.isPickable : false;
        this._depthSort = options ? options.enableDepthSort : false;
        this._particlesIntersect = options ? options.particleIntersection : false;
        this._bSphereOnly = options ? options.boundingSphereOnly : false;
        this._bSphereRadiusFactor = (options && options.bSphereRadiusFactor) ? options.bSphereRadiusFactor : 1.0;
        if (options && options.updatable !== undefined) {
            this._updatable = options.updatable;
        }
        else {
            this._updatable = true;
        }
        if (this._pickable) {
            this.pickedParticles = [];
        }
        if (this._depthSort) {
            this.depthSortedParticles = [];
        }
    }
    /**
     * Builds the SPS underlying mesh. Returns a standard Mesh.
     * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.
     * @returns the created mesh
     */
    SolidParticleSystem.prototype.buildMesh = function () {
        if (this.nbParticles === 0) {
            var triangle = DiscBuilder.CreateDisc("", { radius: 1, tessellation: 3 }, this._scene);
            this.addShape(triangle, 1);
            triangle.dispose();
        }
        this._indices32 = (this._needs32Bits) ? new Uint32Array(this._indices) : new Uint16Array(this._indices);
        this._positions32 = new Float32Array(this._positions);
        this._uvs32 = new Float32Array(this._uvs);
        this._colors32 = new Float32Array(this._colors);
        if (this.recomputeNormals) {
            VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);
        }
        this._normals32 = new Float32Array(this._normals);
        this._fixedNormal32 = new Float32Array(this._normals);
        if (this._mustUnrotateFixedNormals) { // the particles could be created already rotated in the mesh with a positionFunction
            this._unrotateFixedNormals();
        }
        var vertexData = new VertexData();
        vertexData.indices = (this._depthSort) ? this._indices : this._indices32;
        vertexData.set(this._positions32, VertexBuffer.PositionKind);
        vertexData.set(this._normals32, VertexBuffer.NormalKind);
        if (this._uvs32.length > 0) {
            vertexData.set(this._uvs32, VertexBuffer.UVKind);
        }
        if (this._colors32.length > 0) {
            vertexData.set(this._colors32, VertexBuffer.ColorKind);
        }
        var mesh = new Mesh(this.name, this._scene);
        vertexData.applyToMesh(mesh, this._updatable);
        this.mesh = mesh;
        this.mesh.isPickable = this._pickable;
        // free memory
        if (!this._depthSort) {
            this._indices = null;
        }
        this._positions = null;
        this._normals = null;
        this._uvs = null;
        this._colors = null;
        if (!this._updatable) {
            this.particles.length = 0;
        }
        return mesh;
    };
    /**
     * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.
     * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.
     * Thus the particles generated from `digest()` have their property `position` set yet.
     * @param mesh ( Mesh ) is the mesh to be digested
     * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any
     * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets
     * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets
     * @returns the current SPS
     */
    SolidParticleSystem.prototype.digest = function (mesh, options) {
        var size = (options && options.facetNb) || 1;
        var number = (options && options.number) || 0;
        var delta = (options && options.delta) || 0;
        var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
        var meshInd = mesh.getIndices();
        var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);
        var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);
        var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);
        var f = 0; // facet counter
        var totalFacets = meshInd.length / 3; // a facet is a triangle, so 3 indices
        // compute size from number
        if (number) {
            number = (number > totalFacets) ? totalFacets : number;
            size = Math.round(totalFacets / number);
            delta = 0;
        }
        else {
            size = (size > totalFacets) ? totalFacets : size;
        }
        var facetPos = []; // submesh positions
        var facetInd = []; // submesh indices
        var facetUV = []; // submesh UV
        var facetCol = []; // submesh colors
        var barycenter = Vector3.Zero();
        var sizeO = size;
        while (f < totalFacets) {
            size = sizeO + Math.floor((1 + delta) * Math.random());
            if (f > totalFacets - size) {
                size = totalFacets - f;
            }
            // reset temp arrays
            facetPos.length = 0;
            facetInd.length = 0;
            facetUV.length = 0;
            facetCol.length = 0;
            // iterate over "size" facets
            var fi = 0;
            for (var j = f * 3; j < (f + size) * 3; j++) {
                facetInd.push(fi);
                var i = meshInd[j];
                facetPos.push(meshPos[i * 3], meshPos[i * 3 + 1], meshPos[i * 3 + 2]);
                if (meshUV) {
                    facetUV.push(meshUV[i * 2], meshUV[i * 2 + 1]);
                }
                if (meshCol) {
                    facetCol.push(meshCol[i * 4], meshCol[i * 4 + 1], meshCol[i * 4 + 2], meshCol[i * 4 + 3]);
                }
                fi++;
            }
            // create a model shape for each single particle
            var idx = this.nbParticles;
            var shape = this._posToShape(facetPos);
            var shapeUV = this._uvsToShapeUV(facetUV);
            // compute the barycenter of the shape
            var v;
            for (v = 0; v < shape.length; v++) {
                barycenter.addInPlace(shape[v]);
            }
            barycenter.scaleInPlace(1 / shape.length);
            // shift the shape from its barycenter to the origin
            for (v = 0; v < shape.length; v++) {
                shape[v].subtractInPlace(barycenter);
            }
            var bInfo;
            if (this._particlesIntersect) {
                bInfo = new BoundingInfo(barycenter, barycenter);
            }
            var modelShape = new ModelShape(this._shapeCounter, shape, size * 3, shapeUV, null, null);
            // add the particle in the SPS
            var currentPos = this._positions.length;
            var currentInd = this._indices.length;
            this._meshBuilder(this._index, shape, this._positions, facetInd, this._indices, facetUV, this._uvs, facetCol, this._colors, meshNor, this._normals, idx, 0, null);
            this._addParticle(idx, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo);
            // initialize the particle position
            this.particles[this.nbParticles].position.addInPlace(barycenter);
            this._index += shape.length;
            idx++;
            this.nbParticles++;
            this._shapeCounter++;
            f += size;
        }
        return this;
    };
    // unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()
    SolidParticleSystem.prototype._unrotateFixedNormals = function () {
        var index = 0;
        var idx = 0;
        var tmpNormal = Tmp.Vector3[0];
        var quaternion = Tmp.Quaternion[0];
        var invertedRotMatrix = Tmp.Matrix[0];
        for (var p = 0; p < this.particles.length; p++) {
            var particle = this.particles[p];
            var shape = particle._model._shape;
            // computing the inverse of the rotation matrix from the quaternion
            // is equivalent to computing the matrix of the inverse quaternion, i.e of the conjugate quaternion
            if (particle.rotationQuaternion) {
                particle.rotationQuaternion.conjugateToRef(quaternion);
            }
            else {
                var rotation = particle.rotation;
                Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);
                quaternion.conjugateInPlace();
            }
            quaternion.toRotationMatrix(invertedRotMatrix);
            for (var pt = 0; pt < shape.length; pt++) {
                idx = index + pt * 3;
                Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);
                tmpNormal.toArray(this._fixedNormal32, idx);
            }
            index = idx + 3;
        }
    };
    //reset copy
    SolidParticleSystem.prototype._resetCopy = function () {
        var copy = this._copy;
        copy.position.setAll(0);
        copy.rotation.setAll(0);
        copy.rotationQuaternion = null;
        copy.scaling.setAll(1);
        copy.uvs.copyFromFloats(0.0, 0.0, 1.0, 1.0);
        copy.color = null;
        copy.translateFromPivot = false;
    };
    // _meshBuilder : inserts the shape model in the global SPS mesh
    SolidParticleSystem.prototype._meshBuilder = function (p, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options) {
        var i;
        var u = 0;
        var c = 0;
        var n = 0;
        this._resetCopy();
        var copy = this._copy;
        if (options && options.positionFunction) { // call to custom positionFunction
            options.positionFunction(copy, idx, idxInShape);
            this._mustUnrotateFixedNormals = true;
        }
        var rotMatrix = Tmp.Matrix[0];
        var tmpVertex = Tmp.Vector3[0];
        var tmpRotated = Tmp.Vector3[1];
        var pivotBackTranslation = Tmp.Vector3[2];
        var scaledPivot = Tmp.Vector3[3];
        copy.getRotationMatrix(rotMatrix);
        copy.pivot.multiplyToRef(copy.scaling, scaledPivot);
        if (copy.translateFromPivot) {
            pivotBackTranslation.setAll(0.0);
        }
        else {
            pivotBackTranslation.copyFrom(scaledPivot);
        }
        for (i = 0; i < shape.length; i++) {
            tmpVertex.copyFrom(shape[i]);
            if (options && options.vertexFunction) {
                options.vertexFunction(copy, tmpVertex, i);
            }
            tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);
            Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);
            tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);
            positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);
            if (meshUV) {
                var copyUvs = copy.uvs;
                uvs.push((copyUvs.z - copyUvs.x) * meshUV[u] + copyUvs.x, (copyUvs.w - copyUvs.y) * meshUV[u + 1] + copyUvs.y);
                u += 2;
            }
            if (copy.color) {
                this._color = copy.color;
            }
            else {
                var color = this._color;
                if (meshCol && meshCol[c] !== undefined) {
                    color.r = meshCol[c];
                    color.g = meshCol[c + 1];
                    color.b = meshCol[c + 2];
                    color.a = meshCol[c + 3];
                }
                else {
                    color.r = 1.0;
                    color.g = 1.0;
                    color.b = 1.0;
                    color.a = 1.0;
                }
            }
            colors.push(this._color.r, this._color.g, this._color.b, this._color.a);
            c += 4;
            if (!this.recomputeNormals && meshNor) {
                tmpVertex.x = meshNor[n];
                tmpVertex.y = meshNor[n + 1];
                tmpVertex.z = meshNor[n + 2];
                Vector3.TransformNormalToRef(tmpVertex, rotMatrix, tmpVertex);
                normals.push(tmpVertex.x, tmpVertex.y, tmpVertex.z);
                n += 3;
            }
        }
        for (i = 0; i < meshInd.length; i++) {
            var current_ind = p + meshInd[i];
            indices.push(current_ind);
            if (current_ind > 65535) {
                this._needs32Bits = true;
            }
        }
        if (this._pickable) {
            var nbfaces = meshInd.length / 3;
            for (i = 0; i < nbfaces; i++) {
                this.pickedParticles.push({ idx: idx, faceId: i });
            }
        }
        if (this._depthSort) {
            this.depthSortedParticles.push(new DepthSortedParticle());
        }
        return copy;
    };
    // returns a shape array from positions array
    SolidParticleSystem.prototype._posToShape = function (positions) {
        var shape = [];
        for (var i = 0; i < positions.length; i += 3) {
            shape.push(Vector3.FromArray(positions, i));
        }
        return shape;
    };
    // returns a shapeUV array from a Vector4 uvs
    SolidParticleSystem.prototype._uvsToShapeUV = function (uvs) {
        var shapeUV = [];
        if (uvs) {
            for (var i = 0; i < uvs.length; i++) {
                shapeUV.push(uvs[i]);
            }
        }
        return shapeUV;
    };
    // adds a new particle object in the particles array
    SolidParticleSystem.prototype._addParticle = function (idx, idxpos, idxind, model, shapeId, idxInShape, bInfo) {
        if (bInfo === void 0) { bInfo = null; }
        var sp = new SolidParticle(idx, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);
        this.particles.push(sp);
        return sp;
    };
    /**
     * Adds some particles to the SPS from the model shape. Returns the shape id.
     * Please read the doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#create-an-immutable-sps
     * @param mesh is any Mesh object that will be used as a model for the solid particles.
     * @param nb (positive integer) the number of particles to be created from this model
     * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.
     * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation
     * @returns the number of shapes in the system
     */
    SolidParticleSystem.prototype.addShape = function (mesh, nb, options) {
        var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);
        var meshInd = mesh.getIndices();
        var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);
        var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);
        var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);
        var bbInfo;
        if (this._particlesIntersect) {
            bbInfo = mesh.getBoundingInfo();
        }
        var shape = this._posToShape(meshPos);
        var shapeUV = this._uvsToShapeUV(meshUV);
        var posfunc = options ? options.positionFunction : null;
        var vtxfunc = options ? options.vertexFunction : null;
        var modelShape = new ModelShape(this._shapeCounter, shape, meshInd.length, shapeUV, posfunc, vtxfunc);
        // particles
        var sp;
        var currentCopy;
        var idx = this.nbParticles;
        for (var i = 0; i < nb; i++) {
            var currentPos = this._positions.length;
            var currentInd = this._indices.length;
            currentCopy = this._meshBuilder(this._index, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options);
            if (this._updatable) {
                sp = this._addParticle(idx, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo);
                sp.position.copyFrom(currentCopy.position);
                sp.rotation.copyFrom(currentCopy.rotation);
                if (currentCopy.rotationQuaternion && sp.rotationQuaternion) {
                    sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);
                }
                if (currentCopy.color && sp.color) {
                    sp.color.copyFrom(currentCopy.color);
                }
                sp.scaling.copyFrom(currentCopy.scaling);
                sp.uvs.copyFrom(currentCopy.uvs);
            }
            this._index += shape.length;
            idx++;
        }
        this.nbParticles += nb;
        this._shapeCounter++;
        return this._shapeCounter - 1;
    };
    // rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices
    SolidParticleSystem.prototype._rebuildParticle = function (particle) {
        this._resetCopy();
        var copy = this._copy;
        if (particle._model._positionFunction) { // recall to stored custom positionFunction
            particle._model._positionFunction(copy, particle.idx, particle.idxInShape);
        }
        var rotMatrix = Tmp.Matrix[0];
        var tmpVertex = Tmp.Vector3[0];
        var tmpRotated = Tmp.Vector3[1];
        var pivotBackTranslation = Tmp.Vector3[2];
        var scaledPivot = Tmp.Vector3[3];
        copy.getRotationMatrix(rotMatrix);
        particle.pivot.multiplyToRef(particle.scaling, scaledPivot);
        if (copy.translateFromPivot) {
            pivotBackTranslation.copyFromFloats(0.0, 0.0, 0.0);
        }
        else {
            pivotBackTranslation.copyFrom(scaledPivot);
        }
        var shape = particle._model._shape;
        for (var pt = 0; pt < shape.length; pt++) {
            tmpVertex.copyFrom(shape[pt]);
            if (particle._model._vertexFunction) {
                particle._model._vertexFunction(copy, tmpVertex, pt); // recall to stored vertexFunction
            }
            tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);
            Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);
            tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position).toArray(this._positions32, particle._pos + pt * 3);
        }
        particle.position.setAll(0.0);
        particle.rotation.setAll(0.0);
        particle.rotationQuaternion = null;
        particle.scaling.setAll(1.0);
        particle.uvs.setAll(0.0);
        particle.pivot.setAll(0.0);
        particle.translateFromPivot = false;
        particle.parentId = null;
    };
    /**
     * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.
     * @returns the SPS.
     */
    SolidParticleSystem.prototype.rebuildMesh = function () {
        for (var p = 0; p < this.particles.length; p++) {
            this._rebuildParticle(this.particles[p]);
        }
        this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);
        return this;
    };
    /**
     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
     *  This method calls `updateParticle()` for each particle of the SPS.
     *  For an animated SPS, it is usually called within the render loop.
     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_
     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_
     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_
     * @returns the SPS.
     */
    SolidParticleSystem.prototype.setParticles = function (start, end, update) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = this.nbParticles - 1; }
        if (update === void 0) { update = true; }
        if (!this._updatable) {
            return this;
        }
        // custom beforeUpdate
        this.beforeUpdateParticles(start, end, update);
        var rotMatrix = Tmp.Matrix[0];
        var invertedMatrix = Tmp.Matrix[1];
        var mesh = this.mesh;
        var colors32 = this._colors32;
        var positions32 = this._positions32;
        var normals32 = this._normals32;
        var uvs32 = this._uvs32;
        var indices32 = this._indices32;
        var indices = this._indices;
        var fixedNormal32 = this._fixedNormal32;
        var tempVectors = Tmp.Vector3;
        var camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);
        var camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);
        var camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);
        var minimum = tempVectors[8].setAll(Number.MAX_VALUE);
        var maximum = tempVectors[9].setAll(-Number.MAX_VALUE);
        var camInvertedPosition = tempVectors[10].setAll(0);
        // cases when the World Matrix is to be computed first
        if (this.billboard || this._depthSort) {
            this.mesh.computeWorldMatrix(true);
            this.mesh._worldMatrix.invertToRef(invertedMatrix);
        }
        // if the particles will always face the camera
        if (this.billboard) {
            // compute the camera position and un-rotate it by the current mesh rotation
            var tmpVertex = tempVectors[0];
            this._camera.getDirectionToRef(Axis.Z, tmpVertex);
            Vector3.TransformNormalToRef(tmpVertex, invertedMatrix, camAxisZ);
            camAxisZ.normalize();
            // same for camera up vector extracted from the cam view matrix
            var view = this._camera.getViewMatrix(true);
            Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);
            Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);
            camAxisY.normalize();
            camAxisX.normalize();
        }
        // if depthSort, compute the camera global position in the mesh local system
        if (this._depthSort) {
            Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition); // then un-rotate the camera
        }
        Matrix.IdentityToRef(rotMatrix);
        var idx = 0; // current position index in the global array positions32
        var index = 0; // position start index in the global array positions32 of the current particle
        var colidx = 0; // current color index in the global array colors32
        var colorIndex = 0; // color start index in the global array colors32 of the current particle
        var uvidx = 0; // current uv index in the global array uvs32
        var uvIndex = 0; // uv start index in the global array uvs32 of the current particle
        var pt = 0; // current index in the particle model shape
        if (this.mesh.isFacetDataEnabled) {
            this._computeBoundingBox = true;
        }
        end = (end >= this.nbParticles) ? this.nbParticles - 1 : end;
        if (this._computeBoundingBox) {
            if (start != 0 || end != this.nbParticles - 1) { // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.
                var boundingInfo = this.mesh._boundingInfo;
                if (boundingInfo) {
                    minimum.copyFrom(boundingInfo.minimum);
                    maximum.copyFrom(boundingInfo.maximum);
                }
            }
        }
        // particle loop
        index = this.particles[start]._pos;
        var vpos = (index / 3) | 0;
        colorIndex = vpos * 4;
        uvIndex = vpos * 2;
        for (var p = start; p <= end; p++) {
            var particle = this.particles[p];
            // call to custom user function to update the particle properties
            this.updateParticle(particle);
            var shape = particle._model._shape;
            var shapeUV = particle._model._shapeUV;
            var particleRotationMatrix = particle._rotationMatrix;
            var particlePosition = particle.position;
            var particleRotation = particle.rotation;
            var particleScaling = particle.scaling;
            var particleGlobalPosition = particle._globalPosition;
            // camera-particle distance for depth sorting
            if (this._depthSort && this._depthSortParticles) {
                var dsp = this.depthSortedParticles[p];
                dsp.ind = particle._ind;
                dsp.indicesLength = particle._model._indicesLength;
                dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);
            }
            // skip the computations for inactive or already invisible particles
            if (!particle.alive || (particle._stillInvisible && !particle.isVisible)) {
                // increment indexes for the next particle
                pt = shape.length;
                index += pt * 3;
                colorIndex += pt * 4;
                uvIndex += pt * 2;
                continue;
            }
            if (particle.isVisible) {
                particle._stillInvisible = false; // un-mark permanent invisibility
                var scaledPivot = tempVectors[12];
                particle.pivot.multiplyToRef(particleScaling, scaledPivot);
                // particle rotation matrix
                if (this.billboard) {
                    particleRotation.x = 0.0;
                    particleRotation.y = 0.0;
                }
                if (this._computeParticleRotation || this.billboard) {
                    particle.getRotationMatrix(rotMatrix);
                }
                var particleHasParent = (particle.parentId !== null);
                if (particleHasParent) {
                    var parent_1 = this.particles[particle.parentId];
                    var parentRotationMatrix = parent_1._rotationMatrix;
                    var parentGlobalPosition = parent_1._globalPosition;
                    var rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];
                    var rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];
                    var rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];
                    particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;
                    particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;
                    particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;
                    if (this._computeParticleRotation || this.billboard) {
                        var rotMatrixValues = rotMatrix.m;
                        particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];
                        particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];
                        particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];
                        particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];
                        particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];
                        particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];
                        particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];
                        particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];
                        particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];
                    }
                }
                else {
                    particleGlobalPosition.x = particlePosition.x;
                    particleGlobalPosition.y = particlePosition.y;
                    particleGlobalPosition.z = particlePosition.z;
                    if (this._computeParticleRotation || this.billboard) {
                        var rotMatrixValues = rotMatrix.m;
                        particleRotationMatrix[0] = rotMatrixValues[0];
                        particleRotationMatrix[1] = rotMatrixValues[1];
                        particleRotationMatrix[2] = rotMatrixValues[2];
                        particleRotationMatrix[3] = rotMatrixValues[4];
                        particleRotationMatrix[4] = rotMatrixValues[5];
                        particleRotationMatrix[5] = rotMatrixValues[6];
                        particleRotationMatrix[6] = rotMatrixValues[8];
                        particleRotationMatrix[7] = rotMatrixValues[9];
                        particleRotationMatrix[8] = rotMatrixValues[10];
                    }
                }
                var pivotBackTranslation = tempVectors[11];
                if (particle.translateFromPivot) {
                    pivotBackTranslation.setAll(0.0);
                }
                else {
                    pivotBackTranslation.copyFrom(scaledPivot);
                }
                // particle vertex loop
                for (pt = 0; pt < shape.length; pt++) {
                    idx = index + pt * 3;
                    colidx = colorIndex + pt * 4;
                    uvidx = uvIndex + pt * 2;
                    var tmpVertex = tempVectors[0];
                    tmpVertex.copyFrom(shape[pt]);
                    if (this._computeParticleVertex) {
                        this.updateParticleVertex(particle, tmpVertex, pt);
                    }
                    // positions
                    var vertexX = tmpVertex.x * particleScaling.x - scaledPivot.x;
                    var vertexY = tmpVertex.y * particleScaling.y - scaledPivot.y;
                    var vertexZ = tmpVertex.z * particleScaling.z - scaledPivot.z;
                    var rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];
                    var rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];
                    var rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];
                    rotatedX += pivotBackTranslation.x;
                    rotatedY += pivotBackTranslation.y;
                    rotatedZ += pivotBackTranslation.z;
                    var px = positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;
                    var py = positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;
                    var pz = positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;
                    if (this._computeBoundingBox) {
                        minimum.minimizeInPlaceFromFloats(px, py, pz);
                        maximum.maximizeInPlaceFromFloats(px, py, pz);
                    }
                    // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()
                    if (!this._computeParticleVertex) {
                        var normalx = fixedNormal32[idx];
                        var normaly = fixedNormal32[idx + 1];
                        var normalz = fixedNormal32[idx + 2];
                        var rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];
                        var rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];
                        var rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];
                        normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;
                        normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;
                        normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;
                    }
                    if (this._computeParticleColor && particle.color) {
                        var color = particle.color;
                        var colors32_1 = this._colors32;
                        colors32_1[colidx] = color.r;
                        colors32_1[colidx + 1] = color.g;
                        colors32_1[colidx + 2] = color.b;
                        colors32_1[colidx + 3] = color.a;
                    }
                    if (this._computeParticleTexture) {
                        var uvs = particle.uvs;
                        uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;
                        uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;
                    }
                }
            }
            // particle just set invisible : scaled to zero and positioned at the origin
            else {
                particle._stillInvisible = true; // mark the particle as invisible
                for (pt = 0; pt < shape.length; pt++) {
                    idx = index + pt * 3;
                    colidx = colorIndex + pt * 4;
                    uvidx = uvIndex + pt * 2;
                    positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;
                    normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;
                    if (this._computeParticleColor && particle.color) {
                        var color = particle.color;
                        colors32[colidx] = color.r;
                        colors32[colidx + 1] = color.g;
                        colors32[colidx + 2] = color.b;
                        colors32[colidx + 3] = color.a;
                    }
                    if (this._computeParticleTexture) {
                        var uvs = particle.uvs;
                        uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;
                        uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;
                    }
                }
            }
            // if the particle intersections must be computed : update the bbInfo
            if (this._particlesIntersect) {
                var bInfo = particle._boundingInfo;
                var bBox = bInfo.boundingBox;
                var bSphere = bInfo.boundingSphere;
                var modelBoundingInfo = particle._modelBoundingInfo;
                if (!this._bSphereOnly) {
                    // place, scale and rotate the particle bbox within the SPS local system, then update it
                    var modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;
                    var tempMin = tempVectors[1];
                    var tempMax = tempVectors[2];
                    tempMin.setAll(Number.MAX_VALUE);
                    tempMax.setAll(-Number.MAX_VALUE);
                    for (var b = 0; b < 8; b++) {
                        var scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;
                        var scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;
                        var scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;
                        var rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];
                        var rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];
                        var rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];
                        var x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;
                        var y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;
                        var z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;
                        tempMin.minimizeInPlaceFromFloats(x, y, z);
                        tempMax.maximizeInPlaceFromFloats(x, y, z);
                    }
                    bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);
                }
                // place and scale the particle bouding sphere in the SPS local system, then update it
                var minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);
                var maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);
                var bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);
                var halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);
                var bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);
                var bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);
                bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);
            }
            // increment indexes for the next particle
            index = idx + 3;
            colorIndex = colidx + 4;
            uvIndex = uvidx + 2;
        }
        // if the VBO must be updated
        if (update) {
            if (this._computeParticleColor) {
                mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);
            }
            if (this._computeParticleTexture) {
                mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);
            }
            mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);
            if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {
                if (this._computeParticleVertex || mesh.isFacetDataEnabled) {
                    // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]
                    var params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;
                    VertexData.ComputeNormals(positions32, indices32, normals32, params);
                    for (var i = 0; i < normals32.length; i++) {
                        fixedNormal32[i] = normals32[i];
                    }
                }
                if (!mesh.areNormalsFrozen) {
                    mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);
                }
            }
            if (this._depthSort && this._depthSortParticles) {
                var depthSortedParticles = this.depthSortedParticles;
                depthSortedParticles.sort(depthSortFunction);
                var dspl = depthSortedParticles.length;
                var sid = 0;
                for (var sorted = 0; sorted < dspl; sorted++) {
                    var lind = depthSortedParticles[sorted].indicesLength;
                    var sind = depthSortedParticles[sorted].ind;
                    for (var i = 0; i < lind; i++) {
                        indices32[sid] = indices[sind + i];
                        sid++;
                    }
                }
                mesh.updateIndices(indices32);
            }
        }
        if (this._computeBoundingBox) {
            if (mesh._boundingInfo) {
                mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);
            }
            else {
                mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);
            }
        }
        this.afterUpdateParticles(start, end, update);
        return this;
    };
    /**
    * Disposes the SPS.
    */
    SolidParticleSystem.prototype.dispose = function () {
        this.mesh.dispose();
        this.vars = null;
        // drop references to internal big arrays for the GC
        this._positions = null;
        this._indices = null;
        this._normals = null;
        this._uvs = null;
        this._colors = null;
        this._indices32 = null;
        this._positions32 = null;
        this._normals32 = null;
        this._fixedNormal32 = null;
        this._uvs32 = null;
        this._colors32 = null;
        this.pickedParticles = null;
    };
    /**
     * Visibilty helper : Recomputes the visible size according to the mesh bounding box
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
     * @returns the SPS.
     */
    SolidParticleSystem.prototype.refreshVisibleSize = function () {
        if (!this._isVisibilityBoxLocked) {
            this.mesh.refreshBoundingInfo();
        }
        return this;
    };
    /**
     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.
     * @param size the size (float) of the visibility box
     * note : this doesn't lock the SPS mesh bounding box.
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
     */
    SolidParticleSystem.prototype.setVisibilityBox = function (size) {
        var vis = size / 2;
        this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));
    };
    Object.defineProperty(SolidParticleSystem.prototype, "isAlwaysVisible", {
        /**
         * Gets whether the SPS as always visible or not
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         */
        get: function () {
            return this._alwaysVisible;
        },
        /**
         * Sets the SPS as always visible or not
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         */
        set: function (val) {
            this._alwaysVisible = val;
            this.mesh.alwaysSelectAsActiveMesh = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SolidParticleSystem.prototype, "isVisibilityBoxLocked", {
        /**
         * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         */
        get: function () {
            return this._isVisibilityBoxLocked;
        },
        /**
         * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         */
        set: function (val) {
            this._isVisibilityBoxLocked = val;
            var boundingInfo = this.mesh.getBoundingInfo();
            boundingInfo.isLocked = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SolidParticleSystem.prototype, "computeParticleRotation", {
        /**
         * Gets if `setParticles()` computes the particle rotations or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
         */
        get: function () {
            return this._computeParticleRotation;
        },
        /**
         * Tells to `setParticles()` to compute the particle rotations or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
         */
        set: function (val) {
            this._computeParticleRotation = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SolidParticleSystem.prototype, "computeParticleColor", {
        /**
         * Gets if `setParticles()` computes the particle colors or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
         */
        get: function () {
            return this._computeParticleColor;
        },
        /**
         * Tells to `setParticles()` to compute the particle colors or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
         */
        set: function (val) {
            this._computeParticleColor = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SolidParticleSystem.prototype, "computeParticleTexture", {
        /**
         * Gets if `setParticles()` computes the particle textures or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
         */
        get: function () {
            return this._computeParticleTexture;
        },
        set: function (val) {
            this._computeParticleTexture = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SolidParticleSystem.prototype, "computeParticleVertex", {
        /**
         * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.
         * Default value : false. The SPS is faster when it's set to false.
         * Note : the particle custom vertex positions aren't stored values.
         */
        get: function () {
            return this._computeParticleVertex;
        },
        /**
         * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.
         * Default value : false. The SPS is faster when it's set to false.
         * Note : the particle custom vertex positions aren't stored values.
         */
        set: function (val) {
            this._computeParticleVertex = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SolidParticleSystem.prototype, "computeBoundingBox", {
        /**
         * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
         */
        get: function () {
            return this._computeBoundingBox;
        },
        /**
         * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
         */
        set: function (val) {
            this._computeBoundingBox = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SolidParticleSystem.prototype, "depthSortParticles", {
        /**
         * Gets if `setParticles()` sorts or not the distance between each particle and the camera.
         * Skipped when `enableDepthSort` is set to `false` (default) at construction time.
         * Default : `true`
         */
        get: function () {
            return this._depthSortParticles;
        },
        /**
         * Tells to `setParticles()` to sort or not the distance between each particle and the camera.
         * Skipped when `enableDepthSort` is set to `false` (default) at construction time.
         * Default : `true`
         */
        set: function (val) {
            this._depthSortParticles = val;
        },
        enumerable: true,
        configurable: true
    });
    // =======================================================================
    // Particle behavior logic
    // these following methods may be overwritten by the user to fit his needs
    /**
     * This function does nothing. It may be overwritten to set all the particle first values.
     * The SPS doesn't call this function, you may have to call it by your own.
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
     */
    SolidParticleSystem.prototype.initParticles = function () {
    };
    /**
     * This function does nothing. It may be overwritten to recycle a particle.
     * The SPS doesn't call this function, you may have to call it by your own.
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
     * @param particle The particle to recycle
     * @returns the recycled particle
     */
    SolidParticleSystem.prototype.recycleParticle = function (particle) {
        return particle;
    };
    /**
     * Updates a particle : this function should  be overwritten by the user.
     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
     * @example : just set a particle position or velocity and recycle conditions
     * @param particle The particle to update
     * @returns the updated particle
     */
    SolidParticleSystem.prototype.updateParticle = function (particle) {
        return particle;
    };
    /**
     * Updates a vertex of a particle : it can be overwritten by the user.
     * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.
     * @param particle the current particle
     * @param vertex the current index of the current particle
     * @param pt the index of the current vertex in the particle shape
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#update-each-particle-shape
     * @example : just set a vertex particle position
     * @returns the updated vertex
     */
    SolidParticleSystem.prototype.updateParticleVertex = function (particle, vertex, pt) {
        return vertex;
    };
    /**
     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.
     * This does nothing and may be overwritten by the user.
     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
     * @param update the boolean update value actually passed to setParticles()
     */
    SolidParticleSystem.prototype.beforeUpdateParticles = function (start, stop, update) {
    };
    /**
     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
     * This will be passed three parameters.
     * This does nothing and may be overwritten by the user.
     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
     * @param update the boolean update value actually passed to setParticles()
     */
    SolidParticleSystem.prototype.afterUpdateParticles = function (start, stop, update) {
    };
    return SolidParticleSystem;
}());

/**
 * Gets the current physics engine
 * @returns a IPhysicsEngine or null if none attached
 */
Scene.prototype.getPhysicsEngine = function () {
    return this._physicsEngine;
};
/**
 * Enables physics to the current scene
 * @param gravity defines the scene's gravity for the physics engine
 * @param plugin defines the physics engine to be used. defaults to OimoJS.
 * @return a boolean indicating if the physics engine was initialized
 */
Scene.prototype.enablePhysics = function (gravity, plugin) {
    if (gravity === void 0) { gravity = null; }
    if (this._physicsEngine) {
        return true;
    }
    // Register the component to the scene
    var component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE);
    if (!component) {
        component = new PhysicsEngineSceneComponent(this);
        this._addComponent(component);
    }
    try {
        this._physicsEngine = new PhysicsEngine(gravity, plugin);
        return true;
    }
    catch (e) {
        Logger.Error(e.message);
        return false;
    }
};
/**
 * Disables and disposes the physics engine associated with the scene
 */
Scene.prototype.disablePhysicsEngine = function () {
    if (!this._physicsEngine) {
        return;
    }
    this._physicsEngine.dispose();
    this._physicsEngine = null;
};
/**
 * Gets a boolean indicating if there is an active physics engine
 * @returns a boolean indicating if there is an active physics engine
 */
Scene.prototype.isPhysicsEnabled = function () {
    return this._physicsEngine !== undefined;
};
/**
 * Deletes a physics compound impostor
 * @param compound defines the compound to delete
 */
Scene.prototype.deleteCompoundImpostor = function (compound) {
    var mesh = compound.parts[0].mesh;
    if (mesh.physicsImpostor) {
        mesh.physicsImpostor.dispose( /*true*/);
        mesh.physicsImpostor = null;
    }
};
/** @hidden */
Scene.prototype._advancePhysicsEngineStep = function (step) {
    if (this._physicsEngine) {
        this.onBeforePhysicsObservable.notifyObservers(this);
        this._physicsEngine._step(step / 1000);
        this.onAfterPhysicsObservable.notifyObservers(this);
    }
};
Object.defineProperty(AbstractMesh.prototype, "physicsImpostor", {
    get: function () {
        return this._physicsImpostor;
    },
    set: function (value) {
        var _this = this;
        if (this._physicsImpostor === value) {
            return;
        }
        if (this._disposePhysicsObserver) {
            this.onDisposeObservable.remove(this._disposePhysicsObserver);
        }
        this._physicsImpostor = value;
        if (value) {
            this._disposePhysicsObserver = this.onDisposeObservable.add(function () {
                // Physics
                if (_this.physicsImpostor) {
                    _this.physicsImpostor.dispose( /*!doNotRecurse*/);
                    _this.physicsImpostor = null;
                }
            });
        }
    },
    enumerable: true,
    configurable: true
});
/**
 * Gets the current physics impostor
 * @see http://doc.babylonjs.com/features/physics_engine
 * @returns a physics impostor or null
 */
AbstractMesh.prototype.getPhysicsImpostor = function () {
    return this.physicsImpostor;
};
/**
 * Apply a physic impulse to the mesh
 * @param force defines the force to apply
 * @param contactPoint defines where to apply the force
 * @returns the current mesh
 * @see http://doc.babylonjs.com/how_to/using_the_physics_engine
 */
AbstractMesh.prototype.applyImpulse = function (force, contactPoint) {
    if (!this.physicsImpostor) {
        return this;
    }
    this.physicsImpostor.applyImpulse(force, contactPoint);
    return this;
};
/**
 * Creates a physic joint between two meshes
 * @param otherMesh defines the other mesh to use
 * @param pivot1 defines the pivot to use on this mesh
 * @param pivot2 defines the pivot to use on the other mesh
 * @param options defines additional options (can be plugin dependent)
 * @returns the current mesh
 * @see https://www.babylonjs-playground.com/#0BS5U0#0
 */
AbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh, pivot1, pivot2, options) {
    if (!this.physicsImpostor || !otherMesh.physicsImpostor) {
        return this;
    }
    this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {
        mainPivot: pivot1,
        connectedPivot: pivot2,
        nativeParams: options
    });
    return this;
};
/**
 * Defines the physics engine scene component responsible to manage a physics engine
 */
var PhysicsEngineSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function PhysicsEngineSceneComponent(scene) {
        var _this = this;
        /**
         * The component name helpful to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_PHYSICSENGINE;
        this.scene = scene;
        this.scene.onBeforePhysicsObservable = new Observable();
        this.scene.onAfterPhysicsObservable = new Observable();
        // Replace the function used to get the deterministic frame time
        this.scene.getDeterministicFrameTime = function () {
            if (_this.scene._physicsEngine) {
                return _this.scene._physicsEngine.getTimeStep() * 1000;
            }
            return 1000.0 / 60.0;
        };
    }
    /**
     * Registers the component in a given scene
     */
    PhysicsEngineSceneComponent.prototype.register = function () {
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    PhysicsEngineSceneComponent.prototype.rebuild = function () {
        // Nothing to do for this component
    };
    /**
     * Disposes the component and the associated ressources
     */
    PhysicsEngineSceneComponent.prototype.dispose = function () {
        this.scene.onBeforePhysicsObservable.clear();
        this.scene.onAfterPhysicsObservable.clear();
        if (this.scene._physicsEngine) {
            this.scene.disablePhysicsEngine();
        }
    };
    return PhysicsEngineSceneComponent;
}());

/**
 * A helper for physics simulations
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
 */
var PhysicsHelper = /** @class */ (function () {
    /**
     * Initializes the Physics helper
     * @param scene Babylon.js scene
     */
    function PhysicsHelper(scene) {
        this._scene = scene;
        this._physicsEngine = this._scene.getPhysicsEngine();
        if (!this._physicsEngine) {
            Logger.Warn('Physics engine not enabled. Please enable the physics before you can use the methods.');
            return;
        }
    }
    /**
     * Applies a radial explosion impulse
     * @param origin the origin of the explosion
     * @param radiusOrEventOptions the radius or the options of radial explosion
     * @param strength the explosion strength
     * @param falloff possible options: Constant & Linear. Defaults to Constant
     * @returns A physics radial explosion event, or null
     */
    PhysicsHelper.prototype.applyRadialExplosionImpulse = function (origin, radiusOrEventOptions, strength, falloff) {
        if (!this._physicsEngine) {
            Logger.Warn('Physics engine not enabled. Please enable the physics before you call this method.');
            return null;
        }
        var impostors = this._physicsEngine.getImpostors();
        if (impostors.length === 0) {
            return null;
        }
        if (typeof radiusOrEventOptions === 'number') {
            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();
            radiusOrEventOptions.radius = radiusOrEventOptions;
            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;
        }
        var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);
        var affectedImpostorsWithData = Array();
        impostors.forEach(function (impostor) {
            var impostorHitData = event.getImpostorHitData(impostor, origin);
            if (!impostorHitData) {
                return;
            }
            impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);
            affectedImpostorsWithData.push({
                impostor: impostor,
                hitData: impostorHitData,
            });
        });
        event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);
        event.dispose(false);
        return event;
    };
    /**
     * Applies a radial explosion force
     * @param origin the origin of the explosion
     * @param radiusOrEventOptions the radius or the options of radial explosion
     * @param strength the explosion strength
     * @param falloff possible options: Constant & Linear. Defaults to Constant
     * @returns A physics radial explosion event, or null
     */
    PhysicsHelper.prototype.applyRadialExplosionForce = function (origin, radiusOrEventOptions, strength, falloff) {
        if (!this._physicsEngine) {
            Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');
            return null;
        }
        var impostors = this._physicsEngine.getImpostors();
        if (impostors.length === 0) {
            return null;
        }
        if (typeof radiusOrEventOptions === 'number') {
            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();
            radiusOrEventOptions.radius = radiusOrEventOptions;
            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;
        }
        var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);
        var affectedImpostorsWithData = Array();
        impostors.forEach(function (impostor) {
            var impostorHitData = event.getImpostorHitData(impostor, origin);
            if (!impostorHitData) {
                return;
            }
            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);
            affectedImpostorsWithData.push({
                impostor: impostor,
                hitData: impostorHitData,
            });
        });
        event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);
        event.dispose(false);
        return event;
    };
    /**
     * Creates a gravitational field
     * @param origin the origin of the explosion
     * @param radiusOrEventOptions the radius or the options of radial explosion
     * @param strength the explosion strength
     * @param falloff possible options: Constant & Linear. Defaults to Constant
     * @returns A physics gravitational field event, or null
     */
    PhysicsHelper.prototype.gravitationalField = function (origin, radiusOrEventOptions, strength, falloff) {
        if (!this._physicsEngine) {
            Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');
            return null;
        }
        var impostors = this._physicsEngine.getImpostors();
        if (impostors.length === 0) {
            return null;
        }
        if (typeof radiusOrEventOptions === 'number') {
            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();
            radiusOrEventOptions.radius = radiusOrEventOptions;
            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;
        }
        var event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);
        event.dispose(false);
        return event;
    };
    /**
     * Creates a physics updraft event
     * @param origin the origin of the updraft
     * @param radiusOrEventOptions the radius or the options of the updraft
     * @param strength the strength of the updraft
     * @param height the height of the updraft
     * @param updraftMode possible options: Center & Perpendicular. Defaults to Center
     * @returns A physics updraft event, or null
     */
    PhysicsHelper.prototype.updraft = function (origin, radiusOrEventOptions, strength, height, updraftMode) {
        if (!this._physicsEngine) {
            Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');
            return null;
        }
        if (this._physicsEngine.getImpostors().length === 0) {
            return null;
        }
        if (typeof radiusOrEventOptions === 'number') {
            radiusOrEventOptions = new PhysicsUpdraftEventOptions();
            radiusOrEventOptions.radius = radiusOrEventOptions;
            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
            radiusOrEventOptions.height = height || radiusOrEventOptions.height;
            radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;
        }
        var event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);
        event.dispose(false);
        return event;
    };
    /**
     * Creates a physics vortex event
     * @param origin the of the vortex
     * @param radiusOrEventOptions the radius or the options of the vortex
     * @param strength the strength of the vortex
     * @param height   the height of the vortex
     * @returns a Physics vortex event, or null
     * A physics vortex event or null
     */
    PhysicsHelper.prototype.vortex = function (origin, radiusOrEventOptions, strength, height) {
        if (!this._physicsEngine) {
            Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');
            return null;
        }
        if (this._physicsEngine.getImpostors().length === 0) {
            return null;
        }
        if (typeof radiusOrEventOptions === 'number') {
            radiusOrEventOptions = new PhysicsVortexEventOptions();
            radiusOrEventOptions.radius = radiusOrEventOptions;
            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;
            radiusOrEventOptions.height = height || radiusOrEventOptions.height;
        }
        var event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);
        event.dispose(false);
        return event;
    };
    return PhysicsHelper;
}());
/**
 * Represents a physics radial explosion event
 */
var PhysicsRadialExplosionEvent = /** @class */ (function () {
    /**
     * Initializes a radial explosioin event
     * @param _scene BabylonJS scene
     * @param _options The options for the vortex event
     */
    function PhysicsRadialExplosionEvent(_scene, _options) {
        this._scene = _scene;
        this._options = _options;
        this._dataFetched = false; // check if the data has been fetched. If not, do cleanup
        this._options = __assign({}, (new PhysicsRadialExplosionEventOptions()), this._options);
    }
    /**
     * Returns the data related to the radial explosion event (sphere).
     * @returns The radial explosion event data
     */
    PhysicsRadialExplosionEvent.prototype.getData = function () {
        this._dataFetched = true;
        return {
            sphere: this._sphere,
        };
    };
    /**
     * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.
     * @param impostor A physics imposter
     * @param origin the origin of the explosion
     * @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null
     */
    PhysicsRadialExplosionEvent.prototype.getImpostorHitData = function (impostor, origin) {
        if (impostor.mass === 0) {
            return null;
        }
        if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {
            return null;
        }
        if (impostor.object.getClassName() !== 'Mesh' && impostor.object.getClassName() !== 'InstancedMesh') {
            return null;
        }
        var impostorObjectCenter = impostor.getObjectCenter();
        var direction = impostorObjectCenter.subtract(origin);
        var ray = new Ray(origin, direction, this._options.radius);
        var hit = ray.intersectsMesh(impostor.object);
        var contactPoint = hit.pickedPoint;
        if (!contactPoint) {
            return null;
        }
        var distanceFromOrigin = Vector3.Distance(origin, contactPoint);
        if (distanceFromOrigin > this._options.radius) {
            return null;
        }
        var multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant
            ? this._options.strength
            : this._options.strength * (1 - (distanceFromOrigin / this._options.radius));
        var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);
        return { force: force, contactPoint: contactPoint, distanceFromOrigin: distanceFromOrigin };
    };
    /**
     * Triggers affecterd impostors callbacks
     * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)
     */
    PhysicsRadialExplosionEvent.prototype.triggerAffectedImpostorsCallback = function (affectedImpostorsWithData) {
        if (this._options.affectedImpostorsCallback) {
            this._options.affectedImpostorsCallback(affectedImpostorsWithData);
        }
    };
    /**
     * Disposes the sphere.
     * @param force Specifies if the sphere should be disposed by force
     */
    PhysicsRadialExplosionEvent.prototype.dispose = function (force) {
        var _this = this;
        if (force === void 0) { force = true; }
        if (force) {
            this._sphere.dispose();
        }
        else {
            setTimeout(function () {
                if (!_this._dataFetched) {
                    _this._sphere.dispose();
                }
            }, 0);
        }
    };
    /*** Helpers ***/
    PhysicsRadialExplosionEvent.prototype._prepareSphere = function () {
        if (!this._sphere) {
            this._sphere = SphereBuilder.CreateSphere("radialExplosionEventSphere", this._options.sphere, this._scene);
            this._sphere.isVisible = false;
        }
    };
    PhysicsRadialExplosionEvent.prototype._intersectsWithSphere = function (impostor, origin, radius) {
        var impostorObject = impostor.object;
        this._prepareSphere();
        this._sphere.position = origin;
        this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);
        this._sphere._updateBoundingInfo();
        this._sphere.computeWorldMatrix(true);
        return this._sphere.intersectsMesh(impostorObject, true);
    };
    return PhysicsRadialExplosionEvent;
}());
/**
 * Represents a gravitational field event
 */
var PhysicsGravitationalFieldEvent = /** @class */ (function () {
    /**
     * Initializes the physics gravitational field event
     * @param _physicsHelper A physics helper
     * @param _scene BabylonJS scene
     * @param _origin The origin position of the gravitational field event
     * @param _options The options for the vortex event
     */
    function PhysicsGravitationalFieldEvent(_physicsHelper, _scene, _origin, _options) {
        this._physicsHelper = _physicsHelper;
        this._scene = _scene;
        this._origin = _origin;
        this._options = _options;
        this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup
        this._options = __assign({}, (new PhysicsRadialExplosionEventOptions()), this._options);
        this._tickCallback = this._tick.bind(this);
        this._options.strength = this._options.strength * -1;
    }
    /**
     * Returns the data related to the gravitational field event (sphere).
     * @returns A gravitational field event
     */
    PhysicsGravitationalFieldEvent.prototype.getData = function () {
        this._dataFetched = true;
        return {
            sphere: this._sphere,
        };
    };
    /**
     * Enables the gravitational field.
     */
    PhysicsGravitationalFieldEvent.prototype.enable = function () {
        this._tickCallback.call(this);
        this._scene.registerBeforeRender(this._tickCallback);
    };
    /**
     * Disables the gravitational field.
     */
    PhysicsGravitationalFieldEvent.prototype.disable = function () {
        this._scene.unregisterBeforeRender(this._tickCallback);
    };
    /**
     * Disposes the sphere.
     * @param force The force to dispose from the gravitational field event
     */
    PhysicsGravitationalFieldEvent.prototype.dispose = function (force) {
        var _this = this;
        if (force === void 0) { force = true; }
        if (force) {
            this._sphere.dispose();
        }
        else {
            setTimeout(function () {
                if (!_this._dataFetched) {
                    _this._sphere.dispose();
                }
            }, 0);
        }
    };
    PhysicsGravitationalFieldEvent.prototype._tick = function () {
        // Since the params won't change, we fetch the event only once
        if (this._sphere) {
            this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);
        }
        else {
            var radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);
            if (radialExplosionEvent) {
                this._sphere = radialExplosionEvent.getData().sphere.clone('radialExplosionEventSphereClone');
            }
        }
    };
    return PhysicsGravitationalFieldEvent;
}());
/**
 * Represents a physics updraft event
 */
var PhysicsUpdraftEvent = /** @class */ (function () {
    /**
     * Initializes the physics updraft event
     * @param _scene BabylonJS scene
     * @param _origin The origin position of the updraft
     * @param _options The options for the updraft event
     */
    function PhysicsUpdraftEvent(_scene, _origin, _options) {
        this._scene = _scene;
        this._origin = _origin;
        this._options = _options;
        this._originTop = Vector3.Zero(); // the most upper part of the cylinder
        this._originDirection = Vector3.Zero(); // used if the updraftMode is perpendicular
        this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom
        this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup
        this._physicsEngine = this._scene.getPhysicsEngine();
        this._options = __assign({}, (new PhysicsUpdraftEventOptions()), this._options);
        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);
        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);
        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {
            this._originDirection = this._origin.subtract(this._originTop).normalize();
        }
        this._tickCallback = this._tick.bind(this);
        this._prepareCylinder();
    }
    /**
     * Returns the data related to the updraft event (cylinder).
     * @returns A physics updraft event
     */
    PhysicsUpdraftEvent.prototype.getData = function () {
        this._dataFetched = true;
        return {
            cylinder: this._cylinder,
        };
    };
    /**
     * Enables the updraft.
     */
    PhysicsUpdraftEvent.prototype.enable = function () {
        this._tickCallback.call(this);
        this._scene.registerBeforeRender(this._tickCallback);
    };
    /**
     * Disables the updraft.
     */
    PhysicsUpdraftEvent.prototype.disable = function () {
        this._scene.unregisterBeforeRender(this._tickCallback);
    };
    /**
     * Disposes the cylinder.
     * @param force Specifies if the updraft should be disposed by force
     */
    PhysicsUpdraftEvent.prototype.dispose = function (force) {
        var _this = this;
        if (force === void 0) { force = true; }
        if (!this._cylinder) {
            return;
        }
        if (force) {
            this._cylinder.dispose();
        }
        else {
            setTimeout(function () {
                if (!_this._dataFetched) {
                    _this._cylinder.dispose();
                }
            }, 0);
        }
    };
    PhysicsUpdraftEvent.prototype.getImpostorHitData = function (impostor) {
        if (impostor.mass === 0) {
            return null;
        }
        if (!this._intersectsWithCylinder(impostor)) {
            return null;
        }
        var impostorObjectCenter = impostor.getObjectCenter();
        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {
            var direction = this._originDirection;
        }
        else {
            var direction = impostorObjectCenter.subtract(this._originTop);
        }
        var distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);
        var multiplier = this._options.strength * -1;
        var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);
        return { force: force, contactPoint: impostorObjectCenter, distanceFromOrigin: distanceFromOrigin };
    };
    PhysicsUpdraftEvent.prototype._tick = function () {
        var _this = this;
        this._physicsEngine.getImpostors().forEach(function (impostor) {
            var impostorHitData = _this.getImpostorHitData(impostor);
            if (!impostorHitData) {
                return;
            }
            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);
        });
    };
    /*** Helpers ***/
    PhysicsUpdraftEvent.prototype._prepareCylinder = function () {
        if (!this._cylinder) {
            this._cylinder = CylinderBuilder.CreateCylinder("updraftEventCylinder", {
                height: this._options.height,
                diameter: this._options.radius * 2,
            }, this._scene);
            this._cylinder.isVisible = false;
        }
    };
    PhysicsUpdraftEvent.prototype._intersectsWithCylinder = function (impostor) {
        var impostorObject = impostor.object;
        this._cylinder.position = this._cylinderPosition;
        return this._cylinder.intersectsMesh(impostorObject, true);
    };
    return PhysicsUpdraftEvent;
}());
/**
 * Represents a physics vortex event
 */
var PhysicsVortexEvent = /** @class */ (function () {
    /**
     * Initializes the physics vortex event
     * @param _scene The BabylonJS scene
     * @param _origin The origin position of the vortex
     * @param _options The options for the vortex event
     */
    function PhysicsVortexEvent(_scene, _origin, _options) {
        this._scene = _scene;
        this._origin = _origin;
        this._options = _options;
        this._originTop = Vector3.Zero(); // the most upper part of the cylinder
        this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom
        this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup
        this._physicsEngine = this._scene.getPhysicsEngine();
        this._options = __assign({}, (new PhysicsVortexEventOptions()), this._options);
        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);
        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);
        this._tickCallback = this._tick.bind(this);
        this._prepareCylinder();
    }
    /**
     * Returns the data related to the vortex event (cylinder).
     * @returns The physics vortex event data
     */
    PhysicsVortexEvent.prototype.getData = function () {
        this._dataFetched = true;
        return {
            cylinder: this._cylinder,
        };
    };
    /**
     * Enables the vortex.
     */
    PhysicsVortexEvent.prototype.enable = function () {
        this._tickCallback.call(this);
        this._scene.registerBeforeRender(this._tickCallback);
    };
    /**
     * Disables the cortex.
     */
    PhysicsVortexEvent.prototype.disable = function () {
        this._scene.unregisterBeforeRender(this._tickCallback);
    };
    /**
     * Disposes the sphere.
     * @param force
     */
    PhysicsVortexEvent.prototype.dispose = function (force) {
        var _this = this;
        if (force === void 0) { force = true; }
        if (force) {
            this._cylinder.dispose();
        }
        else {
            setTimeout(function () {
                if (!_this._dataFetched) {
                    _this._cylinder.dispose();
                }
            }, 0);
        }
    };
    PhysicsVortexEvent.prototype.getImpostorHitData = function (impostor) {
        if (impostor.mass === 0) {
            return null;
        }
        if (!this._intersectsWithCylinder(impostor)) {
            return null;
        }
        if (impostor.object.getClassName() !== 'Mesh' && impostor.object.getClassName() !== 'InstancedMesh') {
            return null;
        }
        var impostorObjectCenter = impostor.getObjectCenter();
        var originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)
        var originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);
        var ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);
        var hit = ray.intersectsMesh(impostor.object);
        var contactPoint = hit.pickedPoint;
        if (!contactPoint) {
            return null;
        }
        var absoluteDistanceFromOrigin = hit.distance / this._options.radius;
        var directionToOrigin = contactPoint.normalize();
        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {
            directionToOrigin = directionToOrigin.negate();
        }
        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {
            var forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;
            var forceY = directionToOrigin.y * this._options.updraftForceMultiplier;
            var forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;
        }
        else {
            var perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();
            var forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;
            var forceY = this._originTop.y * this._options.updraftForceMultiplier;
            var forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;
        }
        var force = new Vector3(forceX, forceY, forceZ);
        force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);
        return { force: force, contactPoint: impostorObjectCenter, distanceFromOrigin: absoluteDistanceFromOrigin };
    };
    PhysicsVortexEvent.prototype._tick = function () {
        var _this = this;
        this._physicsEngine.getImpostors().forEach(function (impostor) {
            var impostorHitData = _this.getImpostorHitData(impostor);
            if (!impostorHitData) {
                return;
            }
            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);
        });
    };
    /*** Helpers ***/
    PhysicsVortexEvent.prototype._prepareCylinder = function () {
        if (!this._cylinder) {
            this._cylinder = CylinderBuilder.CreateCylinder("vortexEventCylinder", {
                height: this._options.height,
                diameter: this._options.radius * 2,
            }, this._scene);
            this._cylinder.isVisible = false;
        }
    };
    PhysicsVortexEvent.prototype._intersectsWithCylinder = function (impostor) {
        var impostorObject = impostor.object;
        this._cylinder.position = this._cylinderPosition;
        return this._cylinder.intersectsMesh(impostorObject, true);
    };
    return PhysicsVortexEvent;
}());
/**
 * Options fot the radial explosion event
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
 */
var PhysicsRadialExplosionEventOptions = /** @class */ (function () {
    function PhysicsRadialExplosionEventOptions() {
        /**
         * The radius of the sphere for the radial explosion.
         */
        this.radius = 5;
        /**
         * The strenth of the explosion.
         */
        this.strength = 10;
        /**
         * The strenght of the force in correspondence to the distance of the affected object
         */
        this.falloff = PhysicsRadialImpulseFalloff.Constant;
        /**
         * Sphere options for the radial explosion.
         */
        this.sphere = { segments: 32, diameter: 1 };
    }
    return PhysicsRadialExplosionEventOptions;
}());
/**
 * Options fot the updraft event
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
 */
var PhysicsUpdraftEventOptions = /** @class */ (function () {
    function PhysicsUpdraftEventOptions() {
        /**
         * The radius of the cylinder for the vortex
         */
        this.radius = 5;
        /**
         * The strenth of the updraft.
         */
        this.strength = 10;
        /**
         * The height of the cylinder for the updraft.
         */
        this.height = 10;
        /**
         * The mode for the the updraft.
         */
        this.updraftMode = PhysicsUpdraftMode.Center;
    }
    return PhysicsUpdraftEventOptions;
}());
/**
 * Options fot the vortex event
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
 */
var PhysicsVortexEventOptions = /** @class */ (function () {
    function PhysicsVortexEventOptions() {
        /**
         * The radius of the cylinder for the vortex
         */
        this.radius = 5;
        /**
         * The strenth of the vortex.
         */
        this.strength = 10;
        /**
         * The height of the cylinder for the vortex.
         */
        this.height = 10;
        /**
         * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1
         */
        this.centripetalForceThreshold = 0.7;
        /**
         * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the treshold.
         */
        this.centripetalForceMultiplier = 5;
        /**
         * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the treshold.
         */
        this.centrifugalForceMultiplier = 0.5;
        /**
         * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.
         */
        this.updraftForceMultiplier = 0.02;
    }
    return PhysicsVortexEventOptions;
}());
/**
* The strenght of the force in correspondence to the distance of the affected object
* @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
*/
var PhysicsRadialImpulseFalloff;
(function (PhysicsRadialImpulseFalloff) {
    /** Defines that impulse is constant in strength across it's whole radius */
    PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff["Constant"] = 0] = "Constant";
    /** Defines that impulse gets weaker if it's further from the origin */
    PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff["Linear"] = 1] = "Linear";
})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));
/**
 * The strength of the force in correspondence to the distance of the affected object
 * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
 */
var PhysicsUpdraftMode;
(function (PhysicsUpdraftMode) {
    /** Defines that the upstream forces will pull towards the top center of the cylinder */
    PhysicsUpdraftMode[PhysicsUpdraftMode["Center"] = 0] = "Center";
    /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */
    PhysicsUpdraftMode[PhysicsUpdraftMode["Perpendicular"] = 1] = "Perpendicular";
})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));

var name$D = 'blackAndWhitePixelShader';
var shader$D = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform float degree;\nvoid main(void)\n{\nvec3 color=texture2D(textureSampler,vUV).rgb;\nfloat luminance=dot(color,vec3(0.3,0.59,0.11));\nvec3 blackAndWhite=vec3(luminance,luminance,luminance);\ngl_FragColor=vec4(color-((color-blackAndWhite)*degree),1.0);\n}";
Effect.ShadersStore[name$D] = shader$D;

/**
 * Post process used to render in black and white
 */
var BlackAndWhitePostProcess = /** @class */ (function (_super) {
    __extends(BlackAndWhitePostProcess, _super);
    /**
     * Creates a black and white post process
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#black-and-white
     * @param name The name of the effect.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     */
    function BlackAndWhitePostProcess(name, options, camera, samplingMode, engine, reusable) {
        var _this = _super.call(this, name, "blackAndWhite", ["degree"], null, options, camera, samplingMode, engine, reusable) || this;
        /**
         * Linear about to convert he result to black and white (default: 1)
         */
        _this.degree = 1;
        _this.onApplyObservable.add(function (effect) {
            effect.setFloat("degree", _this.degree);
        });
        return _this;
    }
    return BlackAndWhitePostProcess;
}(PostProcess));

/**
 * This represents a set of one or more post processes in Babylon.
 * A post process can be used to apply a shader to a texture after it is rendered.
 * @example https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
 */
var PostProcessRenderEffect = /** @class */ (function () {
    /**
     * Instantiates a post process render effect.
     * A post process can be used to apply a shader to a texture after it is rendered.
     * @param engine The engine the effect is tied to
     * @param name The name of the effect
     * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.
     * @param singleInstance False if this post process can be run on multiple cameras. (default: true)
     */
    function PostProcessRenderEffect(engine, name, getPostProcesses, singleInstance) {
        this._name = name;
        this._singleInstance = singleInstance || true;
        this._getPostProcesses = getPostProcesses;
        this._cameras = {};
        this._indicesForCamera = {};
        this._postProcesses = {};
    }
    Object.defineProperty(PostProcessRenderEffect.prototype, "isSupported", {
        /**
         * Checks if all the post processes in the effect are supported.
         */
        get: function () {
            for (var index in this._postProcesses) {
                if (this._postProcesses.hasOwnProperty(index)) {
                    var pps = this._postProcesses[index];
                    for (var ppIndex = 0; ppIndex < pps.length; ppIndex++) {
                        if (!pps[ppIndex].isSupported) {
                            return false;
                        }
                    }
                }
            }
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the current state of the effect
     * @hidden
     */
    PostProcessRenderEffect.prototype._update = function () {
    };
    /**
     * Attaches the effect on cameras
     * @param cameras The camera to attach to.
     * @hidden
     */
    PostProcessRenderEffect.prototype._attachCameras = function (cameras) {
        var _this = this;
        var cameraKey;
        var cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
            return;
        }
        for (var i = 0; i < cams.length; i++) {
            var camera = cams[i];
            var cameraName = camera.name;
            if (this._singleInstance) {
                cameraKey = 0;
            }
            else {
                cameraKey = cameraName;
            }
            if (!this._postProcesses[cameraKey]) {
                var postProcess = this._getPostProcesses();
                if (postProcess) {
                    this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];
                }
            }
            if (!this._indicesForCamera[cameraName]) {
                this._indicesForCamera[cameraName] = [];
            }
            this._postProcesses[cameraKey].forEach(function (postProcess) {
                var index = camera.attachPostProcess(postProcess);
                _this._indicesForCamera[cameraName].push(index);
            });
            if (!this._cameras[cameraName]) {
                this._cameras[cameraName] = camera;
            }
        }
    };
    /**
     * Detatches the effect on cameras
     * @param cameras The camera to detatch from.
     * @hidden
     */
    PostProcessRenderEffect.prototype._detachCameras = function (cameras) {
        var cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
            return;
        }
        for (var i = 0; i < cams.length; i++) {
            var camera = cams[i];
            var cameraName = camera.name;
            var postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];
            if (postProcesses) {
                postProcesses.forEach(function (postProcess) {
                    camera.detachPostProcess(postProcess);
                });
            }
            if (this._cameras[cameraName]) {
                this._cameras[cameraName] = null;
            }
        }
    };
    /**
     * Enables the effect on given cameras
     * @param cameras The camera to enable.
     * @hidden
     */
    PostProcessRenderEffect.prototype._enable = function (cameras) {
        var _this = this;
        var cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
            return;
        }
        for (var i = 0; i < cams.length; i++) {
            var camera = cams[i];
            var cameraName = camera.name;
            for (var j = 0; j < this._indicesForCamera[cameraName].length; j++) {
                if (camera._postProcesses[this._indicesForCamera[cameraName][j]] === undefined || camera._postProcesses[this._indicesForCamera[cameraName][j]] === null) {
                    this._postProcesses[this._singleInstance ? 0 : cameraName].forEach(function (postProcess) {
                        cams[i].attachPostProcess(postProcess, _this._indicesForCamera[cameraName][j]);
                    });
                }
            }
        }
    };
    /**
     * Disables the effect on the given cameras
     * @param cameras The camera to disable.
     * @hidden
     */
    PostProcessRenderEffect.prototype._disable = function (cameras) {
        var cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
            return;
        }
        for (var i = 0; i < cams.length; i++) {
            var camera = cams[i];
            var cameraName = camera.name;
            this._postProcesses[this._singleInstance ? 0 : cameraName].forEach(function (postProcess) {
                camera.detachPostProcess(postProcess);
            });
        }
    };
    /**
     * Gets a list of the post processes contained in the effect.
     * @param camera The camera to get the post processes on.
     * @returns The list of the post processes in the effect.
     */
    PostProcessRenderEffect.prototype.getPostProcesses = function (camera) {
        if (this._singleInstance) {
            return this._postProcesses[0];
        }
        else {
            if (!camera) {
                return null;
            }
            return this._postProcesses[camera.name];
        }
    };
    return PostProcessRenderEffect;
}());

var name$E = 'extractHighlightsPixelShader';
var shader$E = "#include<helperFunctions>\n\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform float threshold;\nuniform float exposure;\nvoid main(void)\n{\ngl_FragColor=texture2D(textureSampler,vUV);\nfloat luma=getLuminance(gl_FragColor.rgb*exposure);\ngl_FragColor.rgb=step(threshold,luma)*gl_FragColor.rgb;\n}";
Effect.ShadersStore[name$E] = shader$E;

/**
 * The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
 */
var ExtractHighlightsPostProcess = /** @class */ (function (_super) {
    __extends(ExtractHighlightsPostProcess, _super);
    function ExtractHighlightsPostProcess(name, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "extractHighlights", ["threshold", "exposure"], null, options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, blockCompilation) || this;
        /**
         * The luminance threshold, pixels below this value will be set to black.
         */
        _this.threshold = 0.9;
        /** @hidden */
        _this._exposure = 1;
        /**
         * Post process which has the input texture to be used when performing highlight extraction
         * @hidden
         */
        _this._inputPostProcess = null;
        _this.onApplyObservable.add(function (effect) {
            if (_this._inputPostProcess) {
                effect.setTextureFromPostProcess("textureSampler", _this._inputPostProcess);
            }
            effect.setFloat('threshold', Math.pow(_this.threshold, ToGammaSpace));
            effect.setFloat('exposure', _this._exposure);
        });
        return _this;
    }
    return ExtractHighlightsPostProcess;
}(PostProcess));

var name$F = 'bloomMergePixelShader';
var shader$F = "uniform sampler2D textureSampler;\nuniform sampler2D bloomBlur;\nvarying vec2 vUV;\nuniform float bloomWeight;\nvoid main(void)\n{\ngl_FragColor=texture2D(textureSampler,vUV);\nvec3 blurred=texture2D(bloomBlur,vUV).rgb;\ngl_FragColor.rgb=gl_FragColor.rgb+(blurred.rgb*bloomWeight);\n}\n";
Effect.ShadersStore[name$F] = shader$F;

/**
 * The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
 */
var BloomMergePostProcess = /** @class */ (function (_super) {
    __extends(BloomMergePostProcess, _super);
    /**
     * Creates a new instance of @see BloomMergePostProcess
     * @param name The name of the effect.
     * @param originalFromInput Post process which's input will be used for the merge.
     * @param blurred Blurred highlights post process which's output will be used.
     * @param weight Weight of the bloom to be added to the original input.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function BloomMergePostProcess(name, originalFromInput, blurred, 
    /** Weight of the bloom to be added to the original input. */
    weight, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "bloomMerge", ["bloomWeight"], ["circleOfConfusionSampler", "blurStep0", "blurStep1", "blurStep2", "bloomBlur"], options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, true) || this;
        _this.weight = weight;
        _this.onApplyObservable.add(function (effect) {
            effect.setTextureFromPostProcess("textureSampler", originalFromInput);
            effect.setTextureFromPostProcessOutput("bloomBlur", blurred);
            effect.setFloat("bloomWeight", _this.weight);
        });
        if (!blockCompilation) {
            _this.updateEffect();
        }
        return _this;
    }
    return BloomMergePostProcess;
}(PostProcess));

/**
 * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras
 */
var BloomEffect = /** @class */ (function (_super) {
    __extends(BloomEffect, _super);
    /**
     * Creates a new instance of @see BloomEffect
     * @param scene The scene the effect belongs to.
     * @param bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.
     * @param bloomKernel The size of the kernel to be used when applying the blur.
     * @param bloomWeight The the strength of bloom.
     * @param pipelineTextureType The type of texture to be used when performing the post processing.
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function BloomEffect(scene, bloomScale, bloomWeight, bloomKernel, pipelineTextureType, blockCompilation) {
        if (pipelineTextureType === void 0) { pipelineTextureType = 0; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, scene.getEngine(), "bloom", function () {
            return _this._effects;
        }, true) || this;
        _this.bloomScale = bloomScale;
        /**
         * @hidden Internal
         */
        _this._effects = [];
        _this._downscale = new ExtractHighlightsPostProcess("highlights", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
        _this._blurX = new BlurPostProcess("horizontal blur", new Vector2(1.0, 0), 10.0, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);
        _this._blurX.alwaysForcePOT = true;
        _this._blurX.autoClear = false;
        _this._blurY = new BlurPostProcess("vertical blur", new Vector2(0, 1.0), 10.0, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);
        _this._blurY.alwaysForcePOT = true;
        _this._blurY.autoClear = false;
        _this.kernel = bloomKernel;
        _this._effects = [_this._downscale, _this._blurX, _this._blurY];
        _this._merge = new BloomMergePostProcess("bloomMerge", _this._downscale, _this._blurY, bloomWeight, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
        _this._merge.autoClear = false;
        _this._effects.push(_this._merge);
        return _this;
    }
    Object.defineProperty(BloomEffect.prototype, "threshold", {
        /**
         * The luminance threshold to find bright areas of the image to bloom.
         */
        get: function () {
            return this._downscale.threshold;
        },
        set: function (value) {
            this._downscale.threshold = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BloomEffect.prototype, "weight", {
        /**
         * The strength of the bloom.
         */
        get: function () {
            return this._merge.weight;
        },
        set: function (value) {
            this._merge.weight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BloomEffect.prototype, "kernel", {
        /**
         * Specifies the size of the bloom blur kernel, relative to the final output size
         */
        get: function () {
            return this._blurX.kernel / this.bloomScale;
        },
        set: function (value) {
            this._blurX.kernel = value * this.bloomScale;
            this._blurY.kernel = value * this.bloomScale;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes each of the internal effects for a given camera.
     * @param camera The camera to dispose the effect on.
     */
    BloomEffect.prototype.disposeEffects = function (camera) {
        for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
            this._effects[effectIndex].dispose(camera);
        }
    };
    /**
     * @hidden Internal
     */
    BloomEffect.prototype._updateEffects = function () {
        for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
            this._effects[effectIndex].updateEffect();
        }
    };
    /**
     * Internal
     * @returns if all the contained post processes are ready.
     * @hidden
     */
    BloomEffect.prototype._isReady = function () {
        for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
            if (!this._effects[effectIndex].isReady()) {
                return false;
            }
        }
        return true;
    };
    return BloomEffect;
}(PostProcessRenderEffect));

var name$G = 'chromaticAberrationPixelShader';
var shader$G = "\nuniform sampler2D textureSampler;\n\nuniform float chromatic_aberration;\nuniform float radialIntensity;\nuniform vec2 direction;\nuniform vec2 centerPosition;\nuniform float screen_width;\nuniform float screen_height;\n\nvarying vec2 vUV;\nvoid main(void)\n{\nvec2 centered_screen_pos=vec2(vUV.x-centerPosition.x,vUV.y-centerPosition.y);\nvec2 directionOfEffect=direction;\nif(directionOfEffect.x == 0. && directionOfEffect.y == 0.){\ndirectionOfEffect=normalize(centered_screen_pos);\n}\nfloat radius2=centered_screen_pos.x*centered_screen_pos.x\n+centered_screen_pos.y*centered_screen_pos.y;\nfloat radius=sqrt(radius2);\nvec4 original=texture2D(textureSampler,vUV);\n\nvec3 ref_indices=vec3(-0.3,0.0,0.3);\nfloat ref_shiftX=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.x/screen_width;\nfloat ref_shiftY=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.y/screen_height;\n\nvec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);\nvec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);\nvec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);\noriginal.r=texture2D(textureSampler,ref_coords_r).r;\noriginal.g=texture2D(textureSampler,ref_coords_g).g;\noriginal.b=texture2D(textureSampler,ref_coords_b).b;\noriginal.a=clamp(texture2D(textureSampler,ref_coords_r).a+texture2D(textureSampler,ref_coords_g).a+texture2D(textureSampler,ref_coords_b).a,0.,1.);\ngl_FragColor=original;\n}";
Effect.ShadersStore[name$G] = shader$G;

/**
 * The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
 */
var ChromaticAberrationPostProcess = /** @class */ (function (_super) {
    __extends(ChromaticAberrationPostProcess, _super);
    /**
     * Creates a new instance ChromaticAberrationPostProcess
     * @param name The name of the effect.
     * @param screenWidth The width of the screen to apply the effect on.
     * @param screenHeight The height of the screen to apply the effect on.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function ChromaticAberrationPostProcess(name, screenWidth, screenHeight, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "chromaticAberration", ["chromatic_aberration", "screen_width", "screen_height", "direction", "radialIntensity", "centerPosition"], [], options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, blockCompilation) || this;
        /**
         * The amount of seperation of rgb channels (default: 30)
         */
        _this.aberrationAmount = 30;
        /**
         * The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)
         */
        _this.radialIntensity = 0;
        /**
         * The normilized direction in which the rgb channels should be seperated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))
         */
        _this.direction = new Vector2(0.707, 0.707);
        /**
         * The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corder] (default: Vector2(0.5 ,0.5))
         */
        _this.centerPosition = new Vector2(0.5, 0.5);
        _this.onApplyObservable.add(function (effect) {
            effect.setFloat('chromatic_aberration', _this.aberrationAmount);
            effect.setFloat('screen_width', screenWidth);
            effect.setFloat('screen_height', screenHeight);
            effect.setFloat('radialIntensity', _this.radialIntensity);
            effect.setFloat2('direction', _this.direction.x, _this.direction.y);
            effect.setFloat2('centerPosition', _this.centerPosition.x, _this.centerPosition.y);
        });
        return _this;
    }
    return ChromaticAberrationPostProcess;
}(PostProcess));

var name$H = 'circleOfConfusionPixelShader';
var shader$H = "\nuniform sampler2D depthSampler;\n\nvarying vec2 vUV;\n\nuniform vec2 cameraMinMaxZ;\n\nuniform float focusDistance;\nuniform float cocPrecalculation;\nvoid main(void)\n{\nfloat depth=texture2D(depthSampler,vUV).r;\nfloat pixelDistance=(cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth)*1000.0;\nfloat coc=abs(cocPrecalculation* ((focusDistance-pixelDistance)/pixelDistance));\ncoc=clamp(coc,0.0,1.0);\ngl_FragColor=vec4(coc,depth,coc,1.0);\n}\n";
Effect.ShadersStore[name$H] = shader$H;

/**
 * The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
 */
var CircleOfConfusionPostProcess = /** @class */ (function (_super) {
    __extends(CircleOfConfusionPostProcess, _super);
    /**
     * Creates a new instance CircleOfConfusionPostProcess
     * @param name The name of the effect.
     * @param depthTexture The depth texture of the scene to compute the circle of confusion. This must be set in order for this to function but may be set after initialization if needed.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function CircleOfConfusionPostProcess(name, depthTexture, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "circleOfConfusion", ["cameraMinMaxZ", "focusDistance", "cocPrecalculation"], ["depthSampler"], options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, blockCompilation) || this;
        /**
         * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
         */
        _this.lensSize = 50;
        /**
         * F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
         */
        _this.fStop = 1.4;
        /**
         * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
         */
        _this.focusDistance = 2000;
        /**
         * Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)
         */
        _this.focalLength = 50;
        _this._depthTexture = null;
        _this._depthTexture = depthTexture;
        _this.onApplyObservable.add(function (effect) {
            if (!_this._depthTexture) {
                Logger.Warn("No depth texture set on CircleOfConfusionPostProcess");
                return;
            }
            effect.setTexture("depthSampler", _this._depthTexture);
            // Circle of confusion calculation, See https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch23.html
            var aperture = _this.lensSize / _this.fStop;
            var cocPrecalculation = ((aperture * _this.focalLength) / ((_this.focusDistance - _this.focalLength))); // * ((this.focusDistance - pixelDistance)/pixelDistance) [This part is done in shader]
            effect.setFloat('focusDistance', _this.focusDistance);
            effect.setFloat('cocPrecalculation', cocPrecalculation);
            effect.setFloat2('cameraMinMaxZ', _this._depthTexture.activeCamera.minZ, _this._depthTexture.activeCamera.maxZ);
        });
        return _this;
    }
    Object.defineProperty(CircleOfConfusionPostProcess.prototype, "depthTexture", {
        /**
         * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
         */
        set: function (value) {
            this._depthTexture = value;
        },
        enumerable: true,
        configurable: true
    });
    return CircleOfConfusionPostProcess;
}(PostProcess));

var name$I = 'colorCorrectionPixelShader';
var shader$I = "\nuniform sampler2D textureSampler;\nuniform sampler2D colorTable;\n\nvarying vec2 vUV;\n\nconst float SLICE_COUNT=16.0;\n\nvec4 sampleAs3DTexture(sampler2D textureSampler,vec3 uv,float width) {\nfloat sliceSize=1.0/width;\nfloat slicePixelSize=sliceSize/width;\nfloat sliceInnerSize=slicePixelSize*(width-1.0);\nfloat zSlice0=min(floor(uv.z*width),width-1.0);\nfloat zSlice1=min(zSlice0+1.0,width-1.0);\nfloat xOffset=slicePixelSize*0.5+uv.x*sliceInnerSize;\nfloat s0=xOffset+(zSlice0*sliceSize);\nfloat s1=xOffset+(zSlice1*sliceSize);\nvec4 slice0Color=texture2D(textureSampler,vec2(s0,uv.y));\nvec4 slice1Color=texture2D(textureSampler,vec2(s1,uv.y));\nfloat zOffset=mod(uv.z*width,1.0);\nvec4 result=mix(slice0Color,slice1Color,zOffset);\nreturn result;\n}\nvoid main(void)\n{\nvec4 screen_color=texture2D(textureSampler,vUV);\ngl_FragColor=sampleAs3DTexture(colorTable,screen_color.rgb,SLICE_COUNT);\n}";
Effect.ShadersStore[name$I] = shader$I;

/**
 *
 * This post-process allows the modification of rendered colors by using
 * a 'look-up table' (LUT). This effect is also called Color Grading.
 *
 * The object needs to be provided an url to a texture containing the color
 * look-up table: the texture must be 256 pixels wide and 16 pixels high.
 * Use an image editing software to tweak the LUT to match your needs.
 *
 * For an example of a color LUT, see here:
 * @see http://udn.epicgames.com/Three/rsrc/Three/ColorGrading/RGBTable16x1.png
 * For explanations on color grading, see here:
 * @see http://udn.epicgames.com/Three/ColorGrading.html
 *
 */
var ColorCorrectionPostProcess = /** @class */ (function (_super) {
    __extends(ColorCorrectionPostProcess, _super);
    function ColorCorrectionPostProcess(name, colorTableUrl, options, camera, samplingMode, engine, reusable) {
        var _this = _super.call(this, name, 'colorCorrection', null, ['colorTable'], options, camera, samplingMode, engine, reusable) || this;
        _this._colorTableTexture = new Texture(colorTableUrl, camera.getScene(), true, false, Texture.TRILINEAR_SAMPLINGMODE);
        _this._colorTableTexture.anisotropicFilteringLevel = 1;
        _this._colorTableTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
        _this._colorTableTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
        _this.onApply = function (effect) {
            effect.setTexture("colorTable", _this._colorTableTexture);
        };
        return _this;
    }
    return ColorCorrectionPostProcess;
}(PostProcess));

var name$J = 'convolutionPixelShader';
var shader$J = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 screenSize;\nuniform float kernel[9];\nvoid main(void)\n{\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\nvec4 colorSum =\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,-1))*kernel[0] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,-1))*kernel[1] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,-1))*kernel[2] +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0))*kernel[3] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,0))*kernel[4] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0))*kernel[5] +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,1))*kernel[6] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1))*kernel[7] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,1))*kernel[8];\nfloat kernelWeight =\nkernel[0] +\nkernel[1] +\nkernel[2] +\nkernel[3] +\nkernel[4] +\nkernel[5] +\nkernel[6] +\nkernel[7] +\nkernel[8];\nif (kernelWeight<=0.0) {\nkernelWeight=1.0;\n}\ngl_FragColor=vec4((colorSum/kernelWeight).rgb,1);\n}";
Effect.ShadersStore[name$J] = shader$J;

/**
 * The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
 * input texture to perform effects such as edge detection or sharpening
 * See http://en.wikipedia.org/wiki/Kernel_(image_processing)
 */
var ConvolutionPostProcess = /** @class */ (function (_super) {
    __extends(ConvolutionPostProcess, _super);
    /**
     * Creates a new instance ConvolutionPostProcess
     * @param name The name of the effect.
     * @param kernel Array of 9 values corrisponding to the 3x3 kernel to be applied
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     */
    function ConvolutionPostProcess(name, 
    /** Array of 9 values corrisponding to the 3x3 kernel to be applied */
    kernel, options, camera, samplingMode, engine, reusable, textureType) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        var _this = _super.call(this, name, "convolution", ["kernel", "screenSize"], null, options, camera, samplingMode, engine, reusable, null, textureType) || this;
        _this.kernel = kernel;
        _this.onApply = function (effect) {
            effect.setFloat2("screenSize", _this.width, _this.height);
            effect.setArray("kernel", _this.kernel);
        };
        return _this;
    }
    // Statics
    /**
     * Edge detection 0 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    ConvolutionPostProcess.EdgeDetect0Kernel = [1, 0, -1, 0, 0, 0, -1, 0, 1];
    /**
     * Edge detection 1 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    ConvolutionPostProcess.EdgeDetect1Kernel = [0, 1, 0, 1, -4, 1, 0, 1, 0];
    /**
     * Edge detection 2 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    ConvolutionPostProcess.EdgeDetect2Kernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1];
    /**
     * Kernel to sharpen an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    ConvolutionPostProcess.SharpenKernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
    /**
     * Kernel to emboss an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    ConvolutionPostProcess.EmbossKernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2];
    /**
     * Kernel to blur an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    ConvolutionPostProcess.GaussianKernel = [0, 1, 0, 1, 1, 1, 0, 1, 0];
    return ConvolutionPostProcess;
}(PostProcess));

/**
 * The DepthOfFieldBlurPostProcess applied a blur in a give direction.
 * This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
 * based on samples that have a large difference in distance than the center pixel.
 * See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
 */
var DepthOfFieldBlurPostProcess = /** @class */ (function (_super) {
    __extends(DepthOfFieldBlurPostProcess, _super);
    /**
     * Creates a new instance CircleOfConfusionPostProcess
     * @param name The name of the effect.
     * @param scene The scene the effect belongs to.
     * @param direction The direction the blur should be applied.
     * @param kernel The size of the kernel used to blur.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param circleOfConfusion The circle of confusion + depth map to be used to avoid blurring accross edges
     * @param imageToBlur The image to apply the blur to (default: Current rendered frame)
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function DepthOfFieldBlurPostProcess(name, scene, direction, kernel, options, camera, circleOfConfusion, imageToBlur, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (imageToBlur === void 0) { imageToBlur = null; }
        if (samplingMode === void 0) { samplingMode = Texture.BILINEAR_SAMPLINGMODE; }
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, direction, kernel, options, camera, samplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE, engine, reusable, textureType = Constants.TEXTURETYPE_UNSIGNED_INT, "#define DOF 1\r\n", blockCompilation) || this;
        _this.direction = direction;
        _this.onApplyObservable.add(function (effect) {
            if (imageToBlur != null) {
                effect.setTextureFromPostProcess("textureSampler", imageToBlur);
            }
            effect.setTextureFromPostProcessOutput("circleOfConfusionSampler", circleOfConfusion);
            if (scene.activeCamera) {
                effect.setFloat2('cameraMinMaxZ', scene.activeCamera.minZ, scene.activeCamera.maxZ);
            }
        });
        return _this;
    }
    return DepthOfFieldBlurPostProcess;
}(BlurPostProcess));

var name$K = 'depthOfFieldMergePixelShader';
var shader$K = "uniform sampler2D textureSampler;\nvarying vec2 vUV;\nuniform sampler2D circleOfConfusionSampler;\nuniform sampler2D blurStep0;\n#if BLUR_LEVEL>0\nuniform sampler2D blurStep1;\n#endif\n#if BLUR_LEVEL>1\nuniform sampler2D blurStep2;\n#endif\nvoid main(void)\n{\nfloat coc=texture2D(circleOfConfusionSampler,vUV).r;\n#if BLUR_LEVEL == 0\nvec4 original=texture2D(textureSampler,vUV);\nvec4 blurred0=texture2D(blurStep0,vUV);\ngl_FragColor=mix(original,blurred0,coc);\n#endif\n#if BLUR_LEVEL == 1\nif(coc<0.5){\nvec4 original=texture2D(textureSampler,vUV);\nvec4 blurred1=texture2D(blurStep1,vUV);\ngl_FragColor=mix(original,blurred1,coc/0.5);\n}else{\nvec4 blurred0=texture2D(blurStep0,vUV);\nvec4 blurred1=texture2D(blurStep1,vUV);\ngl_FragColor=mix(blurred1,blurred0,(coc-0.5)/0.5);\n}\n#endif\n#if BLUR_LEVEL == 2\nif(coc<0.33){\nvec4 original=texture2D(textureSampler,vUV);\nvec4 blurred2=texture2D(blurStep2,vUV);\ngl_FragColor=mix(original,blurred2,coc/0.33);\n}else if(coc<0.66){\nvec4 blurred1=texture2D(blurStep1,vUV);\nvec4 blurred2=texture2D(blurStep2,vUV);\ngl_FragColor=mix(blurred2,blurred1,(coc-0.33)/0.33);\n}else{\nvec4 blurred0=texture2D(blurStep0,vUV);\nvec4 blurred1=texture2D(blurStep1,vUV);\ngl_FragColor=mix(blurred1,blurred0,(coc-0.66)/0.34);\n}\n#endif\n}\n";
Effect.ShadersStore[name$K] = shader$K;

/**
 * Options to be set when merging outputs from the default pipeline.
 */
var DepthOfFieldMergePostProcessOptions = /** @class */ (function () {
    function DepthOfFieldMergePostProcessOptions() {
    }
    return DepthOfFieldMergePostProcessOptions;
}());
/**
 * The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
 */
var DepthOfFieldMergePostProcess = /** @class */ (function (_super) {
    __extends(DepthOfFieldMergePostProcess, _super);
    /**
     * Creates a new instance of DepthOfFieldMergePostProcess
     * @param name The name of the effect.
     * @param originalFromInput Post process which's input will be used for the merge.
     * @param circleOfConfusion Circle of confusion post process which's output will be used to blur each pixel.
     * @param blurSteps Blur post processes from low to high which will be mixed with the original image.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function DepthOfFieldMergePostProcess(name, originalFromInput, circleOfConfusion, blurSteps, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "depthOfFieldMerge", [], ["circleOfConfusionSampler", "blurStep0", "blurStep1", "blurStep2"], options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, true) || this;
        _this.blurSteps = blurSteps;
        _this.onApplyObservable.add(function (effect) {
            effect.setTextureFromPostProcess("textureSampler", originalFromInput);
            effect.setTextureFromPostProcessOutput("circleOfConfusionSampler", circleOfConfusion);
            blurSteps.forEach(function (step, index) {
                effect.setTextureFromPostProcessOutput("blurStep" + (blurSteps.length - index - 1), step);
            });
        });
        if (!blockCompilation) {
            _this.updateEffect();
        }
        return _this;
    }
    /**
     * Updates the effect with the current post process compile time values and recompiles the shader.
     * @param defines Define statements that should be added at the beginning of the shader. (default: null)
     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
     * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
     * @param onCompiled Called when the shader has been compiled.
     * @param onError Called if there is an error when compiling a shader.
     */
    DepthOfFieldMergePostProcess.prototype.updateEffect = function (defines, uniforms, samplers, indexParameters, onCompiled, onError) {
        if (defines === void 0) { defines = null; }
        if (uniforms === void 0) { uniforms = null; }
        if (samplers === void 0) { samplers = null; }
        if (!defines) {
            defines = "";
            defines += "#define BLUR_LEVEL " + (this.blurSteps.length - 1) + "\n";
        }
        _super.prototype.updateEffect.call(this, defines, uniforms, samplers, indexParameters, onCompiled, onError);
    };
    return DepthOfFieldMergePostProcess;
}(PostProcess));

/**
 * Specifies the level of max blur that should be applied when using the depth of field effect
 */
var DepthOfFieldEffectBlurLevel;
(function (DepthOfFieldEffectBlurLevel) {
    /**
     * Subtle blur
     */
    DepthOfFieldEffectBlurLevel[DepthOfFieldEffectBlurLevel["Low"] = 0] = "Low";
    /**
     * Medium blur
     */
    DepthOfFieldEffectBlurLevel[DepthOfFieldEffectBlurLevel["Medium"] = 1] = "Medium";
    /**
     * Large blur
     */
    DepthOfFieldEffectBlurLevel[DepthOfFieldEffectBlurLevel["High"] = 2] = "High";
})(DepthOfFieldEffectBlurLevel || (DepthOfFieldEffectBlurLevel = {}));
/**
 * The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.
 */
var DepthOfFieldEffect = /** @class */ (function (_super) {
    __extends(DepthOfFieldEffect, _super);
    /**
     * Creates a new instance DepthOfFieldEffect
     * @param scene The scene the effect belongs to.
     * @param depthTexture The depth texture of the scene to compute the circle of confusion.This must be set in order for this to function but may be set after initialization if needed.
     * @param pipelineTextureType The type of texture to be used when performing the post processing.
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function DepthOfFieldEffect(scene, depthTexture, blurLevel, pipelineTextureType, blockCompilation) {
        if (blurLevel === void 0) { blurLevel = DepthOfFieldEffectBlurLevel.Low; }
        if (pipelineTextureType === void 0) { pipelineTextureType = 0; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, scene.getEngine(), "depth of field", function () {
            return _this._effects;
        }, true) || this;
        /**
         * @hidden Internal post processes in depth of field effect
         */
        _this._effects = [];
        // Circle of confusion value for each pixel is used to determine how much to blur that pixel
        _this._circleOfConfusion = new CircleOfConfusionPostProcess("circleOfConfusion", depthTexture, 1, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
        // Create a pyramid of blurred images (eg. fullSize 1/4 blur, half size 1/2 blur, quarter size 3/4 blur, eith size 4/4 blur)
        // Blur the image but do not blur on sharp far to near distance changes to avoid bleeding artifacts
        // See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
        _this._depthOfFieldBlurY = [];
        _this._depthOfFieldBlurX = [];
        var blurCount = 1;
        var kernelSize = 15;
        switch (blurLevel) {
            case DepthOfFieldEffectBlurLevel.High: {
                blurCount = 3;
                kernelSize = 51;
                break;
            }
            case DepthOfFieldEffectBlurLevel.Medium: {
                blurCount = 2;
                kernelSize = 31;
                break;
            }
            default: {
                kernelSize = 15;
                blurCount = 1;
                break;
            }
        }
        var adjustedKernelSize = kernelSize / Math.pow(2, blurCount - 1);
        var ratio = 1.0;
        for (var i = 0; i < blurCount; i++) {
            var blurY = new DepthOfFieldBlurPostProcess("verticle blur", scene, new Vector2(0, 1.0), adjustedKernelSize, ratio, null, _this._circleOfConfusion, i == 0 ? _this._circleOfConfusion : null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
            blurY.autoClear = false;
            ratio = 0.75 / Math.pow(2, i);
            var blurX = new DepthOfFieldBlurPostProcess("horizontal blur", scene, new Vector2(1.0, 0), adjustedKernelSize, ratio, null, _this._circleOfConfusion, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
            blurX.autoClear = false;
            _this._depthOfFieldBlurY.push(blurY);
            _this._depthOfFieldBlurX.push(blurX);
        }
        // Set all post processes on the effect.
        _this._effects = [_this._circleOfConfusion];
        for (var i = 0; i < _this._depthOfFieldBlurX.length; i++) {
            _this._effects.push(_this._depthOfFieldBlurY[i]);
            _this._effects.push(_this._depthOfFieldBlurX[i]);
        }
        // Merge blurred images with original image based on circleOfConfusion
        _this._dofMerge = new DepthOfFieldMergePostProcess("dofMerge", _this._circleOfConfusion, _this._circleOfConfusion, _this._depthOfFieldBlurX, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);
        _this._dofMerge.autoClear = false;
        _this._effects.push(_this._dofMerge);
        return _this;
    }
    Object.defineProperty(DepthOfFieldEffect.prototype, "focalLength", {
        get: function () {
            return this._circleOfConfusion.focalLength;
        },
        /**
         * The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)
         */
        set: function (value) {
            this._circleOfConfusion.focalLength = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DepthOfFieldEffect.prototype, "fStop", {
        get: function () {
            return this._circleOfConfusion.fStop;
        },
        /**
         * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
         */
        set: function (value) {
            this._circleOfConfusion.fStop = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DepthOfFieldEffect.prototype, "focusDistance", {
        get: function () {
            return this._circleOfConfusion.focusDistance;
        },
        /**
         * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
         */
        set: function (value) {
            this._circleOfConfusion.focusDistance = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DepthOfFieldEffect.prototype, "lensSize", {
        get: function () {
            return this._circleOfConfusion.lensSize;
        },
        /**
         * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
         */
        set: function (value) {
            this._circleOfConfusion.lensSize = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Get the current class name of the current effet
    * @returns "DepthOfFieldEffect"
    */
    DepthOfFieldEffect.prototype.getClassName = function () {
        return "DepthOfFieldEffect";
    };
    Object.defineProperty(DepthOfFieldEffect.prototype, "depthTexture", {
        /**
         * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
         */
        set: function (value) {
            this._circleOfConfusion.depthTexture = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes each of the internal effects for a given camera.
     * @param camera The camera to dispose the effect on.
     */
    DepthOfFieldEffect.prototype.disposeEffects = function (camera) {
        for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
            this._effects[effectIndex].dispose(camera);
        }
    };
    /**
     * @hidden Internal
     */
    DepthOfFieldEffect.prototype._updateEffects = function () {
        for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
            this._effects[effectIndex].updateEffect();
        }
    };
    /**
     * Internal
     * @returns if all the contained post processes are ready.
     * @hidden
     */
    DepthOfFieldEffect.prototype._isReady = function () {
        for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
            if (!this._effects[effectIndex].isReady()) {
                return false;
            }
        }
        return true;
    };
    return DepthOfFieldEffect;
}(PostProcessRenderEffect));

var name$L = 'displayPassPixelShader';
var shader$L = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D passSampler;\nvoid main(void)\n{\ngl_FragColor=texture2D(passSampler,vUV);\n}";
Effect.ShadersStore[name$L] = shader$L;

/**
 * DisplayPassPostProcess which produces an output the same as it's input
 */
var DisplayPassPostProcess = /** @class */ (function (_super) {
    __extends(DisplayPassPostProcess, _super);
    /**
     * Creates the DisplayPassPostProcess
     * @param name The name of the effect.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     */
    function DisplayPassPostProcess(name, options, camera, samplingMode, engine, reusable) {
        return _super.call(this, name, "displayPass", ["passSampler"], ["passSampler"], options, camera, samplingMode, engine, reusable) || this;
    }
    return DisplayPassPostProcess;
}(PostProcess));

var name$M = 'filterPixelShader';
var shader$M = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform mat4 kernelMatrix;\nvoid main(void)\n{\nvec3 baseColor=texture2D(textureSampler,vUV).rgb;\nvec3 updatedColor=(kernelMatrix*vec4(baseColor,1.0)).rgb;\ngl_FragColor=vec4(updatedColor,1.0);\n}";
Effect.ShadersStore[name$M] = shader$M;

/**
 * Applies a kernel filter to the image
 */
var FilterPostProcess = /** @class */ (function (_super) {
    __extends(FilterPostProcess, _super);
    /**
     *
     * @param name The name of the effect.
     * @param kernelMatrix The matrix to be applied to the image
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     */
    function FilterPostProcess(name, 
    /** The matrix to be applied to the image */
    kernelMatrix, options, camera, samplingMode, engine, reusable) {
        var _this = _super.call(this, name, "filter", ["kernelMatrix"], null, options, camera, samplingMode, engine, reusable) || this;
        _this.kernelMatrix = kernelMatrix;
        _this.onApply = function (effect) {
            effect.setMatrix("kernelMatrix", _this.kernelMatrix);
        };
        return _this;
    }
    return FilterPostProcess;
}(PostProcess));

var name$N = 'fxaaPixelShader';
var shader$N = "uniform sampler2D textureSampler;\nuniform vec2 texelSize;\nvarying vec2 vUV;\nvarying vec2 sampleCoordS;\nvarying vec2 sampleCoordE;\nvarying vec2 sampleCoordN;\nvarying vec2 sampleCoordW;\nvarying vec2 sampleCoordNW;\nvarying vec2 sampleCoordSE;\nvarying vec2 sampleCoordNE;\nvarying vec2 sampleCoordSW;\nconst float fxaaQualitySubpix=1.0;\nconst float fxaaQualityEdgeThreshold=0.166;\nconst float fxaaQualityEdgeThresholdMin=0.0833;\nconst vec3 kLumaCoefficients=vec3(0.2126,0.7152,0.0722);\n#define FxaaLuma(rgba) dot(rgba.rgb,kLumaCoefficients)\nvoid main(){\nvec2 posM;\nposM.x=vUV.x;\nposM.y=vUV.y;\nvec4 rgbyM=texture2D(textureSampler,vUV,0.0);\nfloat lumaM=FxaaLuma(rgbyM);\nfloat lumaS=FxaaLuma(texture2D(textureSampler,sampleCoordS,0.0));\nfloat lumaE=FxaaLuma(texture2D(textureSampler,sampleCoordE,0.0));\nfloat lumaN=FxaaLuma(texture2D(textureSampler,sampleCoordN,0.0));\nfloat lumaW=FxaaLuma(texture2D(textureSampler,sampleCoordW,0.0));\nfloat maxSM=max(lumaS,lumaM);\nfloat minSM=min(lumaS,lumaM);\nfloat maxESM=max(lumaE,maxSM);\nfloat minESM=min(lumaE,minSM);\nfloat maxWN=max(lumaN,lumaW);\nfloat minWN=min(lumaN,lumaW);\nfloat rangeMax=max(maxWN,maxESM);\nfloat rangeMin=min(minWN,minESM);\nfloat rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;\nfloat range=rangeMax-rangeMin;\nfloat rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);\n#ifndef MALI\nif(range<rangeMaxClamped)\n{\ngl_FragColor=rgbyM;\nreturn;\n}\n#endif\nfloat lumaNW=FxaaLuma(texture2D(textureSampler,sampleCoordNW,0.0));\nfloat lumaSE=FxaaLuma(texture2D(textureSampler,sampleCoordSE,0.0));\nfloat lumaNE=FxaaLuma(texture2D(textureSampler,sampleCoordNE,0.0));\nfloat lumaSW=FxaaLuma(texture2D(textureSampler,sampleCoordSW,0.0));\nfloat lumaNS=lumaN+lumaS;\nfloat lumaWE=lumaW+lumaE;\nfloat subpixRcpRange=1.0/range;\nfloat subpixNSWE=lumaNS+lumaWE;\nfloat edgeHorz1=(-2.0*lumaM)+lumaNS;\nfloat edgeVert1=(-2.0*lumaM)+lumaWE;\nfloat lumaNESE=lumaNE+lumaSE;\nfloat lumaNWNE=lumaNW+lumaNE;\nfloat edgeHorz2=(-2.0*lumaE)+lumaNESE;\nfloat edgeVert2=(-2.0*lumaN)+lumaNWNE;\nfloat lumaNWSW=lumaNW+lumaSW;\nfloat lumaSWSE=lumaSW+lumaSE;\nfloat edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);\nfloat edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);\nfloat edgeHorz3=(-2.0*lumaW)+lumaNWSW;\nfloat edgeVert3=(-2.0*lumaS)+lumaSWSE;\nfloat edgeHorz=abs(edgeHorz3)+edgeHorz4;\nfloat edgeVert=abs(edgeVert3)+edgeVert4;\nfloat subpixNWSWNESE=lumaNWSW+lumaNESE;\nfloat lengthSign=texelSize.x;\nbool horzSpan=edgeHorz>=edgeVert;\nfloat subpixA=subpixNSWE*2.0+subpixNWSWNESE;\nif (!horzSpan)\n{\nlumaN=lumaW;\n}\nif (!horzSpan)\n{\nlumaS=lumaE;\n}\nif (horzSpan)\n{\nlengthSign=texelSize.y;\n}\nfloat subpixB=(subpixA*(1.0/12.0))-lumaM;\nfloat gradientN=lumaN-lumaM;\nfloat gradientS=lumaS-lumaM;\nfloat lumaNN=lumaN+lumaM;\nfloat lumaSS=lumaS+lumaM;\nbool pairN=abs(gradientN)>=abs(gradientS);\nfloat gradient=max(abs(gradientN),abs(gradientS));\nif (pairN)\n{\nlengthSign=-lengthSign;\n}\nfloat subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);\nvec2 posB;\nposB.x=posM.x;\nposB.y=posM.y;\nvec2 offNP;\noffNP.x=(!horzSpan) ? 0.0 : texelSize.x;\noffNP.y=(horzSpan) ? 0.0 : texelSize.y;\nif (!horzSpan)\n{\nposB.x+=lengthSign*0.5;\n}\nif (horzSpan)\n{\nposB.y+=lengthSign*0.5;\n}\nvec2 posN;\nposN.x=posB.x-offNP.x*1.5;\nposN.y=posB.y-offNP.y*1.5;\nvec2 posP;\nposP.x=posB.x+offNP.x*1.5;\nposP.y=posB.y+offNP.y*1.5;\nfloat subpixD=((-2.0)*subpixC)+3.0;\nfloat lumaEndN=FxaaLuma(texture2D(textureSampler,posN,0.0));\nfloat subpixE=subpixC*subpixC;\nfloat lumaEndP=FxaaLuma(texture2D(textureSampler,posP,0.0));\nif (!pairN)\n{\nlumaNN=lumaSS;\n}\nfloat gradientScaled=gradient*1.0/4.0;\nfloat lumaMM=lumaM-lumaNN*0.5;\nfloat subpixF=subpixD*subpixE;\nbool lumaMLTZero=lumaMM<0.0;\nlumaEndN-=lumaNN*0.5;\nlumaEndP-=lumaNN*0.5;\nbool doneN=abs(lumaEndN)>=gradientScaled;\nbool doneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN)\n{\nposN.x-=offNP.x*3.0;\n}\nif (!doneN)\n{\nposN.y-=offNP.y*3.0;\n}\nbool doneNP=(!doneN) || (!doneP);\nif (!doneP)\n{\nposP.x+=offNP.x*3.0;\n}\nif (!doneP)\n{\nposP.y+=offNP.y*3.0;\n}\nif (doneNP)\n{\nif (!doneN) lumaEndN=FxaaLuma(texture2D(textureSampler,posN.xy,0.0));\nif (!doneP) lumaEndP=FxaaLuma(texture2D(textureSampler,posP.xy,0.0));\nif (!doneN) lumaEndN=lumaEndN-lumaNN*0.5;\nif (!doneP) lumaEndP=lumaEndP-lumaNN*0.5;\ndoneN=abs(lumaEndN)>=gradientScaled;\ndoneP=abs(lumaEndP)>=gradientScaled;\nif (!doneN) posN.x-=offNP.x*12.0;\nif (!doneN) posN.y-=offNP.y*12.0;\ndoneNP=(!doneN) || (!doneP);\nif (!doneP) posP.x+=offNP.x*12.0;\nif (!doneP) posP.y+=offNP.y*12.0;\n}\nfloat dstN=posM.x-posN.x;\nfloat dstP=posP.x-posM.x;\nif (!horzSpan)\n{\ndstN=posM.y-posN.y;\n}\nif (!horzSpan)\n{\ndstP=posP.y-posM.y;\n}\nbool goodSpanN=(lumaEndN<0.0) != lumaMLTZero;\nfloat spanLength=(dstP+dstN);\nbool goodSpanP=(lumaEndP<0.0) != lumaMLTZero;\nfloat spanLengthRcp=1.0/spanLength;\nbool directionN=dstN<dstP;\nfloat dst=min(dstN,dstP);\nbool goodSpan=directionN ? goodSpanN : goodSpanP;\nfloat subpixG=subpixF*subpixF;\nfloat pixelOffset=(dst*(-spanLengthRcp))+0.5;\nfloat subpixH=subpixG*fxaaQualitySubpix;\nfloat pixelOffsetGood=goodSpan ? pixelOffset : 0.0;\nfloat pixelOffsetSubpix=max(pixelOffsetGood,subpixH);\nif (!horzSpan)\n{\nposM.x+=pixelOffsetSubpix*lengthSign;\n}\nif (horzSpan)\n{\nposM.y+=pixelOffsetSubpix*lengthSign;\n}\n#ifdef MALI\nif(range<rangeMaxClamped)\n{\ngl_FragColor=rgbyM;\n}\nelse\n{\ngl_FragColor=texture2D(textureSampler,posM,0.0);\n}\n#else\ngl_FragColor=texture2D(textureSampler,posM,0.0);\n#endif\n}";
Effect.ShadersStore[name$N] = shader$N;

var name$O = 'fxaaVertexShader';
var shader$O = "\nattribute vec2 position;\nuniform vec2 texelSize;\n\nvarying vec2 vUV;\nvarying vec2 sampleCoordS;\nvarying vec2 sampleCoordE;\nvarying vec2 sampleCoordN;\nvarying vec2 sampleCoordW;\nvarying vec2 sampleCoordNW;\nvarying vec2 sampleCoordSE;\nvarying vec2 sampleCoordNE;\nvarying vec2 sampleCoordSW;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvUV=(position*madd+madd);\nsampleCoordS=vUV+vec2( 0.0,1.0)*texelSize;\nsampleCoordE=vUV+vec2( 1.0,0.0)*texelSize;\nsampleCoordN=vUV+vec2( 0.0,-1.0)*texelSize;\nsampleCoordW=vUV+vec2(-1.0,0.0)*texelSize;\nsampleCoordNW=vUV+vec2(-1.0,-1.0)*texelSize;\nsampleCoordSE=vUV+vec2( 1.0,1.0)*texelSize;\nsampleCoordNE=vUV+vec2( 1.0,-1.0)*texelSize;\nsampleCoordSW=vUV+vec2(-1.0,1.0)*texelSize;\ngl_Position=vec4(position,0.0,1.0);\n}";
Effect.ShadersStore[name$O] = shader$O;

/**
 * Fxaa post process
 * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#fxaa
 */
var FxaaPostProcess = /** @class */ (function (_super) {
    __extends(FxaaPostProcess, _super);
    function FxaaPostProcess(name, options, camera, samplingMode, engine, reusable, textureType) {
        if (camera === void 0) { camera = null; }
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        var _this = _super.call(this, name, "fxaa", ["texelSize"], null, options, camera, samplingMode || Texture.BILINEAR_SAMPLINGMODE, engine, reusable, null, textureType, "fxaa", undefined, true) || this;
        var defines = _this._getDefines();
        _this.updateEffect(defines);
        _this.onApplyObservable.add(function (effect) {
            var texelSize = _this.texelSize;
            effect.setFloat2("texelSize", texelSize.x, texelSize.y);
        });
        return _this;
    }
    FxaaPostProcess.prototype._getDefines = function () {
        var engine = this.getEngine();
        if (!engine) {
            return null;
        }
        var glInfo = engine.getGlInfo();
        if (glInfo && glInfo.renderer && glInfo.renderer.toLowerCase().indexOf("mali") > -1) {
            return "#define MALI 1\n";
        }
        return null;
    };
    return FxaaPostProcess;
}(PostProcess));

var name$P = 'grainPixelShader';
var shader$P = "#include<helperFunctions>\n\nuniform sampler2D textureSampler;\n\nuniform float intensity;\nuniform float animatedSeed;\n\nvarying vec2 vUV;\nvoid main(void)\n{\ngl_FragColor=texture2D(textureSampler,vUV);\nvec2 seed=vUV*(animatedSeed);\nfloat grain=dither(seed,intensity);\n\nfloat lum=getLuminance(gl_FragColor.rgb);\nfloat grainAmount=(cos(-PI+(lum*PI*2.))+1.)/2.;\ngl_FragColor.rgb+=grain*grainAmount;\ngl_FragColor.rgb=max(gl_FragColor.rgb,0.0);\n}";
Effect.ShadersStore[name$P] = shader$P;

/**
 * The GrainPostProcess adds noise to the image at mid luminance levels
 */
var GrainPostProcess = /** @class */ (function (_super) {
    __extends(GrainPostProcess, _super);
    /**
     * Creates a new instance of @see GrainPostProcess
     * @param name The name of the effect.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function GrainPostProcess(name, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "grain", ["intensity", "animatedSeed"], [], options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, blockCompilation) || this;
        /**
         * The intensity of the grain added (default: 30)
         */
        _this.intensity = 30;
        /**
         * If the grain should be randomized on every frame
         */
        _this.animated = false;
        _this.onApplyObservable.add(function (effect) {
            effect.setFloat('intensity', _this.intensity);
            effect.setFloat('animatedSeed', _this.animated ? Math.random() + 1 : 1);
        });
        return _this;
    }
    return GrainPostProcess;
}(PostProcess));

var name$Q = 'highlightsPixelShader';
var shader$Q = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nconst vec3 RGBLuminanceCoefficients=vec3(0.2126,0.7152,0.0722);\nvoid main(void)\n{\nvec4 tex=texture2D(textureSampler,vUV);\nvec3 c=tex.rgb;\nfloat luma=dot(c.rgb,RGBLuminanceCoefficients);\n\n\ngl_FragColor=vec4(pow(c,vec3(25.0-luma*15.0)),tex.a);\n}";
Effect.ShadersStore[name$Q] = shader$Q;

/**
 * Extracts highlights from the image
 * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses
 */
var HighlightsPostProcess = /** @class */ (function (_super) {
    __extends(HighlightsPostProcess, _super);
    /**
     * Extracts highlights from the image
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses
     * @param name The name of the effect.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of texture for the post process (default: Engine.TEXTURETYPE_UNSIGNED_INT)
     */
    function HighlightsPostProcess(name, options, camera, samplingMode, engine, reusable, textureType) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        return _super.call(this, name, "highlights", null, null, options, camera, samplingMode, engine, reusable, null, textureType) || this;
    }
    return HighlightsPostProcess;
}(PostProcess));

var name$R = 'mrtFragmentDeclaration';
var shader$R = "#if __VERSION__>=200\nlayout(location=0) out vec4 glFragData[{X}];\n#endif\n";
Effect.IncludesShadersStore[name$R] = shader$R;

var name$S = 'geometryPixelShader';
var shader$S = "#extension GL_EXT_draw_buffers : require\nprecision highp float;\nprecision highp int;\nvarying vec3 vNormalV;\nvarying vec4 vViewPos;\n#ifdef POSITION\nvarying vec3 vPosition;\n#endif\n#ifdef VELOCITY\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n#endif\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#include<mrtFragmentDeclaration>[RENDER_TARGET_COUNT]\nvoid main() {\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\ngl_FragData[0]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\n\ngl_FragData[1]=vec4(normalize(vNormalV),1.0);\n\n#ifdef POSITION\ngl_FragData[POSITION_INDEX]=vec4(vPosition,1.0);\n#endif\n#ifdef VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\nvec2 velocity=abs(a-b);\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\ngl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\n#endif\n}";
Effect.ShadersStore[name$S] = shader$S;

var name$T = 'geometryVertexShader';
var shader$T = "precision highp float;\nprecision highp int;\n#include<bonesDeclaration>\n#include<instancesDeclaration>\nattribute vec3 position;\nattribute vec3 normal;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n\nuniform mat4 viewProjection;\nuniform mat4 view;\nvarying vec3 vNormalV;\nvarying vec4 vViewPos;\n#ifdef POSITION\nvarying vec3 vPosition;\n#endif\n#ifdef VELOCITY\nuniform mat4 previousWorld;\nuniform mat4 previousViewProjection;\n#ifdef BONES_VELOCITY_ENABLED\n#if NUM_BONE_INFLUENCERS>0\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#endif\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n#endif\nvoid main(void)\n{\n#include<instancesVertex>\n#if defined(VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n\nvCurrentPosition=viewProjection*finalWorld*vec4(position,1.0);\nvPreviousPosition=previousViewProjection*previousWorld*vec4(position,1.0);\n#endif\n#include<bonesVertex>\nvec4 pos=vec4(finalWorld*vec4(position,1.0));\nvNormalV=normalize(vec3((view*finalWorld)*vec4(normal,0.0)));\nvViewPos=view*pos;\n#if defined(VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(position,1.0);\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*previousWorld*previousInfluence*vec4(position,1.0);\n#else\nvPreviousPosition=previousViewProjection*previousWorld*vec4(position,1.0);\n#endif\n#endif\n#ifdef POSITION\nvPosition=pos.xyz/pos.w;\n#endif\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}";
Effect.ShadersStore[name$T] = shader$T;

/**
 * This renderer is helpfull to fill one of the render target with a geometry buffer.
 */
var GeometryBufferRenderer = /** @class */ (function () {
    /**
     * Creates a new G Buffer for the scene
     * @param scene The scene the buffer belongs to
     * @param ratio How big is the buffer related to the main canvas.
     */
    function GeometryBufferRenderer(scene, ratio) {
        if (ratio === void 0) { ratio = 1; }
        /**
         * Dictionary used to store the previous transformation matrices of each rendered mesh
         * in order to compute objects velocities when enableVelocity is set to "true"
         * @hidden
         */
        this._previousTransformationMatrices = {};
        /**
         * Dictionary used to store the previous bones transformation matrices of each rendered mesh
         * in order to compute objects velocities when enableVelocity is set to "true"
         * @hidden
         */
        this._previousBonesTransformationMatrices = {};
        /**
         * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).
         * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).
         */
        this.excludedSkinnedMeshesFromVelocity = [];
        this._enablePosition = false;
        this._enableVelocity = false;
        this._positionIndex = -1;
        this._velocityIndex = -1;
        this._scene = scene;
        this._ratio = ratio;
        GeometryBufferRenderer._SceneComponentInitialization(this._scene);
        // Render target
        this._createRenderTargets();
    }
    Object.defineProperty(GeometryBufferRenderer.prototype, "renderList", {
        /**
         * Set the render list (meshes to be rendered) used in the G buffer.
         */
        set: function (meshes) {
            this._multiRenderTarget.renderList = meshes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryBufferRenderer.prototype, "isSupported", {
        /**
         * Gets wether or not G buffer are supported by the running hardware.
         * This requires draw buffer supports
         */
        get: function () {
            return this._multiRenderTarget.isSupported;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the index of the given texture type in the G-Buffer textures array
     * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX
     * @returns the index of the given texture type in the G-Buffer textures array
     */
    GeometryBufferRenderer.prototype.getTextureIndex = function (textureType) {
        switch (textureType) {
            case GeometryBufferRenderer.POSITION_TEXTURE_TYPE: return this._positionIndex;
            case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE: return this._velocityIndex;
            default: return -1;
        }
    };
    Object.defineProperty(GeometryBufferRenderer.prototype, "enablePosition", {
        /**
         * Gets a boolean indicating if objects positions are enabled for the G buffer.
         */
        get: function () {
            return this._enablePosition;
        },
        /**
         * Sets whether or not objects positions are enabled for the G buffer.
         */
        set: function (enable) {
            this._enablePosition = enable;
            this.dispose();
            this._createRenderTargets();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryBufferRenderer.prototype, "enableVelocity", {
        /**
         * Gets a boolean indicating if objects velocities are enabled for the G buffer.
         */
        get: function () {
            return this._enableVelocity;
        },
        /**
         * Sets wether or not objects velocities are enabled for the G buffer.
         */
        set: function (enable) {
            this._enableVelocity = enable;
            if (!enable) {
                this._previousTransformationMatrices = {};
            }
            this.dispose();
            this._createRenderTargets();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryBufferRenderer.prototype, "scene", {
        /**
         * Gets the scene associated with the buffer.
         */
        get: function () {
            return this._scene;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryBufferRenderer.prototype, "ratio", {
        /**
         * Gets the ratio used by the buffer during its creation.
         * How big is the buffer related to the main canvas.
         */
        get: function () {
            return this._ratio;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks wether everything is ready to render a submesh to the G buffer.
     * @param subMesh the submesh to check readiness for
     * @param useInstances is the mesh drawn using instance or not
     * @returns true if ready otherwise false
     */
    GeometryBufferRenderer.prototype.isReady = function (subMesh, useInstances) {
        var material = subMesh.getMaterial();
        if (material && material.disableDepthWrite) {
            return false;
        }
        var defines = [];
        var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
        var mesh = subMesh.getMesh();
        // Alpha test
        if (material && material.needAlphaTesting()) {
            defines.push("#define ALPHATEST");
            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                attribs.push(VertexBuffer.UVKind);
                defines.push("#define UV1");
            }
            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
                attribs.push(VertexBuffer.UV2Kind);
                defines.push("#define UV2");
            }
        }
        // Buffers
        if (this._enablePosition) {
            defines.push("#define POSITION");
            defines.push("#define POSITION_INDEX " + this._positionIndex);
        }
        if (this._enableVelocity) {
            defines.push("#define VELOCITY");
            defines.push("#define VELOCITY_INDEX " + this._velocityIndex);
            if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {
                defines.push("#define BONES_VELOCITY_ENABLED");
            }
        }
        // Bones
        if (mesh.useBones && mesh.computeBonesUsingShaders) {
            attribs.push(VertexBuffer.MatricesIndicesKind);
            attribs.push(VertexBuffer.MatricesWeightsKind);
            if (mesh.numBoneInfluencers > 4) {
                attribs.push(VertexBuffer.MatricesIndicesExtraKind);
                attribs.push(VertexBuffer.MatricesWeightsExtraKind);
            }
            defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
            defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
        }
        else {
            defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        // Instances
        if (useInstances) {
            defines.push("#define INSTANCES");
            attribs.push("world0");
            attribs.push("world1");
            attribs.push("world2");
            attribs.push("world3");
        }
        // Setup textures count
        defines.push("#define RENDER_TARGET_COUNT " + this._multiRenderTarget.textures.length);
        // Get correct effect
        var join = defines.join("\n");
        if (this._cachedDefines !== join) {
            this._cachedDefines = join;
            this._effect = this._scene.getEngine().createEffect("geometry", attribs, ["world", "mBones", "viewProjection", "diffuseMatrix", "view", "previousWorld", "previousViewProjection", "mPreviousBones"], ["diffuseSampler"], join, undefined, undefined, undefined, { buffersCount: this._enablePosition ? 3 : 2 });
        }
        return this._effect.isReady();
    };
    /**
     * Gets the current underlying G Buffer.
     * @returns the buffer
     */
    GeometryBufferRenderer.prototype.getGBuffer = function () {
        return this._multiRenderTarget;
    };
    Object.defineProperty(GeometryBufferRenderer.prototype, "samples", {
        /**
         * Gets the number of samples used to render the buffer (anti aliasing).
         */
        get: function () {
            return this._multiRenderTarget.samples;
        },
        /**
         * Sets the number of samples used to render the buffer (anti aliasing).
         */
        set: function (value) {
            this._multiRenderTarget.samples = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes the renderer and frees up associated resources.
     */
    GeometryBufferRenderer.prototype.dispose = function () {
        this.getGBuffer().dispose();
    };
    GeometryBufferRenderer.prototype._createRenderTargets = function () {
        var _this = this;
        var engine = this._scene.getEngine();
        var count = 2;
        if (this._enablePosition) {
            this._positionIndex = count;
            count++;
        }
        if (this._enableVelocity) {
            this._velocityIndex = count;
            count++;
        }
        this._multiRenderTarget = new MultiRenderTarget("gBuffer", { width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio }, count, this._scene, { generateMipMaps: false, generateDepthTexture: true, defaultType: Constants.TEXTURETYPE_FLOAT });
        if (!this.isSupported) {
            return;
        }
        this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._multiRenderTarget.refreshRate = 1;
        this._multiRenderTarget.renderParticles = false;
        this._multiRenderTarget.renderList = null;
        // set default depth value to 1.0 (far away)
        this._multiRenderTarget.onClearObservable.add(function (engine) {
            engine.clear(new Color4(0.0, 0.0, 0.0, 1.0), true, true, true);
        });
        // Custom render function
        var renderSubMesh = function (subMesh) {
            var mesh = subMesh.getRenderingMesh();
            var scene = _this._scene;
            var engine = scene.getEngine();
            var material = subMesh.getMaterial();
            if (!material) {
                return;
            }
            // Velocity
            if (_this._enableVelocity && !_this._previousTransformationMatrices[mesh.uniqueId]) {
                _this._previousTransformationMatrices[mesh.uniqueId] = {
                    world: Matrix.Identity(),
                    viewProjection: scene.getTransformMatrix()
                };
                if (mesh.skeleton) {
                    var bonesTransformations = mesh.skeleton.getTransformMatrices(mesh);
                    _this._previousBonesTransformationMatrices[mesh.uniqueId] = _this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));
                }
            }
            // Culling
            engine.setState(material.backFaceCulling, 0, false, scene.useRightHandedSystem);
            // Managing instances
            var batch = mesh._getInstancesRenderList(subMesh._id);
            if (batch.mustReturn) {
                return;
            }
            var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null);
            if (_this.isReady(subMesh, hardwareInstancedRendering)) {
                engine.enableEffect(_this._effect);
                mesh._bind(subMesh, _this._effect, Material.TriangleFillMode);
                _this._effect.setMatrix("viewProjection", scene.getTransformMatrix());
                _this._effect.setMatrix("view", scene.getViewMatrix());
                // Alpha test
                if (material && material.needAlphaTesting()) {
                    var alphaTexture = material.getAlphaTestTexture();
                    if (alphaTexture) {
                        _this._effect.setTexture("diffuseSampler", alphaTexture);
                        _this._effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
                    }
                }
                // Bones
                if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
                    _this._effect.setMatrices("mBones", mesh.skeleton.getTransformMatrices(mesh));
                    if (_this._enableVelocity) {
                        _this._effect.setMatrices("mPreviousBones", _this._previousBonesTransformationMatrices[mesh.uniqueId]);
                    }
                }
                // Velocity
                if (_this._enableVelocity) {
                    _this._effect.setMatrix("previousWorld", _this._previousTransformationMatrices[mesh.uniqueId].world);
                    _this._effect.setMatrix("previousViewProjection", _this._previousTransformationMatrices[mesh.uniqueId].viewProjection);
                }
                // Draw
                mesh._processRendering(subMesh, _this._effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return _this._effect.setMatrix("world", world); });
            }
            // Velocity
            if (_this._enableVelocity) {
                _this._previousTransformationMatrices[mesh.uniqueId].world = mesh.getWorldMatrix().clone();
                _this._previousTransformationMatrices[mesh.uniqueId].viewProjection = _this._scene.getTransformMatrix().clone();
                if (mesh.skeleton) {
                    _this._copyBonesTransformationMatrices(mesh.skeleton.getTransformMatrices(mesh), _this._previousBonesTransformationMatrices[mesh.uniqueId]);
                }
            }
        };
        this._multiRenderTarget.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
            var index;
            if (depthOnlySubMeshes.length) {
                engine.setColorWrite(false);
                for (index = 0; index < depthOnlySubMeshes.length; index++) {
                    renderSubMesh(depthOnlySubMeshes.data[index]);
                }
                engine.setColorWrite(true);
            }
            for (index = 0; index < opaqueSubMeshes.length; index++) {
                renderSubMesh(opaqueSubMeshes.data[index]);
            }
            for (index = 0; index < alphaTestSubMeshes.length; index++) {
                renderSubMesh(alphaTestSubMeshes.data[index]);
            }
        };
    };
    // Copies the bones transformation matrices into the target array and returns the target's reference
    GeometryBufferRenderer.prototype._copyBonesTransformationMatrices = function (source, target) {
        for (var i = 0; i < source.length; i++) {
            target[i] = source[i];
        }
        return target;
    };
    /**
     * Constant used to retrieve the position texture index in the G-Buffer textures array
     * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)
     */
    GeometryBufferRenderer.POSITION_TEXTURE_TYPE = 1;
    /**
     * Constant used to retrieve the velocity texture index in the G-Buffer textures array
     * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)
     */
    GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 2;
    /** @hidden */
    GeometryBufferRenderer._SceneComponentInitialization = function (_) {
        throw _DevTools.WarnImport("GeometryBufferRendererSceneComponent");
    };
    return GeometryBufferRenderer;
}());

Object.defineProperty(Scene.prototype, "geometryBufferRenderer", {
    get: function () {
        this._geometryBufferRenderer;
    },
    set: function (value) {
        if (value && value.isSupported) {
            this._geometryBufferRenderer = value;
        }
    },
    enumerable: true,
    configurable: true
});
Scene.prototype.enableGeometryBufferRenderer = function (ratio) {
    if (ratio === void 0) { ratio = 1; }
    if (this._geometryBufferRenderer) {
        return this._geometryBufferRenderer;
    }
    this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio);
    if (!this._geometryBufferRenderer.isSupported) {
        this._geometryBufferRenderer = null;
    }
    return this._geometryBufferRenderer;
};
Scene.prototype.disableGeometryBufferRenderer = function () {
    if (!this._geometryBufferRenderer) {
        return;
    }
    this._geometryBufferRenderer.dispose();
    this._geometryBufferRenderer = null;
};
/**
 * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful
 * in several rendering techniques.
 */
var GeometryBufferRendererSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function GeometryBufferRendererSceneComponent(scene) {
        /**
         * The component name helpful to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;
        this.scene = scene;
    }
    /**
     * Registers the component in a given scene
     */
    GeometryBufferRendererSceneComponent.prototype.register = function () {
        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    GeometryBufferRendererSceneComponent.prototype.rebuild = function () {
        // Nothing to do for this component
    };
    /**
     * Disposes the component and the associated ressources
     */
    GeometryBufferRendererSceneComponent.prototype.dispose = function () {
        // Nothing to do for this component
    };
    GeometryBufferRendererSceneComponent.prototype._gatherRenderTargets = function (renderTargets) {
        if (this.scene._geometryBufferRenderer) {
            renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());
        }
    };
    return GeometryBufferRendererSceneComponent;
}());
GeometryBufferRenderer._SceneComponentInitialization = function (scene) {
    // Register the G Buffer component to the scene.
    var component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER);
    if (!component) {
        component = new GeometryBufferRendererSceneComponent(scene);
        scene._addComponent(component);
    }
};

var name$U = 'motionBlurPixelShader';
var shader$U = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D velocitySampler;\nuniform float motionStrength;\nuniform float motionScale;\nuniform vec2 screenSize;\nvoid main(void)\n{\n#ifdef GEOMETRY_SUPPORTED\nvec2 texelSize=1.0/screenSize;\nvec2 velocityColor=texture2D(velocitySampler,vUV).rg*2.0-1.0;\nvec2 velocity=vec2(pow(velocityColor.r,3.0),pow(velocityColor.g,3.0));\nvelocity*=motionScale*motionStrength;\nfloat speed=length(velocity/texelSize);\nint samplesCount=int(clamp(speed,1.0,SAMPLES));\nvelocity=normalize(velocity)*texelSize;\nfloat hlim=float(-samplesCount)*0.5+0.5;\nvec4 result=texture2D(textureSampler,vUV);\nfor (int i=1; i<int(SAMPLES); ++i)\n{\nif (i>=samplesCount)\nbreak;\nvec2 offset=vUV+velocity*(hlim+float(i));\nresult+=texture2D(textureSampler,offset);\n}\ngl_FragColor=result/float(samplesCount);\ngl_FragColor.a=1.0;\n#else\ngl_FragColor=texture2D(textureSampler,vUV);\n#endif\n}\n";
Effect.ShadersStore[name$U] = shader$U;

/**
 * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.
 * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.
 * As an example, all you have to do is to create the post-process:
 *  var mb = new BABYLON.MotionBlurPostProcess(
 *      'mb', // The name of the effect.
 *      scene, // The scene containing the objects to blur according to their velocity.
 *      1.0, // The required width/height ratio to downsize to before computing the render pass.
 *      camera // The camera to apply the render pass to.
 * );
 * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.
 */
var MotionBlurPostProcess = /** @class */ (function (_super) {
    __extends(MotionBlurPostProcess, _super);
    /**
     * Creates a new instance MotionBlurPostProcess
     * @param name The name of the effect.
     * @param scene The scene containing the objects to blur according to their velocity.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function MotionBlurPostProcess(name, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "motionBlur", ["motionStrength", "motionScale", "screenSize"], ["velocitySampler"], options, camera, samplingMode, engine, reusable, "#define GEOMETRY_SUPPORTED\n#define SAMPLES 64.0", textureType, undefined, null, blockCompilation) || this;
        /**
         * Defines how much the image is blurred by the movement. Default value is equal to 1
         */
        _this.motionStrength = 1;
        _this._motionBlurSamples = 32;
        _this._geometryBufferRenderer = scene.enableGeometryBufferRenderer();
        if (!_this._geometryBufferRenderer) {
            // Geometry buffer renderer is not supported. So, work as a passthrough.
            Logger.Warn("Multiple Render Target support needed to compute object based motion blur");
            _this.updateEffect();
        }
        else {
            // Geometry buffer renderer is supported.
            _this._geometryBufferRenderer.enableVelocity = true;
            _this.onApply = function (effect) {
                effect.setVector2("screenSize", new Vector2(_this.width, _this.height));
                effect.setFloat("motionScale", scene.getAnimationRatio());
                effect.setFloat("motionStrength", _this.motionStrength);
                if (_this._geometryBufferRenderer) {
                    var velocityIndex = _this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);
                    effect.setTexture("velocitySampler", _this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);
                }
            };
        }
        return _this;
    }
    Object.defineProperty(MotionBlurPostProcess.prototype, "motionBlurSamples", {
        /**
         * Gets the number of iterations are used for motion blur quality. Default value is equal to 32
         */
        get: function () {
            return this._motionBlurSamples;
        },
        /**
         * Sets the number of iterations to be used for motion blur quality
         */
        set: function (samples) {
            this._motionBlurSamples = samples;
            if (this._geometryBufferRenderer) {
                this.updateEffect("#define GEOMETRY_SUPPORTED\n#define SAMPLES " + samples.toFixed(1));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Excludes the given skinned mesh from computing bones velocities.
     * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.
     * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.
     */
    MotionBlurPostProcess.prototype.excludeSkinnedMesh = function (skinnedMesh) {
        if (this._geometryBufferRenderer && skinnedMesh.skeleton) {
            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity.push(skinnedMesh);
        }
    };
    /**
     * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.
     * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.
     * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.
     */
    MotionBlurPostProcess.prototype.removeExcludedSkinnedMesh = function (skinnedMesh) {
        if (this._geometryBufferRenderer && skinnedMesh.skeleton) {
            var index = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity.indexOf(skinnedMesh);
            if (index !== -1) {
                this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity.splice(index, 1);
            }
        }
    };
    /**
     * Disposes the post process.
     * @param camera The camera to dispose the post process on.
     */
    MotionBlurPostProcess.prototype.dispose = function (camera) {
        if (this._geometryBufferRenderer) {
            // Clear previous transformation matrices dictionary used to compute objects velocities
            this._geometryBufferRenderer._previousTransformationMatrices = {};
            this._geometryBufferRenderer._previousBonesTransformationMatrices = {};
            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];
        }
        _super.prototype.dispose.call(this, camera);
    };
    return MotionBlurPostProcess;
}(PostProcess));

var name$V = 'refractionPixelShader';
var shader$V = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D refractionSampler;\n\nuniform vec3 baseColor;\nuniform float depth;\nuniform float colorLevel;\nvoid main() {\nfloat ref=1.0-texture2D(refractionSampler,vUV).r;\nvec2 uv=vUV-vec2(0.5);\nvec2 offset=uv*depth*ref;\nvec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;\ngl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);\n}";
Effect.ShadersStore[name$V] = shader$V;

/**
 * Post process which applies a refractin texture
 * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#refraction
 */
var RefractionPostProcess = /** @class */ (function (_super) {
    __extends(RefractionPostProcess, _super);
    /**
     * Initializes the RefractionPostProcess
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#refraction
     * @param name The name of the effect.
     * @param refractionTextureUrl Url of the refraction texture to use
     * @param color the base color of the refraction (used to taint the rendering)
     * @param depth simulated refraction depth
     * @param colorLevel the coefficient of the base color (0 to remove base color tainting)
     * @param camera The camera to apply the render pass to.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     */
    function RefractionPostProcess(name, refractionTextureUrl, 
    /** the base color of the refraction (used to taint the rendering) */
    color, 
    /** simulated refraction depth */
    depth, 
    /** the coefficient of the base color (0 to remove base color tainting) */
    colorLevel, options, camera, samplingMode, engine, reusable) {
        var _this = _super.call(this, name, "refraction", ["baseColor", "depth", "colorLevel"], ["refractionSampler"], options, camera, samplingMode, engine, reusable) || this;
        _this.color = color;
        _this.depth = depth;
        _this.colorLevel = colorLevel;
        _this._ownRefractionTexture = true;
        _this.onActivateObservable.add(function (cam) {
            _this._refTexture = _this._refTexture || new Texture(refractionTextureUrl, cam.getScene());
        });
        _this.onApplyObservable.add(function (effect) {
            effect.setColor3("baseColor", _this.color);
            effect.setFloat("depth", _this.depth);
            effect.setFloat("colorLevel", _this.colorLevel);
            effect.setTexture("refractionSampler", _this._refTexture);
        });
        return _this;
    }
    Object.defineProperty(RefractionPostProcess.prototype, "refractionTexture", {
        /**
         * Gets or sets the refraction texture
         * Please note that you are responsible for disposing the texture if you set it manually
         */
        get: function () {
            return this._refTexture;
        },
        set: function (value) {
            if (this._refTexture && this._ownRefractionTexture) {
                this._refTexture.dispose();
            }
            this._refTexture = value;
            this._ownRefractionTexture = false;
        },
        enumerable: true,
        configurable: true
    });
    // Methods
    /**
     * Disposes of the post process
     * @param camera Camera to dispose post process on
     */
    RefractionPostProcess.prototype.dispose = function (camera) {
        if (this._refTexture && this._ownRefractionTexture) {
            this._refTexture.dispose();
            this._refTexture = null;
        }
        _super.prototype.dispose.call(this, camera);
    };
    return RefractionPostProcess;
}(PostProcess));

var name$W = 'sharpenPixelShader';
var shader$W = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 screenSize;\nuniform vec2 sharpnessAmounts;\nvoid main(void)\n{\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\nvec4 color=texture2D(textureSampler,vUV);\nvec4 edgeDetection=texture2D(textureSampler,vUV+onePixel*vec2(0,-1)) +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0)) +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0)) +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1)) -\ncolor*4.0;\ngl_FragColor=max(vec4(color.rgb*sharpnessAmounts.y,color.a)-(sharpnessAmounts.x*vec4(edgeDetection.rgb,0)),0.);\n}";
Effect.ShadersStore[name$W] = shader$W;

/**
 * The SharpenPostProcess applies a sharpen kernel to every pixel
 * See http://en.wikipedia.org/wiki/Kernel_(image_processing)
 */
var SharpenPostProcess = /** @class */ (function (_super) {
    __extends(SharpenPostProcess, _super);
    /**
     * Creates a new instance ConvolutionPostProcess
     * @param name The name of the effect.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType Type of textures used when performing the post process. (default: 0)
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    function SharpenPostProcess(name, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (textureType === void 0) { textureType = Constants.TEXTURETYPE_UNSIGNED_INT; }
        if (blockCompilation === void 0) { blockCompilation = false; }
        var _this = _super.call(this, name, "sharpen", ["sharpnessAmounts", "screenSize"], null, options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, blockCompilation) || this;
        /**
         * How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)
         */
        _this.colorAmount = 1.0;
        /**
         * How much sharpness should be applied (default: 0.3)
         */
        _this.edgeAmount = 0.3;
        _this.onApply = function (effect) {
            effect.setFloat2("screenSize", _this.width, _this.height);
            effect.setFloat2("sharpnessAmounts", _this.edgeAmount, _this.colorAmount);
        };
        return _this;
    }
    return SharpenPostProcess;
}(PostProcess));

/**
 * PostProcessRenderPipeline
 * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
 */
var PostProcessRenderPipeline = /** @class */ (function () {
    /**
     * Initializes a PostProcessRenderPipeline
     * @param engine engine to add the pipeline to
     * @param name name of the pipeline
     */
    function PostProcessRenderPipeline(engine, name) {
        this.engine = engine;
        this._name = name;
        this._renderEffects = {};
        this._renderEffectsForIsolatedPass = new Array();
        this._cameras = [];
    }
    Object.defineProperty(PostProcessRenderPipeline.prototype, "name", {
        /**
         * Gets pipeline name
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the class name
     * @returns "PostProcessRenderPipeline"
     */
    PostProcessRenderPipeline.prototype.getClassName = function () {
        return "PostProcessRenderPipeline";
    };
    Object.defineProperty(PostProcessRenderPipeline.prototype, "isSupported", {
        /**
         * If all the render effects in the pipeline are supported
         */
        get: function () {
            for (var renderEffectName in this._renderEffects) {
                if (this._renderEffects.hasOwnProperty(renderEffectName)) {
                    if (!this._renderEffects[renderEffectName].isSupported) {
                        return false;
                    }
                }
            }
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds an effect to the pipeline
     * @param renderEffect the effect to add
     */
    PostProcessRenderPipeline.prototype.addEffect = function (renderEffect) {
        this._renderEffects[renderEffect._name] = renderEffect;
    };
    // private
    /** @hidden */
    PostProcessRenderPipeline.prototype._rebuild = function () {
    };
    /** @hidden */
    PostProcessRenderPipeline.prototype._enableEffect = function (renderEffectName, cameras) {
        var renderEffects = this._renderEffects[renderEffectName];
        if (!renderEffects) {
            return;
        }
        renderEffects._enable(Tools.MakeArray(cameras || this._cameras));
    };
    /** @hidden */
    PostProcessRenderPipeline.prototype._disableEffect = function (renderEffectName, cameras) {
        var renderEffects = this._renderEffects[renderEffectName];
        if (!renderEffects) {
            return;
        }
        renderEffects._disable(Tools.MakeArray(cameras || this._cameras));
    };
    /** @hidden */
    PostProcessRenderPipeline.prototype._attachCameras = function (cameras, unique) {
        var cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
            return;
        }
        var indicesToDelete = [];
        var i;
        for (i = 0; i < cams.length; i++) {
            var camera = cams[i];
            var cameraName = camera.name;
            if (this._cameras.indexOf(camera) === -1) {
                this._cameras[cameraName] = camera;
            }
            else if (unique) {
                indicesToDelete.push(i);
            }
        }
        for (i = 0; i < indicesToDelete.length; i++) {
            cameras.splice(indicesToDelete[i], 1);
        }
        for (var renderEffectName in this._renderEffects) {
            if (this._renderEffects.hasOwnProperty(renderEffectName)) {
                this._renderEffects[renderEffectName]._attachCameras(cams);
            }
        }
    };
    /** @hidden */
    PostProcessRenderPipeline.prototype._detachCameras = function (cameras) {
        var cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
            return;
        }
        for (var renderEffectName in this._renderEffects) {
            if (this._renderEffects.hasOwnProperty(renderEffectName)) {
                this._renderEffects[renderEffectName]._detachCameras(cams);
            }
        }
        for (var i = 0; i < cams.length; i++) {
            this._cameras.splice(this._cameras.indexOf(cams[i]), 1);
        }
    };
    /** @hidden */
    PostProcessRenderPipeline.prototype._update = function () {
        for (var renderEffectName in this._renderEffects) {
            if (this._renderEffects.hasOwnProperty(renderEffectName)) {
                this._renderEffects[renderEffectName]._update();
            }
        }
        for (var i = 0; i < this._cameras.length; i++) {
            var cameraName = this._cameras[i].name;
            if (this._renderEffectsForIsolatedPass[cameraName]) {
                this._renderEffectsForIsolatedPass[cameraName]._update();
            }
        }
    };
    /** @hidden */
    PostProcessRenderPipeline.prototype._reset = function () {
        this._renderEffects = {};
        this._renderEffectsForIsolatedPass = new Array();
    };
    PostProcessRenderPipeline.prototype._enableMSAAOnFirstPostProcess = function (sampleCount) {
        // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)
        var effectKeys = Object.keys(this._renderEffects);
        if (this.engine.webGLVersion === 1) {
            return false;
        }
        if (effectKeys.length > 0) {
            var postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();
            if (postProcesses) {
                postProcesses[0].samples = sampleCount;
            }
        }
        return true;
    };
    /**
     * Disposes of the pipeline
     */
    PostProcessRenderPipeline.prototype.dispose = function () {
        // Must be implemented by children
    };
    __decorate([
        serialize()
    ], PostProcessRenderPipeline.prototype, "_name", void 0);
    return PostProcessRenderPipeline;
}());

/**
 * PostProcessRenderPipelineManager class
 * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
 */
var PostProcessRenderPipelineManager = /** @class */ (function () {
    /**
     * Initializes a PostProcessRenderPipelineManager
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
     */
    function PostProcessRenderPipelineManager() {
        this._renderPipelines = {};
    }
    Object.defineProperty(PostProcessRenderPipelineManager.prototype, "supportedPipelines", {
        /**
         * Gets the list of supported render pipelines
         */
        get: function () {
            var result = [];
            for (var renderPipelineName in this._renderPipelines) {
                if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {
                    var pipeline = this._renderPipelines[renderPipelineName];
                    if (pipeline.isSupported) {
                        result.push(pipeline);
                    }
                }
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a pipeline to the manager
     * @param renderPipeline The pipeline to add
     */
    PostProcessRenderPipelineManager.prototype.addPipeline = function (renderPipeline) {
        this._renderPipelines[renderPipeline._name] = renderPipeline;
    };
    /**
     * Attaches a camera to the pipeline
     * @param renderPipelineName The name of the pipeline to attach to
     * @param cameras the camera to attach
     * @param unique if the camera can be attached multiple times to the pipeline
     */
    PostProcessRenderPipelineManager.prototype.attachCamerasToRenderPipeline = function (renderPipelineName, cameras, unique) {
        if (unique === void 0) { unique = false; }
        var renderPipeline = this._renderPipelines[renderPipelineName];
        if (!renderPipeline) {
            return;
        }
        renderPipeline._attachCameras(cameras, unique);
    };
    /**
     * Detaches a camera from the pipeline
     * @param renderPipelineName The name of the pipeline to detach from
     * @param cameras the camera to detach
     */
    PostProcessRenderPipelineManager.prototype.detachCamerasFromRenderPipeline = function (renderPipelineName, cameras) {
        var renderPipeline = this._renderPipelines[renderPipelineName];
        if (!renderPipeline) {
            return;
        }
        renderPipeline._detachCameras(cameras);
    };
    /**
     * Enables an effect by name on a pipeline
     * @param renderPipelineName the name of the pipeline to enable the effect in
     * @param renderEffectName the name of the effect to enable
     * @param cameras the cameras that the effect should be enabled on
     */
    PostProcessRenderPipelineManager.prototype.enableEffectInPipeline = function (renderPipelineName, renderEffectName, cameras) {
        var renderPipeline = this._renderPipelines[renderPipelineName];
        if (!renderPipeline) {
            return;
        }
        renderPipeline._enableEffect(renderEffectName, cameras);
    };
    /**
     * Disables an effect by name on a pipeline
     * @param renderPipelineName the name of the pipeline to disable the effect in
     * @param renderEffectName the name of the effect to disable
     * @param cameras the cameras that the effect should be disabled on
     */
    PostProcessRenderPipelineManager.prototype.disableEffectInPipeline = function (renderPipelineName, renderEffectName, cameras) {
        var renderPipeline = this._renderPipelines[renderPipelineName];
        if (!renderPipeline) {
            return;
        }
        renderPipeline._disableEffect(renderEffectName, cameras);
    };
    /**
     * Updates the state of all contained render pipelines and disposes of any non supported pipelines
     */
    PostProcessRenderPipelineManager.prototype.update = function () {
        for (var renderPipelineName in this._renderPipelines) {
            if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {
                var pipeline = this._renderPipelines[renderPipelineName];
                if (!pipeline.isSupported) {
                    pipeline.dispose();
                    delete this._renderPipelines[renderPipelineName];
                }
                else {
                    pipeline._update();
                }
            }
        }
    };
    /** @hidden */
    PostProcessRenderPipelineManager.prototype._rebuild = function () {
        for (var renderPipelineName in this._renderPipelines) {
            if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {
                var pipeline = this._renderPipelines[renderPipelineName];
                pipeline._rebuild();
            }
        }
    };
    /**
     * Disposes of the manager and pipelines
     */
    PostProcessRenderPipelineManager.prototype.dispose = function () {
        for (var renderPipelineName in this._renderPipelines) {
            if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {
                var pipeline = this._renderPipelines[renderPipelineName];
                pipeline.dispose();
            }
        }
    };
    return PostProcessRenderPipelineManager;
}());

Object.defineProperty(Scene.prototype, "postProcessRenderPipelineManager", {
    get: function () {
        if (!this._postProcessRenderPipelineManager) {
            // Register the G Buffer component to the scene.
            var component = this._getComponent(SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER);
            if (!component) {
                component = new PostProcessRenderPipelineManagerSceneComponent(this);
                this._addComponent(component);
            }
            this._postProcessRenderPipelineManager = new PostProcessRenderPipelineManager();
        }
        return this._postProcessRenderPipelineManager;
    },
    enumerable: true,
    configurable: true
});
/**
 * Defines the Render Pipeline scene component responsible to rendering pipelines
 */
var PostProcessRenderPipelineManagerSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function PostProcessRenderPipelineManagerSceneComponent(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER;
        this.scene = scene;
    }
    /**
     * Registers the component in a given scene
     */
    PostProcessRenderPipelineManagerSceneComponent.prototype.register = function () {
        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER, this, this._gatherRenderTargets);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    PostProcessRenderPipelineManagerSceneComponent.prototype.rebuild = function () {
        if (this.scene._postProcessRenderPipelineManager) {
            this.scene._postProcessRenderPipelineManager._rebuild();
        }
    };
    /**
     * Disposes the component and the associated ressources
     */
    PostProcessRenderPipelineManagerSceneComponent.prototype.dispose = function () {
        if (this.scene._postProcessRenderPipelineManager) {
            this.scene._postProcessRenderPipelineManager.dispose();
        }
    };
    PostProcessRenderPipelineManagerSceneComponent.prototype._gatherRenderTargets = function () {
        if (this.scene._postProcessRenderPipelineManager) {
            this.scene._postProcessRenderPipelineManager.update();
        }
    };
    return PostProcessRenderPipelineManagerSceneComponent;
}());

/**
 * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
 * See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
 */
var DefaultRenderingPipeline = /** @class */ (function (_super) {
    __extends(DefaultRenderingPipeline, _super);
    /**
     * @constructor
     * @param name - The rendering pipeline name (default: "")
     * @param hdr - If high dynamic range textures should be used (default: true)
     * @param scene - The scene linked to this pipeline (default: the last created scene)
     * @param cameras - The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)
     * @param automaticBuild - if false, you will have to manually call prepare() to update the pipeline (default: true)
     */
    function DefaultRenderingPipeline(name, hdr, scene, cameras, automaticBuild) {
        if (name === void 0) { name = ""; }
        if (hdr === void 0) { hdr = true; }
        if (scene === void 0) { scene = EngineStore.LastCreatedScene; }
        if (automaticBuild === void 0) { automaticBuild = true; }
        var _this = _super.call(this, scene.getEngine(), name) || this;
        _this._camerasToBeAttached = [];
        /**
         * ID of the sharpen post process,
         */
        _this.SharpenPostProcessId = "SharpenPostProcessEffect";
        /**
         * @ignore
         * ID of the image processing post process;
         */
        _this.ImageProcessingPostProcessId = "ImageProcessingPostProcessEffect";
        /**
         * @ignore
         * ID of the Fast Approximate Anti-Aliasing post process;
         */
        _this.FxaaPostProcessId = "FxaaPostProcessEffect";
        /**
         * ID of the chromatic aberration post process,
         */
        _this.ChromaticAberrationPostProcessId = "ChromaticAberrationPostProcessEffect";
        /**
         * ID of the grain post process
         */
        _this.GrainPostProcessId = "GrainPostProcessEffect";
        /**
         * Glow post process which adds a glow to emissive areas of the image
         */
        _this._glowLayer = null;
        /**
         * Animations which can be used to tweak settings over a period of time
         */
        _this.animations = [];
        _this._imageProcessingConfigurationObserver = null;
        // Values
        _this._sharpenEnabled = false;
        _this._bloomEnabled = false;
        _this._depthOfFieldEnabled = false;
        _this._depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;
        _this._fxaaEnabled = false;
        _this._imageProcessingEnabled = true;
        _this._bloomScale = 0.5;
        _this._chromaticAberrationEnabled = false;
        _this._grainEnabled = false;
        _this._buildAllowed = true;
        _this._resizeObserver = null;
        _this._hardwareScaleLevel = 1.0;
        _this._bloomKernel = 64;
        /**
         * Specifies the weight of the bloom in the final rendering
         */
        _this._bloomWeight = 0.15;
        /**
         * Specifies the luma threshold for the area that will be blurred by the bloom
         */
        _this._bloomThreshold = 0.9;
        _this._samples = 1;
        _this._hasCleared = false;
        _this._prevPostProcess = null;
        _this._prevPrevPostProcess = null;
        _this._depthOfFieldSceneObserver = null;
        _this._cameras = cameras || scene.cameras;
        _this._cameras = _this._cameras.slice();
        _this._camerasToBeAttached = _this._cameras.slice();
        _this._buildAllowed = automaticBuild;
        // Initialize
        _this._scene = scene;
        var caps = _this._scene.getEngine().getCaps();
        _this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);
        // Misc
        if (_this._hdr) {
            if (caps.textureHalfFloatRender) {
                _this._defaultPipelineTextureType = Constants.TEXTURETYPE_HALF_FLOAT;
            }
            else if (caps.textureFloatRender) {
                _this._defaultPipelineTextureType = Constants.TEXTURETYPE_FLOAT;
            }
        }
        else {
            _this._defaultPipelineTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;
        }
        // Attach
        scene.postProcessRenderPipelineManager.addPipeline(_this);
        var engine = _this._scene.getEngine();
        // Create post processes before hand so they can be modified before enabled.
        // Block compilation flag is set to true to avoid compilation prior to use, these will be updated on first use in build pipeline.
        _this.sharpen = new SharpenPostProcess("sharpen", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, _this._defaultPipelineTextureType, true);
        _this._sharpenEffect = new PostProcessRenderEffect(engine, _this.SharpenPostProcessId, function () { return _this.sharpen; }, true);
        _this.depthOfField = new DepthOfFieldEffect(_this._scene, null, _this._depthOfFieldBlurLevel, _this._defaultPipelineTextureType, true);
        _this.bloom = new BloomEffect(_this._scene, _this._bloomScale, _this._bloomWeight, _this.bloomKernel, _this._defaultPipelineTextureType, true);
        _this.chromaticAberration = new ChromaticAberrationPostProcess("ChromaticAberration", engine.getRenderWidth(), engine.getRenderHeight(), 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, _this._defaultPipelineTextureType, true);
        _this._chromaticAberrationEffect = new PostProcessRenderEffect(engine, _this.ChromaticAberrationPostProcessId, function () { return _this.chromaticAberration; }, true);
        _this.grain = new GrainPostProcess("Grain", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, _this._defaultPipelineTextureType, true);
        _this._grainEffect = new PostProcessRenderEffect(engine, _this.GrainPostProcessId, function () { return _this.grain; }, true);
        _this._resizeObserver = engine.onResizeObservable.add(function () {
            _this._hardwareScaleLevel = engine.getHardwareScalingLevel();
            _this.bloomKernel = _this.bloomKernel;
        });
        _this._imageProcessingConfigurationObserver = _this._scene.imageProcessingConfiguration.onUpdateParameters.add(function () {
            _this.bloom._downscale._exposure = _this._scene.imageProcessingConfiguration.exposure;
        });
        _this._buildPipeline();
        return _this;
    }
    Object.defineProperty(DefaultRenderingPipeline.prototype, "scene", {
        /**
         * Gets active scene
         */
        get: function () {
            return this._scene;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "sharpenEnabled", {
        get: function () {
            return this._sharpenEnabled;
        },
        /**
         * Enable or disable the sharpen process from the pipeline
         */
        set: function (enabled) {
            if (this._sharpenEnabled === enabled) {
                return;
            }
            this._sharpenEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "bloomKernel", {
        /**
         * Specifies the size of the bloom blur kernel, relative to the final output size
         */
        get: function () {
            return this._bloomKernel;
        },
        set: function (value) {
            this._bloomKernel = value;
            this.bloom.kernel = value / this._hardwareScaleLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "bloomWeight", {
        get: function () {
            return this._bloomWeight;
        },
        /**
         * The strength of the bloom.
         */
        set: function (value) {
            if (this._bloomWeight === value) {
                return;
            }
            this.bloom.weight = value;
            this._bloomWeight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "bloomThreshold", {
        get: function () {
            return this._bloomThreshold;
        },
        /**
         * The strength of the bloom.
         */
        set: function (value) {
            if (this._bloomThreshold === value) {
                return;
            }
            this.bloom.threshold = value;
            this._bloomThreshold = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "bloomScale", {
        get: function () {
            return this._bloomScale;
        },
        /**
         * The scale of the bloom, lower value will provide better performance.
         */
        set: function (value) {
            if (this._bloomScale === value) {
                return;
            }
            this._bloomScale = value;
            // recreate bloom and dispose old as this setting is not dynamic
            this._rebuildBloom();
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "bloomEnabled", {
        get: function () {
            return this._bloomEnabled;
        },
        /**
         * Enable or disable the bloom from the pipeline
         */
        set: function (enabled) {
            if (this._bloomEnabled === enabled) {
                return;
            }
            this._bloomEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    DefaultRenderingPipeline.prototype._rebuildBloom = function () {
        // recreate bloom and dispose old as this setting is not dynamic
        var oldBloom = this.bloom;
        this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel, this._defaultPipelineTextureType, false);
        this.bloom.threshold = oldBloom.threshold;
        for (var i = 0; i < this._cameras.length; i++) {
            oldBloom.disposeEffects(this._cameras[i]);
        }
    };
    Object.defineProperty(DefaultRenderingPipeline.prototype, "depthOfFieldEnabled", {
        /**
         * If the depth of field is enabled.
         */
        get: function () {
            return this._depthOfFieldEnabled;
        },
        set: function (enabled) {
            if (this._depthOfFieldEnabled === enabled) {
                return;
            }
            this._depthOfFieldEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "depthOfFieldBlurLevel", {
        /**
         * Blur level of the depth of field effect. (Higher blur will effect performance)
         */
        get: function () {
            return this._depthOfFieldBlurLevel;
        },
        set: function (value) {
            if (this._depthOfFieldBlurLevel === value) {
                return;
            }
            this._depthOfFieldBlurLevel = value;
            // recreate dof and dispose old as this setting is not dynamic
            var oldDof = this.depthOfField;
            this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);
            this.depthOfField.focalLength = oldDof.focalLength;
            this.depthOfField.focusDistance = oldDof.focusDistance;
            this.depthOfField.fStop = oldDof.fStop;
            this.depthOfField.lensSize = oldDof.lensSize;
            for (var i = 0; i < this._cameras.length; i++) {
                oldDof.disposeEffects(this._cameras[i]);
            }
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "fxaaEnabled", {
        get: function () {
            return this._fxaaEnabled;
        },
        /**
         * If the anti aliasing is enabled.
         */
        set: function (enabled) {
            if (this._fxaaEnabled === enabled) {
                return;
            }
            this._fxaaEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "samples", {
        get: function () {
            return this._samples;
        },
        /**
         * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
         */
        set: function (sampleCount) {
            if (this._samples === sampleCount) {
                return;
            }
            this._samples = sampleCount;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "imageProcessingEnabled", {
        get: function () {
            return this._imageProcessingEnabled;
        },
        /**
         * If image processing is enabled.
         */
        set: function (enabled) {
            if (this._imageProcessingEnabled === enabled) {
                return;
            }
            this._imageProcessingEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "glowLayerEnabled", {
        get: function () {
            return this._glowLayer != null;
        },
        /**
         * If glow layer is enabled. (Adds a glow effect to emmissive materials)
         */
        set: function (enabled) {
            if (enabled && !this._glowLayer) {
                this._glowLayer = new GlowLayer("", this._scene);
            }
            else if (!enabled && this._glowLayer) {
                this._glowLayer.dispose();
                this._glowLayer = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "glowLayer", {
        /**
         * Gets the glow layer (or null if not defined)
         */
        get: function () {
            return this._glowLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "chromaticAberrationEnabled", {
        get: function () {
            return this._chromaticAberrationEnabled;
        },
        /**
         * Enable or disable the chromaticAberration process from the pipeline
         */
        set: function (enabled) {
            if (this._chromaticAberrationEnabled === enabled) {
                return;
            }
            this._chromaticAberrationEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderingPipeline.prototype, "grainEnabled", {
        get: function () {
            return this._grainEnabled;
        },
        /**
         * Enable or disable the grain process from the pipeline
         */
        set: function (enabled) {
            if (this._grainEnabled === enabled) {
                return;
            }
            this._grainEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the class name
     * @returns "DefaultRenderingPipeline"
     */
    DefaultRenderingPipeline.prototype.getClassName = function () {
        return "DefaultRenderingPipeline";
    };
    /**
     * Force the compilation of the entire pipeline.
     */
    DefaultRenderingPipeline.prototype.prepare = function () {
        var previousState = this._buildAllowed;
        this._buildAllowed = true;
        this._buildPipeline();
        this._buildAllowed = previousState;
    };
    DefaultRenderingPipeline.prototype._setAutoClearAndTextureSharing = function (postProcess, skipTextureSharing) {
        if (skipTextureSharing === void 0) { skipTextureSharing = false; }
        if (this._hasCleared) {
            postProcess.autoClear = false;
        }
        else {
            postProcess.autoClear = true;
            this._scene.autoClear = false;
            this._hasCleared = true;
        }
        if (!skipTextureSharing) {
            if (this._prevPrevPostProcess) {
                postProcess.shareOutputWith(this._prevPrevPostProcess);
            }
            else {
                postProcess.useOwnOutput();
            }
            if (this._prevPostProcess) {
                this._prevPrevPostProcess = this._prevPostProcess;
            }
            this._prevPostProcess = postProcess;
        }
    };
    DefaultRenderingPipeline.prototype._buildPipeline = function () {
        var _this = this;
        if (!this._buildAllowed) {
            return;
        }
        this._scene.autoClear = true;
        var engine = this._scene.getEngine();
        this._disposePostProcesses();
        if (this._cameras !== null) {
            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
            // get back cameras to be used to reattach pipeline
            this._cameras = this._camerasToBeAttached.slice();
        }
        this._reset();
        this._prevPostProcess = null;
        this._prevPrevPostProcess = null;
        this._hasCleared = false;
        if (this.depthOfFieldEnabled) {
            // Multi camera suport
            if (this._cameras.length > 1) {
                for (var _i = 0, _a = this._cameras; _i < _a.length; _i++) {
                    var camera = _a[_i];
                    var depthRenderer = this._scene.enableDepthRenderer(camera);
                    depthRenderer.useOnlyInActiveCamera = true;
                }
                this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add(function (scene) {
                    if (_this._cameras.indexOf(scene.activeCamera) > -1) {
                        _this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();
                    }
                });
            }
            else {
                this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
                var depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);
                this.depthOfField.depthTexture = depthRenderer.getDepthMap();
            }
            if (!this.depthOfField._isReady()) {
                this.depthOfField._updateEffects();
            }
            this.addEffect(this.depthOfField);
            this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);
        }
        else {
            this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
        }
        if (this.bloomEnabled) {
            if (!this.bloom._isReady()) {
                this.bloom._updateEffects();
            }
            this.addEffect(this.bloom);
            this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);
        }
        if (this._imageProcessingEnabled) {
            this.imageProcessing = new ImageProcessingPostProcess("imageProcessing", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);
            if (this._hdr) {
                this.addEffect(new PostProcessRenderEffect(engine, this.ImageProcessingPostProcessId, function () { return _this.imageProcessing; }, true));
                this._setAutoClearAndTextureSharing(this.imageProcessing);
            }
            else {
                this._scene.imageProcessingConfiguration.applyByPostProcess = false;
            }
        }
        if (this.sharpenEnabled) {
            if (!this.sharpen.isReady()) {
                this.sharpen.updateEffect();
            }
            this.addEffect(this._sharpenEffect);
            this._setAutoClearAndTextureSharing(this.sharpen);
        }
        if (this.grainEnabled) {
            if (!this.grain.isReady()) {
                this.grain.updateEffect();
            }
            this.addEffect(this._grainEffect);
            this._setAutoClearAndTextureSharing(this.grain);
        }
        if (this.chromaticAberrationEnabled) {
            if (!this.chromaticAberration.isReady()) {
                this.chromaticAberration.updateEffect();
            }
            this.addEffect(this._chromaticAberrationEffect);
            this._setAutoClearAndTextureSharing(this.chromaticAberration);
        }
        if (this.fxaaEnabled) {
            this.fxaa = new FxaaPostProcess("fxaa", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);
            this.addEffect(new PostProcessRenderEffect(engine, this.FxaaPostProcessId, function () { return _this.fxaa; }, true));
            this._setAutoClearAndTextureSharing(this.fxaa, true);
        }
        if (this._cameras !== null) {
            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);
        }
        if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {
            Logger.Warn("MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0");
        }
    };
    DefaultRenderingPipeline.prototype._disposePostProcesses = function (disposeNonRecreated) {
        if (disposeNonRecreated === void 0) { disposeNonRecreated = false; }
        for (var i = 0; i < this._cameras.length; i++) {
            var camera = this._cameras[i];
            if (this.imageProcessing) {
                this.imageProcessing.dispose(camera);
            }
            if (this.fxaa) {
                this.fxaa.dispose(camera);
            }
            // These are created in the constructor and should not be disposed on every pipeline change
            if (disposeNonRecreated) {
                if (this.sharpen) {
                    this.sharpen.dispose(camera);
                }
                if (this.depthOfField) {
                    this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
                    this.depthOfField.disposeEffects(camera);
                }
                if (this.bloom) {
                    this.bloom.disposeEffects(camera);
                }
                if (this.chromaticAberration) {
                    this.chromaticAberration.dispose(camera);
                }
                if (this.grain) {
                    this.grain.dispose(camera);
                }
                if (this._glowLayer) {
                    this._glowLayer.dispose();
                }
            }
        }
        this.imageProcessing = null;
        this.fxaa = null;
        if (disposeNonRecreated) {
            this.sharpen = null;
            this._sharpenEffect = null;
            this.depthOfField = null;
            this.bloom = null;
            this.chromaticAberration = null;
            this._chromaticAberrationEffect = null;
            this.grain = null;
            this._grainEffect = null;
            this._glowLayer = null;
        }
    };
    /**
     * Adds a camera to the pipeline
     * @param camera the camera to be added
     */
    DefaultRenderingPipeline.prototype.addCamera = function (camera) {
        this._camerasToBeAttached.push(camera);
        this._buildPipeline();
    };
    /**
     * Removes a camera from the pipeline
     * @param camera the camera to remove
     */
    DefaultRenderingPipeline.prototype.removeCamera = function (camera) {
        var index = this._camerasToBeAttached.indexOf(camera);
        this._camerasToBeAttached.splice(index, 1);
        this._buildPipeline();
    };
    /**
     * Dispose of the pipeline and stop all post processes
     */
    DefaultRenderingPipeline.prototype.dispose = function () {
        this._disposePostProcesses(true);
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
        this._scene.autoClear = true;
        if (this._resizeObserver) {
            this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);
            this._resizeObserver = null;
        }
        this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);
        _super.prototype.dispose.call(this);
    };
    /**
     * Serialize the rendering pipeline (Used when exporting)
     * @returns the serialized object
     */
    DefaultRenderingPipeline.prototype.serialize = function () {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "DefaultRenderingPipeline";
        return serializationObject;
    };
    /**
     * Parse the serialized pipeline
     * @param source Source pipeline.
     * @param scene The scene to load the pipeline to.
     * @param rootUrl The URL of the serialized pipeline.
     * @returns An instantiated pipeline from the serialized object.
     */
    DefaultRenderingPipeline.Parse = function (source, scene, rootUrl) {
        return SerializationHelper.Parse(function () { return new DefaultRenderingPipeline(source._name, source._name._hdr, scene); }, source, scene, rootUrl);
    };
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "sharpenEnabled", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "bloomKernel", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "_bloomWeight", void 0);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "_bloomThreshold", void 0);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "_hdr", void 0);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "bloomWeight", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "bloomThreshold", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "bloomScale", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "bloomEnabled", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "depthOfFieldEnabled", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "depthOfFieldBlurLevel", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "fxaaEnabled", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "samples", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "imageProcessingEnabled", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "glowLayerEnabled", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "chromaticAberrationEnabled", null);
    __decorate([
        serialize()
    ], DefaultRenderingPipeline.prototype, "grainEnabled", null);
    return DefaultRenderingPipeline;
}(PostProcessRenderPipeline));
_TypeStore.RegisteredTypes["BABYLON.DefaultRenderingPipeline"] = DefaultRenderingPipeline;

var name$X = 'lensHighlightsPixelShader';
var shader$X = "\nuniform sampler2D textureSampler;\n\nuniform float gain;\nuniform float threshold;\nuniform float screen_width;\nuniform float screen_height;\n\nvarying vec2 vUV;\n\nvec4 highlightColor(vec4 color) {\nvec4 highlight=color;\nfloat luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));\nfloat lum_threshold;\nif (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }\nelse { lum_threshold=0.5+0.44*threshold; }\nluminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);\nhighlight*=luminance*gain;\nhighlight.a=1.0;\nreturn highlight;\n}\nvoid main(void)\n{\nvec4 original=texture2D(textureSampler,vUV);\n\nif (gain == -1.0) {\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\nreturn;\n}\nfloat w=2.0/screen_width;\nfloat h=2.0/screen_height;\nfloat weight=1.0;\n\nvec4 blurred=vec4(0.0,0.0,0.0,0.0);\n#ifdef PENTAGON\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));\n#else\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));\n#endif\nblurred/=39.0;\ngl_FragColor=blurred;\n\n}";
Effect.ShadersStore[name$X] = shader$X;

var name$Y = 'depthOfFieldPixelShader';
var shader$Y = "\n\n\n\n\nuniform sampler2D textureSampler;\nuniform sampler2D highlightsSampler;\nuniform sampler2D depthSampler;\nuniform sampler2D grainSampler;\n\nuniform float grain_amount;\nuniform bool blur_noise;\nuniform float screen_width;\nuniform float screen_height;\nuniform float distortion;\nuniform bool dof_enabled;\n\nuniform float screen_distance;\nuniform float aperture;\nuniform float darken;\nuniform float edge_blur;\nuniform bool highlights;\n\nuniform float near;\nuniform float far;\n\nvarying vec2 vUV;\n\n#define PI 3.14159265\n#define TWOPI 6.28318530\n#define inverse_focal_length 0.1\n\nvec2 centered_screen_pos;\nvec2 distorted_coords;\nfloat radius2;\nfloat radius;\n\nvec2 rand(vec2 co)\n{\nfloat noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));\nfloat noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));\nreturn clamp(vec2(noise1,noise2),0.0,1.0);\n}\n\nvec2 getDistortedCoords(vec2 coords) {\nif (distortion == 0.0) { return coords; }\nvec2 direction=1.0*normalize(centered_screen_pos);\nvec2 dist_coords=vec2(0.5,0.5);\ndist_coords.x=0.5+direction.x*radius2*1.0;\ndist_coords.y=0.5+direction.y*radius2*1.0;\nfloat dist_amount=clamp(distortion*0.23,0.0,1.0);\ndist_coords=mix(coords,dist_coords,dist_amount);\nreturn dist_coords;\n}\n\nfloat sampleScreen(inout vec4 color,const in vec2 offset,const in float weight) {\n\nvec2 coords=distorted_coords;\nfloat angle=rand(coords*100.0).x*TWOPI;\ncoords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));\ncolor+=texture2D(textureSampler,coords)*weight;\nreturn weight;\n}\n\nfloat getBlurLevel(float size) {\nreturn min(3.0,ceil(size/1.0));\n}\n\nvec4 getBlurColor(float size) {\nvec4 col=texture2D(textureSampler,distorted_coords);\nif (size == 0.0) { return col; }\n\n\nfloat blur_level=getBlurLevel(size);\nfloat w=(size/screen_width);\nfloat h=(size/screen_height);\nfloat total_weight=1.0;\nvec2 sample_coords;\ntotal_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);\ntotal_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);\ntotal_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);\ntotal_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);\ntotal_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);\ntotal_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);\ntotal_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);\ntotal_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);\ntotal_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);\nif (blur_level>1.0) {\ntotal_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);\ntotal_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);\ntotal_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);\ntotal_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);\ntotal_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);\ntotal_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);\ntotal_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);\ntotal_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);\ntotal_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);\n}\nif (blur_level>2.0) {\ntotal_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);\ntotal_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);\ntotal_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);\ntotal_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);\ntotal_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);\ntotal_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);\ntotal_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);\ntotal_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);\ntotal_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);\n}\ncol/=total_weight;\n\nif (darken>0.0) {\ncol.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);\n}\n\n\n\n\nreturn col;\n}\nvoid main(void)\n{\n\ncentered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);\nradius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;\nradius=sqrt(radius2);\ndistorted_coords=getDistortedCoords(vUV);\nvec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height);\nfloat depth=texture2D(depthSampler,distorted_coords).r;\nfloat distance=near+(far-near)*depth;\nvec4 color=texture2D(textureSampler,vUV);\n\n\nfloat coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));\n\nif (dof_enabled == false || coc<0.07) { coc=0.0; }\n\nfloat edge_blur_amount=0.0;\nif (edge_blur>0.0) {\nedge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;\n}\n\nfloat blur_amount=max(edge_blur_amount,coc);\n\nif (blur_amount == 0.0) {\ngl_FragColor=texture2D(textureSampler,distorted_coords);\n}\nelse {\n\ngl_FragColor=getBlurColor(blur_amount*1.7);\n\nif (highlights) {\ngl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;\n}\nif (blur_noise) {\n\nvec2 noise=rand(distorted_coords)*0.01*blur_amount;\nvec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);\ngl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;\n}\n}\n\nif (grain_amount>0.0) {\nvec4 grain_color=texture2D(grainSampler,texels_coords*0.003);\ngl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;\n}\n}\n";
Effect.ShadersStore[name$Y] = shader$Y;

/**
 * BABYLON.JS Chromatic Aberration GLSL Shader
 * Author: Olivier Guyot
 * Separates very slightly R, G and B colors on the edges of the screen
 * Inspired by Francois Tarlier & Martins Upitis
 */
var LensRenderingPipeline = /** @class */ (function (_super) {
    __extends(LensRenderingPipeline, _super);
    /**
     * @constructor
     *
     * Effect parameters are as follow:
     * {
     *      chromatic_aberration: number;       // from 0 to x (1 for realism)
     *      edge_blur: number;                  // from 0 to x (1 for realism)
     *      distortion: number;                 // from 0 to x (1 for realism)
     *      grain_amount: number;               // from 0 to 1
     *      grain_texture: BABYLON.Texture;     // texture to use for grain effect; if unset, use random B&W noise
     *      dof_focus_distance: number;         // depth-of-field: focus distance; unset to disable (disabled by default)
     *      dof_aperture: number;               // depth-of-field: focus blur bias (default: 1)
     *      dof_darken: number;                 // depth-of-field: darken that which is out of focus (from 0 to 1, disabled by default)
     *      dof_pentagon: boolean;              // depth-of-field: makes a pentagon-like "bokeh" effect
     *      dof_gain: number;                   // depth-of-field: highlights gain; unset to disable (disabled by default)
     *      dof_threshold: number;              // depth-of-field: highlights threshold (default: 1)
     *      blur_noise: boolean;                // add a little bit of noise to the blur (default: true)
     * }
     * Note: if an effect parameter is unset, effect is disabled
     *
     * @param name The rendering pipeline name
     * @param parameters - An object containing all parameters (see above)
     * @param scene The scene linked to this pipeline
     * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
     * @param cameras The array of cameras that the rendering pipeline will be attached to
     */
    function LensRenderingPipeline(name, parameters, scene, ratio, cameras) {
        if (ratio === void 0) { ratio = 1.0; }
        var _this = _super.call(this, scene.getEngine(), name) || this;
        // Lens effects can be of the following:
        // - chromatic aberration (slight shift of RGB colors)
        // - blur on the edge of the lens
        // - lens distortion
        // - depth-of-field blur & highlights enhancing
        // - depth-of-field 'bokeh' effect (shapes appearing in blurred areas)
        // - grain effect (noise or custom texture)
        // Two additional texture samplers are needed:
        // - depth map (for depth-of-field)
        // - grain texture
        /**
         * @ignore
         * The chromatic aberration PostProcess id in the pipeline
         */
        _this.LensChromaticAberrationEffect = "LensChromaticAberrationEffect";
        /**
         * @ignore
         * The highlights enhancing PostProcess id in the pipeline
         */
        _this.HighlightsEnhancingEffect = "HighlightsEnhancingEffect";
        /**
         * @ignore
        * The depth-of-field PostProcess id in the pipeline
        */
        _this.LensDepthOfFieldEffect = "LensDepthOfFieldEffect";
        _this._pentagonBokehIsEnabled = false;
        _this._scene = scene;
        // Fetch texture samplers
        _this._depthTexture = scene.enableDepthRenderer().getDepthMap(); // Force depth renderer "on"
        if (parameters.grain_texture) {
            _this._grainTexture = parameters.grain_texture;
        }
        else {
            _this._createGrainTexture();
        }
        // save parameters
        _this._edgeBlur = parameters.edge_blur ? parameters.edge_blur : 0;
        _this._grainAmount = parameters.grain_amount ? parameters.grain_amount : 0;
        _this._chromaticAberration = parameters.chromatic_aberration ? parameters.chromatic_aberration : 0;
        _this._distortion = parameters.distortion ? parameters.distortion : 0;
        _this._highlightsGain = parameters.dof_gain !== undefined ? parameters.dof_gain : -1;
        _this._highlightsThreshold = parameters.dof_threshold ? parameters.dof_threshold : 1;
        _this._dofDistance = parameters.dof_focus_distance !== undefined ? parameters.dof_focus_distance : -1;
        _this._dofAperture = parameters.dof_aperture ? parameters.dof_aperture : 1;
        _this._dofDarken = parameters.dof_darken ? parameters.dof_darken : 0;
        _this._dofPentagon = parameters.dof_pentagon !== undefined ? parameters.dof_pentagon : true;
        _this._blurNoise = parameters.blur_noise !== undefined ? parameters.blur_noise : true;
        // Create effects
        _this._createChromaticAberrationPostProcess(ratio);
        _this._createHighlightsPostProcess(ratio);
        _this._createDepthOfFieldPostProcess(ratio / 4);
        // Set up pipeline
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.LensChromaticAberrationEffect, function () { return _this._chromaticAberrationPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.HighlightsEnhancingEffect, function () { return _this._highlightsPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.LensDepthOfFieldEffect, function () { return _this._depthOfFieldPostProcess; }, true));
        if (_this._highlightsGain === -1) {
            _this._disableEffect(_this.HighlightsEnhancingEffect, null);
        }
        // Finish
        scene.postProcessRenderPipelineManager.addPipeline(_this);
        if (cameras) {
            scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name, cameras);
        }
        return _this;
    }
    /**
     * Get the class name
     * @returns "LensRenderingPipeline"
     */
    LensRenderingPipeline.prototype.getClassName = function () {
        return "LensRenderingPipeline";
    };
    Object.defineProperty(LensRenderingPipeline.prototype, "scene", {
        // Properties
        /**
         * Gets associated scene
         */
        get: function () {
            return this._scene;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "edgeBlur", {
        /**
         * Gets or sets the edge blur
         */
        get: function () {
            return this._edgeBlur;
        },
        set: function (value) {
            this.setEdgeBlur(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "grainAmount", {
        /**
         * Gets or sets the grain amount
         */
        get: function () {
            return this._grainAmount;
        },
        set: function (value) {
            this.setGrainAmount(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "chromaticAberration", {
        /**
         * Gets or sets the chromatic aberration amount
         */
        get: function () {
            return this._chromaticAberration;
        },
        set: function (value) {
            this.setChromaticAberration(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "dofAperture", {
        /**
         * Gets or sets the depth of field aperture
         */
        get: function () {
            return this._dofAperture;
        },
        set: function (value) {
            this.setAperture(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "edgeDistortion", {
        /**
         * Gets or sets the edge distortion
         */
        get: function () {
            return this._distortion;
        },
        set: function (value) {
            this.setEdgeDistortion(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "dofDistortion", {
        /**
         * Gets or sets the depth of field distortion
         */
        get: function () {
            return this._dofDistance;
        },
        set: function (value) {
            this.setFocusDistance(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "darkenOutOfFocus", {
        /**
         * Gets or sets the darken out of focus amount
         */
        get: function () {
            return this._dofDarken;
        },
        set: function (value) {
            this.setDarkenOutOfFocus(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "blurNoise", {
        /**
         * Gets or sets a boolean indicating if blur noise is enabled
         */
        get: function () {
            return this._blurNoise;
        },
        set: function (value) {
            this._blurNoise = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "pentagonBokeh", {
        /**
         * Gets or sets a boolean indicating if pentagon bokeh is enabled
         */
        get: function () {
            return this._pentagonBokehIsEnabled;
        },
        set: function (value) {
            if (value) {
                this.enablePentagonBokeh();
            }
            else {
                this.disablePentagonBokeh();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "highlightsGain", {
        /**
         * Gets or sets the highlight grain amount
         */
        get: function () {
            return this._highlightsGain;
        },
        set: function (value) {
            this.setHighlightsGain(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LensRenderingPipeline.prototype, "highlightsThreshold", {
        /**
         * Gets or sets the highlight threshold
         */
        get: function () {
            return this._highlightsThreshold;
        },
        set: function (value) {
            this.setHighlightsThreshold(value);
        },
        enumerable: true,
        configurable: true
    });
    // public methods (self explanatory)
    /**
     * Sets the amount of blur at the edges
     * @param amount blur amount
     */
    LensRenderingPipeline.prototype.setEdgeBlur = function (amount) { this._edgeBlur = amount; };
    /**
     * Sets edge blur to 0
     */
    LensRenderingPipeline.prototype.disableEdgeBlur = function () { this._edgeBlur = 0; };
    /**
     * Sets the amout of grain
     * @param amount Amount of grain
     */
    LensRenderingPipeline.prototype.setGrainAmount = function (amount) { this._grainAmount = amount; };
    /**
     * Set grain amount to 0
     */
    LensRenderingPipeline.prototype.disableGrain = function () { this._grainAmount = 0; };
    /**
     * Sets the chromatic aberration amount
     * @param amount amount of chromatic aberration
     */
    LensRenderingPipeline.prototype.setChromaticAberration = function (amount) { this._chromaticAberration = amount; };
    /**
     * Sets chromatic aberration amount to 0
     */
    LensRenderingPipeline.prototype.disableChromaticAberration = function () { this._chromaticAberration = 0; };
    /**
     * Sets the EdgeDistortion amount
     * @param amount amount of EdgeDistortion
     */
    LensRenderingPipeline.prototype.setEdgeDistortion = function (amount) { this._distortion = amount; };
    /**
     * Sets edge distortion to 0
     */
    LensRenderingPipeline.prototype.disableEdgeDistortion = function () { this._distortion = 0; };
    /**
     * Sets the FocusDistance amount
     * @param amount amount of FocusDistance
     */
    LensRenderingPipeline.prototype.setFocusDistance = function (amount) { this._dofDistance = amount; };
    /**
    * Disables depth of field
    */
    LensRenderingPipeline.prototype.disableDepthOfField = function () { this._dofDistance = -1; };
    /**
     * Sets the Aperture amount
     * @param amount amount of Aperture
     */
    LensRenderingPipeline.prototype.setAperture = function (amount) { this._dofAperture = amount; };
    /**
     * Sets the DarkenOutOfFocus amount
     * @param amount amount of DarkenOutOfFocus
     */
    LensRenderingPipeline.prototype.setDarkenOutOfFocus = function (amount) { this._dofDarken = amount; };
    /**
     * Creates a pentagon bokeh effect
     */
    LensRenderingPipeline.prototype.enablePentagonBokeh = function () {
        this._highlightsPostProcess.updateEffect("#define PENTAGON\n");
        this._pentagonBokehIsEnabled = true;
    };
    /**
     * Disables the pentagon bokeh effect
     */
    LensRenderingPipeline.prototype.disablePentagonBokeh = function () {
        this._pentagonBokehIsEnabled = false;
        this._highlightsPostProcess.updateEffect();
    };
    /**
     * Enables noise blur
     */
    LensRenderingPipeline.prototype.enableNoiseBlur = function () { this._blurNoise = true; };
    /**
     * Disables noise blur
     */
    LensRenderingPipeline.prototype.disableNoiseBlur = function () { this._blurNoise = false; };
    /**
     * Sets the HighlightsGain amount
     * @param amount amount of HighlightsGain
     */
    LensRenderingPipeline.prototype.setHighlightsGain = function (amount) {
        this._highlightsGain = amount;
    };
    /**
     * Sets the HighlightsThreshold amount
     * @param amount amount of HighlightsThreshold
     */
    LensRenderingPipeline.prototype.setHighlightsThreshold = function (amount) {
        if (this._highlightsGain === -1) {
            this._highlightsGain = 1.0;
        }
        this._highlightsThreshold = amount;
    };
    /**
     * Disables highlights
     */
    LensRenderingPipeline.prototype.disableHighlights = function () {
        this._highlightsGain = -1;
    };
    /**
     * Removes the internal pipeline assets and detaches the pipeline from the scene cameras
     * @param disableDepthRender If the scens depth rendering should be disabled (default: false)
     */
    LensRenderingPipeline.prototype.dispose = function (disableDepthRender) {
        if (disableDepthRender === void 0) { disableDepthRender = false; }
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
        this._chromaticAberrationPostProcess = null;
        this._highlightsPostProcess = null;
        this._depthOfFieldPostProcess = null;
        this._grainTexture.dispose();
        if (disableDepthRender) {
            this._scene.disableDepthRenderer();
        }
    };
    // colors shifting and distortion
    LensRenderingPipeline.prototype._createChromaticAberrationPostProcess = function (ratio) {
        var _this = this;
        this._chromaticAberrationPostProcess = new PostProcess("LensChromaticAberration", "chromaticAberration", ["chromatic_aberration", "screen_width", "screen_height", "direction", "radialIntensity", "centerPosition"], // uniforms
        [], // samplers
        ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
        this._chromaticAberrationPostProcess.onApply = function (effect) {
            effect.setFloat('chromatic_aberration', _this._chromaticAberration);
            effect.setFloat('screen_width', _this._scene.getEngine().getRenderWidth());
            effect.setFloat('screen_height', _this._scene.getEngine().getRenderHeight());
            effect.setFloat('radialIntensity', 1);
            effect.setFloat2('direction', 17, 17);
            effect.setFloat2('centerPosition', 0.5, 0.5);
        };
    };
    // highlights enhancing
    LensRenderingPipeline.prototype._createHighlightsPostProcess = function (ratio) {
        var _this = this;
        this._highlightsPostProcess = new PostProcess("LensHighlights", "lensHighlights", ["gain", "threshold", "screen_width", "screen_height"], // uniforms
        [], // samplers
        ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, this._dofPentagon ? "#define PENTAGON\n" : "");
        this._highlightsPostProcess.onApply = function (effect) {
            effect.setFloat('gain', _this._highlightsGain);
            effect.setFloat('threshold', _this._highlightsThreshold);
            effect.setTextureFromPostProcess("textureSampler", _this._chromaticAberrationPostProcess);
            effect.setFloat('screen_width', _this._scene.getEngine().getRenderWidth());
            effect.setFloat('screen_height', _this._scene.getEngine().getRenderHeight());
        };
    };
    // colors shifting and distortion
    LensRenderingPipeline.prototype._createDepthOfFieldPostProcess = function (ratio) {
        var _this = this;
        this._depthOfFieldPostProcess = new PostProcess("LensDepthOfField", "depthOfField", [
            "grain_amount", "blur_noise", "screen_width", "screen_height", "distortion", "dof_enabled",
            "screen_distance", "aperture", "darken", "edge_blur", "highlights", "near", "far"
        ], ["depthSampler", "grainSampler", "highlightsSampler"], ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
        this._depthOfFieldPostProcess.onApply = function (effect) {
            effect.setTexture("depthSampler", _this._depthTexture);
            effect.setTexture("grainSampler", _this._grainTexture);
            effect.setTextureFromPostProcess("textureSampler", _this._highlightsPostProcess);
            effect.setTextureFromPostProcess("highlightsSampler", _this._depthOfFieldPostProcess);
            effect.setFloat('grain_amount', _this._grainAmount);
            effect.setBool('blur_noise', _this._blurNoise);
            effect.setFloat('screen_width', _this._scene.getEngine().getRenderWidth());
            effect.setFloat('screen_height', _this._scene.getEngine().getRenderHeight());
            effect.setFloat('distortion', _this._distortion);
            effect.setBool('dof_enabled', (_this._dofDistance !== -1));
            effect.setFloat('screen_distance', 1.0 / (0.1 - 1.0 / _this._dofDistance));
            effect.setFloat('aperture', _this._dofAperture);
            effect.setFloat('darken', _this._dofDarken);
            effect.setFloat('edge_blur', _this._edgeBlur);
            effect.setBool('highlights', (_this._highlightsGain !== -1));
            if (_this._scene.activeCamera) {
                effect.setFloat('near', _this._scene.activeCamera.minZ);
                effect.setFloat('far', _this._scene.activeCamera.maxZ);
            }
        };
    };
    // creates a black and white random noise texture, 512x512
    LensRenderingPipeline.prototype._createGrainTexture = function () {
        var size = 512;
        this._grainTexture = new DynamicTexture("LensNoiseTexture", size, this._scene, false, Texture.BILINEAR_SAMPLINGMODE);
        this._grainTexture.wrapU = Texture.WRAP_ADDRESSMODE;
        this._grainTexture.wrapV = Texture.WRAP_ADDRESSMODE;
        var context = this._grainTexture.getContext();
        var rand = function (min, max) {
            return Math.random() * (max - min) + min;
        };
        var value;
        for (var x = 0; x < size; x++) {
            for (var y = 0; y < size; y++) {
                value = Math.floor(rand(0.42, 0.58) * 255);
                context.fillStyle = 'rgb(' + value + ', ' + value + ', ' + value + ')';
                context.fillRect(x, y, 1, 1);
            }
        }
        this._grainTexture.update(false);
    };
    return LensRenderingPipeline;
}(PostProcessRenderPipeline));

var name$Z = 'ssao2PixelShader';
var shader$Z = "\nprecision highp float;\nuniform sampler2D textureSampler;\nuniform float near;\nuniform float far;\nuniform float radius;\nfloat scales[16]=float[16](\n0.1,\n0.11406250000000001,\n0.131640625,\n0.15625,\n0.187890625,\n0.2265625,\n0.272265625,\n0.325,\n0.384765625,\n0.4515625,\n0.525390625,\n0.60625,\n0.694140625,\n0.7890625,\n0.891015625,\n1.0\n);\nvarying vec2 vUV;\nfloat perspectiveDepthToViewZ( const in float invClipZ,const in float near,const in float far ) {\nreturn ( near*far )/( ( far-near )*invClipZ-far );\n}\nfloat viewZToPerspectiveDepth( const in float viewZ,const in float near,const in float far ) {\nreturn ( near*far/viewZ+far)/( far-near );\n}\nfloat viewZToOrthographicDepth( const in float viewZ,const in float near,const in float far ) {\nreturn ( viewZ+near )/( near-far );\n}\n#ifdef SSAO\nuniform sampler2D randomSampler;\nuniform sampler2D normalSampler;\nuniform float randTextureTiles;\nuniform float samplesFactor;\nuniform vec3 sampleSphere[SAMPLES];\nuniform float totalStrength;\nuniform float base;\nuniform float xViewport;\nuniform float yViewport;\nuniform float maxZ;\nuniform float minZAspect;\nuniform vec2 texelSize;\nuniform mat4 projection;\nvoid main()\n{\nvec3 random=texture2D(randomSampler,vUV*randTextureTiles).rgb;\nfloat depth=texture2D(textureSampler,vUV).r;\nfloat depthSign=depth/abs(depth);\ndepth=depth*depthSign;\nvec3 normal=texture2D(normalSampler,vUV).rgb;\nfloat occlusion=0.0;\nfloat correctedRadius=min(radius,minZAspect*depth/near);\nvec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);\nvec3 origin=vViewRay*depth;\nvec3 rvec=random*2.0-1.0;\nrvec.z=0.0;\n\nfloat dotProduct=dot(rvec,normal);\nrvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);\nvec3 tangent=normalize(rvec-normal*dot(rvec,normal));\nvec3 bitangent=cross(normal,tangent);\nmat3 tbn=mat3(tangent,bitangent,normal);\nfloat difference;\nfor (int i=0; i<SAMPLES; ++i) {\n\nvec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];\nsamplePosition=samplePosition*correctedRadius+origin;\n\nvec4 offset=vec4(samplePosition,1.0);\noffset=projection*offset;\noffset.xyz/=offset.w;\noffset.xy=offset.xy*0.5+0.5;\nif (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {\ncontinue;\n}\n\nfloat sampleDepth=abs(texture2D(textureSampler,offset.xy).r);\n\ndifference=depthSign*samplePosition.z-sampleDepth;\nfloat rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);\nocclusion+=(difference>=0.0 ? 1.0 : 0.0)*rangeCheck;\n}\nocclusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\nfloat result=clamp(ao+base,0.0,1.0);\ngl_FragColor=vec4(vec3(result),1.0);\n}\n#endif\n#ifdef BILATERAL_BLUR\nuniform sampler2D depthSampler;\nuniform float outSize;\nuniform float samplerOffsets[SAMPLES];\nvec4 blur9(sampler2D image,vec2 uv,float resolution,vec2 direction) {\nvec4 color=vec4(0.0);\nvec2 off1=vec2(1.3846153846)*direction;\nvec2 off2=vec2(3.2307692308)*direction;\ncolor+=texture2D(image,uv)*0.2270270270;\ncolor+=texture2D(image,uv+(off1/resolution))*0.3162162162;\ncolor+=texture2D(image,uv-(off1/resolution))*0.3162162162;\ncolor+=texture2D(image,uv+(off2/resolution))*0.0702702703;\ncolor+=texture2D(image,uv-(off2/resolution))*0.0702702703;\nreturn color;\n}\nvec4 blur13(sampler2D image,vec2 uv,float resolution,vec2 direction) {\nvec4 color=vec4(0.0);\nvec2 off1=vec2(1.411764705882353)*direction;\nvec2 off2=vec2(3.2941176470588234)*direction;\nvec2 off3=vec2(5.176470588235294)*direction;\ncolor+=texture2D(image,uv)*0.1964825501511404;\ncolor+=texture2D(image,uv+(off1/resolution))*0.2969069646728344;\ncolor+=texture2D(image,uv-(off1/resolution))*0.2969069646728344;\ncolor+=texture2D(image,uv+(off2/resolution))*0.09447039785044732;\ncolor+=texture2D(image,uv-(off2/resolution))*0.09447039785044732;\ncolor+=texture2D(image,uv+(off3/resolution))*0.010381362401148057;\ncolor+=texture2D(image,uv-(off3/resolution))*0.010381362401148057;\nreturn color;\n}\nvec4 blur13Bilateral(sampler2D image,vec2 uv,float resolution,vec2 direction) {\nvec4 color=vec4(0.0);\nvec2 off1=vec2(1.411764705882353)*direction;\nvec2 off2=vec2(3.2941176470588234)*direction;\nvec2 off3=vec2(5.176470588235294)*direction;\nfloat compareDepth=abs(texture2D(depthSampler,uv).r);\nfloat sampleDepth;\nfloat weight;\nfloat weightSum=30.0;\ncolor+=texture2D(image,uv)*30.0;\nsampleDepth=abs(texture2D(depthSampler,uv+(off1/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv+(off1/resolution))*weight;\nsampleDepth=abs(texture2D(depthSampler,uv-(off1/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv-(off1/resolution))*weight;\nsampleDepth=abs(texture2D(depthSampler,uv+(off2/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv+(off2/resolution))*weight;\nsampleDepth=abs(texture2D(depthSampler,uv-(off2/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv-(off2/resolution))*weight;\nsampleDepth=abs(texture2D(depthSampler,uv+(off3/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv+(off3/resolution))*weight;\nsampleDepth=abs(texture2D(depthSampler,uv-(off3/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv-(off3/resolution))*weight;\nreturn color/weightSum;\n}\nvoid main()\n{\n#if EXPENSIVE\nfloat compareDepth=abs(texture2D(depthSampler,vUV).r);\nfloat texelsize=1.0/outSize;\nfloat result=0.0;\nfloat weightSum=0.0;\nfor (int i=0; i<SAMPLES; ++i)\n{\n#ifdef BILATERAL_BLUR_H\nvec2 direction=vec2(1.0,0.0);\nvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\n#else\nvec2 direction=vec2(0.0,1.0);\nvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\n#endif\nvec2 samplePos=vUV+sampleOffset;\nfloat sampleDepth=abs(texture2D(depthSampler,samplePos).r);\nfloat weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30000.0);\nresult+=texture2D(textureSampler,samplePos).r*weight;\nweightSum+=weight;\n}\nresult/=weightSum;\ngl_FragColor.rgb=vec3(result);\ngl_FragColor.a=1.0;\n#else\nvec4 color;\n#ifdef BILATERAL_BLUR_H\nvec2 direction=vec2(1.0,0.0);\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\n#else\nvec2 direction=vec2(0.0,1.0);\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\n#endif\ngl_FragColor.rgb=vec3(color.r);\ngl_FragColor.a=1.0;\n#endif\n}\n#endif\n";
Effect.ShadersStore[name$Z] = shader$Z;

var name$_ = 'ssaoCombinePixelShader';
var shader$_ = "uniform sampler2D textureSampler;\nuniform sampler2D originalColor;\nuniform vec4 viewport;\nvarying vec2 vUV;\nvoid main(void) {\nvec4 ssaoColor=texture2D(textureSampler,viewport.xy+vUV*viewport.zw);\nvec4 sceneColor=texture2D(originalColor,vUV);\ngl_FragColor=sceneColor*ssaoColor;\n}\n";
Effect.ShadersStore[name$_] = shader$_;

/**
 * Render pipeline to produce ssao effect
 */
var SSAO2RenderingPipeline = /** @class */ (function (_super) {
    __extends(SSAO2RenderingPipeline, _super);
    /**
     * @constructor
     * @param name The rendering pipeline name
     * @param scene The scene linked to this pipeline
     * @param ratio The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, blurRatio: 1.0 }
     * @param cameras The array of cameras that the rendering pipeline will be attached to
     */
    function SSAO2RenderingPipeline(name, scene, ratio, cameras) {
        var _this = _super.call(this, scene.getEngine(), name) || this;
        // Members
        /**
         * @ignore
        * The PassPostProcess id in the pipeline that contains the original scene color
        */
        _this.SSAOOriginalSceneColorEffect = "SSAOOriginalSceneColorEffect";
        /**
         * @ignore
        * The SSAO PostProcess id in the pipeline
        */
        _this.SSAORenderEffect = "SSAORenderEffect";
        /**
         * @ignore
        * The horizontal blur PostProcess id in the pipeline
        */
        _this.SSAOBlurHRenderEffect = "SSAOBlurHRenderEffect";
        /**
         * @ignore
        * The vertical blur PostProcess id in the pipeline
        */
        _this.SSAOBlurVRenderEffect = "SSAOBlurVRenderEffect";
        /**
         * @ignore
        * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
        */
        _this.SSAOCombineRenderEffect = "SSAOCombineRenderEffect";
        /**
        * The output strength of the SSAO post-process. Default value is 1.0.
        */
        _this.totalStrength = 1.0;
        /**
        * Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
        */
        _this.maxZ = 100.0;
        /**
        * In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much
        */
        _this.minZAspect = 0.2;
        _this._samples = 8;
        _this._textureSamples = 1;
        _this._expensiveBlur = true;
        /**
        * The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
        */
        _this.radius = 2.0;
        /**
        * The base color of the SSAO post-process
        * The final result is "base + ssao" between [0, 1]
        */
        _this.base = 0;
        _this._firstUpdate = true;
        _this._bits = new Uint32Array(1);
        _this._scene = scene;
        _this._ratio = ratio;
        if (!_this.isSupported) {
            Logger.Error("SSAO 2 needs WebGL 2 support.");
            return _this;
        }
        var ssaoRatio = _this._ratio.ssaoRatio || ratio;
        var blurRatio = _this._ratio.blurRatio || ratio;
        // Set up assets
        var geometryBufferRenderer = scene.enableGeometryBufferRenderer();
        _this._createRandomTexture();
        _this._depthTexture = geometryBufferRenderer.getGBuffer().textures[0];
        _this._normalTexture = geometryBufferRenderer.getGBuffer().textures[1];
        _this._originalColorPostProcess = new PassPostProcess("SSAOOriginalSceneColor", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);
        _this._originalColorPostProcess.samples = _this.textureSamples;
        _this._createSSAOPostProcess(1.0);
        _this._createBlurPostProcess(ssaoRatio, blurRatio);
        _this._createSSAOCombinePostProcess(blurRatio);
        // Set up pipeline
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOOriginalSceneColorEffect, function () { return _this._originalColorPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAORenderEffect, function () { return _this._ssaoPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurHRenderEffect, function () { return _this._blurHPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurVRenderEffect, function () { return _this._blurVPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOCombineRenderEffect, function () { return _this._ssaoCombinePostProcess; }, true));
        // Finish
        scene.postProcessRenderPipelineManager.addPipeline(_this);
        if (cameras) {
            scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name, cameras);
        }
        return _this;
    }
    Object.defineProperty(SSAO2RenderingPipeline.prototype, "samples", {
        get: function () {
            return this._samples;
        },
        /**
        * Number of samples used for the SSAO calculations. Default value is 8
        */
        set: function (n) {
            this._ssaoPostProcess.updateEffect("#define SAMPLES " + n + "\n#define SSAO");
            this._samples = n;
            this._sampleSphere = this._generateHemisphere();
            this._firstUpdate = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SSAO2RenderingPipeline.prototype, "textureSamples", {
        get: function () {
            return this._textureSamples;
        },
        /**
        * Number of samples to use for antialiasing
        */
        set: function (n) {
            this._textureSamples = n;
            this._originalColorPostProcess.samples = n;
            this._blurHPostProcess.samples = n;
            this._blurVPostProcess.samples = n;
            this._ssaoPostProcess.samples = n;
            this._ssaoCombinePostProcess.samples = n;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SSAO2RenderingPipeline.prototype, "expensiveBlur", {
        get: function () {
            return this._expensiveBlur;
        },
        /**
        * If bilateral blur should be used
        */
        set: function (b) {
            this._blurHPostProcess.updateEffect("#define BILATERAL_BLUR\n#define BILATERAL_BLUR_H\n#define SAMPLES 16\n#define EXPENSIVE " + (b ? "1" : "0") + "\n", null, ["textureSampler", "depthSampler"]);
            this._blurVPostProcess.updateEffect("#define BILATERAL_BLUR\n#define SAMPLES 16\n#define EXPENSIVE " + (b ? "1" : "0") + "\n", null, ["textureSampler", "depthSampler"]);
            this._expensiveBlur = b;
            this._firstUpdate = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SSAO2RenderingPipeline, "IsSupported", {
        /**
        *  Support test.
        */
        get: function () {
            var engine = EngineStore.LastCreatedEngine;
            if (!engine) {
                return false;
            }
            return engine.getCaps().drawBuffersExtension;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SSAO2RenderingPipeline.prototype, "scene", {
        /**
         * Gets active scene
         */
        get: function () {
            return this._scene;
        },
        enumerable: true,
        configurable: true
    });
    // Public Methods
    /**
     * Get the class name
     * @returns "SSAO2RenderingPipeline"
     */
    SSAO2RenderingPipeline.prototype.getClassName = function () {
        return "SSAO2RenderingPipeline";
    };
    /**
     * Removes the internal pipeline assets and detatches the pipeline from the scene cameras
     */
    SSAO2RenderingPipeline.prototype.dispose = function (disableGeometryBufferRenderer) {
        if (disableGeometryBufferRenderer === void 0) { disableGeometryBufferRenderer = false; }
        for (var i = 0; i < this._scene.cameras.length; i++) {
            var camera = this._scene.cameras[i];
            this._originalColorPostProcess.dispose(camera);
            this._ssaoPostProcess.dispose(camera);
            this._blurHPostProcess.dispose(camera);
            this._blurVPostProcess.dispose(camera);
            this._ssaoCombinePostProcess.dispose(camera);
        }
        this._randomTexture.dispose();
        if (disableGeometryBufferRenderer) {
            this._scene.disableGeometryBufferRenderer();
        }
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
        _super.prototype.dispose.call(this);
    };
    // Private Methods
    SSAO2RenderingPipeline.prototype._createBlurPostProcess = function (ssaoRatio, blurRatio) {
        var _this = this;
        this._samplerOffsets = [];
        var expensive = this.expensiveBlur;
        for (var i = -8; i < 8; i++) {
            this._samplerOffsets.push(i * 2 + 0.5);
        }
        this._blurHPostProcess = new PostProcess("BlurH", "ssao2", ["outSize", "samplerOffsets", "near", "far", "radius"], ["depthSampler"], ssaoRatio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define BILATERAL_BLUR\n#define BILATERAL_BLUR_H\n#define SAMPLES 16\n#define EXPENSIVE " + (expensive ? "1" : "0") + "\n");
        this._blurHPostProcess.onApply = function (effect) {
            if (!_this._scene.activeCamera) {
                return;
            }
            effect.setFloat("outSize", _this._ssaoCombinePostProcess.width > 0 ? _this._ssaoCombinePostProcess.width : _this._originalColorPostProcess.width);
            effect.setFloat("near", _this._scene.activeCamera.minZ);
            effect.setFloat("far", _this._scene.activeCamera.maxZ);
            effect.setFloat("radius", _this.radius);
            effect.setTexture("depthSampler", _this._depthTexture);
            if (_this._firstUpdate) {
                effect.setArray("samplerOffsets", _this._samplerOffsets);
            }
        };
        this._blurVPostProcess = new PostProcess("BlurV", "ssao2", ["outSize", "samplerOffsets", "near", "far", "radius"], ["depthSampler"], blurRatio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define BILATERAL_BLUR\n#define BILATERAL_BLUR_V\n#define SAMPLES 16\n#define EXPENSIVE " + (expensive ? "1" : "0") + "\n");
        this._blurVPostProcess.onApply = function (effect) {
            if (!_this._scene.activeCamera) {
                return;
            }
            effect.setFloat("outSize", _this._ssaoCombinePostProcess.height > 0 ? _this._ssaoCombinePostProcess.height : _this._originalColorPostProcess.height);
            effect.setFloat("near", _this._scene.activeCamera.minZ);
            effect.setFloat("far", _this._scene.activeCamera.maxZ);
            effect.setFloat("radius", _this.radius);
            effect.setTexture("depthSampler", _this._depthTexture);
            if (_this._firstUpdate) {
                effect.setArray("samplerOffsets", _this._samplerOffsets);
                _this._firstUpdate = false;
            }
        };
        this._blurHPostProcess.samples = this.textureSamples;
        this._blurVPostProcess.samples = this.textureSamples;
    };
    /** @hidden */
    SSAO2RenderingPipeline.prototype._rebuild = function () {
        this._firstUpdate = true;
        _super.prototype._rebuild.call(this);
    };
    //Van der Corput radical inverse
    SSAO2RenderingPipeline.prototype._radicalInverse_VdC = function (i) {
        this._bits[0] = i;
        this._bits[0] = ((this._bits[0] << 16) | (this._bits[0] >> 16)) >>> 0;
        this._bits[0] = ((this._bits[0] & 0x55555555) << 1) | ((this._bits[0] & 0xAAAAAAAA) >>> 1) >>> 0;
        this._bits[0] = ((this._bits[0] & 0x33333333) << 2) | ((this._bits[0] & 0xCCCCCCCC) >>> 2) >>> 0;
        this._bits[0] = ((this._bits[0] & 0x0F0F0F0F) << 4) | ((this._bits[0] & 0xF0F0F0F0) >>> 4) >>> 0;
        this._bits[0] = ((this._bits[0] & 0x00FF00FF) << 8) | ((this._bits[0] & 0xFF00FF00) >>> 8) >>> 0;
        return this._bits[0] * 2.3283064365386963e-10; // / 0x100000000 or / 4294967296
    };
    SSAO2RenderingPipeline.prototype._hammersley = function (i, n) {
        return [i / n, this._radicalInverse_VdC(i)];
    };
    SSAO2RenderingPipeline.prototype._hemisphereSample_uniform = function (u, v) {
        var phi = v * 2.0 * Math.PI;
        // rejecting samples that are close to tangent plane to avoid z-fighting artifacts
        var cosTheta = 1.0 - (u * 0.85 + 0.15);
        var sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);
        return new Vector3(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta);
    };
    SSAO2RenderingPipeline.prototype._generateHemisphere = function () {
        var numSamples = this.samples;
        var result = [];
        var vector;
        var i = 0;
        while (i < numSamples) {
            if (numSamples < 16) {
                vector = this._hemisphereSample_uniform(Math.random(), Math.random());
            }
            else {
                var rand = this._hammersley(i, numSamples);
                vector = this._hemisphereSample_uniform(rand[0], rand[1]);
            }
            result.push(vector.x, vector.y, vector.z);
            i++;
        }
        return result;
    };
    SSAO2RenderingPipeline.prototype._createSSAOPostProcess = function (ratio) {
        var _this = this;
        var numSamples = this.samples;
        this._sampleSphere = this._generateHemisphere();
        this._ssaoPostProcess = new PostProcess("ssao2", "ssao2", [
            "sampleSphere", "samplesFactor", "randTextureTiles", "totalStrength", "radius",
            "base", "range", "projection", "near", "far", "texelSize",
            "xViewport", "yViewport", "maxZ", "minZAspect"
        ], ["randomSampler", "normalSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define SAMPLES " + numSamples + "\n#define SSAO");
        this._ssaoPostProcess.onApply = function (effect) {
            if (_this._firstUpdate) {
                effect.setArray3("sampleSphere", _this._sampleSphere);
                effect.setFloat("randTextureTiles", 32.0);
            }
            if (!_this._scene.activeCamera) {
                return;
            }
            effect.setFloat("samplesFactor", 1 / _this.samples);
            effect.setFloat("totalStrength", _this.totalStrength);
            effect.setFloat2("texelSize", 1 / _this._ssaoPostProcess.width, 1 / _this._ssaoPostProcess.height);
            effect.setFloat("radius", _this.radius);
            effect.setFloat("maxZ", _this.maxZ);
            effect.setFloat("minZAspect", _this.minZAspect);
            effect.setFloat("base", _this.base);
            effect.setFloat("near", _this._scene.activeCamera.minZ);
            effect.setFloat("far", _this._scene.activeCamera.maxZ);
            effect.setFloat("xViewport", Math.tan(_this._scene.activeCamera.fov / 2) * _this._scene.getEngine().getAspectRatio(_this._scene.activeCamera, true));
            effect.setFloat("yViewport", Math.tan(_this._scene.activeCamera.fov / 2));
            effect.setMatrix("projection", _this._scene.getProjectionMatrix());
            effect.setTexture("textureSampler", _this._depthTexture);
            effect.setTexture("normalSampler", _this._normalTexture);
            effect.setTexture("randomSampler", _this._randomTexture);
        };
        this._ssaoPostProcess.samples = this.textureSamples;
    };
    SSAO2RenderingPipeline.prototype._createSSAOCombinePostProcess = function (ratio) {
        var _this = this;
        this._ssaoCombinePostProcess = new PostProcess("ssaoCombine", "ssaoCombine", [], ["originalColor", "viewport"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
        this._ssaoCombinePostProcess.onApply = function (effect) {
            var viewport = _this._scene.activeCamera.viewport;
            effect.setVector4("viewport", Tmp.Vector4[0].copyFromFloats(viewport.x, viewport.y, viewport.width, viewport.height));
            effect.setTextureFromPostProcess("originalColor", _this._originalColorPostProcess);
        };
        this._ssaoCombinePostProcess.samples = this.textureSamples;
    };
    SSAO2RenderingPipeline.prototype._createRandomTexture = function () {
        var size = 128;
        this._randomTexture = new DynamicTexture("SSAORandomTexture", size, this._scene, false, Texture.TRILINEAR_SAMPLINGMODE);
        this._randomTexture.wrapU = Texture.WRAP_ADDRESSMODE;
        this._randomTexture.wrapV = Texture.WRAP_ADDRESSMODE;
        var context = this._randomTexture.getContext();
        var rand = function (min, max) {
            return Math.random() * (max - min) + min;
        };
        var randVector = Vector3.Zero();
        for (var x = 0; x < size; x++) {
            for (var y = 0; y < size; y++) {
                randVector.x = rand(0.0, 1.0);
                randVector.y = rand(0.0, 1.0);
                randVector.z = 0.0;
                randVector.normalize();
                randVector.scaleInPlace(255);
                randVector.x = Math.floor(randVector.x);
                randVector.y = Math.floor(randVector.y);
                context.fillStyle = 'rgb(' + randVector.x + ', ' + randVector.y + ', ' + randVector.z + ')';
                context.fillRect(x, y, 1, 1);
            }
        }
        this._randomTexture.update(false);
    };
    /**
     * Serialize the rendering pipeline (Used when exporting)
     * @returns the serialized object
     */
    SSAO2RenderingPipeline.prototype.serialize = function () {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "SSAO2RenderingPipeline";
        return serializationObject;
    };
    /**
     * Parse the serialized pipeline
     * @param source Source pipeline.
     * @param scene The scene to load the pipeline to.
     * @param rootUrl The URL of the serialized pipeline.
     * @returns An instantiated pipeline from the serialized object.
     */
    SSAO2RenderingPipeline.Parse = function (source, scene, rootUrl) {
        return SerializationHelper.Parse(function () { return new SSAO2RenderingPipeline(source._name, scene, source._ratio); }, source, scene, rootUrl);
    };
    __decorate([
        serialize()
    ], SSAO2RenderingPipeline.prototype, "totalStrength", void 0);
    __decorate([
        serialize()
    ], SSAO2RenderingPipeline.prototype, "maxZ", void 0);
    __decorate([
        serialize()
    ], SSAO2RenderingPipeline.prototype, "minZAspect", void 0);
    __decorate([
        serialize("samples")
    ], SSAO2RenderingPipeline.prototype, "_samples", void 0);
    __decorate([
        serialize("textureSamples")
    ], SSAO2RenderingPipeline.prototype, "_textureSamples", void 0);
    __decorate([
        serialize()
    ], SSAO2RenderingPipeline.prototype, "_ratio", void 0);
    __decorate([
        serialize("expensiveBlur")
    ], SSAO2RenderingPipeline.prototype, "_expensiveBlur", void 0);
    __decorate([
        serialize()
    ], SSAO2RenderingPipeline.prototype, "radius", void 0);
    __decorate([
        serialize()
    ], SSAO2RenderingPipeline.prototype, "base", void 0);
    return SSAO2RenderingPipeline;
}(PostProcessRenderPipeline));
_TypeStore.RegisteredTypes["BABYLON.SSAO2RenderingPipeline"] = SSAO2RenderingPipeline;

var name$$ = 'ssaoPixelShader';
var shader$$ = "\nuniform sampler2D textureSampler;\nvarying vec2 vUV;\n#ifdef SSAO\nuniform sampler2D randomSampler;\nuniform float randTextureTiles;\nuniform float samplesFactor;\nuniform vec3 sampleSphere[SAMPLES];\nuniform float totalStrength;\nuniform float radius;\nuniform float area;\nuniform float fallOff;\nuniform float base;\nvec3 normalFromDepth(float depth,vec2 coords)\n{\nvec2 offset1=vec2(0.0,radius);\nvec2 offset2=vec2(radius,0.0);\nfloat depth1=texture2D(textureSampler,coords+offset1).r;\nfloat depth2=texture2D(textureSampler,coords+offset2).r;\nvec3 p1=vec3(offset1,depth1-depth);\nvec3 p2=vec3(offset2,depth2-depth);\nvec3 normal=cross(p1,p2);\nnormal.z=-normal.z;\nreturn normalize(normal);\n}\nvoid main()\n{\nvec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);\nfloat depth=texture2D(textureSampler,vUV).r;\nvec3 position=vec3(vUV,depth);\nvec3 normal=normalFromDepth(depth,vUV);\nfloat radiusDepth=radius/depth;\nfloat occlusion=0.0;\nvec3 ray;\nvec3 hemiRay;\nfloat occlusionDepth;\nfloat difference;\nfor (int i=0; i<SAMPLES; i++)\n{\nray=radiusDepth*reflect(sampleSphere[i],random);\nhemiRay=position+sign(dot(ray,normal))*ray;\nocclusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;\ndifference=depth-occlusionDepth;\nocclusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));\n}\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\nfloat result=clamp(ao+base,0.0,1.0);\ngl_FragColor.r=result;\ngl_FragColor.g=result;\ngl_FragColor.b=result;\ngl_FragColor.a=1.0;\n}\n#endif\n";
Effect.ShadersStore[name$$] = shader$$;

/**
 * Render pipeline to produce ssao effect
 */
var SSAORenderingPipeline = /** @class */ (function (_super) {
    __extends(SSAORenderingPipeline, _super);
    /**
     * @constructor
     * @param name - The rendering pipeline name
     * @param scene - The scene linked to this pipeline
     * @param ratio - The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, combineRatio: 1.0 }
     * @param cameras - The array of cameras that the rendering pipeline will be attached to
     */
    function SSAORenderingPipeline(name, scene, ratio, cameras) {
        var _this = _super.call(this, scene.getEngine(), name) || this;
        // Members
        /**
         * @ignore
        * The PassPostProcess id in the pipeline that contains the original scene color
        */
        _this.SSAOOriginalSceneColorEffect = "SSAOOriginalSceneColorEffect";
        /**
         * @ignore
        * The SSAO PostProcess id in the pipeline
        */
        _this.SSAORenderEffect = "SSAORenderEffect";
        /**
         * @ignore
        * The horizontal blur PostProcess id in the pipeline
        */
        _this.SSAOBlurHRenderEffect = "SSAOBlurHRenderEffect";
        /**
         * @ignore
        * The vertical blur PostProcess id in the pipeline
        */
        _this.SSAOBlurVRenderEffect = "SSAOBlurVRenderEffect";
        /**
         * @ignore
        * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
        */
        _this.SSAOCombineRenderEffect = "SSAOCombineRenderEffect";
        /**
        * The output strength of the SSAO post-process. Default value is 1.0.
        */
        _this.totalStrength = 1.0;
        /**
        * The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006
        */
        _this.radius = 0.0001;
        /**
        * Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel
        * Must not be equal to fallOff and superior to fallOff.
        * Default value is 0.0075
        */
        _this.area = 0.0075;
        /**
        * Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel
        * Must not be equal to area and inferior to area.
        * Default value is 0.000001
        */
        _this.fallOff = 0.000001;
        /**
        * The base color of the SSAO post-process
        * The final result is "base + ssao" between [0, 1]
        */
        _this.base = 0.5;
        _this._firstUpdate = true;
        _this._scene = scene;
        // Set up assets
        _this._createRandomTexture();
        _this._depthTexture = scene.enableDepthRenderer().getDepthMap(); // Force depth renderer "on"
        var ssaoRatio = ratio.ssaoRatio || ratio;
        var combineRatio = ratio.combineRatio || ratio;
        _this._originalColorPostProcess = new PassPostProcess("SSAOOriginalSceneColor", combineRatio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);
        _this._createSSAOPostProcess(ssaoRatio);
        _this._createBlurPostProcess(ssaoRatio);
        _this._createSSAOCombinePostProcess(combineRatio);
        // Set up pipeline
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOOriginalSceneColorEffect, function () { return _this._originalColorPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAORenderEffect, function () { return _this._ssaoPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurHRenderEffect, function () { return _this._blurHPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurVRenderEffect, function () { return _this._blurVPostProcess; }, true));
        _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOCombineRenderEffect, function () { return _this._ssaoCombinePostProcess; }, true));
        // Finish
        scene.postProcessRenderPipelineManager.addPipeline(_this);
        if (cameras) {
            scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name, cameras);
        }
        return _this;
    }
    Object.defineProperty(SSAORenderingPipeline.prototype, "scene", {
        /**
         * Gets active scene
         */
        get: function () {
            return this._scene;
        },
        enumerable: true,
        configurable: true
    });
    // Public Methods
    /**
     * Get the class name
     * @returns "SSAORenderingPipeline"
     */
    SSAORenderingPipeline.prototype.getClassName = function () {
        return "SSAORenderingPipeline";
    };
    /**
     * Removes the internal pipeline assets and detatches the pipeline from the scene cameras
     */
    SSAORenderingPipeline.prototype.dispose = function (disableDepthRender) {
        if (disableDepthRender === void 0) { disableDepthRender = false; }
        for (var i = 0; i < this._scene.cameras.length; i++) {
            var camera = this._scene.cameras[i];
            this._originalColorPostProcess.dispose(camera);
            this._ssaoPostProcess.dispose(camera);
            this._blurHPostProcess.dispose(camera);
            this._blurVPostProcess.dispose(camera);
            this._ssaoCombinePostProcess.dispose(camera);
        }
        this._randomTexture.dispose();
        if (disableDepthRender) {
            this._scene.disableDepthRenderer();
        }
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
        _super.prototype.dispose.call(this);
    };
    // Private Methods
    SSAORenderingPipeline.prototype._createBlurPostProcess = function (ratio) {
        var _this = this;
        var size = 16;
        this._blurHPostProcess = new BlurPostProcess("BlurH", new Vector2(1, 0), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);
        this._blurVPostProcess = new BlurPostProcess("BlurV", new Vector2(0, 1), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);
        this._blurHPostProcess.onActivateObservable.add(function () {
            var dw = _this._blurHPostProcess.width / _this._scene.getEngine().getRenderWidth();
            _this._blurHPostProcess.kernel = size * dw;
        });
        this._blurVPostProcess.onActivateObservable.add(function () {
            var dw = _this._blurVPostProcess.height / _this._scene.getEngine().getRenderHeight();
            _this._blurVPostProcess.kernel = size * dw;
        });
    };
    /** @hidden */
    SSAORenderingPipeline.prototype._rebuild = function () {
        this._firstUpdate = true;
        _super.prototype._rebuild.call(this);
    };
    SSAORenderingPipeline.prototype._createSSAOPostProcess = function (ratio) {
        var _this = this;
        var numSamples = 16;
        var sampleSphere = [
            0.5381, 0.1856, -0.4319,
            0.1379, 0.2486, 0.4430,
            0.3371, 0.5679, -0.0057,
            -0.6999, -0.0451, -0.0019,
            0.0689, -0.1598, -0.8547,
            0.0560, 0.0069, -0.1843,
            -0.0146, 0.1402, 0.0762,
            0.0100, -0.1924, -0.0344,
            -0.3577, -0.5301, -0.4358,
            -0.3169, 0.1063, 0.0158,
            0.0103, -0.5869, 0.0046,
            -0.0897, -0.4940, 0.3287,
            0.7119, -0.0154, -0.0918,
            -0.0533, 0.0596, -0.5411,
            0.0352, -0.0631, 0.5460,
            -0.4776, 0.2847, -0.0271
        ];
        var samplesFactor = 1.0 / numSamples;
        this._ssaoPostProcess = new PostProcess("ssao", "ssao", [
            "sampleSphere", "samplesFactor", "randTextureTiles", "totalStrength", "radius",
            "area", "fallOff", "base", "range", "viewport"
        ], ["randomSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define SAMPLES " + numSamples + "\n#define SSAO");
        this._ssaoPostProcess.onApply = function (effect) {
            if (_this._firstUpdate) {
                effect.setArray3("sampleSphere", sampleSphere);
                effect.setFloat("samplesFactor", samplesFactor);
                effect.setFloat("randTextureTiles", 4.0);
            }
            effect.setFloat("totalStrength", _this.totalStrength);
            effect.setFloat("radius", _this.radius);
            effect.setFloat("area", _this.area);
            effect.setFloat("fallOff", _this.fallOff);
            effect.setFloat("base", _this.base);
            effect.setTexture("textureSampler", _this._depthTexture);
            effect.setTexture("randomSampler", _this._randomTexture);
        };
    };
    SSAORenderingPipeline.prototype._createSSAOCombinePostProcess = function (ratio) {
        var _this = this;
        this._ssaoCombinePostProcess = new PostProcess("ssaoCombine", "ssaoCombine", [], ["originalColor", "viewport"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
        this._ssaoCombinePostProcess.onApply = function (effect) {
            effect.setVector4("viewport", Tmp.Vector4[0].copyFromFloats(0, 0, 1.0, 1.0));
            effect.setTextureFromPostProcess("originalColor", _this._originalColorPostProcess);
        };
    };
    SSAORenderingPipeline.prototype._createRandomTexture = function () {
        var size = 512;
        this._randomTexture = new DynamicTexture("SSAORandomTexture", size, this._scene, false, Texture.TRILINEAR_SAMPLINGMODE);
        this._randomTexture.wrapU = Texture.WRAP_ADDRESSMODE;
        this._randomTexture.wrapV = Texture.WRAP_ADDRESSMODE;
        var context = this._randomTexture.getContext();
        var rand = function (min, max) {
            return Math.random() * (max - min) + min;
        };
        var randVector = Vector3.Zero();
        for (var x = 0; x < size; x++) {
            for (var y = 0; y < size; y++) {
                randVector.x = Math.floor(rand(-1.0, 1.0) * 255);
                randVector.y = Math.floor(rand(-1.0, 1.0) * 255);
                randVector.z = Math.floor(rand(-1.0, 1.0) * 255);
                context.fillStyle = 'rgb(' + randVector.x + ', ' + randVector.y + ', ' + randVector.z + ')';
                context.fillRect(x, y, 1, 1);
            }
        }
        this._randomTexture.update(false);
    };
    __decorate([
        serialize()
    ], SSAORenderingPipeline.prototype, "totalStrength", void 0);
    __decorate([
        serialize()
    ], SSAORenderingPipeline.prototype, "radius", void 0);
    __decorate([
        serialize()
    ], SSAORenderingPipeline.prototype, "area", void 0);
    __decorate([
        serialize()
    ], SSAORenderingPipeline.prototype, "fallOff", void 0);
    __decorate([
        serialize()
    ], SSAORenderingPipeline.prototype, "base", void 0);
    return SSAORenderingPipeline;
}(PostProcessRenderPipeline));

var name$10 = 'standardPixelShader';
var shader$10 = "uniform sampler2D textureSampler;\nvarying vec2 vUV;\n#if defined(PASS_POST_PROCESS)\nvoid main(void)\n{\nvec4 color=texture2D(textureSampler,vUV);\ngl_FragColor=color;\n}\n#endif\n#if defined(DOWN_SAMPLE_X4)\nuniform vec2 dsOffsets[16];\nvoid main(void)\n{\nvec4 average=vec4(0.0,0.0,0.0,0.0);\naverage=texture2D(textureSampler,vUV+dsOffsets[0]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[1]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[2]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[3]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[4]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[5]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[6]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[7]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[8]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[9]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[10]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[11]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[12]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[13]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[14]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[15]);\naverage/=16.0;\ngl_FragColor=average;\n}\n#endif\n#if defined(BRIGHT_PASS)\nuniform vec2 dsOffsets[4];\nuniform float brightThreshold;\nvoid main(void)\n{\nvec4 average=vec4(0.0,0.0,0.0,0.0);\naverage=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));\naverage*=0.25;\nfloat luminance=length(average.rgb);\nif (luminance<brightThreshold) {\naverage=vec4(0.0,0.0,0.0,1.0);\n}\ngl_FragColor=average;\n}\n#endif\n#if defined(TEXTURE_ADDER)\nuniform sampler2D otherSampler;\nuniform sampler2D lensSampler;\nuniform float exposure;\nvoid main(void)\n{\nvec3 colour=texture2D(textureSampler,vUV).rgb;\ncolour*=exposure;\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\ncolour=retColor*retColor;\ncolour+=colour*texture2D(lensSampler,vUV).rgb;\nvec4 finalColor=vec4(colour.rgb,1.0)+texture2D(otherSampler,vUV);\ngl_FragColor=finalColor;\n}\n#endif\n#if defined(VLS)\n#define PI 3.1415926535897932384626433832795\nuniform mat4 shadowViewProjection;\nuniform mat4 lightWorld;\nuniform vec3 cameraPosition;\nuniform vec3 sunDirection;\nuniform vec3 sunColor;\nuniform vec2 depthValues;\nuniform float scatteringCoefficient;\nuniform float scatteringPower;\nuniform sampler2D shadowMapSampler;\nuniform sampler2D positionSampler;\nfloat computeScattering(float lightDotView)\n{\nfloat result=1.0-scatteringCoefficient*scatteringCoefficient;\nresult/=(4.0*PI*pow(1.0+scatteringCoefficient*scatteringCoefficient-(2.0*scatteringCoefficient)*lightDotView,1.5));\nreturn result;\n}\nvoid main(void)\n{\n\nvec3 worldPos=texture2D(positionSampler,vUV).rgb;\nvec3 startPosition=cameraPosition;\nvec3 rayVector=worldPos-startPosition;\nfloat rayLength=length(rayVector);\nvec3 rayDirection=rayVector/rayLength;\nfloat stepLength=rayLength/NB_STEPS;\nvec3 stepL=rayDirection*stepLength;\nvec3 currentPosition=startPosition;\nvec3 accumFog=vec3(0.0);\nfor (int i=0; i<int(NB_STEPS); i++)\n{\nvec4 worldInShadowCameraSpace=shadowViewProjection*vec4(currentPosition,1.0);\nfloat depthMetric=(worldInShadowCameraSpace.z+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depthMetric,0.0,1.0);\nworldInShadowCameraSpace.xyz/=worldInShadowCameraSpace.w;\nworldInShadowCameraSpace.xyz=0.5*worldInShadowCameraSpace.xyz+vec3(0.5);\nfloat shadowMapValue=texture2D(shadowMapSampler,worldInShadowCameraSpace.xy).r;\nif (shadowMapValue>shadowPixelDepth)\naccumFog+=sunColor*computeScattering(dot(rayDirection,sunDirection));\ncurrentPosition+=stepL;\n}\naccumFog/=NB_STEPS;\nvec3 color=accumFog*scatteringPower;\ngl_FragColor=vec4(color*exp(color) ,1.0);\n}\n#endif\n#if defined(VLSMERGE)\nuniform sampler2D originalSampler;\nvoid main(void)\n{\ngl_FragColor=texture2D(originalSampler,vUV)+texture2D(textureSampler,vUV);\n}\n#endif\n#if defined(LUMINANCE)\nuniform vec2 lumOffsets[4];\nvoid main()\n{\nfloat average=0.0;\nvec4 color=vec4(0.0);\nfloat maximum=-1e20;\nvec3 weight=vec3(0.299,0.587,0.114);\nfor (int i=0; i<4; i++)\n{\ncolor=texture2D(textureSampler,vUV+ lumOffsets[i]);\n\nfloat GreyValue=dot(color.rgb,vec3(0.33,0.33,0.33));\n\n#ifdef WEIGHTED_AVERAGE\nfloat GreyValue=dot(color.rgb,weight);\n#endif\n#ifdef BRIGHTNESS\nfloat GreyValue=max(color.r,max(color.g,color.b));\n#endif\n#ifdef HSL_COMPONENT\nfloat GreyValue=0.5*(max(color.r,max(color.g,color.b))+min(color.r,min(color.g,color.b)));\n#endif\n#ifdef MAGNITUDE\nfloat GreyValue=length(color.rgb);\n#endif\nmaximum=max(maximum,GreyValue);\naverage+=(0.25*log(1e-5+GreyValue));\n}\naverage=exp(average);\ngl_FragColor=vec4(average,maximum,0.0,1.0);\n}\n#endif\n#if defined(LUMINANCE_DOWN_SAMPLE)\nuniform vec2 dsOffsets[9];\nuniform float halfDestPixelSize;\n#ifdef FINAL_DOWN_SAMPLER\nvec4 pack(float value) {\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\nvec4 res=fract(value*bit_shift);\nres-=res.xxyz*bit_mask;\nreturn res;\n}\n#endif\nvoid main()\n{\nvec4 color=vec4(0.0);\nfloat average=0.0;\nfor (int i=0; i<9; i++)\n{\ncolor=texture2D(textureSampler,vUV+vec2(halfDestPixelSize,halfDestPixelSize)+dsOffsets[i]);\naverage+=color.r;\n}\naverage/=9.0;\n#ifdef FINAL_DOWN_SAMPLER\ngl_FragColor=pack(average);\n#else\ngl_FragColor=vec4(average,average,0.0,1.0);\n#endif\n}\n#endif\n#if defined(HDR)\nuniform sampler2D textureAdderSampler;\nuniform float averageLuminance;\nvoid main()\n{\nvec4 color=texture2D(textureAdderSampler,vUV);\n#ifndef AUTO_EXPOSURE\nvec4 adjustedColor=color/averageLuminance;\ncolor=adjustedColor;\ncolor.a=1.0;\n#endif\ngl_FragColor=color;\n}\n#endif\n#if defined(LENS_FLARE)\n#define GHOSTS 3\nuniform sampler2D lensColorSampler;\nuniform float strength;\nuniform float ghostDispersal;\nuniform float haloWidth;\nuniform vec2 resolution;\nuniform float distortionStrength;\nfloat hash(vec2 p)\n{\nfloat h=dot(p,vec2(127.1,311.7));\nreturn -1.0+2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(in vec2 p)\n{\nvec2 i=floor(p);\nvec2 f=fract(p);\nvec2 u=f*f*(3.0-2.0*f);\nreturn mix(mix(hash(i+vec2(0.0,0.0)),\nhash(i+vec2(1.0,0.0)),u.x),\nmix(hash(i+vec2(0.0,1.0)),\nhash(i+vec2(1.0,1.0)),u.x),u.y);\n}\nfloat fbm(vec2 p)\n{\nfloat f=0.0;\nf+=0.5000*noise(p); p*=2.02;\nf+=0.2500*noise(p); p*=2.03;\nf+=0.1250*noise(p); p*=2.01;\nf+=0.0625*noise(p); p*=2.04;\nf/=0.9375;\nreturn f;\n}\nvec3 pattern(vec2 uv)\n{\nvec2 p=-1.0+2.0*uv;\nfloat p2=dot(p,p);\nfloat f=fbm(vec2(15.0*p2))/2.0;\nfloat r=0.2+0.6*sin(12.5*length(uv-vec2(0.5)));\nfloat g=0.2+0.6*sin(20.5*length(uv-vec2(0.5)));\nfloat b=0.2+0.6*sin(17.2*length(uv-vec2(0.5)));\nreturn (1.0-f)*vec3(r,g,b);\n}\nfloat luminance(vec3 color)\n{\nreturn dot(color.rgb,vec3(0.2126,0.7152,0.0722));\n}\nvec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion)\n{\nreturn vec4(\ntexture2D(tex,texcoord+direction*distortion.r).r,\ntexture2D(tex,texcoord+direction*distortion.g).g,\ntexture2D(tex,texcoord+direction*distortion.b).b,\n1.0\n);\n}\nvoid main(void)\n{\nvec2 uv=-vUV+vec2(1.0);\nvec2 ghostDir=(vec2(0.5)-uv)*ghostDispersal;\nvec2 texelSize=1.0/resolution;\nvec3 distortion=vec3(-texelSize.x*distortionStrength,0.0,texelSize.x*distortionStrength);\nvec4 result=vec4(0.0);\nfloat ghostIndice=1.0;\nfor (int i=0; i<GHOSTS; ++i)\n{\nvec2 offset=fract(uv+ghostDir*ghostIndice);\nfloat weight=length(vec2(0.5)-offset)/length(vec2(0.5));\nweight=pow(1.0-weight,10.0);\nresult+=textureDistorted(textureSampler,offset,normalize(ghostDir),distortion)*weight*strength;\nghostIndice+=1.0;\n}\nvec2 haloVec=normalize(ghostDir)*haloWidth;\nfloat weight=length(vec2(0.5)-fract(uv+haloVec))/length(vec2(0.5));\nweight=pow(1.0-weight,10.0);\nresult+=textureDistorted(textureSampler,fract(uv+haloVec),normalize(ghostDir),distortion)*weight*strength;\nresult*=texture2D(lensColorSampler,vec2(length(vec2(0.5)-uv)/length(vec2(0.5))));\ngl_FragColor=result;\n}\n#endif\n#if defined(LENS_FLARE_COMPOSE)\nuniform sampler2D otherSampler;\nuniform sampler2D lensDirtSampler;\nuniform sampler2D lensStarSampler;\nuniform mat4 lensStarMatrix;\nvoid main(void)\n{\nvec2 lensFlareCoords=(lensStarMatrix*vec4(vUV,1.0,1.0)).xy;\nvec4 lensMod=texture2D(lensDirtSampler,vUV);\nlensMod+=texture2D(lensStarSampler,vUV);\nvec4 result=texture2D(textureSampler,vUV)*lensMod;\ngl_FragColor=texture2D(otherSampler,vUV)+result;\n}\n#endif\n#if defined(DEPTH_OF_FIELD)\nuniform sampler2D otherSampler;\nuniform sampler2D depthSampler;\nuniform float distance;\nvoid main(void)\n{\nvec4 sharp=texture2D(otherSampler,vUV);\nvec4 blur=texture2D(textureSampler,vUV);\nfloat dist=clamp(texture2D(depthSampler,vUV).r*distance,0.0,1.0);\nfloat factor=0.0;\nif (dist<0.05)\nfactor=1.0;\nelse if (dist<0.1)\nfactor=20.0*(0.1-dist);\nelse if (dist<0.5)\nfactor=0.0;\nelse\nfactor=2.0*(dist-0.5);\nfactor=clamp(factor,0.0,0.90);\ngl_FragColor=mix(sharp,blur,factor);\n}\n#endif\n#if defined(MOTION_BLUR)\nuniform mat4 inverseViewProjection;\nuniform mat4 prevViewProjection;\nuniform vec2 screenSize;\nuniform float motionScale;\nuniform float motionStrength;\nuniform sampler2D depthSampler;\nvoid main(void)\n{\nvec2 texelSize=1.0/screenSize;\nfloat depth=texture2D(depthSampler,vUV).r;\nvec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);\ncpos=cpos*inverseViewProjection;\nvec4 ppos=cpos*prevViewProjection;\nppos.xyz/=ppos.w;\nppos.xy=ppos.xy*0.5+0.5;\nvec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;\nfloat speed=length(velocity/texelSize);\nint nSamples=int(clamp(speed,1.0,MAX_MOTION_SAMPLES));\nvec4 result=texture2D(textureSampler,vUV);\nfor (int i=1; i<int(MAX_MOTION_SAMPLES); ++i) {\nif (i>=nSamples)\nbreak;\nvec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);\nresult+=texture2D(textureSampler,offset1);\n}\ngl_FragColor=result/float(nSamples);\n}\n#endif\n";
Effect.ShadersStore[name$10] = shader$10;

/**
 * Standard rendering pipeline
 * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
 * @see https://doc.babylonjs.com/how_to/using_standard_rendering_pipeline
 */
var StandardRenderingPipeline = /** @class */ (function (_super) {
    __extends(StandardRenderingPipeline, _super);
    /**
     * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
     * @constructor
     * @param name The rendering pipeline name
     * @param scene The scene linked to this pipeline
     * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
     * @param originalPostProcess the custom original color post-process. Must be "reusable". Can be null.
     * @param cameras The array of cameras that the rendering pipeline will be attached to
     */
    function StandardRenderingPipeline(name, scene, ratio, originalPostProcess, cameras) {
        if (originalPostProcess === void 0) { originalPostProcess = null; }
        var _this = _super.call(this, scene.getEngine(), name) || this;
        /**
         * Post-process used to down scale an image x4
         */
        _this.downSampleX4PostProcess = null;
        /**
         * Post-process used to calculate the illuminated surfaces controlled by a threshold
         */
        _this.brightPassPostProcess = null;
        /**
         * Post-process array storing all the horizontal blur post-processes used by the pipeline
         */
        _this.blurHPostProcesses = [];
        /**
         * Post-process array storing all the vertical blur post-processes used by the pipeline
         */
        _this.blurVPostProcesses = [];
        /**
         * Post-process used to add colors of 2 textures (typically brightness + real scene color)
         */
        _this.textureAdderPostProcess = null;
        /**
         * Post-process used to create volumetric lighting effect
         */
        _this.volumetricLightPostProcess = null;
        /**
         * Post-process used to smooth the previous volumetric light post-process on the X axis
         */
        _this.volumetricLightSmoothXPostProcess = null;
        /**
         * Post-process used to smooth the previous volumetric light post-process on the Y axis
         */
        _this.volumetricLightSmoothYPostProcess = null;
        /**
         * Post-process used to merge the volumetric light effect and the real scene color
         */
        _this.volumetricLightMergePostProces = null;
        /**
         * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)
         */
        _this.volumetricLightFinalPostProcess = null;
        /**
         * Base post-process used to calculate the average luminance of the final image for HDR
         */
        _this.luminancePostProcess = null;
        /**
         * Post-processes used to create down sample post-processes in order to get
         * the average luminance of the final image for HDR
         * Array of length "StandardRenderingPipeline.LuminanceSteps"
         */
        _this.luminanceDownSamplePostProcesses = [];
        /**
         * Post-process used to create a HDR effect (light adaptation)
         */
        _this.hdrPostProcess = null;
        /**
         * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)
         */
        _this.textureAdderFinalPostProcess = null;
        /**
         * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)
         */
        _this.lensFlareFinalPostProcess = null;
        /**
         * Post-process used to merge the final HDR post-process and the real scene color
         */
        _this.hdrFinalPostProcess = null;
        /**
         * Post-process used to create a lens flare effect
         */
        _this.lensFlarePostProcess = null;
        /**
         * Post-process that merges the result of the lens flare post-process and the real scene color
         */
        _this.lensFlareComposePostProcess = null;
        /**
         * Post-process used to create a motion blur effect
         */
        _this.motionBlurPostProcess = null;
        /**
         * Post-process used to create a depth of field effect
         */
        _this.depthOfFieldPostProcess = null;
        /**
         * The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
         */
        _this.fxaaPostProcess = null;
        // Values
        /**
         * Represents the brightness threshold in order to configure the illuminated surfaces
         */
        _this.brightThreshold = 1.0;
        /**
         * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)
         */
        _this.blurWidth = 512.0;
        /**
         * Sets if the blur for highlighted surfaces must be only horizontal
         */
        _this.horizontalBlur = false;
        /**
         * Texture used typically to simulate "dirty" on camera lens
         */
        _this.lensTexture = null;
        /**
         * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]
         */
        _this.volumetricLightCoefficient = 0.2;
        /**
         * The overall power of volumetric lights, typically in interval [0, 10] maximum
         */
        _this.volumetricLightPower = 4.0;
        /**
         * Used the set the blur intensity to smooth the volumetric lights
         */
        _this.volumetricLightBlurScale = 64.0;
        /**
         * Light (spot or directional) used to generate the volumetric lights rays
         * The source light must have a shadow generate so the pipeline can get its
         * depth map
         */
        _this.sourceLight = null;
        /**
         * For eye adaptation, represents the minimum luminance the eye can see
         */
        _this.hdrMinimumLuminance = 1.0;
        /**
         * For eye adaptation, represents the decrease luminance speed
         */
        _this.hdrDecreaseRate = 0.5;
        /**
         * For eye adaptation, represents the increase luminance speed
         */
        _this.hdrIncreaseRate = 0.5;
        /**
         * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled
         */
        _this.lensColorTexture = null;
        /**
         * The overall strengh for the lens flare effect
         */
        _this.lensFlareStrength = 20.0;
        /**
         * Dispersion coefficient for lens flare ghosts
         */
        _this.lensFlareGhostDispersal = 1.4;
        /**
         * Main lens flare halo width
         */
        _this.lensFlareHaloWidth = 0.7;
        /**
         * Based on the lens distortion effect, defines how much the lens flare result
         * is distorted
         */
        _this.lensFlareDistortionStrength = 16.0;
        /**
         * Lens star texture must be used to simulate rays on the flares and is available
         * in the documentation
         */
        _this.lensStarTexture = null;
        /**
         * As the "lensTexture" (can be the same texture or different), it is used to apply the lens
         * flare effect by taking account of the dirt texture
         */
        _this.lensFlareDirtTexture = null;
        /**
         * Represents the focal length for the depth of field effect
         */
        _this.depthOfFieldDistance = 10.0;
        /**
         * Represents the blur intensity for the blurred part of the depth of field effect
         */
        _this.depthOfFieldBlurWidth = 64.0;
        /**
         * For motion blur, defines how much the image is blurred by the movement
         */
        _this.motionStrength = 1.0;
        /**
         * List of animations for the pipeline (IAnimatable implementation)
         */
        _this.animations = [];
        _this._currentDepthOfFieldSource = null;
        _this._fixedExposure = 1.0;
        _this._currentExposure = 1.0;
        _this._hdrAutoExposure = false;
        _this._hdrCurrentLuminance = 1.0;
        // Getters and setters
        _this._bloomEnabled = false;
        _this._depthOfFieldEnabled = false;
        _this._vlsEnabled = false;
        _this._lensFlareEnabled = false;
        _this._hdrEnabled = false;
        _this._motionBlurEnabled = false;
        _this._fxaaEnabled = false;
        _this._motionBlurSamples = 64.0;
        _this._volumetricLightStepsCount = 50.0;
        _this._samples = 1;
        _this._cameras = cameras || [];
        // Initialize
        _this._scene = scene;
        _this._basePostProcess = originalPostProcess;
        _this._ratio = ratio;
        // Misc
        _this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_HALF_FLOAT;
        // Finish
        scene.postProcessRenderPipelineManager.addPipeline(_this);
        _this._buildPipeline();
        return _this;
    }
    Object.defineProperty(StandardRenderingPipeline.prototype, "exposure", {
        /**
         * Gets the overall exposure used by the pipeline
         */
        get: function () {
            return this._fixedExposure;
        },
        /**
         * Sets the overall exposure used by the pipeline
         */
        set: function (value) {
            this._fixedExposure = value;
            this._currentExposure = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "hdrAutoExposure", {
        /**
         * Gets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process
         */
        get: function () {
            return this._hdrAutoExposure;
        },
        /**
         * Sets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process
         */
        set: function (value) {
            this._hdrAutoExposure = value;
            if (this.hdrPostProcess) {
                var defines = ["#define HDR"];
                if (value) {
                    defines.push("#define AUTO_EXPOSURE");
                }
                this.hdrPostProcess.updateEffect(defines.join("\n"));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "BloomEnabled", {
        /**
         * @ignore
         * Specifies if the bloom pipeline is enabled
         */
        get: function () {
            return this._bloomEnabled;
        },
        set: function (enabled) {
            if (this._bloomEnabled === enabled) {
                return;
            }
            this._bloomEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "DepthOfFieldEnabled", {
        /**
         * @ignore
         * Specifies if the depth of field pipeline is enabed
         */
        get: function () {
            return this._depthOfFieldEnabled;
        },
        set: function (enabled) {
            if (this._depthOfFieldEnabled === enabled) {
                return;
            }
            this._depthOfFieldEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "LensFlareEnabled", {
        /**
         * @ignore
         * Specifies if the lens flare pipeline is enabed
         */
        get: function () {
            return this._lensFlareEnabled;
        },
        set: function (enabled) {
            if (this._lensFlareEnabled === enabled) {
                return;
            }
            this._lensFlareEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "HDREnabled", {
        /**
         * @ignore
         * Specifies if the HDR pipeline is enabled
         */
        get: function () {
            return this._hdrEnabled;
        },
        set: function (enabled) {
            if (this._hdrEnabled === enabled) {
                return;
            }
            this._hdrEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "VLSEnabled", {
        /**
         * @ignore
         * Specifies if the volumetric lights scattering effect is enabled
         */
        get: function () {
            return this._vlsEnabled;
        },
        set: function (enabled) {
            if (this._vlsEnabled === enabled) {
                return;
            }
            if (enabled) {
                var geometry = this._scene.enableGeometryBufferRenderer();
                if (!geometry) {
                    Logger.Warn("Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline");
                    return;
                }
            }
            this._vlsEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "MotionBlurEnabled", {
        /**
         * @ignore
         * Specifies if the motion blur effect is enabled
         */
        get: function () {
            return this._motionBlurEnabled;
        },
        set: function (enabled) {
            if (this._motionBlurEnabled === enabled) {
                return;
            }
            this._motionBlurEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "fxaaEnabled", {
        /**
         * Specifies if anti-aliasing is enabled
         */
        get: function () {
            return this._fxaaEnabled;
        },
        set: function (enabled) {
            if (this._fxaaEnabled === enabled) {
                return;
            }
            this._fxaaEnabled = enabled;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "volumetricLightStepsCount", {
        /**
         * Specifies the number of steps used to calculate the volumetric lights
         * Typically in interval [50, 200]
         */
        get: function () {
            return this._volumetricLightStepsCount;
        },
        set: function (count) {
            if (this.volumetricLightPostProcess) {
                this.volumetricLightPostProcess.updateEffect("#define VLS\n#define NB_STEPS " + count.toFixed(1));
            }
            this._volumetricLightStepsCount = count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "motionBlurSamples", {
        /**
         * Specifies the number of samples used for the motion blur effect
         * Typically in interval [16, 64]
         */
        get: function () {
            return this._motionBlurSamples;
        },
        set: function (samples) {
            if (this.motionBlurPostProcess) {
                this.motionBlurPostProcess.updateEffect("#define MOTION_BLUR\n#define MAX_MOTION_SAMPLES " + samples.toFixed(1));
            }
            this._motionBlurSamples = samples;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StandardRenderingPipeline.prototype, "samples", {
        /**
         * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
         */
        get: function () {
            return this._samples;
        },
        set: function (sampleCount) {
            if (this._samples === sampleCount) {
                return;
            }
            this._samples = sampleCount;
            this._buildPipeline();
        },
        enumerable: true,
        configurable: true
    });
    StandardRenderingPipeline.prototype._buildPipeline = function () {
        var _this = this;
        var ratio = this._ratio;
        var scene = this._scene;
        this._disposePostProcesses();
        this._reset();
        // Create pass post-process
        if (!this._basePostProcess) {
            this.originalPostProcess = new PostProcess("HDRPass", "standard", [], [], ratio, null, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", this._floatTextureType);
            this.originalPostProcess.onApply = function () {
                _this._currentDepthOfFieldSource = _this.originalPostProcess;
            };
        }
        else {
            this.originalPostProcess = this._basePostProcess;
        }
        if (this._bloomEnabled || this._vlsEnabled || this._lensFlareEnabled || this._depthOfFieldEnabled || this._motionBlurEnabled) {
            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRPassPostProcess", function () { return _this.originalPostProcess; }, true));
        }
        this._currentDepthOfFieldSource = this.originalPostProcess;
        if (this._bloomEnabled) {
            // Create down sample X4 post-process
            this._createDownSampleX4PostProcess(scene, ratio / 2);
            // Create bright pass post-process
            this._createBrightPassPostProcess(scene, ratio / 2);
            // Create gaussian blur post-processes (down sampling blurs)
            this._createBlurPostProcesses(scene, ratio / 4, 1);
            // Create texture adder post-process
            this._createTextureAdderPostProcess(scene, ratio);
            // Create depth-of-field source post-process
            this.textureAdderFinalPostProcess = new PostProcess("HDRDepthOfFieldSource", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", Constants.TEXTURETYPE_UNSIGNED_INT);
            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBaseDepthOfFieldSource", function () { return _this.textureAdderFinalPostProcess; }, true));
        }
        if (this._vlsEnabled) {
            // Create volumetric light
            this._createVolumetricLightPostProcess(scene, ratio);
            // Create volumetric light final post-process
            this.volumetricLightFinalPostProcess = new PostProcess("HDRVLSFinal", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", Constants.TEXTURETYPE_UNSIGNED_INT);
            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRVLSFinal", function () { return _this.volumetricLightFinalPostProcess; }, true));
        }
        if (this._lensFlareEnabled) {
            // Create lens flare post-process
            this._createLensFlarePostProcess(scene, ratio);
            // Create depth-of-field source post-process post lens-flare and disable it now
            this.lensFlareFinalPostProcess = new PostProcess("HDRPostLensFlareDepthOfFieldSource", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", Constants.TEXTURETYPE_UNSIGNED_INT);
            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRPostLensFlareDepthOfFieldSource", function () { return _this.lensFlareFinalPostProcess; }, true));
        }
        if (this._hdrEnabled) {
            // Create luminance
            this._createLuminancePostProcesses(scene, this._floatTextureType);
            // Create HDR
            this._createHdrPostProcess(scene, ratio);
            // Create depth-of-field source post-process post hdr and disable it now
            this.hdrFinalPostProcess = new PostProcess("HDRPostHDReDepthOfFieldSource", "standard", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define PASS_POST_PROCESS", Constants.TEXTURETYPE_UNSIGNED_INT);
            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRPostHDReDepthOfFieldSource", function () { return _this.hdrFinalPostProcess; }, true));
        }
        if (this._depthOfFieldEnabled) {
            // Create gaussian blur used by depth-of-field
            this._createBlurPostProcesses(scene, ratio / 2, 3, "depthOfFieldBlurWidth");
            // Create depth-of-field post-process
            this._createDepthOfFieldPostProcess(scene, ratio);
        }
        if (this._motionBlurEnabled) {
            // Create motion blur post-process
            this._createMotionBlurPostProcess(scene, ratio);
        }
        if (this._fxaaEnabled) {
            // Create fxaa post-process
            this.fxaaPostProcess = new FxaaPostProcess("fxaa", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);
            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRFxaa", function () { return _this.fxaaPostProcess; }, true));
        }
        if (this._cameras !== null) {
            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);
        }
        if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {
            Logger.Warn("MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0");
        }
    };
    // Down Sample X4 Post-Processs
    StandardRenderingPipeline.prototype._createDownSampleX4PostProcess = function (scene, ratio) {
        var _this = this;
        var downSampleX4Offsets = new Array(32);
        this.downSampleX4PostProcess = new PostProcess("HDRDownSampleX4", "standard", ["dsOffsets"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define DOWN_SAMPLE_X4", Constants.TEXTURETYPE_UNSIGNED_INT);
        this.downSampleX4PostProcess.onApply = function (effect) {
            var id = 0;
            var width = _this.downSampleX4PostProcess.width;
            var height = _this.downSampleX4PostProcess.height;
            for (var i = -2; i < 2; i++) {
                for (var j = -2; j < 2; j++) {
                    downSampleX4Offsets[id] = (i + 0.5) * (1.0 / width);
                    downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / height);
                    id += 2;
                }
            }
            effect.setArray2("dsOffsets", downSampleX4Offsets);
        };
        // Add to pipeline
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRDownSampleX4", function () { return _this.downSampleX4PostProcess; }, true));
    };
    // Brightpass Post-Process
    StandardRenderingPipeline.prototype._createBrightPassPostProcess = function (scene, ratio) {
        var _this = this;
        var brightOffsets = new Array(8);
        this.brightPassPostProcess = new PostProcess("HDRBrightPass", "standard", ["dsOffsets", "brightThreshold"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define BRIGHT_PASS", Constants.TEXTURETYPE_UNSIGNED_INT);
        this.brightPassPostProcess.onApply = function (effect) {
            var sU = (1.0 / _this.brightPassPostProcess.width);
            var sV = (1.0 / _this.brightPassPostProcess.height);
            brightOffsets[0] = -0.5 * sU;
            brightOffsets[1] = 0.5 * sV;
            brightOffsets[2] = 0.5 * sU;
            brightOffsets[3] = 0.5 * sV;
            brightOffsets[4] = -0.5 * sU;
            brightOffsets[5] = -0.5 * sV;
            brightOffsets[6] = 0.5 * sU;
            brightOffsets[7] = -0.5 * sV;
            effect.setArray2("dsOffsets", brightOffsets);
            effect.setFloat("brightThreshold", _this.brightThreshold);
        };
        // Add to pipeline
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBrightPass", function () { return _this.brightPassPostProcess; }, true));
    };
    // Create blur H&V post-processes
    StandardRenderingPipeline.prototype._createBlurPostProcesses = function (scene, ratio, indice, blurWidthKey) {
        var _this = this;
        if (blurWidthKey === void 0) { blurWidthKey = "blurWidth"; }
        var engine = scene.getEngine();
        var blurX = new BlurPostProcess("HDRBlurH" + "_" + indice, new Vector2(1, 0), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);
        var blurY = new BlurPostProcess("HDRBlurV" + "_" + indice, new Vector2(0, 1), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);
        blurX.onActivateObservable.add(function () {
            var dw = blurX.width / engine.getRenderWidth();
            blurX.kernel = _this[blurWidthKey] * dw;
        });
        blurY.onActivateObservable.add(function () {
            var dw = blurY.height / engine.getRenderHeight();
            blurY.kernel = _this.horizontalBlur ? 64 * dw : _this[blurWidthKey] * dw;
        });
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBlurH" + indice, function () { return blurX; }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRBlurV" + indice, function () { return blurY; }, true));
        this.blurHPostProcesses.push(blurX);
        this.blurVPostProcesses.push(blurY);
    };
    // Create texture adder post-process
    StandardRenderingPipeline.prototype._createTextureAdderPostProcess = function (scene, ratio) {
        var _this = this;
        this.textureAdderPostProcess = new PostProcess("HDRTextureAdder", "standard", ["exposure"], ["otherSampler", "lensSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define TEXTURE_ADDER", Constants.TEXTURETYPE_UNSIGNED_INT);
        this.textureAdderPostProcess.onApply = function (effect) {
            effect.setTextureFromPostProcess("otherSampler", _this._vlsEnabled ? _this._currentDepthOfFieldSource : _this.originalPostProcess);
            effect.setTexture("lensSampler", _this.lensTexture);
            effect.setFloat("exposure", _this._currentExposure);
            _this._currentDepthOfFieldSource = _this.textureAdderFinalPostProcess;
        };
        // Add to pipeline
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRTextureAdder", function () { return _this.textureAdderPostProcess; }, true));
    };
    StandardRenderingPipeline.prototype._createVolumetricLightPostProcess = function (scene, ratio) {
        var _this = this;
        var geometryRenderer = scene.enableGeometryBufferRenderer();
        geometryRenderer.enablePosition = true;
        var geometry = geometryRenderer.getGBuffer();
        // Base post-process
        this.volumetricLightPostProcess = new PostProcess("HDRVLS", "standard", ["shadowViewProjection", "cameraPosition", "sunDirection", "sunColor", "scatteringCoefficient", "scatteringPower", "depthValues"], ["shadowMapSampler", "positionSampler"], ratio / 8, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define VLS\n#define NB_STEPS " + this._volumetricLightStepsCount.toFixed(1));
        var depthValues = Vector2.Zero();
        this.volumetricLightPostProcess.onApply = function (effect) {
            if (_this.sourceLight && _this.sourceLight.getShadowGenerator() && _this._scene.activeCamera) {
                var generator = _this.sourceLight.getShadowGenerator();
                effect.setTexture("shadowMapSampler", generator.getShadowMap());
                effect.setTexture("positionSampler", geometry.textures[2]);
                effect.setColor3("sunColor", _this.sourceLight.diffuse);
                effect.setVector3("sunDirection", _this.sourceLight.getShadowDirection());
                effect.setVector3("cameraPosition", _this._scene.activeCamera.globalPosition);
                effect.setMatrix("shadowViewProjection", generator.getTransformMatrix());
                effect.setFloat("scatteringCoefficient", _this.volumetricLightCoefficient);
                effect.setFloat("scatteringPower", _this.volumetricLightPower);
                depthValues.x = _this.sourceLight.getDepthMinZ(_this._scene.activeCamera);
                depthValues.y = _this.sourceLight.getDepthMaxZ(_this._scene.activeCamera);
                effect.setVector2("depthValues", depthValues);
            }
        };
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRVLS", function () { return _this.volumetricLightPostProcess; }, true));
        // Smooth
        this._createBlurPostProcesses(scene, ratio / 4, 0, "volumetricLightBlurScale");
        // Merge
        this.volumetricLightMergePostProces = new PostProcess("HDRVLSMerge", "standard", [], ["originalSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define VLSMERGE");
        this.volumetricLightMergePostProces.onApply = function (effect) {
            effect.setTextureFromPostProcess("originalSampler", _this._bloomEnabled ? _this.textureAdderFinalPostProcess : _this.originalPostProcess);
            _this._currentDepthOfFieldSource = _this.volumetricLightFinalPostProcess;
        };
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRVLSMerge", function () { return _this.volumetricLightMergePostProces; }, true));
    };
    // Create luminance
    StandardRenderingPipeline.prototype._createLuminancePostProcesses = function (scene, textureType) {
        var _this = this;
        // Create luminance
        var size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);
        this.luminancePostProcess = new PostProcess("HDRLuminance", "standard", ["lumOffsets"], [], { width: size, height: size }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define LUMINANCE", textureType);
        var offsets = [];
        this.luminancePostProcess.onApply = function (effect) {
            var sU = (1.0 / _this.luminancePostProcess.width);
            var sV = (1.0 / _this.luminancePostProcess.height);
            offsets[0] = -0.5 * sU;
            offsets[1] = 0.5 * sV;
            offsets[2] = 0.5 * sU;
            offsets[3] = 0.5 * sV;
            offsets[4] = -0.5 * sU;
            offsets[5] = -0.5 * sV;
            offsets[6] = 0.5 * sU;
            offsets[7] = -0.5 * sV;
            effect.setArray2("lumOffsets", offsets);
        };
        // Add to pipeline
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLuminance", function () { return _this.luminancePostProcess; }, true));
        // Create down sample luminance
        for (var i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {
            var size = Math.pow(3, i);
            var defines = "#define LUMINANCE_DOWN_SAMPLE\n";
            if (i === 0) {
                defines += "#define FINAL_DOWN_SAMPLER";
            }
            var postProcess = new PostProcess("HDRLuminanceDownSample" + i, "standard", ["dsOffsets", "halfDestPixelSize"], [], { width: size, height: size }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines, textureType);
            this.luminanceDownSamplePostProcesses.push(postProcess);
        }
        // Create callbacks and add effects
        var lastLuminance = this.luminancePostProcess;
        this.luminanceDownSamplePostProcesses.forEach(function (pp, index) {
            var downSampleOffsets = new Array(18);
            pp.onApply = function (effect) {
                if (!lastLuminance) {
                    return;
                }
                var id = 0;
                for (var x = -1; x < 2; x++) {
                    for (var y = -1; y < 2; y++) {
                        downSampleOffsets[id] = x / lastLuminance.width;
                        downSampleOffsets[id + 1] = y / lastLuminance.height;
                        id += 2;
                    }
                }
                effect.setArray2("dsOffsets", downSampleOffsets);
                effect.setFloat("halfDestPixelSize", 0.5 / lastLuminance.width);
                if (index === _this.luminanceDownSamplePostProcesses.length - 1) {
                    lastLuminance = _this.luminancePostProcess;
                }
                else {
                    lastLuminance = pp;
                }
            };
            if (index === _this.luminanceDownSamplePostProcesses.length - 1) {
                pp.onAfterRender = function () {
                    var pixel = scene.getEngine().readPixels(0, 0, 1, 1);
                    var bit_shift = new Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);
                    _this._hdrCurrentLuminance = (pixel[0] * bit_shift.x + pixel[1] * bit_shift.y + pixel[2] * bit_shift.z + pixel[3] * bit_shift.w) / 100.0;
                };
            }
            _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLuminanceDownSample" + index, function () { return pp; }, true));
        });
    };
    // Create HDR post-process
    StandardRenderingPipeline.prototype._createHdrPostProcess = function (scene, ratio) {
        var _this = this;
        var defines = ["#define HDR"];
        if (this._hdrAutoExposure) {
            defines.push("#define AUTO_EXPOSURE");
        }
        this.hdrPostProcess = new PostProcess("HDR", "standard", ["averageLuminance"], ["textureAdderSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines.join("\n"), Constants.TEXTURETYPE_UNSIGNED_INT);
        var outputLiminance = 1;
        var time = 0;
        var lastTime = 0;
        this.hdrPostProcess.onApply = function (effect) {
            effect.setTextureFromPostProcess("textureAdderSampler", _this._currentDepthOfFieldSource);
            time += scene.getEngine().getDeltaTime();
            if (outputLiminance < 0) {
                outputLiminance = _this._hdrCurrentLuminance;
            }
            else {
                var dt = (lastTime - time) / 1000.0;
                if (_this._hdrCurrentLuminance < outputLiminance + _this.hdrDecreaseRate * dt) {
                    outputLiminance += _this.hdrDecreaseRate * dt;
                }
                else if (_this._hdrCurrentLuminance > outputLiminance - _this.hdrIncreaseRate * dt) {
                    outputLiminance -= _this.hdrIncreaseRate * dt;
                }
                else {
                    outputLiminance = _this._hdrCurrentLuminance;
                }
            }
            if (_this.hdrAutoExposure) {
                _this._currentExposure = _this._fixedExposure / outputLiminance;
            }
            else {
                outputLiminance = Scalar.Clamp(outputLiminance, _this.hdrMinimumLuminance, 1e20);
                effect.setFloat("averageLuminance", outputLiminance);
            }
            lastTime = time;
            _this._currentDepthOfFieldSource = _this.hdrFinalPostProcess;
        };
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDR", function () { return _this.hdrPostProcess; }, true));
    };
    // Create lens flare post-process
    StandardRenderingPipeline.prototype._createLensFlarePostProcess = function (scene, ratio) {
        var _this = this;
        this.lensFlarePostProcess = new PostProcess("HDRLensFlare", "standard", ["strength", "ghostDispersal", "haloWidth", "resolution", "distortionStrength"], ["lensColorSampler"], ratio / 2, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define LENS_FLARE", Constants.TEXTURETYPE_UNSIGNED_INT);
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLensFlare", function () { return _this.lensFlarePostProcess; }, true));
        this._createBlurPostProcesses(scene, ratio / 4, 2);
        this.lensFlareComposePostProcess = new PostProcess("HDRLensFlareCompose", "standard", ["lensStarMatrix"], ["otherSampler", "lensDirtSampler", "lensStarSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define LENS_FLARE_COMPOSE", Constants.TEXTURETYPE_UNSIGNED_INT);
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRLensFlareCompose", function () { return _this.lensFlareComposePostProcess; }, true));
        var resolution = new Vector2(0, 0);
        // Lens flare
        this.lensFlarePostProcess.onApply = function (effect) {
            effect.setTextureFromPostProcess("textureSampler", _this._bloomEnabled ? _this.blurHPostProcesses[0] : _this.originalPostProcess);
            effect.setTexture("lensColorSampler", _this.lensColorTexture);
            effect.setFloat("strength", _this.lensFlareStrength);
            effect.setFloat("ghostDispersal", _this.lensFlareGhostDispersal);
            effect.setFloat("haloWidth", _this.lensFlareHaloWidth);
            // Shift
            resolution.x = _this.lensFlarePostProcess.width;
            resolution.y = _this.lensFlarePostProcess.height;
            effect.setVector2("resolution", resolution);
            effect.setFloat("distortionStrength", _this.lensFlareDistortionStrength);
        };
        // Compose
        var scaleBias1 = Matrix.FromValues(2.0, 0.0, -1.0, 0.0, 0.0, 2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
        var scaleBias2 = Matrix.FromValues(0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
        this.lensFlareComposePostProcess.onApply = function (effect) {
            if (!_this._scene.activeCamera) {
                return;
            }
            effect.setTextureFromPostProcess("otherSampler", _this._currentDepthOfFieldSource);
            effect.setTexture("lensDirtSampler", _this.lensFlareDirtTexture);
            effect.setTexture("lensStarSampler", _this.lensStarTexture);
            // Lens start rotation matrix
            var camerax = _this._scene.activeCamera.getViewMatrix().getRow(0);
            var cameraz = _this._scene.activeCamera.getViewMatrix().getRow(2);
            var camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1.0, 0.0, 0.0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0.0, 0.0, 1.0));
            camRot *= 4.0;
            var starRotation = Matrix.FromValues(Math.cos(camRot) * 0.5, -Math.sin(camRot), 0.0, 0.0, Math.sin(camRot), Math.cos(camRot) * 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
            var lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);
            effect.setMatrix("lensStarMatrix", lensStarMatrix);
            _this._currentDepthOfFieldSource = _this.lensFlareFinalPostProcess;
        };
    };
    // Create depth-of-field post-process
    StandardRenderingPipeline.prototype._createDepthOfFieldPostProcess = function (scene, ratio) {
        var _this = this;
        this.depthOfFieldPostProcess = new PostProcess("HDRDepthOfField", "standard", ["distance"], ["otherSampler", "depthSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define DEPTH_OF_FIELD", Constants.TEXTURETYPE_UNSIGNED_INT);
        this.depthOfFieldPostProcess.onApply = function (effect) {
            effect.setTextureFromPostProcess("otherSampler", _this._currentDepthOfFieldSource);
            effect.setTexture("depthSampler", _this._getDepthTexture());
            effect.setFloat("distance", _this.depthOfFieldDistance);
        };
        // Add to pipeline
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRDepthOfField", function () { return _this.depthOfFieldPostProcess; }, true));
    };
    // Create motion blur post-process
    StandardRenderingPipeline.prototype._createMotionBlurPostProcess = function (scene, ratio) {
        var _this = this;
        this.motionBlurPostProcess = new PostProcess("HDRMotionBlur", "standard", ["inverseViewProjection", "prevViewProjection", "screenSize", "motionScale", "motionStrength"], ["depthSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, "#define MOTION_BLUR\n#define MAX_MOTION_SAMPLES " + this.motionBlurSamples.toFixed(1), Constants.TEXTURETYPE_UNSIGNED_INT);
        var motionScale = 0;
        var prevViewProjection = Matrix.Identity();
        var invViewProjection = Matrix.Identity();
        var viewProjection = Matrix.Identity();
        var screenSize = Vector2.Zero();
        this.motionBlurPostProcess.onApply = function (effect) {
            viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());
            viewProjection.invertToRef(invViewProjection);
            effect.setMatrix("inverseViewProjection", invViewProjection);
            effect.setMatrix("prevViewProjection", prevViewProjection);
            prevViewProjection = viewProjection;
            screenSize.x = _this.motionBlurPostProcess.width;
            screenSize.y = _this.motionBlurPostProcess.height;
            effect.setVector2("screenSize", screenSize);
            motionScale = scene.getEngine().getFps() / 60.0;
            effect.setFloat("motionScale", motionScale);
            effect.setFloat("motionStrength", _this.motionStrength);
            effect.setTexture("depthSampler", _this._getDepthTexture());
        };
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), "HDRMotionBlur", function () { return _this.motionBlurPostProcess; }, true));
    };
    StandardRenderingPipeline.prototype._getDepthTexture = function () {
        if (this._scene.getEngine().getCaps().drawBuffersExtension) {
            var renderer = this._scene.enableGeometryBufferRenderer();
            return renderer.getGBuffer().textures[0];
        }
        return this._scene.enableDepthRenderer().getDepthMap();
    };
    StandardRenderingPipeline.prototype._disposePostProcesses = function () {
        for (var i = 0; i < this._cameras.length; i++) {
            var camera = this._cameras[i];
            if (this.originalPostProcess) {
                this.originalPostProcess.dispose(camera);
            }
            if (this.downSampleX4PostProcess) {
                this.downSampleX4PostProcess.dispose(camera);
            }
            if (this.brightPassPostProcess) {
                this.brightPassPostProcess.dispose(camera);
            }
            if (this.textureAdderPostProcess) {
                this.textureAdderPostProcess.dispose(camera);
            }
            if (this.textureAdderFinalPostProcess) {
                this.textureAdderFinalPostProcess.dispose(camera);
            }
            if (this.volumetricLightPostProcess) {
                this.volumetricLightPostProcess.dispose(camera);
            }
            if (this.volumetricLightSmoothXPostProcess) {
                this.volumetricLightSmoothXPostProcess.dispose(camera);
            }
            if (this.volumetricLightSmoothYPostProcess) {
                this.volumetricLightSmoothYPostProcess.dispose(camera);
            }
            if (this.volumetricLightMergePostProces) {
                this.volumetricLightMergePostProces.dispose(camera);
            }
            if (this.volumetricLightFinalPostProcess) {
                this.volumetricLightFinalPostProcess.dispose(camera);
            }
            if (this.lensFlarePostProcess) {
                this.lensFlarePostProcess.dispose(camera);
            }
            if (this.lensFlareComposePostProcess) {
                this.lensFlareComposePostProcess.dispose(camera);
            }
            for (var j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {
                this.luminanceDownSamplePostProcesses[j].dispose(camera);
            }
            if (this.luminancePostProcess) {
                this.luminancePostProcess.dispose(camera);
            }
            if (this.hdrPostProcess) {
                this.hdrPostProcess.dispose(camera);
            }
            if (this.hdrFinalPostProcess) {
                this.hdrFinalPostProcess.dispose(camera);
            }
            if (this.depthOfFieldPostProcess) {
                this.depthOfFieldPostProcess.dispose(camera);
            }
            if (this.motionBlurPostProcess) {
                this.motionBlurPostProcess.dispose(camera);
            }
            if (this.fxaaPostProcess) {
                this.fxaaPostProcess.dispose(camera);
            }
            for (var j = 0; j < this.blurHPostProcesses.length; j++) {
                this.blurHPostProcesses[j].dispose(camera);
            }
            for (var j = 0; j < this.blurVPostProcesses.length; j++) {
                this.blurVPostProcesses[j].dispose(camera);
            }
        }
        this.originalPostProcess = null;
        this.downSampleX4PostProcess = null;
        this.brightPassPostProcess = null;
        this.textureAdderPostProcess = null;
        this.textureAdderFinalPostProcess = null;
        this.volumetricLightPostProcess = null;
        this.volumetricLightSmoothXPostProcess = null;
        this.volumetricLightSmoothYPostProcess = null;
        this.volumetricLightMergePostProces = null;
        this.volumetricLightFinalPostProcess = null;
        this.lensFlarePostProcess = null;
        this.lensFlareComposePostProcess = null;
        this.luminancePostProcess = null;
        this.hdrPostProcess = null;
        this.hdrFinalPostProcess = null;
        this.depthOfFieldPostProcess = null;
        this.motionBlurPostProcess = null;
        this.fxaaPostProcess = null;
        this.luminanceDownSamplePostProcesses = [];
        this.blurHPostProcesses = [];
        this.blurVPostProcesses = [];
    };
    /**
     * Dispose of the pipeline and stop all post processes
     */
    StandardRenderingPipeline.prototype.dispose = function () {
        this._disposePostProcesses();
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
        _super.prototype.dispose.call(this);
    };
    /**
     * Serialize the rendering pipeline (Used when exporting)
     * @returns the serialized object
     */
    StandardRenderingPipeline.prototype.serialize = function () {
        var serializationObject = SerializationHelper.Serialize(this);
        if (this.sourceLight) {
            serializationObject.sourceLightId = this.sourceLight.id;
        }
        serializationObject.customType = "StandardRenderingPipeline";
        return serializationObject;
    };
    /**
     * Parse the serialized pipeline
     * @param source Source pipeline.
     * @param scene The scene to load the pipeline to.
     * @param rootUrl The URL of the serialized pipeline.
     * @returns An instantiated pipeline from the serialized object.
     */
    StandardRenderingPipeline.Parse = function (source, scene, rootUrl) {
        var p = SerializationHelper.Parse(function () { return new StandardRenderingPipeline(source._name, scene, source._ratio); }, source, scene, rootUrl);
        if (source.sourceLightId) {
            p.sourceLight = scene.getLightByID(source.sourceLightId);
        }
        return p;
    };
    /**
     * Luminance steps
     */
    StandardRenderingPipeline.LuminanceSteps = 6;
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "brightThreshold", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "blurWidth", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "horizontalBlur", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "exposure", null);
    __decorate([
        serializeAsTexture("lensTexture")
    ], StandardRenderingPipeline.prototype, "lensTexture", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "volumetricLightCoefficient", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "volumetricLightPower", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "volumetricLightBlurScale", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "hdrMinimumLuminance", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "hdrDecreaseRate", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "hdrIncreaseRate", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "hdrAutoExposure", null);
    __decorate([
        serializeAsTexture("lensColorTexture")
    ], StandardRenderingPipeline.prototype, "lensColorTexture", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "lensFlareStrength", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "lensFlareGhostDispersal", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "lensFlareHaloWidth", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "lensFlareDistortionStrength", void 0);
    __decorate([
        serializeAsTexture("lensStarTexture")
    ], StandardRenderingPipeline.prototype, "lensStarTexture", void 0);
    __decorate([
        serializeAsTexture("lensFlareDirtTexture")
    ], StandardRenderingPipeline.prototype, "lensFlareDirtTexture", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "depthOfFieldDistance", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "depthOfFieldBlurWidth", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "motionStrength", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "_ratio", void 0);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "BloomEnabled", null);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "DepthOfFieldEnabled", null);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "LensFlareEnabled", null);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "HDREnabled", null);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "VLSEnabled", null);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "MotionBlurEnabled", null);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "fxaaEnabled", null);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "volumetricLightStepsCount", null);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "motionBlurSamples", null);
    __decorate([
        serialize()
    ], StandardRenderingPipeline.prototype, "samples", null);
    return StandardRenderingPipeline;
}(PostProcessRenderPipeline));
_TypeStore.RegisteredTypes["BABYLON.StandardRenderingPipeline"] = StandardRenderingPipeline;

var name$11 = 'tonemapPixelShader';
var shader$11 = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform float _ExposureAdjustment;\n#if defined(HABLE_TONEMAPPING)\nconst float A=0.15;\nconst float B=0.50;\nconst float C=0.10;\nconst float D=0.20;\nconst float E=0.02;\nconst float F=0.30;\nconst float W=11.2;\n#endif\nfloat Luminance(vec3 c)\n{\nreturn dot(c,vec3(0.22,0.707,0.071));\n}\nvoid main(void)\n{\nvec3 colour=texture2D(textureSampler,vUV).rgb;\n#if defined(REINHARD_TONEMAPPING)\nfloat lum=Luminance(colour.rgb);\nfloat lumTm=lum*_ExposureAdjustment;\nfloat scale=lumTm/(1.0+lumTm);\ncolour*=scale/lum;\n#elif defined(HABLE_TONEMAPPING)\ncolour*=_ExposureAdjustment;\nconst float ExposureBias=2.0;\nvec3 x=ExposureBias*colour;\nvec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\nx=vec3(W,W,W);\nvec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);\ncolour=curr*whiteScale;\n#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\ncolour*=_ExposureAdjustment;\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\ncolour=retColor*retColor;\n#elif defined(PHOTOGRAPHIC_TONEMAPPING)\ncolour=vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);\n#endif\ngl_FragColor=vec4(colour.rgb,1.0);\n}";
Effect.ShadersStore[name$11] = shader$11;

/** Defines operator used for tonemapping */
var TonemappingOperator;
(function (TonemappingOperator) {
    /** Hable */
    TonemappingOperator[TonemappingOperator["Hable"] = 0] = "Hable";
    /** Reinhard */
    TonemappingOperator[TonemappingOperator["Reinhard"] = 1] = "Reinhard";
    /** HejiDawson */
    TonemappingOperator[TonemappingOperator["HejiDawson"] = 2] = "HejiDawson";
    /** Photographic */
    TonemappingOperator[TonemappingOperator["Photographic"] = 3] = "Photographic";
})(TonemappingOperator || (TonemappingOperator = {}));
/**
 * Defines a post process to apply tone mapping
 */
var TonemapPostProcess = /** @class */ (function (_super) {
    __extends(TonemapPostProcess, _super);
    /**
     * Creates a new TonemapPostProcess
     * @param name defines the name of the postprocess
     * @param _operator defines the operator to use
     * @param exposureAdjustment defines the required exposure adjustement
     * @param camera defines the camera to use (can be null)
     * @param samplingMode defines the required sampling mode (BABYLON.Texture.BILINEAR_SAMPLINGMODE by default)
     * @param engine defines the hosting engine (can be ignore if camera is set)
     * @param textureFormat defines the texture format to use (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)
     */
    function TonemapPostProcess(name, _operator, 
    /** Defines the required exposure adjustement */
    exposureAdjustment, camera, samplingMode, engine, textureFormat) {
        if (samplingMode === void 0) { samplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE; }
        if (textureFormat === void 0) { textureFormat = Constants.TEXTURETYPE_UNSIGNED_INT; }
        var _this = _super.call(this, name, "tonemap", ["_ExposureAdjustment"], null, 1.0, camera, samplingMode, engine, true, null, textureFormat) || this;
        _this._operator = _operator;
        _this.exposureAdjustment = exposureAdjustment;
        var defines = "#define ";
        if (_this._operator === TonemappingOperator.Hable) {
            defines += "HABLE_TONEMAPPING";
        }
        else if (_this._operator === TonemappingOperator.Reinhard) {
            defines += "REINHARD_TONEMAPPING";
        }
        else if (_this._operator === TonemappingOperator.HejiDawson) {
            defines += "OPTIMIZED_HEJIDAWSON_TONEMAPPING";
        }
        else if (_this._operator === TonemappingOperator.Photographic) {
            defines += "PHOTOGRAPHIC_TONEMAPPING";
        }
        //sadly a second call to create the effect.
        _this.updateEffect(defines);
        _this.onApply = function (effect) {
            effect.setFloat("_ExposureAdjustment", _this.exposureAdjustment);
        };
        return _this;
    }
    return TonemapPostProcess;
}(PostProcess));

var name$12 = 'depthVertexShader';
var shader$12 = "\nattribute vec3 position;\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nuniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\nvarying float vDepthMetric;\nvoid main(void)\n{\n#include<instancesVertex>\n#include<bonesVertex>\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}";
Effect.ShadersStore[name$12] = shader$12;

var name$13 = 'volumetricLightScatteringPixelShader';
var shader$13 = "uniform sampler2D textureSampler;\nuniform sampler2D lightScatteringSampler;\nuniform float decay;\nuniform float exposure;\nuniform float weight;\nuniform float density;\nuniform vec2 meshPositionOnScreen;\nvarying vec2 vUV;\nvoid main(void) {\nvec2 tc=vUV;\nvec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);\ndeltaTexCoord*=1.0/float(NUM_SAMPLES)*density;\nfloat illuminationDecay=1.0;\nvec4 color=texture2D(lightScatteringSampler,tc)*0.4;\nfor(int i=0; i<NUM_SAMPLES; i++) {\ntc-=deltaTexCoord;\nvec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;\ndataSample*=illuminationDecay*weight;\ncolor+=dataSample;\nilluminationDecay*=decay;\n}\nvec4 realColor=texture2D(textureSampler,vUV);\ngl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),1))+(realColor*(1.5-0.4)));\n}\n";
Effect.ShadersStore[name$13] = shader$13;

var name$14 = 'volumetricLightScatteringPassPixelShader';
var shader$14 = "#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\n#endif\n#if defined(ALPHATEST)\nuniform sampler2D diffuseSampler;\n#endif\nvoid main(void)\n{\n#if defined(ALPHATEST)\nvec4 diffuseColor=texture2D(diffuseSampler,vUV);\nif (diffuseColor.a<0.4)\ndiscard;\n#endif\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\n}\n";
Effect.ShadersStore[name$14] = shader$14;

/**
 *  Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html
 */
var VolumetricLightScatteringPostProcess = /** @class */ (function (_super) {
    __extends(VolumetricLightScatteringPostProcess, _super);
    /**
     * @constructor
     * @param name The post-process name
     * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
     * @param camera The camera that the post-process will be attached to
     * @param mesh The mesh used to create the light scattering
     * @param samples The post-process quality, default 100
     * @param samplingModeThe post-process filtering mode
     * @param engine The babylon engine
     * @param reusable If the post-process is reusable
     * @param scene The constructor needs a scene reference to initialize internal components. If "camera" is null a "scene" must be provided
     */
    function VolumetricLightScatteringPostProcess(name, ratio, camera, mesh, samples, samplingMode, engine, reusable, scene) {
        if (samples === void 0) { samples = 100; }
        if (samplingMode === void 0) { samplingMode = Texture.BILINEAR_SAMPLINGMODE; }
        var _this = _super.call(this, name, "volumetricLightScattering", ["decay", "exposure", "weight", "meshPositionOnScreen", "density"], ["lightScatteringSampler"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, "#define NUM_SAMPLES " + samples) || this;
        _this._screenCoordinates = Vector2.Zero();
        /**
        * Custom position of the mesh. Used if "useCustomMeshPosition" is set to "true"
        */
        _this.customMeshPosition = Vector3.Zero();
        /**
        * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)
        */
        _this.useCustomMeshPosition = false;
        /**
        * If the post-process should inverse the light scattering direction
        */
        _this.invert = true;
        /**
        * Array containing the excluded meshes not rendered in the internal pass
        */
        _this.excludedMeshes = new Array();
        /**
        * Controls the overall intensity of the post-process
        */
        _this.exposure = 0.3;
        /**
        * Dissipates each sample's contribution in range [0, 1]
        */
        _this.decay = 0.96815;
        /**
        * Controls the overall intensity of each sample
        */
        _this.weight = 0.58767;
        /**
        * Controls the density of each sample
        */
        _this.density = 0.926;
        scene = ((camera === null) ? scene : camera.getScene()); // parameter "scene" can be null.
        engine = scene.getEngine();
        _this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
        // Configure mesh
        _this.mesh = ((mesh !== null) ? mesh : VolumetricLightScatteringPostProcess.CreateDefaultMesh("VolumetricLightScatteringMesh", scene));
        // Configure
        _this._createPass(scene, ratio.passRatio || ratio);
        _this.onActivate = function (camera) {
            if (!_this.isSupported) {
                _this.dispose(camera);
            }
            _this.onActivate = null;
        };
        _this.onApplyObservable.add(function (effect) {
            _this._updateMeshScreenCoordinates(scene);
            effect.setTexture("lightScatteringSampler", _this._volumetricLightScatteringRTT);
            effect.setFloat("exposure", _this.exposure);
            effect.setFloat("decay", _this.decay);
            effect.setFloat("weight", _this.weight);
            effect.setFloat("density", _this.density);
            effect.setVector2("meshPositionOnScreen", _this._screenCoordinates);
        });
        return _this;
    }
    Object.defineProperty(VolumetricLightScatteringPostProcess.prototype, "useDiffuseColor", {
        /**
         * @hidden
         * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead
         */
        get: function () {
            Logger.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead");
            return false;
        },
        set: function (useDiffuseColor) {
            Logger.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the string "VolumetricLightScatteringPostProcess"
     * @returns "VolumetricLightScatteringPostProcess"
     */
    VolumetricLightScatteringPostProcess.prototype.getClassName = function () {
        return "VolumetricLightScatteringPostProcess";
    };
    VolumetricLightScatteringPostProcess.prototype._isReady = function (subMesh, useInstances) {
        var mesh = subMesh.getMesh();
        // Render this.mesh as default
        if (mesh === this.mesh && mesh.material) {
            return mesh.material.isReady(mesh);
        }
        var defines = [];
        var attribs = [VertexBuffer.PositionKind];
        var material = subMesh.getMaterial();
        // Alpha test
        if (material) {
            if (material.needAlphaTesting()) {
                defines.push("#define ALPHATEST");
            }
            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                attribs.push(VertexBuffer.UVKind);
                defines.push("#define UV1");
            }
            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
                attribs.push(VertexBuffer.UV2Kind);
                defines.push("#define UV2");
            }
        }
        // Bones
        if (mesh.useBones && mesh.computeBonesUsingShaders) {
            attribs.push(VertexBuffer.MatricesIndicesKind);
            attribs.push(VertexBuffer.MatricesWeightsKind);
            defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
            defines.push("#define BonesPerMesh " + (mesh.skeleton ? (mesh.skeleton.bones.length + 1) : 0));
        }
        else {
            defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        // Instances
        if (useInstances) {
            defines.push("#define INSTANCES");
            attribs.push("world0");
            attribs.push("world1");
            attribs.push("world2");
            attribs.push("world3");
        }
        // Get correct effect
        var join = defines.join("\n");
        if (this._cachedDefines !== join) {
            this._cachedDefines = join;
            this._volumetricLightScatteringPass = mesh.getScene().getEngine().createEffect({ vertexElement: "depth", fragmentElement: "volumetricLightScatteringPass" }, attribs, ["world", "mBones", "viewProjection", "diffuseMatrix"], ["diffuseSampler"], join);
        }
        return this._volumetricLightScatteringPass.isReady();
    };
    /**
     * Sets the new light position for light scattering effect
     * @param position The new custom light position
     */
    VolumetricLightScatteringPostProcess.prototype.setCustomMeshPosition = function (position) {
        this.customMeshPosition = position;
    };
    /**
     * Returns the light position for light scattering effect
     * @return Vector3 The custom light position
     */
    VolumetricLightScatteringPostProcess.prototype.getCustomMeshPosition = function () {
        return this.customMeshPosition;
    };
    /**
     * Disposes the internal assets and detaches the post-process from the camera
     */
    VolumetricLightScatteringPostProcess.prototype.dispose = function (camera) {
        var rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);
        if (rttIndex !== -1) {
            camera.getScene().customRenderTargets.splice(rttIndex, 1);
        }
        this._volumetricLightScatteringRTT.dispose();
        _super.prototype.dispose.call(this, camera);
    };
    /**
     * Returns the render target texture used by the post-process
     * @return the render target texture used by the post-process
     */
    VolumetricLightScatteringPostProcess.prototype.getPass = function () {
        return this._volumetricLightScatteringRTT;
    };
    // Private methods
    VolumetricLightScatteringPostProcess.prototype._meshExcluded = function (mesh) {
        if (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
            return true;
        }
        return false;
    };
    VolumetricLightScatteringPostProcess.prototype._createPass = function (scene, ratio) {
        var _this = this;
        var engine = scene.getEngine();
        this._volumetricLightScatteringRTT = new RenderTargetTexture("volumetricLightScatteringMap", { width: engine.getRenderWidth() * ratio, height: engine.getRenderHeight() * ratio }, scene, false, true, Constants.TEXTURETYPE_UNSIGNED_INT);
        this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._volumetricLightScatteringRTT.renderList = null;
        this._volumetricLightScatteringRTT.renderParticles = false;
        this._volumetricLightScatteringRTT.ignoreCameraViewport = true;
        var camera = this.getCamera();
        if (camera) {
            camera.customRenderTargets.push(this._volumetricLightScatteringRTT);
        }
        else {
            scene.customRenderTargets.push(this._volumetricLightScatteringRTT);
        }
        // Custom render function for submeshes
        var renderSubMesh = function (subMesh) {
            var mesh = subMesh.getRenderingMesh();
            if (_this._meshExcluded(mesh)) {
                return;
            }
            var material = subMesh.getMaterial();
            if (!material) {
                return;
            }
            var scene = mesh.getScene();
            var engine = scene.getEngine();
            // Culling
            engine.setState(material.backFaceCulling);
            // Managing instances
            var batch = mesh._getInstancesRenderList(subMesh._id);
            if (batch.mustReturn) {
                return;
            }
            var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null);
            if (_this._isReady(subMesh, hardwareInstancedRendering)) {
                var effect = _this._volumetricLightScatteringPass;
                if (mesh === _this.mesh) {
                    if (subMesh.effect) {
                        effect = subMesh.effect;
                    }
                    else {
                        effect = material.getEffect();
                    }
                }
                engine.enableEffect(effect);
                mesh._bind(subMesh, effect, Material.TriangleFillMode);
                if (mesh === _this.mesh) {
                    material.bind(mesh.getWorldMatrix(), mesh);
                }
                else {
                    _this._volumetricLightScatteringPass.setMatrix("viewProjection", scene.getTransformMatrix());
                    // Alpha test
                    if (material && material.needAlphaTesting()) {
                        var alphaTexture = material.getAlphaTestTexture();
                        _this._volumetricLightScatteringPass.setTexture("diffuseSampler", alphaTexture);
                        if (alphaTexture) {
                            _this._volumetricLightScatteringPass.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
                        }
                    }
                    // Bones
                    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
                        _this._volumetricLightScatteringPass.setMatrices("mBones", mesh.skeleton.getTransformMatrices(mesh));
                    }
                }
                // Draw
                mesh._processRendering(subMesh, _this._volumetricLightScatteringPass, Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return effect.setMatrix("world", world); });
            }
        };
        // Render target texture callbacks
        var savedSceneClearColor;
        var sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);
        this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(function () {
            savedSceneClearColor = scene.clearColor;
            scene.clearColor = sceneClearColor;
        });
        this._volumetricLightScatteringRTT.onAfterRenderObservable.add(function () {
            scene.clearColor = savedSceneClearColor;
        });
        this._volumetricLightScatteringRTT.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
            var engine = scene.getEngine();
            var index;
            if (depthOnlySubMeshes.length) {
                engine.setColorWrite(false);
                for (index = 0; index < depthOnlySubMeshes.length; index++) {
                    renderSubMesh(depthOnlySubMeshes.data[index]);
                }
                engine.setColorWrite(true);
            }
            for (index = 0; index < opaqueSubMeshes.length; index++) {
                renderSubMesh(opaqueSubMeshes.data[index]);
            }
            for (index = 0; index < alphaTestSubMeshes.length; index++) {
                renderSubMesh(alphaTestSubMeshes.data[index]);
            }
            if (transparentSubMeshes.length) {
                // Sort sub meshes
                for (index = 0; index < transparentSubMeshes.length; index++) {
                    var submesh = transparentSubMeshes.data[index];
                    var boundingInfo = submesh.getBoundingInfo();
                    if (boundingInfo && scene.activeCamera) {
                        submesh._alphaIndex = submesh.getMesh().alphaIndex;
                        submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();
                    }
                }
                var sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);
                sortedArray.sort(function (a, b) {
                    // Alpha index first
                    if (a._alphaIndex > b._alphaIndex) {
                        return 1;
                    }
                    if (a._alphaIndex < b._alphaIndex) {
                        return -1;
                    }
                    // Then distance to camera
                    if (a._distanceToCamera < b._distanceToCamera) {
                        return 1;
                    }
                    if (a._distanceToCamera > b._distanceToCamera) {
                        return -1;
                    }
                    return 0;
                });
                // Render sub meshes
                engine.setAlphaMode(Constants.ALPHA_COMBINE);
                for (index = 0; index < sortedArray.length; index++) {
                    renderSubMesh(sortedArray[index]);
                }
                engine.setAlphaMode(Constants.ALPHA_DISABLE);
            }
        };
    };
    VolumetricLightScatteringPostProcess.prototype._updateMeshScreenCoordinates = function (scene) {
        var transform = scene.getTransformMatrix();
        var meshPosition;
        if (this.useCustomMeshPosition) {
            meshPosition = this.customMeshPosition;
        }
        else if (this.attachedNode) {
            meshPosition = this.attachedNode.position;
        }
        else {
            meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;
        }
        var pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);
        this._screenCoordinates.x = pos.x / this._viewPort.width;
        this._screenCoordinates.y = pos.y / this._viewPort.height;
        if (this.invert) {
            this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;
        }
    };
    // Static methods
    /**
    * Creates a default mesh for the Volumeric Light Scattering post-process
    * @param name The mesh name
    * @param scene The scene where to create the mesh
    * @return the default mesh
    */
    VolumetricLightScatteringPostProcess.CreateDefaultMesh = function (name, scene) {
        var mesh = Mesh.CreatePlane(name, 1, scene);
        mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;
        var material = new StandardMaterial(name + "Material", scene);
        material.emissiveColor = new Color3(1, 1, 1);
        mesh.material = material;
        return mesh;
    };
    __decorate([
        serializeAsVector3()
    ], VolumetricLightScatteringPostProcess.prototype, "customMeshPosition", void 0);
    __decorate([
        serialize()
    ], VolumetricLightScatteringPostProcess.prototype, "useCustomMeshPosition", void 0);
    __decorate([
        serialize()
    ], VolumetricLightScatteringPostProcess.prototype, "invert", void 0);
    __decorate([
        serializeAsMeshReference()
    ], VolumetricLightScatteringPostProcess.prototype, "mesh", void 0);
    __decorate([
        serialize()
    ], VolumetricLightScatteringPostProcess.prototype, "excludedMeshes", void 0);
    __decorate([
        serialize()
    ], VolumetricLightScatteringPostProcess.prototype, "exposure", void 0);
    __decorate([
        serialize()
    ], VolumetricLightScatteringPostProcess.prototype, "decay", void 0);
    __decorate([
        serialize()
    ], VolumetricLightScatteringPostProcess.prototype, "weight", void 0);
    __decorate([
        serialize()
    ], VolumetricLightScatteringPostProcess.prototype, "density", void 0);
    return VolumetricLightScatteringPostProcess;
}(PostProcess));

Object.defineProperty(Scene.prototype, "forceShowBoundingBoxes", {
    get: function () {
        return this._forceShowBoundingBoxes || false;
    },
    set: function (value) {
        this._forceShowBoundingBoxes = value;
        // Lazyly creates a BB renderer if needed.
        if (value) {
            this.getBoundingBoxRenderer();
        }
    },
    enumerable: true,
    configurable: true
});
Scene.prototype.getBoundingBoxRenderer = function () {
    if (!this._boundingBoxRenderer) {
        this._boundingBoxRenderer = new BoundingBoxRenderer(this);
    }
    return this._boundingBoxRenderer;
};
Object.defineProperty(AbstractMesh.prototype, "showBoundingBox", {
    get: function () {
        return this._showBoundingBox || false;
    },
    set: function (value) {
        this._showBoundingBox = value;
        // Lazyly creates a BB renderer if needed.
        if (value) {
            this.getScene().getBoundingBoxRenderer();
        }
    },
    enumerable: true,
    configurable: true
});
/**
 * Component responsible of rendering the bounding box of the meshes in a scene.
 * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties
 */
var BoundingBoxRenderer = /** @class */ (function () {
    /**
     * Instantiates a new bounding box renderer in a scene.
     * @param scene the scene the  renderer renders in
     */
    function BoundingBoxRenderer(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;
        /**
         * Color of the bounding box lines placed in front of an object
         */
        this.frontColor = new Color3(1, 1, 1);
        /**
         * Color of the bounding box lines placed behind an object
         */
        this.backColor = new Color3(0.1, 0.1, 0.1);
        /**
         * Defines if the renderer should show the back lines or not
         */
        this.showBackLines = true;
        /**
         * @hidden
         */
        this.renderList = new SmartArray(32);
        this._vertexBuffers = {};
        this.scene = scene;
        scene._addComponent(this);
    }
    /**
     * Registers the component in a given scene
     */
    BoundingBoxRenderer.prototype.register = function () {
        this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);
        this.scene._activeMeshStage.registerStep(SceneComponentConstants.STEP_ACTIVEMESH_BOUNDINGBOXRENDERER, this, this._activeMesh);
        this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);
        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);
    };
    BoundingBoxRenderer.prototype._evaluateSubMesh = function (mesh, subMesh) {
        if (mesh.showSubMeshesBoundingBox) {
            var boundingInfo = subMesh.getBoundingInfo();
            if (boundingInfo !== null && boundingInfo !== undefined) {
                boundingInfo.boundingBox._tag = mesh.renderingGroupId;
                this.renderList.push(boundingInfo.boundingBox);
            }
        }
    };
    BoundingBoxRenderer.prototype._activeMesh = function (sourceMesh, mesh) {
        if (sourceMesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {
            var boundingInfo = sourceMesh.getBoundingInfo();
            boundingInfo.boundingBox._tag = mesh.renderingGroupId;
            this.renderList.push(boundingInfo.boundingBox);
        }
    };
    BoundingBoxRenderer.prototype._prepareRessources = function () {
        if (this._colorShader) {
            return;
        }
        this._colorShader = new ShaderMaterial("colorShader", this.scene, "color", {
            attributes: [VertexBuffer.PositionKind],
            uniforms: ["world", "viewProjection", "color"]
        });
        var engine = this.scene.getEngine();
        var boxdata = VertexData.CreateBox({ size: 1.0 });
        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);
        this._createIndexBuffer();
    };
    BoundingBoxRenderer.prototype._createIndexBuffer = function () {
        var engine = this.scene.getEngine();
        this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    BoundingBoxRenderer.prototype.rebuild = function () {
        var vb = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vb) {
            vb._rebuild();
        }
        this._createIndexBuffer();
    };
    /**
     * @hidden
     */
    BoundingBoxRenderer.prototype.reset = function () {
        this.renderList.reset();
    };
    /**
     * Render the bounding boxes of a specific rendering group
     * @param renderingGroupId defines the rendering group to render
     */
    BoundingBoxRenderer.prototype.render = function (renderingGroupId) {
        if (this.renderList.length === 0) {
            return;
        }
        this._prepareRessources();
        if (!this._colorShader.isReady()) {
            return;
        }
        var engine = this.scene.getEngine();
        engine.setDepthWrite(false);
        this._colorShader._preBind();
        for (var boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {
            var boundingBox = this.renderList.data[boundingBoxIndex];
            if (boundingBox._tag !== renderingGroupId) {
                continue;
            }
            var min = boundingBox.minimum;
            var max = boundingBox.maximum;
            var diff = max.subtract(min);
            var median = min.add(diff.scale(0.5));
            var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z)
                .multiply(Matrix.Translation(median.x, median.y, median.z))
                .multiply(boundingBox.getWorldMatrix());
            // VBOs
            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());
            if (this.showBackLines) {
                // Back
                engine.setDepthFunctionToGreaterOrEqual();
                this.scene.resetCachedMaterial();
                this._colorShader.setColor4("color", this.backColor.toColor4());
                this._colorShader.bind(worldMatrix);
                // Draw order
                engine.drawElementsType(Material.LineListDrawMode, 0, 24);
            }
            // Front
            engine.setDepthFunctionToLess();
            this.scene.resetCachedMaterial();
            this._colorShader.setColor4("color", this.frontColor.toColor4());
            this._colorShader.bind(worldMatrix);
            // Draw order
            engine.drawElementsType(Material.LineListDrawMode, 0, 24);
        }
        this._colorShader.unbind();
        engine.setDepthFunctionToLessOrEqual();
        engine.setDepthWrite(true);
    };
    /**
     * In case of occlusion queries, we can render the occlusion bounding box through this method
     * @param mesh Define the mesh to render the occlusion bounding box for
     */
    BoundingBoxRenderer.prototype.renderOcclusionBoundingBox = function (mesh) {
        this._prepareRessources();
        if (!this._colorShader.isReady() || !mesh._boundingInfo) {
            return;
        }
        var engine = this.scene.getEngine();
        engine.setDepthWrite(false);
        engine.setColorWrite(false);
        this._colorShader._preBind();
        var boundingBox = mesh._boundingInfo.boundingBox;
        var min = boundingBox.minimum;
        var max = boundingBox.maximum;
        var diff = max.subtract(min);
        var median = min.add(diff.scale(0.5));
        var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z)
            .multiply(Matrix.Translation(median.x, median.y, median.z))
            .multiply(boundingBox.getWorldMatrix());
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());
        engine.setDepthFunctionToLess();
        this.scene.resetCachedMaterial();
        this._colorShader.bind(worldMatrix);
        engine.drawElementsType(Material.LineListDrawMode, 0, 24);
        this._colorShader.unbind();
        engine.setDepthFunctionToLessOrEqual();
        engine.setDepthWrite(true);
        engine.setColorWrite(true);
    };
    /**
     * Dispose and release the resources attached to this renderer.
     */
    BoundingBoxRenderer.prototype.dispose = function () {
        if (!this._colorShader) {
            return;
        }
        this.renderList.dispose();
        this._colorShader.dispose();
        var buffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (buffer) {
            buffer.dispose();
            this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        this.scene.getEngine()._releaseBuffer(this._indexBuffer);
    };
    return BoundingBoxRenderer;
}());

var name$15 = 'depthPixelShader';
var shader$15 = "#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\nvarying float vDepthMetric;\nvoid main(void)\n{\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\ngl_FragColor=vec4(vDepthMetric,vDepthMetric*vDepthMetric,0.0,1.0);\n}";
Effect.ShadersStore[name$15] = shader$15;

/**
 * This represents a depth renderer in Babylon.
 * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing
 */
var DepthRenderer = /** @class */ (function () {
    /**
     * Instantiates a depth renderer
     * @param scene The scene the renderer belongs to
     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)
     * @param camera The camera to be used to render the depth map (default: scene's active camera)
     */
    function DepthRenderer(scene, type, camera) {
        var _this = this;
        if (type === void 0) { type = Constants.TEXTURETYPE_FLOAT; }
        if (camera === void 0) { camera = null; }
        /**
         * Specifiess that the depth renderer will only be used within
         * the camera it is created for.
         * This can help forcing its rendering during the camera processing.
         */
        this.useOnlyInActiveCamera = false;
        this._scene = scene;
        DepthRenderer._SceneComponentInitialization(this._scene);
        this._camera = camera;
        var engine = scene.getEngine();
        // Render target
        this._depthMap = new RenderTargetTexture("depthMap", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type);
        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._depthMap.refreshRate = 1;
        this._depthMap.renderParticles = false;
        this._depthMap.renderList = null;
        // Camera to get depth map from to support multiple concurrent cameras
        this._depthMap.activeCamera = this._camera;
        this._depthMap.ignoreCameraViewport = true;
        this._depthMap.useCameraPostProcesses = false;
        // set default depth value to 1.0 (far away)
        this._depthMap.onClearObservable.add(function (engine) {
            engine.clear(new Color4(1.0, 1.0, 1.0, 1.0), true, true, true);
        });
        // Custom render function
        var renderSubMesh = function (subMesh) {
            var mesh = subMesh.getRenderingMesh();
            var scene = _this._scene;
            var engine = scene.getEngine();
            var material = subMesh.getMaterial();
            if (!material) {
                return;
            }
            // Culling and reverse (right handed system)
            engine.setState(material.backFaceCulling, 0, false, scene.useRightHandedSystem);
            // Managing instances
            var batch = mesh._getInstancesRenderList(subMesh._id);
            if (batch.mustReturn) {
                return;
            }
            var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null);
            var camera = _this._camera || scene.activeCamera;
            if (_this.isReady(subMesh, hardwareInstancedRendering) && camera) {
                engine.enableEffect(_this._effect);
                mesh._bind(subMesh, _this._effect, Material.TriangleFillMode);
                _this._effect.setMatrix("viewProjection", scene.getTransformMatrix());
                _this._effect.setFloat2("depthValues", camera.minZ, camera.minZ + camera.maxZ);
                // Alpha test
                if (material && material.needAlphaTesting()) {
                    var alphaTexture = material.getAlphaTestTexture();
                    if (alphaTexture) {
                        _this._effect.setTexture("diffuseSampler", alphaTexture);
                        _this._effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
                    }
                }
                // Bones
                if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
                    _this._effect.setMatrices("mBones", mesh.skeleton.getTransformMatrices(mesh));
                }
                // Draw
                mesh._processRendering(subMesh, _this._effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return _this._effect.setMatrix("world", world); });
            }
        };
        this._depthMap.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
            var index;
            if (depthOnlySubMeshes.length) {
                engine.setColorWrite(false);
                for (index = 0; index < depthOnlySubMeshes.length; index++) {
                    renderSubMesh(depthOnlySubMeshes.data[index]);
                }
                engine.setColorWrite(true);
            }
            for (index = 0; index < opaqueSubMeshes.length; index++) {
                renderSubMesh(opaqueSubMeshes.data[index]);
            }
            for (index = 0; index < alphaTestSubMeshes.length; index++) {
                renderSubMesh(alphaTestSubMeshes.data[index]);
            }
        };
    }
    /**
     * Creates the depth rendering effect and checks if the effect is ready.
     * @param subMesh The submesh to be used to render the depth map of
     * @param useInstances If multiple world instances should be used
     * @returns if the depth renderer is ready to render the depth map
     */
    DepthRenderer.prototype.isReady = function (subMesh, useInstances) {
        var material = subMesh.getMaterial();
        if (material.disableDepthWrite) {
            return false;
        }
        var defines = [];
        var attribs = [VertexBuffer.PositionKind];
        var mesh = subMesh.getMesh();
        // Alpha test
        if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {
            defines.push("#define ALPHATEST");
            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                attribs.push(VertexBuffer.UVKind);
                defines.push("#define UV1");
            }
            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
                attribs.push(VertexBuffer.UV2Kind);
                defines.push("#define UV2");
            }
        }
        // Bones
        if (mesh.useBones && mesh.computeBonesUsingShaders) {
            attribs.push(VertexBuffer.MatricesIndicesKind);
            attribs.push(VertexBuffer.MatricesWeightsKind);
            if (mesh.numBoneInfluencers > 4) {
                attribs.push(VertexBuffer.MatricesIndicesExtraKind);
                attribs.push(VertexBuffer.MatricesWeightsExtraKind);
            }
            defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
            defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
        }
        else {
            defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        // Instances
        if (useInstances) {
            defines.push("#define INSTANCES");
            attribs.push("world0");
            attribs.push("world1");
            attribs.push("world2");
            attribs.push("world3");
        }
        // Get correct effect
        var join = defines.join("\n");
        if (this._cachedDefines !== join) {
            this._cachedDefines = join;
            this._effect = this._scene.getEngine().createEffect("depth", attribs, ["world", "mBones", "viewProjection", "diffuseMatrix", "depthValues"], ["diffuseSampler"], join);
        }
        return this._effect.isReady();
    };
    /**
     * Gets the texture which the depth map will be written to.
     * @returns The depth map texture
     */
    DepthRenderer.prototype.getDepthMap = function () {
        return this._depthMap;
    };
    /**
     * Disposes of the depth renderer.
     */
    DepthRenderer.prototype.dispose = function () {
        this._depthMap.dispose();
    };
    /** @hidden */
    DepthRenderer._SceneComponentInitialization = function (_) {
        throw _DevTools.WarnImport("DepthRendererSceneComponent");
    };
    return DepthRenderer;
}());

Scene.prototype.enableDepthRenderer = function (camera) {
    camera = camera || this.activeCamera;
    if (!camera) {
        throw "No camera available to enable depth renderer";
    }
    if (!this._depthRenderer) {
        this._depthRenderer = {};
    }
    if (!this._depthRenderer[camera.id]) {
        var textureType = 0;
        if (this.getEngine().getCaps().textureHalfFloatRender) {
            textureType = Constants.TEXTURETYPE_HALF_FLOAT;
        }
        else if (this.getEngine().getCaps().textureFloatRender) {
            textureType = Constants.TEXTURETYPE_FLOAT;
        }
        else {
            throw "Depth renderer does not support int texture type";
        }
        this._depthRenderer[camera.id] = new DepthRenderer(this, textureType, camera);
    }
    return this._depthRenderer[camera.id];
};
Scene.prototype.disableDepthRenderer = function (camera) {
    camera = camera || this.activeCamera;
    if (!camera || !this._depthRenderer || !this._depthRenderer[camera.id]) {
        return;
    }
    this._depthRenderer[camera.id].dispose();
    delete this._depthRenderer[camera.id];
};
/**
 * Defines the Depth Renderer scene component responsible to manage a depth buffer useful
 * in several rendering techniques.
 */
var DepthRendererSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function DepthRendererSceneComponent(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_DEPTHRENDERER;
        this.scene = scene;
    }
    /**
     * Registers the component in a given scene
     */
    DepthRendererSceneComponent.prototype.register = function () {
        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER, this, this._gatherRenderTargets);
        this.scene._gatherActiveCameraRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER, this, this._gatherActiveCameraRenderTargets);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    DepthRendererSceneComponent.prototype.rebuild = function () {
        // Nothing to do for this component
    };
    /**
     * Disposes the component and the associated ressources
     */
    DepthRendererSceneComponent.prototype.dispose = function () {
        for (var key in this.scene._depthRenderer) {
            this.scene._depthRenderer[key].dispose();
        }
    };
    DepthRendererSceneComponent.prototype._gatherRenderTargets = function (renderTargets) {
        if (this.scene._depthRenderer) {
            for (var key in this.scene._depthRenderer) {
                var depthRenderer = this.scene._depthRenderer[key];
                if (!depthRenderer.useOnlyInActiveCamera) {
                    renderTargets.push(depthRenderer.getDepthMap());
                }
            }
        }
    };
    DepthRendererSceneComponent.prototype._gatherActiveCameraRenderTargets = function (renderTargets) {
        if (this.scene._depthRenderer) {
            for (var key in this.scene._depthRenderer) {
                var depthRenderer = this.scene._depthRenderer[key];
                if (depthRenderer.useOnlyInActiveCamera && this.scene.activeCamera.id === key) {
                    renderTargets.push(depthRenderer.getDepthMap());
                }
            }
        }
    };
    return DepthRendererSceneComponent;
}());
DepthRenderer._SceneComponentInitialization = function (scene) {
    // Register the G Buffer component to the scene.
    var component = scene._getComponent(SceneComponentConstants.NAME_DEPTHRENDERER);
    if (!component) {
        component = new DepthRendererSceneComponent(scene);
        scene._addComponent(component);
    }
};

var name$16 = 'linePixelShader';
var shader$16 = "uniform vec4 color;\nvoid main(void) {\ngl_FragColor=color;\n}";
Effect.ShadersStore[name$16] = shader$16;

var name$17 = 'lineVertexShader';
var shader$17 = "\nattribute vec3 position;\nattribute vec4 normal;\n\nuniform mat4 worldViewProjection;\nuniform float width;\nuniform float aspectRatio;\nvoid main(void) {\nvec4 viewPosition=worldViewProjection*vec4(position,1.0);\nvec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);\nvec2 currentScreen=viewPosition.xy/viewPosition.w;\nvec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;\ncurrentScreen.x*=aspectRatio;\nnextScreen.x*=aspectRatio;\nvec2 dir=normalize(nextScreen-currentScreen);\nvec2 normalDir=vec2(-dir.y,dir.x);\nnormalDir*=width/2.0;\nnormalDir.x/=aspectRatio;\nvec4 offset=vec4(normalDir*normal.w,0.0,0.0);\ngl_Position=viewPosition+offset;\n}";
Effect.ShadersStore[name$17] = shader$17;

AbstractMesh.prototype.disableEdgesRendering = function () {
    if (this._edgesRenderer) {
        this._edgesRenderer.dispose();
        this._edgesRenderer = null;
    }
    return this;
};
AbstractMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices) {
    if (epsilon === void 0) { epsilon = 0.95; }
    if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }
    this.disableEdgesRendering();
    this._edgesRenderer = new EdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);
    return this;
};
Object.defineProperty(AbstractMesh.prototype, "edgesRenderer", {
    get: function () {
        return this._edgesRenderer;
    },
    enumerable: true,
    configurable: true
});
LinesMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices) {
    if (epsilon === void 0) { epsilon = 0.95; }
    if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }
    this.disableEdgesRendering();
    this._edgesRenderer = new LineEdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);
    return this;
};
InstancedLinesMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices) {
    if (epsilon === void 0) { epsilon = 0.95; }
    if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }
    LinesMesh.prototype.enableEdgesRendering.apply(this, arguments);
    return this;
};
/**
 * FaceAdjacencies Helper class to generate edges
 */
var FaceAdjacencies = /** @class */ (function () {
    function FaceAdjacencies() {
        this.edges = new Array();
        this.edgesConnectedCount = 0;
    }
    return FaceAdjacencies;
}());
/**
 * This class is used to generate edges of the mesh that could then easily be rendered in a scene.
 */
var EdgesRenderer = /** @class */ (function () {
    /**
     * Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.
     * Beware when you use this class with complex objects as the adjacencies computation can be really long
     * @param  source Mesh used to create edges
     * @param  epsilon sum of angles in adjacency to check for edge
     * @param  checkVerticesInsteadOfIndices bases the edges detection on vertices vs indices
     * @param  generateEdgesLines - should generate Lines or only prepare resources.
     */
    function EdgesRenderer(source, epsilon, checkVerticesInsteadOfIndices, generateEdgesLines) {
        var _this = this;
        if (epsilon === void 0) { epsilon = 0.95; }
        if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }
        if (generateEdgesLines === void 0) { generateEdgesLines = true; }
        /**
         * Define the size of the edges with an orthographic camera
         */
        this.edgesWidthScalerForOrthographic = 1000.0;
        /**
         * Define the size of the edges with a perspective camera
         */
        this.edgesWidthScalerForPerspective = 50.0;
        this._linesPositions = new Array();
        this._linesNormals = new Array();
        this._linesIndices = new Array();
        this._buffers = {};
        this._checkVerticesInsteadOfIndices = false;
        /** Gets or sets a boolean indicating if the edgesRenderer is active */
        this.isEnabled = true;
        this._source = source;
        this._checkVerticesInsteadOfIndices = checkVerticesInsteadOfIndices;
        this._epsilon = epsilon;
        this._prepareRessources();
        if (generateEdgesLines) {
            this._generateEdgesLines();
        }
        this._meshRebuildObserver = this._source.onRebuildObservable.add(function () {
            _this._rebuild();
        });
        this._meshDisposeObserver = this._source.onDisposeObservable.add(function () {
            _this.dispose();
        });
    }
    EdgesRenderer.prototype._prepareRessources = function () {
        if (this._lineShader) {
            return;
        }
        this._lineShader = new ShaderMaterial("lineShader", this._source.getScene(), "line", {
            attributes: ["position", "normal"],
            uniforms: ["worldViewProjection", "color", "width", "aspectRatio"]
        });
        this._lineShader.disableDepthWrite = true;
        this._lineShader.backFaceCulling = false;
    };
    /** @hidden */
    EdgesRenderer.prototype._rebuild = function () {
        var buffer = this._buffers[VertexBuffer.PositionKind];
        if (buffer) {
            buffer._rebuild();
        }
        buffer = this._buffers[VertexBuffer.NormalKind];
        if (buffer) {
            buffer._rebuild();
        }
        var scene = this._source.getScene();
        var engine = scene.getEngine();
        this._ib = engine.createIndexBuffer(this._linesIndices);
    };
    /**
     * Releases the required resources for the edges renderer
     */
    EdgesRenderer.prototype.dispose = function () {
        this._source.onRebuildObservable.remove(this._meshRebuildObserver);
        this._source.onDisposeObservable.remove(this._meshDisposeObserver);
        var buffer = this._buffers[VertexBuffer.PositionKind];
        if (buffer) {
            buffer.dispose();
            this._buffers[VertexBuffer.PositionKind] = null;
        }
        buffer = this._buffers[VertexBuffer.NormalKind];
        if (buffer) {
            buffer.dispose();
            this._buffers[VertexBuffer.NormalKind] = null;
        }
        this._source.getScene().getEngine()._releaseBuffer(this._ib);
        this._lineShader.dispose();
    };
    EdgesRenderer.prototype._processEdgeForAdjacencies = function (pa, pb, p0, p1, p2) {
        if (pa === p0 && pb === p1 || pa === p1 && pb === p0) {
            return 0;
        }
        if (pa === p1 && pb === p2 || pa === p2 && pb === p1) {
            return 1;
        }
        if (pa === p2 && pb === p0 || pa === p0 && pb === p2) {
            return 2;
        }
        return -1;
    };
    EdgesRenderer.prototype._processEdgeForAdjacenciesWithVertices = function (pa, pb, p0, p1, p2) {
        if (pa.equalsWithEpsilon(p0) && pb.equalsWithEpsilon(p1) || pa.equalsWithEpsilon(p1) && pb.equalsWithEpsilon(p0)) {
            return 0;
        }
        if (pa.equalsWithEpsilon(p1) && pb.equalsWithEpsilon(p2) || pa.equalsWithEpsilon(p2) && pb.equalsWithEpsilon(p1)) {
            return 1;
        }
        if (pa.equalsWithEpsilon(p2) && pb.equalsWithEpsilon(p0) || pa.equalsWithEpsilon(p0) && pb.equalsWithEpsilon(p2)) {
            return 2;
        }
        return -1;
    };
    /**
     * Checks if the pair of p0 and p1 is en edge
     * @param faceIndex
     * @param edge
     * @param faceNormals
     * @param  p0
     * @param  p1
     * @private
     */
    EdgesRenderer.prototype._checkEdge = function (faceIndex, edge, faceNormals, p0, p1) {
        var needToCreateLine;
        if (edge === undefined) {
            needToCreateLine = true;
        }
        else {
            var dotProduct = Vector3.Dot(faceNormals[faceIndex], faceNormals[edge]);
            needToCreateLine = dotProduct < this._epsilon;
        }
        if (needToCreateLine) {
            this.createLine(p0, p1, this._linesPositions.length / 3);
        }
    };
    /**
     * push line into the position, normal and index buffer
     * @protected
     */
    EdgesRenderer.prototype.createLine = function (p0, p1, offset) {
        // Positions
        this._linesPositions.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p1.x, p1.y, p1.z);
        // Normals
        this._linesNormals.push(p1.x, p1.y, p1.z, -1, p1.x, p1.y, p1.z, 1, p0.x, p0.y, p0.z, -1, p0.x, p0.y, p0.z, 1);
        // Indices
        this._linesIndices.push(offset, offset + 1, offset + 2, offset, offset + 2, offset + 3);
    };
    /**
     * Generates lines edges from adjacencjes
     * @private
     */
    EdgesRenderer.prototype._generateEdgesLines = function () {
        var positions = this._source.getVerticesData(VertexBuffer.PositionKind);
        var indices = this._source.getIndices();
        if (!indices || !positions) {
            return;
        }
        // First let's find adjacencies
        var adjacencies = new Array();
        var faceNormals = new Array();
        var index;
        var faceAdjacencies;
        // Prepare faces
        for (index = 0; index < indices.length; index += 3) {
            faceAdjacencies = new FaceAdjacencies();
            var p0Index = indices[index];
            var p1Index = indices[index + 1];
            var p2Index = indices[index + 2];
            faceAdjacencies.p0 = new Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
            faceAdjacencies.p1 = new Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
            faceAdjacencies.p2 = new Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);
            var faceNormal = Vector3.Cross(faceAdjacencies.p1.subtract(faceAdjacencies.p0), faceAdjacencies.p2.subtract(faceAdjacencies.p1));
            faceNormal.normalize();
            faceNormals.push(faceNormal);
            adjacencies.push(faceAdjacencies);
        }
        // Scan
        for (index = 0; index < adjacencies.length; index++) {
            faceAdjacencies = adjacencies[index];
            for (var otherIndex = index + 1; otherIndex < adjacencies.length; otherIndex++) {
                var otherFaceAdjacencies = adjacencies[otherIndex];
                if (faceAdjacencies.edgesConnectedCount === 3) { // Full
                    break;
                }
                if (otherFaceAdjacencies.edgesConnectedCount === 3) { // Full
                    continue;
                }
                var otherP0 = indices[otherIndex * 3];
                var otherP1 = indices[otherIndex * 3 + 1];
                var otherP2 = indices[otherIndex * 3 + 2];
                for (var edgeIndex = 0; edgeIndex < 3; edgeIndex++) {
                    var otherEdgeIndex = 0;
                    if (faceAdjacencies.edges[edgeIndex] !== undefined) {
                        continue;
                    }
                    switch (edgeIndex) {
                        case 0:
                            if (this._checkVerticesInsteadOfIndices) {
                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p0, faceAdjacencies.p1, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
                            }
                            else {
                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3], indices[index * 3 + 1], otherP0, otherP1, otherP2);
                            }
                            break;
                        case 1:
                            if (this._checkVerticesInsteadOfIndices) {
                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p1, faceAdjacencies.p2, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
                            }
                            else {
                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 1], indices[index * 3 + 2], otherP0, otherP1, otherP2);
                            }
                            break;
                        case 2:
                            if (this._checkVerticesInsteadOfIndices) {
                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p2, faceAdjacencies.p0, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
                            }
                            else {
                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 2], indices[index * 3], otherP0, otherP1, otherP2);
                            }
                            break;
                    }
                    if (otherEdgeIndex === -1) {
                        continue;
                    }
                    faceAdjacencies.edges[edgeIndex] = otherIndex;
                    otherFaceAdjacencies.edges[otherEdgeIndex] = index;
                    faceAdjacencies.edgesConnectedCount++;
                    otherFaceAdjacencies.edgesConnectedCount++;
                    if (faceAdjacencies.edgesConnectedCount === 3) {
                        break;
                    }
                }
            }
        }
        // Create lines
        for (index = 0; index < adjacencies.length; index++) {
            // We need a line when a face has no adjacency on a specific edge or if all the adjacencies has an angle greater than epsilon
            var current = adjacencies[index];
            this._checkEdge(index, current.edges[0], faceNormals, current.p0, current.p1);
            this._checkEdge(index, current.edges[1], faceNormals, current.p1, current.p2);
            this._checkEdge(index, current.edges[2], faceNormals, current.p2, current.p0);
        }
        // Merge into a single mesh
        var engine = this._source.getScene().getEngine();
        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
        this._ib = engine.createIndexBuffer(this._linesIndices);
        this._indicesCount = this._linesIndices.length;
    };
    /**
     * Checks wether or not the edges renderer is ready to render.
     * @return true if ready, otherwise false.
     */
    EdgesRenderer.prototype.isReady = function () {
        return this._lineShader.isReady();
    };
    /**
     * Renders the edges of the attached mesh,
     */
    EdgesRenderer.prototype.render = function () {
        var scene = this._source.getScene();
        if (!this.isReady() || !scene.activeCamera) {
            return;
        }
        var engine = scene.getEngine();
        this._lineShader._preBind();
        if (this._source.edgesColor.a !== 1) {
            engine.setAlphaMode(Constants.ALPHA_COMBINE);
        }
        else {
            engine.setAlphaMode(Constants.ALPHA_DISABLE);
        }
        // VBOs
        engine.bindBuffers(this._buffers, this._ib, this._lineShader.getEffect());
        scene.resetCachedMaterial();
        this._lineShader.setColor4("color", this._source.edgesColor);
        if (scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
            this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForOrthographic);
        }
        else {
            this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForPerspective);
        }
        this._lineShader.setFloat("aspectRatio", engine.getAspectRatio(scene.activeCamera));
        this._lineShader.bind(this._source.getWorldMatrix());
        // Draw order
        engine.drawElementsType(Material.TriangleFillMode, 0, this._indicesCount);
        this._lineShader.unbind();
    };
    return EdgesRenderer;
}());
/**
 * LineEdgesRenderer for LineMeshes to remove unnecessary triangulation
 */
var LineEdgesRenderer = /** @class */ (function (_super) {
    __extends(LineEdgesRenderer, _super);
    /**
     * This constructor turns off auto generating edges line in Edges Renderer to make it here.
     * @param  source LineMesh used to generate edges
     * @param  epsilon not important (specified angle for edge detection)
     * @param  checkVerticesInsteadOfIndices not important for LineMesh
     */
    function LineEdgesRenderer(source, epsilon, checkVerticesInsteadOfIndices) {
        if (epsilon === void 0) { epsilon = 0.95; }
        if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }
        var _this = _super.call(this, source, epsilon, checkVerticesInsteadOfIndices, false) || this;
        _this._generateEdgesLines();
        return _this;
    }
    /**
     * Generate edges for each line in LinesMesh. Every Line should be rendered as edge.
     */
    LineEdgesRenderer.prototype._generateEdgesLines = function () {
        var positions = this._source.getVerticesData(VertexBuffer.PositionKind);
        var indices = this._source.getIndices();
        if (!indices || !positions) {
            return;
        }
        var p0 = Tmp.Vector3[0];
        var p1 = Tmp.Vector3[1];
        var len = indices.length - 1;
        for (var i = 0, offset = 0; i < len; i += 2, offset += 4) {
            Vector3.FromArrayToRef(positions, 3 * indices[i], p0);
            Vector3.FromArrayToRef(positions, 3 * indices[i + 1], p1);
            this.createLine(p0, p1, offset);
        }
        // Merge into a single mesh
        var engine = this._source.getScene().getEngine();
        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
        this._ib = engine.createIndexBuffer(this._linesIndices);
        this._indicesCount = this._linesIndices.length;
    };
    return LineEdgesRenderer;
}(EdgesRenderer));

var name$18 = 'outlinePixelShader';
var shader$18 = "#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nuniform vec4 color;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#include<logDepthDeclaration>\nvoid main(void) {\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#include<logDepthFragment>\ngl_FragColor=color;\n}";
Effect.ShadersStore[name$18] = shader$18;

var name$19 = 'outlineVertexShader';
var shader$19 = "\nattribute vec3 position;\nattribute vec3 normal;\n#include<bonesDeclaration>\n\nuniform float offset;\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#include<logDepthDeclaration>\nvoid main(void)\n{\nvec3 offsetPosition=position+normal*offset;\n#include<instancesVertex>\n#include<bonesVertex>\ngl_Position=viewProjection*finalWorld*vec4(offsetPosition,1.0);\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<logDepthVertex>\n}\n";
Effect.ShadersStore[name$19] = shader$19;

/**
 * Gets the outline renderer associated with the scene
 * @returns a OutlineRenderer
 */
Scene.prototype.getOutlineRenderer = function () {
    if (!this._outlineRenderer) {
        this._outlineRenderer = new OutlineRenderer(this);
    }
    return this._outlineRenderer;
};
Object.defineProperty(AbstractMesh.prototype, "renderOutline", {
    get: function () {
        return this._renderOutline;
    },
    set: function (value) {
        if (value) {
            // Lazy Load the component.
            this.getScene().getOutlineRenderer();
        }
        this._renderOutline = value;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(AbstractMesh.prototype, "renderOverlay", {
    get: function () {
        return this._renderOverlay;
    },
    set: function (value) {
        if (value) {
            // Lazy Load the component.
            this.getScene().getOutlineRenderer();
        }
        this._renderOverlay = value;
    },
    enumerable: true,
    configurable: true
});
/**
 * This class is responsible to draw bothe outline/overlay of meshes.
 * It should not be used directly but through the available method on mesh.
 */
var OutlineRenderer = /** @class */ (function () {
    /**
     * Instantiates a new outline renderer. (There could be only one per scene).
     * @param scene Defines the scene it belongs to
     */
    function OutlineRenderer(scene) {
        /**
         * The name of the component. Each component must have a unique name.
         */
        this.name = SceneComponentConstants.NAME_OUTLINERENDERER;
        /**
         * Defines a zOffset to prevent zFighting between the overlay and the mesh.
         */
        this.zOffset = 1;
        this.scene = scene;
        this._engine = scene.getEngine();
        this.scene._addComponent(this);
    }
    /**
     * Register the component to one instance of a scene.
     */
    OutlineRenderer.prototype.register = function () {
        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);
        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    OutlineRenderer.prototype.rebuild = function () {
        // Nothing to do here.
    };
    /**
     * Disposes the component and the associated ressources.
     */
    OutlineRenderer.prototype.dispose = function () {
        // Nothing to do here.
    };
    /**
     * Renders the outline in the canvas.
     * @param subMesh Defines the sumesh to render
     * @param batch Defines the batch of meshes in case of instances
     * @param useOverlay Defines if the rendering is for the overlay or the outline
     */
    OutlineRenderer.prototype.render = function (subMesh, batch, useOverlay) {
        var _this = this;
        if (useOverlay === void 0) { useOverlay = false; }
        var scene = this.scene;
        var engine = scene.getEngine();
        var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null) && (batch.visibleInstances[subMesh._id] !== undefined);
        if (!this.isReady(subMesh, hardwareInstancedRendering)) {
            return;
        }
        var mesh = subMesh.getRenderingMesh();
        var material = subMesh.getMaterial();
        if (!material || !scene.activeCamera) {
            return;
        }
        engine.enableEffect(this._effect);
        // Logarithmic depth
        if (material.useLogarithmicDepth) {
            this._effect.setFloat("logarithmicDepthConstant", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));
        }
        this._effect.setFloat("offset", useOverlay ? 0 : mesh.outlineWidth);
        this._effect.setColor4("color", useOverlay ? mesh.overlayColor : mesh.outlineColor, useOverlay ? mesh.overlayAlpha : material.alpha);
        this._effect.setMatrix("viewProjection", scene.getTransformMatrix());
        // Bones
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
            this._effect.setMatrices("mBones", mesh.skeleton.getTransformMatrices(mesh));
        }
        mesh._bind(subMesh, this._effect, Material.TriangleFillMode);
        // Alpha test
        if (material && material.needAlphaTesting()) {
            var alphaTexture = material.getAlphaTestTexture();
            if (alphaTexture) {
                this._effect.setTexture("diffuseSampler", alphaTexture);
                this._effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
            }
        }
        engine.setZOffset(-this.zOffset);
        mesh._processRendering(subMesh, this._effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { _this._effect.setMatrix("world", world); });
        engine.setZOffset(0);
    };
    /**
     * Returns whether or not the outline renderer is ready for a given submesh.
     * All the dependencies e.g. submeshes, texture, effect... mus be ready
     * @param subMesh Defines the submesh to check readyness for
     * @param useInstances Defines wheter wee are trying to render instances or not
     * @returns true if ready otherwise false
     */
    OutlineRenderer.prototype.isReady = function (subMesh, useInstances) {
        var defines = [];
        var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
        var mesh = subMesh.getMesh();
        var material = subMesh.getMaterial();
        if (material) {
            // Alpha test
            if (material.needAlphaTesting()) {
                defines.push("#define ALPHATEST");
                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                    attribs.push(VertexBuffer.UVKind);
                    defines.push("#define UV1");
                }
                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
                    attribs.push(VertexBuffer.UV2Kind);
                    defines.push("#define UV2");
                }
            }
            //Logarithmic depth
            if (material.useLogarithmicDepth) {
                defines.push("#define LOGARITHMICDEPTH");
            }
        }
        // Bones
        if (mesh.useBones && mesh.computeBonesUsingShaders) {
            attribs.push(VertexBuffer.MatricesIndicesKind);
            attribs.push(VertexBuffer.MatricesWeightsKind);
            if (mesh.numBoneInfluencers > 4) {
                attribs.push(VertexBuffer.MatricesIndicesExtraKind);
                attribs.push(VertexBuffer.MatricesWeightsExtraKind);
            }
            defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
            defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
        }
        else {
            defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        // Instances
        if (useInstances) {
            defines.push("#define INSTANCES");
            attribs.push("world0");
            attribs.push("world1");
            attribs.push("world2");
            attribs.push("world3");
        }
        // Get correct effect
        var join = defines.join("\n");
        if (this._cachedDefines !== join) {
            this._cachedDefines = join;
            this._effect = this.scene.getEngine().createEffect("outline", attribs, ["world", "mBones", "viewProjection", "diffuseMatrix", "offset", "color", "logarithmicDepthConstant"], ["diffuseSampler"], join);
        }
        return this._effect.isReady();
    };
    OutlineRenderer.prototype._beforeRenderingMesh = function (mesh, subMesh, batch) {
        // Outline - step 1
        this._savedDepthWrite = this._engine.getDepthWrite();
        if (mesh.renderOutline) {
            var material = subMesh.getMaterial();
            if (material && material.needAlphaBlending) {
                this._engine.cacheStencilState();
                // Draw only to stencil buffer for the original mesh
                // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent
                this._engine.setDepthWrite(false);
                this._engine.setColorWrite(false);
                this._engine.setStencilBuffer(true);
                this._engine.setStencilOperationPass(Constants.REPLACE);
                this._engine.setStencilFunction(Constants.ALWAYS);
                this._engine.setStencilMask(OutlineRenderer._StencilReference);
                this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);
                this.render(subMesh, batch, /* This sets offset to 0 */ true);
                this._engine.setColorWrite(true);
                this._engine.setStencilFunction(Constants.NOTEQUAL);
            }
            // Draw the outline using the above stencil if needed to avoid drawing within the mesh
            this._engine.setDepthWrite(false);
            this.render(subMesh, batch);
            this._engine.setDepthWrite(this._savedDepthWrite);
            if (material && material.needAlphaBlending) {
                this._engine.restoreStencilState();
            }
        }
    };
    OutlineRenderer.prototype._afterRenderingMesh = function (mesh, subMesh, batch) {
        // Overlay
        if (mesh.renderOverlay) {
            var currentMode = this._engine.getAlphaMode();
            this._engine.setAlphaMode(Constants.ALPHA_COMBINE);
            this.render(subMesh, batch, true);
            this._engine.setAlphaMode(currentMode);
        }
        // Outline - step 2
        if (mesh.renderOutline && this._savedDepthWrite) {
            this._engine.setDepthWrite(true);
            this._engine.setColorWrite(false);
            this.render(subMesh, batch);
            this._engine.setColorWrite(true);
        }
    };
    /**
     * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent
     */
    OutlineRenderer._StencilReference = 0x04;
    return OutlineRenderer;
}());

/**
 * Class used to represent a sprite
 * @see http://doc.babylonjs.com/babylon101/sprites
 */
var Sprite = /** @class */ (function () {
    /**
     * Creates a new Sprite
     * @param name defines the name
     * @param manager defines the manager
     */
    function Sprite(
    /** defines the name */
    name, manager) {
        this.name = name;
        /** Gets or sets the main color */
        this.color = new Color4(1.0, 1.0, 1.0, 1.0);
        /** Gets or sets the width */
        this.width = 1.0;
        /** Gets or sets the height */
        this.height = 1.0;
        /** Gets or sets rotation angle */
        this.angle = 0;
        /** Gets or sets the cell index in the sprite sheet */
        this.cellIndex = 0;
        /** Gets or sets a boolean indicating if UV coordinates should be inverted in U axis */
        this.invertU = 0;
        /** Gets or sets a boolean indicating if UV coordinates should be inverted in B axis */
        this.invertV = 0;
        /** Gets the list of attached animations */
        this.animations = new Array();
        /** Gets or sets a boolean indicating if the sprite can be picked */
        this.isPickable = false;
        this._animationStarted = false;
        this._loopAnimation = false;
        this._fromIndex = 0;
        this._toIndex = 0;
        this._delay = 0;
        this._direction = 1;
        this._time = 0;
        /**
         * Gets or sets a boolean indicating if the sprite is visible (renderable). Default is true
         */
        this.isVisible = true;
        this._manager = manager;
        this._manager.sprites.push(this);
        this.position = Vector3.Zero();
    }
    Object.defineProperty(Sprite.prototype, "size", {
        /**
         * Gets or sets the sprite size
         */
        get: function () {
            return this.width;
        },
        set: function (value) {
            this.width = value;
            this.height = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Starts an animation
     * @param from defines the initial key
     * @param to defines the end key
     * @param loop defines if the animation must loop
     * @param delay defines the start delay (in ms)
     * @param onAnimationEnd defines a callback to call when animation ends
     */
    Sprite.prototype.playAnimation = function (from, to, loop, delay, onAnimationEnd) {
        this._fromIndex = from;
        this._toIndex = to;
        this._loopAnimation = loop;
        this._delay = delay;
        this._animationStarted = true;
        if (from < to) {
            this._direction = 1;
        }
        else {
            this._direction = -1;
            this._toIndex = from;
            this._fromIndex = to;
        }
        this.cellIndex = from;
        this._time = 0;
        this._onAnimationEnd = onAnimationEnd;
    };
    /** Stops current animation (if any) */
    Sprite.prototype.stopAnimation = function () {
        this._animationStarted = false;
    };
    /** @hidden */
    Sprite.prototype._animate = function (deltaTime) {
        if (!this._animationStarted) {
            return;
        }
        this._time += deltaTime;
        if (this._time > this._delay) {
            this._time = this._time % this._delay;
            this.cellIndex += this._direction;
            if (this._direction > 0 && this.cellIndex > this._toIndex || this._direction < 0 && this.cellIndex < this._fromIndex) {
                if (this._loopAnimation) {
                    this.cellIndex = this._direction > 0 ? this._fromIndex : this._toIndex;
                }
                else {
                    this.cellIndex = this._toIndex;
                    this._animationStarted = false;
                    if (this._onAnimationEnd) {
                        this._onAnimationEnd();
                    }
                    if (this.disposeWhenFinishedAnimating) {
                        this.dispose();
                    }
                }
            }
        }
    };
    /** Release associated resources */
    Sprite.prototype.dispose = function () {
        for (var i = 0; i < this._manager.sprites.length; i++) {
            if (this._manager.sprites[i] == this) {
                this._manager.sprites.splice(i, 1);
            }
        }
    };
    return Sprite;
}());

Scene.prototype._internalPickSprites = function (ray, predicate, fastCheck, camera) {
    if (!PickingInfo) {
        return null;
    }
    var pickingInfo = null;
    if (!camera) {
        if (!this.activeCamera) {
            return null;
        }
        camera = this.activeCamera;
    }
    if (this.spriteManagers.length > 0) {
        for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {
            var spriteManager = this.spriteManagers[spriteIndex];
            if (!spriteManager.isPickable) {
                continue;
            }
            var result = spriteManager.intersects(ray, camera, predicate, fastCheck);
            if (!result || !result.hit) {
                continue;
            }
            if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
                continue;
            }
            pickingInfo = result;
            if (fastCheck) {
                break;
            }
        }
    }
    return pickingInfo || new PickingInfo();
};
Scene.prototype.pickSprite = function (x, y, predicate, fastCheck, camera) {
    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);
    return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);
};
Scene.prototype.pickSpriteWithRay = function (ray, predicate, fastCheck, camera) {
    if (!this._tempSpritePickingRay) {
        return null;
    }
    if (!camera) {
        if (!this.activeCamera) {
            return null;
        }
        camera = this.activeCamera;
    }
    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);
    return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);
};
Scene.prototype.setPointerOverSprite = function (sprite) {
    if (this._pointerOverSprite === sprite) {
        return;
    }
    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {
        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOutTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));
    }
    this._pointerOverSprite = sprite;
    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {
        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOverTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));
    }
};
Scene.prototype.getPointerOverSprite = function () {
    return this._pointerOverSprite;
};
/**
 * Defines the sprite scene component responsible to manage sprites
 * in a given scene.
 */
var SpriteSceneComponent = /** @class */ (function () {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */
    function SpriteSceneComponent(scene) {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        this.name = SceneComponentConstants.NAME_SPRITE;
        this.scene = scene;
        this.scene.spriteManagers = new Array();
        this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;
        this.scene.onBeforeSpritesRenderingObservable = new Observable();
        this.scene.onAfterSpritesRenderingObservable = new Observable();
        this._spritePredicate = function (sprite) {
            if (!sprite.actionManager) {
                return false;
            }
            return sprite.isPickable && sprite.actionManager.hasPointerTriggers;
        };
    }
    /**
     * Registers the component in a given scene
     */
    SpriteSceneComponent.prototype.register = function () {
        this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);
        this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);
        this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);
    };
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */
    SpriteSceneComponent.prototype.rebuild = function () {
        /** Nothing to do for sprites */
    };
    /**
     * Disposes the component and the associated ressources.
     */
    SpriteSceneComponent.prototype.dispose = function () {
        this.scene.onBeforeSpritesRenderingObservable.clear();
        this.scene.onAfterSpritesRenderingObservable.clear();
        var spriteManagers = this.scene.spriteManagers;
        while (spriteManagers.length) {
            spriteManagers[0].dispose();
        }
    };
    SpriteSceneComponent.prototype._pickSpriteButKeepRay = function (originalPointerInfo, x, y, fastCheck, camera) {
        var result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);
        if (result) {
            result.ray = originalPointerInfo ? originalPointerInfo.ray : null;
        }
        return result;
    };
    SpriteSceneComponent.prototype._pointerMove = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, canvas) {
        var scene = this.scene;
        if (isMeshPicked) {
            scene.setPointerOverSprite(null);
        }
        else {
            pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);
            if (pickResult && pickResult.hit && pickResult.pickedSprite) {
                scene.setPointerOverSprite(pickResult.pickedSprite);
                if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {
                    canvas.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;
                }
                else {
                    canvas.style.cursor = scene.hoverCursor;
                }
            }
            else {
                scene.setPointerOverSprite(null);
            }
        }
        return pickResult;
    };
    SpriteSceneComponent.prototype._pointerDown = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {
        var scene = this.scene;
        scene._pickedDownSprite = null;
        if (scene.spriteManagers.length > 0) {
            pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);
            if (pickResult && pickResult.hit && pickResult.pickedSprite) {
                if (pickResult.pickedSprite.actionManager) {
                    scene._pickedDownSprite = pickResult.pickedSprite;
                    switch (evt.button) {
                        case 0:
                            pickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnLeftPickTrigger, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
                            break;
                        case 1:
                            pickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnCenterPickTrigger, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
                            break;
                        case 2:
                            pickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnRightPickTrigger, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
                            break;
                    }
                    if (pickResult.pickedSprite.actionManager) {
                        pickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnPickDownTrigger, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
                    }
                }
            }
        }
        return pickResult;
    };
    SpriteSceneComponent.prototype._pointerUp = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {
        var scene = this.scene;
        if (scene.spriteManagers.length > 0) {
            var spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);
            if (spritePickResult) {
                if (spritePickResult.hit && spritePickResult.pickedSprite) {
                    if (spritePickResult.pickedSprite.actionManager) {
                        spritePickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnPickUpTrigger, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
                        if (spritePickResult.pickedSprite.actionManager) {
                            if (!this.scene._inputManager._isPointerSwiping()) {
                                spritePickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnPickTrigger, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
                            }
                        }
                    }
                }
                if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {
                    scene._pickedDownSprite.actionManager.processTrigger(Constants.ACTION_OnPickOutTrigger, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));
                }
            }
        }
        return pickResult;
    };
    return SpriteSceneComponent;
}());

var name$1a = 'spritesPixelShader';
var shader$1a = "uniform bool alphaTest;\nvarying vec4 vColor;\n\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\nvec4 color=texture2D(diffuseSampler,vUV);\nif (alphaTest)\n{\nif (color.a<0.95)\ndiscard;\n}\ncolor*=vColor;\n#include<fogFragment>\ngl_FragColor=color;\n}";
Effect.ShadersStore[name$1a] = shader$1a;

var name$1b = 'spritesVertexShader';
var shader$1b = "\nattribute vec4 position;\nattribute vec4 options;\nattribute vec4 cellInfo;\nattribute vec4 color;\n\nuniform vec2 textureInfos;\nuniform mat4 view;\nuniform mat4 projection;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n#include<fogVertexDeclaration>\nvoid main(void) {\nvec3 viewPos=(view*vec4(position.xyz,1.0)).xyz;\nvec2 cornerPos;\nfloat angle=position.w;\nvec2 size=vec2(options.x,options.y);\nvec2 offset=options.zw;\nvec2 uvScale=textureInfos.xy;\ncornerPos=vec2(offset.x-0.5,offset.y-0.5)*size;\n\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\n\nviewPos+=rotatedCorner;\ngl_Position=projection*vec4(viewPos,1.0);\n\nvColor=color;\n\nvec2 uvOffset=vec2(abs(offset.x-cellInfo.x),1.0-abs(offset.y-cellInfo.y));\nvUV=(uvOffset+cellInfo.zw)*uvScale;\n\n#ifdef FOG\nvFogDistance=viewPos;\n#endif\n}";
Effect.ShadersStore[name$1b] = shader$1b;

/**
 * Class used to manage multiple sprites on the same spritesheet
 * @see http://doc.babylonjs.com/babylon101/sprites
 */
var SpriteManager = /** @class */ (function () {
    /**
     * Creates a new sprite manager
     * @param name defines the manager's name
     * @param imgUrl defines the sprite sheet url
     * @param capacity defines the maximum allowed number of sprites
     * @param cellSize defines the size of a sprite cell
     * @param scene defines the hosting scene
     * @param epsilon defines the epsilon value to align texture (0.01 by default)
     * @param samplingMode defines the smapling mode to use with spritesheet
     */
    function SpriteManager(
    /** defines the manager's name */
    name, imgUrl, capacity, cellSize, scene, epsilon, samplingMode) {
        if (epsilon === void 0) { epsilon = 0.01; }
        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }
        this.name = name;
        /** Gets the list of sprites */
        this.sprites = new Array();
        /** Gets or sets the rendering group id (0 by default) */
        this.renderingGroupId = 0;
        /** Gets or sets camera layer mask */
        this.layerMask = 0x0FFFFFFF;
        /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */
        this.fogEnabled = true;
        /** Gets or sets a boolean indicating if the sprites are pickable */
        this.isPickable = false;
        /**
        * An event triggered when the manager is disposed.
        */
        this.onDisposeObservable = new Observable();
        this._vertexBuffers = {};
        if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {
            scene._addComponent(new SpriteSceneComponent(scene));
        }
        this._capacity = capacity;
        this._spriteTexture = new Texture(imgUrl, scene, true, false, samplingMode);
        this._spriteTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._spriteTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
        if (cellSize.width && cellSize.height) {
            this.cellWidth = cellSize.width;
            this.cellHeight = cellSize.height;
        }
        else if (cellSize !== undefined) {
            this.cellWidth = cellSize;
            this.cellHeight = cellSize;
        }
        else {
            return;
        }
        this._epsilon = epsilon;
        this._scene = scene;
        this._scene.spriteManagers.push(this);
        var indices = [];
        var index = 0;
        for (var count = 0; count < capacity; count++) {
            indices.push(index);
            indices.push(index + 1);
            indices.push(index + 2);
            indices.push(index);
            indices.push(index + 2);
            indices.push(index + 3);
            index += 4;
        }
        this._indexBuffer = scene.getEngine().createIndexBuffer(indices);
        // VBO
        // 16 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellIndexX, cellIndexY, color r, color g, color b, color a)
        this._vertexData = new Float32Array(capacity * 16 * 4);
        this._buffer = new Buffer(scene.getEngine(), this._vertexData, true, 16);
        var positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4);
        var options = this._buffer.createVertexBuffer("options", 4, 4);
        var cellInfo = this._buffer.createVertexBuffer("cellInfo", 8, 4);
        var colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, 12, 4);
        this._vertexBuffers[VertexBuffer.PositionKind] = positions;
        this._vertexBuffers["options"] = options;
        this._vertexBuffers["cellInfo"] = cellInfo;
        this._vertexBuffers[VertexBuffer.ColorKind] = colors;
        // Effects
        this._effectBase = this._scene.getEngine().createEffect("sprites", [VertexBuffer.PositionKind, "options", "cellInfo", VertexBuffer.ColorKind], ["view", "projection", "textureInfos", "alphaTest"], ["diffuseSampler"], "");
        this._effectFog = this._scene.getEngine().createEffect("sprites", [VertexBuffer.PositionKind, "options", "cellInfo", VertexBuffer.ColorKind], ["view", "projection", "textureInfos", "alphaTest", "vFogInfos", "vFogColor"], ["diffuseSampler"], "#define FOG");
    }
    Object.defineProperty(SpriteManager.prototype, "onDispose", {
        /**
         * Callback called when the manager is disposed
         */
        set: function (callback) {
            if (this._onDisposeObserver) {
                this.onDisposeObservable.remove(this._onDisposeObserver);
            }
            this._onDisposeObserver = this.onDisposeObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteManager.prototype, "texture", {
        /**
         * Gets or sets the spritesheet texture
         */
        get: function () {
            return this._spriteTexture;
        },
        set: function (value) {
            this._spriteTexture = value;
        },
        enumerable: true,
        configurable: true
    });
    SpriteManager.prototype._appendSpriteVertex = function (index, sprite, offsetX, offsetY, rowSize) {
        var arrayOffset = index * 16;
        if (offsetX === 0) {
            offsetX = this._epsilon;
        }
        else if (offsetX === 1) {
            offsetX = 1 - this._epsilon;
        }
        if (offsetY === 0) {
            offsetY = this._epsilon;
        }
        else if (offsetY === 1) {
            offsetY = 1 - this._epsilon;
        }
        this._vertexData[arrayOffset] = sprite.position.x;
        this._vertexData[arrayOffset + 1] = sprite.position.y;
        this._vertexData[arrayOffset + 2] = sprite.position.z;
        this._vertexData[arrayOffset + 3] = sprite.angle;
        this._vertexData[arrayOffset + 4] = sprite.width;
        this._vertexData[arrayOffset + 5] = sprite.height;
        this._vertexData[arrayOffset + 6] = offsetX;
        this._vertexData[arrayOffset + 7] = offsetY;
        this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;
        this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;
        var offset = (sprite.cellIndex / rowSize) >> 0;
        this._vertexData[arrayOffset + 10] = sprite.cellIndex - offset * rowSize;
        this._vertexData[arrayOffset + 11] = offset;
        // Color
        this._vertexData[arrayOffset + 12] = sprite.color.r;
        this._vertexData[arrayOffset + 13] = sprite.color.g;
        this._vertexData[arrayOffset + 14] = sprite.color.b;
        this._vertexData[arrayOffset + 15] = sprite.color.a;
    };
    /**
     * Intersects the sprites with a ray
     * @param ray defines the ray to intersect with
     * @param camera defines the current active camera
     * @param predicate defines a predicate used to select candidate sprites
     * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)
     * @returns null if no hit or a PickingInfo
     */
    SpriteManager.prototype.intersects = function (ray, camera, predicate, fastCheck) {
        var count = Math.min(this._capacity, this.sprites.length);
        var min = Vector3.Zero();
        var max = Vector3.Zero();
        var distance = Number.MAX_VALUE;
        var currentSprite = null;
        var pickedPoint = Vector3.Zero();
        var cameraSpacePosition = Vector3.Zero();
        var cameraView = camera.getViewMatrix();
        for (var index = 0; index < count; index++) {
            var sprite = this.sprites[index];
            if (!sprite) {
                continue;
            }
            if (predicate) {
                if (!predicate(sprite)) {
                    continue;
                }
            }
            else if (!sprite.isPickable) {
                continue;
            }
            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);
            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);
            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);
            if (ray.intersectsBoxMinMax(min, max)) {
                var currentDistance = Vector3.Distance(cameraSpacePosition, ray.origin);
                if (distance > currentDistance) {
                    distance = currentDistance;
                    currentSprite = sprite;
                    if (fastCheck) {
                        break;
                    }
                }
            }
        }
        if (currentSprite) {
            var result = new PickingInfo();
            cameraView.invertToRef(Tmp.Matrix[0]);
            result.hit = true;
            result.pickedSprite = currentSprite;
            result.distance = distance;
            // Get picked point
            var direction = Tmp.Vector3[0];
            direction.copyFrom(ray.direction);
            direction.normalize();
            direction.scaleInPlace(distance);
            ray.origin.addToRef(direction, pickedPoint);
            result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, Tmp.Matrix[0]);
            return result;
        }
        return null;
    };
    /**
     * Render all child sprites
     */
    SpriteManager.prototype.render = function () {
        // Check
        if (!this._effectBase.isReady() || !this._effectFog.isReady() || !this._spriteTexture
            || !this._spriteTexture.isReady() || !this.sprites.length) {
            return;
        }
        var engine = this._scene.getEngine();
        var baseSize = this._spriteTexture.getBaseSize();
        // Sprites
        var deltaTime = engine.getDeltaTime();
        var max = Math.min(this._capacity, this.sprites.length);
        var rowSize = baseSize.width / this.cellWidth;
        var offset = 0;
        var noSprite = true;
        for (var index = 0; index < max; index++) {
            var sprite = this.sprites[index];
            if (!sprite || !sprite.isVisible) {
                continue;
            }
            noSprite = false;
            sprite._animate(deltaTime);
            this._appendSpriteVertex(offset++, sprite, 0, 0, rowSize);
            this._appendSpriteVertex(offset++, sprite, 1, 0, rowSize);
            this._appendSpriteVertex(offset++, sprite, 1, 1, rowSize);
            this._appendSpriteVertex(offset++, sprite, 0, 1, rowSize);
        }
        if (noSprite) {
            return;
        }
        this._buffer.update(this._vertexData);
        // Render
        var effect = this._effectBase;
        if (this._scene.fogEnabled && this._scene.fogMode !== Scene.FOGMODE_NONE && this.fogEnabled) {
            effect = this._effectFog;
        }
        engine.enableEffect(effect);
        var viewMatrix = this._scene.getViewMatrix();
        effect.setTexture("diffuseSampler", this._spriteTexture);
        effect.setMatrix("view", viewMatrix);
        effect.setMatrix("projection", this._scene.getProjectionMatrix());
        effect.setFloat2("textureInfos", this.cellWidth / baseSize.width, this.cellHeight / baseSize.height);
        // Fog
        if (this._scene.fogEnabled && this._scene.fogMode !== Scene.FOGMODE_NONE && this.fogEnabled) {
            effect.setFloat4("vFogInfos", this._scene.fogMode, this._scene.fogStart, this._scene.fogEnd, this._scene.fogDensity);
            effect.setColor3("vFogColor", this._scene.fogColor);
        }
        // VBOs
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        // Draw order
        engine.setDepthFunctionToLessOrEqual();
        effect.setBool("alphaTest", true);
        engine.setColorWrite(false);
        engine.drawElementsType(Material.TriangleFillMode, 0, (offset / 4) * 6);
        engine.setColorWrite(true);
        effect.setBool("alphaTest", false);
        engine.setAlphaMode(Constants.ALPHA_COMBINE);
        engine.drawElementsType(Material.TriangleFillMode, 0, (offset / 4) * 6);
        engine.setAlphaMode(Constants.ALPHA_DISABLE);
    };
    /**
     * Release associated resources
     */
    SpriteManager.prototype.dispose = function () {
        if (this._buffer) {
            this._buffer.dispose();
            this._buffer = null;
        }
        if (this._indexBuffer) {
            this._scene.getEngine()._releaseBuffer(this._indexBuffer);
            this._indexBuffer = null;
        }
        if (this._spriteTexture) {
            this._spriteTexture.dispose();
            this._spriteTexture = null;
        }
        // Remove from scene
        var index = this._scene.spriteManagers.indexOf(this);
        this._scene.spriteManagers.splice(index, 1);
        // Callback
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
    };
    return SpriteManager;
}());

/**
 * Defines the list of states available for a task inside a AssetsManager
 */
var AssetTaskState;
(function (AssetTaskState) {
    /**
     * Initialization
     */
    AssetTaskState[AssetTaskState["INIT"] = 0] = "INIT";
    /**
     * Running
     */
    AssetTaskState[AssetTaskState["RUNNING"] = 1] = "RUNNING";
    /**
     * Done
     */
    AssetTaskState[AssetTaskState["DONE"] = 2] = "DONE";
    /**
     * Error
     */
    AssetTaskState[AssetTaskState["ERROR"] = 3] = "ERROR";
})(AssetTaskState || (AssetTaskState = {}));
/**
 * Define an abstract asset task used with a AssetsManager class to load assets into a scene
 */
var AbstractAssetTask = /** @class */ (function () {
    /**
     * Creates a new AssetsManager
     * @param name defines the name of the task
     */
    function AbstractAssetTask(
    /**
     * Task name
     */ name) {
        this.name = name;
        this._isCompleted = false;
        this._taskState = AssetTaskState.INIT;
    }
    Object.defineProperty(AbstractAssetTask.prototype, "isCompleted", {
        /**
         * Get if the task is completed
         */
        get: function () {
            return this._isCompleted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractAssetTask.prototype, "taskState", {
        /**
         * Gets the current state of the task
         */
        get: function () {
            return this._taskState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractAssetTask.prototype, "errorObject", {
        /**
         * Gets the current error object (if task is in error)
         */
        get: function () {
            return this._errorObject;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Internal only
     * @hidden
     */
    AbstractAssetTask.prototype._setErrorObject = function (message, exception) {
        if (this._errorObject) {
            return;
        }
        this._errorObject = {
            message: message,
            exception: exception
        };
    };
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    AbstractAssetTask.prototype.run = function (scene, onSuccess, onError) {
        var _this = this;
        this._taskState = AssetTaskState.RUNNING;
        this.runTask(scene, function () {
            _this.onDoneCallback(onSuccess, onError);
        }, function (msg, exception) {
            _this.onErrorCallback(onError, msg, exception);
        });
    };
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    AbstractAssetTask.prototype.runTask = function (scene, onSuccess, onError) {
        throw new Error("runTask is not implemented");
    };
    /**
     * Reset will set the task state back to INIT, so the next load call of the assets manager will execute this task again.
     * This can be used with failed tasks that have the reason for failure fixed.
     */
    AbstractAssetTask.prototype.reset = function () {
        this._taskState = AssetTaskState.INIT;
    };
    AbstractAssetTask.prototype.onErrorCallback = function (onError, message, exception) {
        this._taskState = AssetTaskState.ERROR;
        this._errorObject = {
            message: message,
            exception: exception
        };
        if (this.onError) {
            this.onError(this, message, exception);
        }
        onError();
    };
    AbstractAssetTask.prototype.onDoneCallback = function (onSuccess, onError) {
        try {
            this._taskState = AssetTaskState.DONE;
            this._isCompleted = true;
            if (this.onSuccess) {
                this.onSuccess(this);
            }
            onSuccess();
        }
        catch (e) {
            this.onErrorCallback(onError, "Task is done, error executing success callback(s)", e);
        }
    };
    return AbstractAssetTask;
}());
/**
 * Class used to share progress information about assets loading
 */
var AssetsProgressEvent = /** @class */ (function () {
    /**
     * Creates a AssetsProgressEvent
     * @param remainingCount defines the number of remaining tasks to process
     * @param totalCount defines the total number of tasks
     * @param task defines the task that was just processed
     */
    function AssetsProgressEvent(remainingCount, totalCount, task) {
        this.remainingCount = remainingCount;
        this.totalCount = totalCount;
        this.task = task;
    }
    return AssetsProgressEvent;
}());
/**
 * Define a task used by AssetsManager to load meshes
 */
var MeshAssetTask = /** @class */ (function (_super) {
    __extends(MeshAssetTask, _super);
    /**
     * Creates a new MeshAssetTask
     * @param name defines the name of the task
     * @param meshesNames defines the list of mesh's names you want to load
     * @param rootUrl defines the root url to use as a base to load your meshes and associated resources
     * @param sceneFilename defines the filename of the scene to load from
     */
    function MeshAssetTask(
    /**
     * Defines the name of the task
     */
    name, 
    /**
     * Defines the list of mesh's names you want to load
     */
    meshesNames, 
    /**
     * Defines the root url to use as a base to load your meshes and associated resources
     */
    rootUrl, 
    /**
     * Defines the filename of the scene to load from
     */
    sceneFilename) {
        var _this = _super.call(this, name) || this;
        _this.name = name;
        _this.meshesNames = meshesNames;
        _this.rootUrl = rootUrl;
        _this.sceneFilename = sceneFilename;
        return _this;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    MeshAssetTask.prototype.runTask = function (scene, onSuccess, onError) {
        var _this = this;
        SceneLoader.ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, scene, function (meshes, particleSystems, skeletons, animationGroups) {
            _this.loadedMeshes = meshes;
            _this.loadedParticleSystems = particleSystems;
            _this.loadedSkeletons = skeletons;
            _this.loadedAnimationGroups = animationGroups;
            onSuccess();
        }, null, function (scene, message, exception) {
            onError(message, exception);
        });
    };
    return MeshAssetTask;
}(AbstractAssetTask));
/**
 * Define a task used by AssetsManager to load text content
 */
var TextFileAssetTask = /** @class */ (function (_super) {
    __extends(TextFileAssetTask, _super);
    /**
     * Creates a new TextFileAssetTask object
     * @param name defines the name of the task
     * @param url defines the location of the file to load
     */
    function TextFileAssetTask(
    /**
     * Defines the name of the task
     */
    name, 
    /**
     * Defines the location of the file to load
     */
    url) {
        var _this = _super.call(this, name) || this;
        _this.name = name;
        _this.url = url;
        return _this;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    TextFileAssetTask.prototype.runTask = function (scene, onSuccess, onError) {
        var _this = this;
        scene._loadFile(this.url, function (data) {
            _this.text = data;
            onSuccess();
        }, undefined, false, false, function (request, exception) {
            if (request) {
                onError(request.status + " " + request.statusText, exception);
            }
        });
    };
    return TextFileAssetTask;
}(AbstractAssetTask));
/**
 * Define a task used by AssetsManager to load binary data
 */
var BinaryFileAssetTask = /** @class */ (function (_super) {
    __extends(BinaryFileAssetTask, _super);
    /**
     * Creates a new BinaryFileAssetTask object
     * @param name defines the name of the new task
     * @param url defines the location of the file to load
     */
    function BinaryFileAssetTask(
    /**
     * Defines the name of the task
     */
    name, 
    /**
     * Defines the location of the file to load
     */
    url) {
        var _this = _super.call(this, name) || this;
        _this.name = name;
        _this.url = url;
        return _this;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    BinaryFileAssetTask.prototype.runTask = function (scene, onSuccess, onError) {
        var _this = this;
        scene._loadFile(this.url, function (data) {
            _this.data = data;
            onSuccess();
        }, undefined, true, true, function (request, exception) {
            if (request) {
                onError(request.status + " " + request.statusText, exception);
            }
        });
    };
    return BinaryFileAssetTask;
}(AbstractAssetTask));
/**
 * Define a task used by AssetsManager to load images
 */
var ImageAssetTask = /** @class */ (function (_super) {
    __extends(ImageAssetTask, _super);
    /**
     * Creates a new ImageAssetTask
     * @param name defines the name of the task
     * @param url defines the location of the image to load
     */
    function ImageAssetTask(
    /**
     * Defines the name of the task
     */
    name, 
    /**
     * Defines the location of the image to load
     */
    url) {
        var _this = _super.call(this, name) || this;
        _this.name = name;
        _this.url = url;
        return _this;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    ImageAssetTask.prototype.runTask = function (scene, onSuccess, onError) {
        var _this = this;
        var img = new Image();
        Tools.SetCorsBehavior(this.url, img);
        img.onload = function () {
            _this.image = img;
            onSuccess();
        };
        img.onerror = function (err) {
            onError("Error loading image", err);
        };
        img.src = this.url;
    };
    return ImageAssetTask;
}(AbstractAssetTask));
/**
 * Define a task used by AssetsManager to load 2D textures
 */
var TextureAssetTask = /** @class */ (function (_super) {
    __extends(TextureAssetTask, _super);
    /**
     * Creates a new TextureAssetTask object
     * @param name defines the name of the task
     * @param url defines the location of the file to load
     * @param noMipmap defines if mipmap should not be generated (default is false)
     * @param invertY defines if texture must be inverted on Y axis (default is false)
     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
     */
    function TextureAssetTask(
    /**
     * Defines the name of the task
     */
    name, 
    /**
     * Defines the location of the file to load
     */
    url, 
    /**
     * Defines if mipmap should not be generated (default is false)
     */
    noMipmap, 
    /**
     * Defines if texture must be inverted on Y axis (default is false)
     */
    invertY, 
    /**
     * Defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
     */
    samplingMode) {
        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }
        var _this = _super.call(this, name) || this;
        _this.name = name;
        _this.url = url;
        _this.noMipmap = noMipmap;
        _this.invertY = invertY;
        _this.samplingMode = samplingMode;
        return _this;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    TextureAssetTask.prototype.runTask = function (scene, onSuccess, onError) {
        var onload = function () {
            onSuccess();
        };
        var onerror = function (message, exception) {
            onError(message, exception);
        };
        this.texture = new Texture(this.url, scene, this.noMipmap, this.invertY, this.samplingMode, onload, onerror);
    };
    return TextureAssetTask;
}(AbstractAssetTask));
/**
 * Define a task used by AssetsManager to load cube textures
 */
var CubeTextureAssetTask = /** @class */ (function (_super) {
    __extends(CubeTextureAssetTask, _super);
    /**
     * Creates a new CubeTextureAssetTask
     * @param name defines the name of the task
     * @param url defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
     * @param extensions defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
     * @param noMipmap defines if mipmaps should not be generated (default is false)
     * @param files defines the explicit list of files (undefined by default)
     */
    function CubeTextureAssetTask(
    /**
     * Defines the name of the task
     */
    name, 
    /**
     * Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
     */
    url, 
    /**
     * Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
     */
    extensions, 
    /**
     * Defines if mipmaps should not be generated (default is false)
     */
    noMipmap, 
    /**
     * Defines the explicit list of files (undefined by default)
     */
    files) {
        var _this = _super.call(this, name) || this;
        _this.name = name;
        _this.url = url;
        _this.extensions = extensions;
        _this.noMipmap = noMipmap;
        _this.files = files;
        return _this;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    CubeTextureAssetTask.prototype.runTask = function (scene, onSuccess, onError) {
        var onload = function () {
            onSuccess();
        };
        var onerror = function (message, exception) {
            onError(message, exception);
        };
        this.texture = new CubeTexture(this.url, scene, this.extensions, this.noMipmap, this.files, onload, onerror);
    };
    return CubeTextureAssetTask;
}(AbstractAssetTask));
/**
 * Define a task used by AssetsManager to load HDR cube textures
 */
var HDRCubeTextureAssetTask = /** @class */ (function (_super) {
    __extends(HDRCubeTextureAssetTask, _super);
    /**
     * Creates a new HDRCubeTextureAssetTask object
     * @param name defines the name of the task
     * @param url defines the location of the file to load
     * @param size defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.
     * @param noMipmap defines if mipmaps should not be generated (default is false)
     * @param generateHarmonics specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
     * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
     * @param reserved Internal use only
     */
    function HDRCubeTextureAssetTask(
    /**
     * Defines the name of the task
     */
    name, 
    /**
     * Defines the location of the file to load
     */
    url, 
    /**
     * Defines the desired size (the more it increases the longer the generation will be)
     */
    size, 
    /**
     * Defines if mipmaps should not be generated (default is false)
     */
    noMipmap, 
    /**
     * Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
     */
    generateHarmonics, 
    /**
     * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
     */
    gammaSpace, 
    /**
     * Internal Use Only
     */
    reserved) {
        if (noMipmap === void 0) { noMipmap = false; }
        if (generateHarmonics === void 0) { generateHarmonics = true; }
        if (gammaSpace === void 0) { gammaSpace = false; }
        if (reserved === void 0) { reserved = false; }
        var _this = _super.call(this, name) || this;
        _this.name = name;
        _this.url = url;
        _this.size = size;
        _this.noMipmap = noMipmap;
        _this.generateHarmonics = generateHarmonics;
        _this.gammaSpace = gammaSpace;
        _this.reserved = reserved;
        return _this;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    HDRCubeTextureAssetTask.prototype.runTask = function (scene, onSuccess, onError) {
        var onload = function () {
            onSuccess();
        };
        var onerror = function (message, exception) {
            onError(message, exception);
        };
        this.texture = new HDRCubeTexture(this.url, scene, this.size, this.noMipmap, this.generateHarmonics, this.gammaSpace, this.reserved, onload, onerror);
    };
    return HDRCubeTextureAssetTask;
}(AbstractAssetTask));
/**
 * Define a task used by AssetsManager to load Equirectangular cube textures
 */
var EquiRectangularCubeTextureAssetTask = /** @class */ (function (_super) {
    __extends(EquiRectangularCubeTextureAssetTask, _super);
    /**
     * Creates a new EquiRectangularCubeTextureAssetTask object
     * @param name defines the name of the task
     * @param url defines the location of the file to load
     * @param size defines the desired size (the more it increases the longer the generation will be)
     * If the size is omitted this implies you are using a preprocessed cubemap.
     * @param noMipmap defines if mipmaps should not be generated (default is false)
     * @param gammaSpace specifies if the texture will be used in gamma or linear space
     * (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)
     * (default is true)
     */
    function EquiRectangularCubeTextureAssetTask(
    /**
     * Defines the name of the task
     */
    name, 
    /**
     * Defines the location of the file to load
     */
    url, 
    /**
     * Defines the desired size (the more it increases the longer the generation will be)
     */
    size, 
    /**
     * Defines if mipmaps should not be generated (default is false)
     */
    noMipmap, 
    /**
     * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space,
     * but the standard material would require them in Gamma space) (default is true)
     */
    gammaSpace) {
        if (noMipmap === void 0) { noMipmap = false; }
        if (gammaSpace === void 0) { gammaSpace = true; }
        var _this = _super.call(this, name) || this;
        _this.name = name;
        _this.url = url;
        _this.size = size;
        _this.noMipmap = noMipmap;
        _this.gammaSpace = gammaSpace;
        return _this;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */
    EquiRectangularCubeTextureAssetTask.prototype.runTask = function (scene, onSuccess, onError) {
        var onload = function () {
            onSuccess();
        };
        var onerror = function (message, exception) {
            onError(message, exception);
        };
        this.texture = new EquiRectangularCubeTexture(this.url, scene, this.size, this.noMipmap, this.gammaSpace, onload, onerror);
    };
    return EquiRectangularCubeTextureAssetTask;
}(AbstractAssetTask));
/**
 * This class can be used to easily import assets into a scene
 * @see http://doc.babylonjs.com/how_to/how_to_use_assetsmanager
 */
var AssetsManager = /** @class */ (function () {
    /**
     * Creates a new AssetsManager
     * @param scene defines the scene to work on
     */
    function AssetsManager(scene) {
        this._isLoading = false;
        this._tasks = new Array();
        this._waitingTasksCount = 0;
        this._totalTasksCount = 0;
        /**
         * Observable called when all tasks are processed
         */
        this.onTaskSuccessObservable = new Observable();
        /**
         * Observable called when a task had an error
         */
        this.onTaskErrorObservable = new Observable();
        /**
         * Observable called when all tasks were executed
         */
        this.onTasksDoneObservable = new Observable();
        /**
         * Observable called when a task is done (whatever the result is)
         */
        this.onProgressObservable = new Observable();
        /**
         * Gets or sets a boolean defining if the AssetsManager should use the default loading screen
         * @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        this.useDefaultLoadingScreen = true;
        this._scene = scene;
    }
    /**
     * Add a MeshAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param meshesNames defines the name of meshes to load
     * @param rootUrl defines the root url to use to locate files
     * @param sceneFilename defines the filename of the scene file
     * @returns a new MeshAssetTask object
     */
    AssetsManager.prototype.addMeshTask = function (taskName, meshesNames, rootUrl, sceneFilename) {
        var task = new MeshAssetTask(taskName, meshesNames, rootUrl, sceneFilename);
        this._tasks.push(task);
        return task;
    };
    /**
     * Add a TextFileAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @returns a new TextFileAssetTask object
     */
    AssetsManager.prototype.addTextFileTask = function (taskName, url) {
        var task = new TextFileAssetTask(taskName, url);
        this._tasks.push(task);
        return task;
    };
    /**
     * Add a BinaryFileAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @returns a new BinaryFileAssetTask object
     */
    AssetsManager.prototype.addBinaryFileTask = function (taskName, url) {
        var task = new BinaryFileAssetTask(taskName, url);
        this._tasks.push(task);
        return task;
    };
    /**
     * Add a ImageAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @returns a new ImageAssetTask object
     */
    AssetsManager.prototype.addImageTask = function (taskName, url) {
        var task = new ImageAssetTask(taskName, url);
        this._tasks.push(task);
        return task;
    };
    /**
     * Add a TextureAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @param noMipmap defines if the texture must not receive mipmaps (false by default)
     * @param invertY defines if you want to invert Y axis of the loaded texture (false by default)
     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
     * @returns a new TextureAssetTask object
     */
    AssetsManager.prototype.addTextureTask = function (taskName, url, noMipmap, invertY, samplingMode) {
        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }
        var task = new TextureAssetTask(taskName, url, noMipmap, invertY, samplingMode);
        this._tasks.push(task);
        return task;
    };
    /**
     * Add a CubeTextureAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @param extensions defines the extension to use to load the cube map (can be null)
     * @param noMipmap defines if the texture must not receive mipmaps (false by default)
     * @param files defines the list of files to load (can be null)
     * @returns a new CubeTextureAssetTask object
     */
    AssetsManager.prototype.addCubeTextureTask = function (taskName, url, extensions, noMipmap, files) {
        var task = new CubeTextureAssetTask(taskName, url, extensions, noMipmap, files);
        this._tasks.push(task);
        return task;
    };
    /**
     *
     * Add a HDRCubeTextureAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @param size defines the size you want for the cubemap (can be null)
     * @param noMipmap defines if the texture must not receive mipmaps (false by default)
     * @param generateHarmonics defines if you want to automatically generate (true by default)
     * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
     * @param reserved Internal use only
     * @returns a new HDRCubeTextureAssetTask object
     */
    AssetsManager.prototype.addHDRCubeTextureTask = function (taskName, url, size, noMipmap, generateHarmonics, gammaSpace, reserved) {
        if (noMipmap === void 0) { noMipmap = false; }
        if (generateHarmonics === void 0) { generateHarmonics = true; }
        if (gammaSpace === void 0) { gammaSpace = false; }
        if (reserved === void 0) { reserved = false; }
        var task = new HDRCubeTextureAssetTask(taskName, url, size, noMipmap, generateHarmonics, gammaSpace, reserved);
        this._tasks.push(task);
        return task;
    };
    /**
     *
     * Add a EquiRectangularCubeTextureAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @param size defines the size you want for the cubemap (can be null)
     * @param noMipmap defines if the texture must not receive mipmaps (false by default)
     * @param gammaSpace Specifies if the texture will be used in gamma or linear space
     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)
     * @returns a new EquiRectangularCubeTextureAssetTask object
     */
    AssetsManager.prototype.addEquiRectangularCubeTextureAssetTask = function (taskName, url, size, noMipmap, gammaSpace) {
        if (noMipmap === void 0) { noMipmap = false; }
        if (gammaSpace === void 0) { gammaSpace = true; }
        var task = new EquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap, gammaSpace);
        this._tasks.push(task);
        return task;
    };
    /**
     * Remove a task from the assets manager.
     * @param task the task to remove
     */
    AssetsManager.prototype.removeTask = function (task) {
        var index = this._tasks.indexOf(task);
        if (index > -1) {
            this._tasks.splice(index, 1);
        }
    };
    AssetsManager.prototype._decreaseWaitingTasksCount = function (task) {
        this._waitingTasksCount--;
        try {
            if (this.onProgress) {
                this.onProgress(this._waitingTasksCount, this._totalTasksCount, task);
            }
            this.onProgressObservable.notifyObservers(new AssetsProgressEvent(this._waitingTasksCount, this._totalTasksCount, task));
        }
        catch (e) {
            Logger.Error("Error running progress callbacks.");
            console.log(e);
        }
        if (this._waitingTasksCount === 0) {
            try {
                if (this.onFinish) {
                    this.onFinish(this._tasks);
                }
                // Let's remove successfull tasks
                var currentTasks = this._tasks.slice();
                for (var _i = 0, currentTasks_1 = currentTasks; _i < currentTasks_1.length; _i++) {
                    var task = currentTasks_1[_i];
                    if (task.taskState === AssetTaskState.DONE) {
                        var index = this._tasks.indexOf(task);
                        if (index > -1) {
                            this._tasks.splice(index, 1);
                        }
                    }
                }
                this.onTasksDoneObservable.notifyObservers(this._tasks);
            }
            catch (e) {
                Logger.Error("Error running tasks-done callbacks.");
                console.log(e);
            }
            this._isLoading = false;
            this._scene.getEngine().hideLoadingUI();
        }
    };
    AssetsManager.prototype._runTask = function (task) {
        var _this = this;
        var done = function () {
            try {
                if (_this.onTaskSuccess) {
                    _this.onTaskSuccess(task);
                }
                _this.onTaskSuccessObservable.notifyObservers(task);
                _this._decreaseWaitingTasksCount(task);
            }
            catch (e) {
                error("Error executing task success callbacks", e);
            }
        };
        var error = function (message, exception) {
            task._setErrorObject(message, exception);
            if (_this.onTaskError) {
                _this.onTaskError(task);
            }
            _this.onTaskErrorObservable.notifyObservers(task);
            _this._decreaseWaitingTasksCount(task);
        };
        task.run(this._scene, done, error);
    };
    /**
     * Reset the AssetsManager and remove all tasks
     * @return the current instance of the AssetsManager
     */
    AssetsManager.prototype.reset = function () {
        this._isLoading = false;
        this._tasks = new Array();
        return this;
    };
    /**
     * Start the loading process
     * @return the current instance of the AssetsManager
     */
    AssetsManager.prototype.load = function () {
        if (this._isLoading) {
            return this;
        }
        this._isLoading = true;
        this._waitingTasksCount = this._tasks.length;
        this._totalTasksCount = this._tasks.length;
        if (this._waitingTasksCount === 0) {
            this._isLoading = false;
            if (this.onFinish) {
                this.onFinish(this._tasks);
            }
            this.onTasksDoneObservable.notifyObservers(this._tasks);
            return this;
        }
        if (this.useDefaultLoadingScreen) {
            this._scene.getEngine().displayLoadingUI();
        }
        for (var index = 0; index < this._tasks.length; index++) {
            var task = this._tasks[index];
            if (task.taskState === AssetTaskState.INIT) {
                this._runTask(task);
            }
        }
        return this;
    };
    /**
     * Start the loading process as an async operation
     * @return a promise returning the list of failed tasks
     */
    AssetsManager.prototype.loadAsync = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.onTasksDoneObservable.addOnce(function (remainingTasks) {
                if (remainingTasks && remainingTasks.length) {
                    reject(remainingTasks);
                }
                else {
                    resolve();
                }
            });
        });
    };
    return AssetsManager;
}());

/**
 * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)
 */
var MeshExploder = /** @class */ (function () {
    /**
     * Explodes meshes from a center mesh.
     * @param meshes The meshes to explode.
     * @param centerMesh The mesh to be center of explosion.
     */
    function MeshExploder(meshes, centerMesh) {
        this._meshesOrigins = [];
        this._toCenterVectors = [];
        this._scaledDirection = Vector3.Zero();
        this._newPosition = Vector3.Zero();
        this._centerPosition = Vector3.Zero();
        this._meshes = meshes.slice();
        if (centerMesh) {
            this._centerMesh = centerMesh;
        }
        else {
            this._setCenterMesh();
        }
        var centerMeshIndex = this._meshes.indexOf(this._centerMesh);
        if (centerMeshIndex >= 0) {
            this._meshes.splice(centerMeshIndex, 1);
        }
        this._centerPosition = this._centerMesh.getAbsolutePosition().clone();
        for (var index = 0; index < this._meshes.length; index++) {
            if (this._meshes[index]) {
                var mesh = this._meshes[index];
                this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();
                this._toCenterVectors[index] = Vector3.Zero();
                if (mesh._boundingInfo && this._centerMesh._boundingInfo) {
                    mesh._boundingInfo.boundingBox.centerWorld.subtractToRef(this._centerMesh._boundingInfo.boundingBox.centerWorld, this._toCenterVectors[index]);
                }
            }
        }
    }
    MeshExploder.prototype._setCenterMesh = function () {
        var averageCenter = Vector3.Zero();
        var totalCenters = Vector3.Zero();
        var shortestToCenter = Number.MAX_VALUE;
        for (var index = 0; index < this._meshes.length; index++) {
            if (this._meshes[index]) {
                var mesh = this._meshes[index];
                var boundingInfo = mesh.getBoundingInfo();
                if (boundingInfo) {
                    totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);
                }
            }
        }
        averageCenter = totalCenters.scale(1 / this._meshes.length);
        for (var index = 0; index < this._meshes.length; index++) {
            if (this._meshes[index]) {
                var mesh = this._meshes[index];
                var boundingInfo = mesh.getBoundingInfo();
                if (boundingInfo) {
                    var distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();
                    if (distanceToCenter < shortestToCenter) {
                        this._centerMesh = mesh;
                        shortestToCenter = distanceToCenter;
                    }
                }
            }
        }
    };
    /**
     * Get class name
     * @returns "MeshExploder"
     */
    MeshExploder.prototype.getClassName = function () {
        return "MeshExploder";
    };
    /**
     * "Exploded meshes"
     * @returns Array of meshes with the centerMesh at index 0.
     */
    MeshExploder.prototype.getMeshes = function () {
        var meshArray = this._meshes.slice();
        meshArray.unshift(this._centerMesh);
        return meshArray;
    };
    /**
     * Explodes meshes giving a specific direction
     * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.
     */
    MeshExploder.prototype.explode = function (direction) {
        if (direction === void 0) { direction = 1.0; }
        for (var index = 0; index < this._meshes.length; index++) {
            if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {
                this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);
                this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);
                this._meshes[index].setAbsolutePosition(this._newPosition);
            }
        }
        this._centerMesh.setAbsolutePosition(this._centerPosition);
    };
    return MeshExploder;
}());

/**
 * Class used to help managing file picking and drag'n'drop
 */
var FilesInput = /** @class */ (function () {
    /**
     * Creates a new FilesInput
     * @param engine defines the rendering engine
     * @param scene defines the hosting scene
     * @param sceneLoadedCallback callback called when scene is loaded
     * @param progressCallback callback called to track progress
     * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop
     * @param textureLoadingCallback callback called when a texture is loading
     * @param startingProcessingFilesCallback callback called when the system is about to process all files
     * @param onReloadCallback callback called when a reload is requested
     * @param errorCallback callback call if an error occurs
     */
    function FilesInput(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback) {
        /**
         * Callback called when a file is processed
         */
        this.onProcessFileCallback = function () { return true; };
        this._engine = engine;
        this._currentScene = scene;
        this._sceneLoadedCallback = sceneLoadedCallback;
        this._progressCallback = progressCallback;
        this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;
        this._textureLoadingCallback = textureLoadingCallback;
        this._startingProcessingFilesCallback = startingProcessingFilesCallback;
        this._onReloadCallback = onReloadCallback;
        this._errorCallback = errorCallback;
    }
    Object.defineProperty(FilesInput, "FilesToLoad", {
        /**
         * List of files ready to be loaded
         */
        get: function () {
            return FilesInputStore.FilesToLoad;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Calls this function to listen to drag'n'drop events on a specific DOM element
     * @param elementToMonitor defines the DOM element to track
     */
    FilesInput.prototype.monitorElementForDragNDrop = function (elementToMonitor) {
        var _this = this;
        if (elementToMonitor) {
            this._elementToMonitor = elementToMonitor;
            this._dragEnterHandler = function (e) { _this.drag(e); };
            this._dragOverHandler = function (e) { _this.drag(e); };
            this._dropHandler = function (e) { _this.drop(e); };
            this._elementToMonitor.addEventListener("dragenter", this._dragEnterHandler, false);
            this._elementToMonitor.addEventListener("dragover", this._dragOverHandler, false);
            this._elementToMonitor.addEventListener("drop", this._dropHandler, false);
        }
    };
    /**
     * Release all associated resources
     */
    FilesInput.prototype.dispose = function () {
        if (!this._elementToMonitor) {
            return;
        }
        this._elementToMonitor.removeEventListener("dragenter", this._dragEnterHandler);
        this._elementToMonitor.removeEventListener("dragover", this._dragOverHandler);
        this._elementToMonitor.removeEventListener("drop", this._dropHandler);
    };
    FilesInput.prototype.renderFunction = function () {
        if (this._additionalRenderLoopLogicCallback) {
            this._additionalRenderLoopLogicCallback();
        }
        if (this._currentScene) {
            if (this._textureLoadingCallback) {
                var remaining = this._currentScene.getWaitingItemsCount();
                if (remaining > 0) {
                    this._textureLoadingCallback(remaining);
                }
            }
            this._currentScene.render();
        }
    };
    FilesInput.prototype.drag = function (e) {
        e.stopPropagation();
        e.preventDefault();
    };
    FilesInput.prototype.drop = function (eventDrop) {
        eventDrop.stopPropagation();
        eventDrop.preventDefault();
        this.loadFiles(eventDrop);
    };
    FilesInput.prototype._traverseFolder = function (folder, files, remaining, callback) {
        var _this = this;
        var reader = folder.createReader();
        var relativePath = folder.fullPath.replace(/^\//, "").replace(/(.+?)\/?$/, "$1/");
        reader.readEntries(function (entries) {
            remaining.count += entries.length;
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var entry = entries_1[_i];
                if (entry.isFile) {
                    entry.file(function (file) {
                        file.correctName = relativePath + file.name;
                        files.push(file);
                        if (--remaining.count === 0) {
                            callback();
                        }
                    });
                }
                else if (entry.isDirectory) {
                    _this._traverseFolder(entry, files, remaining, callback);
                }
            }
            if (--remaining.count) {
                callback();
            }
        });
    };
    FilesInput.prototype._processFiles = function (files) {
        for (var i = 0; i < files.length; i++) {
            var name = files[i].correctName.toLowerCase();
            var extension = name.split('.').pop();
            if (!this.onProcessFileCallback(files[i], name, extension)) {
                continue;
            }
            if ((extension === "babylon" || extension === "stl" || extension === "obj" || extension === "gltf" || extension === "glb")
                && name.indexOf(".binary.babylon") === -1 && name.indexOf(".incremental.babylon") === -1) {
                this._sceneFileToLoad = files[i];
            }
            FilesInput.FilesToLoad[name] = files[i];
        }
    };
    /**
     * Load files from a drop event
     * @param event defines the drop event to use as source
     */
    FilesInput.prototype.loadFiles = function (event) {
        var _this = this;
        // Handling data transfer via drag'n'drop
        if (event && event.dataTransfer && event.dataTransfer.files) {
            this._filesToLoad = event.dataTransfer.files;
        }
        // Handling files from input files
        if (event && event.target && event.target.files) {
            this._filesToLoad = event.target.files;
        }
        if (!this._filesToLoad || this._filesToLoad.length === 0) {
            return;
        }
        if (this._startingProcessingFilesCallback) {
            this._startingProcessingFilesCallback(this._filesToLoad);
        }
        if (this._filesToLoad && this._filesToLoad.length > 0) {
            var files_1 = new Array();
            var folders = [];
            var items = event.dataTransfer ? event.dataTransfer.items : null;
            for (var i = 0; i < this._filesToLoad.length; i++) {
                var fileToLoad = this._filesToLoad[i];
                var name_1 = fileToLoad.name.toLowerCase();
                var entry = void 0;
                fileToLoad.correctName = name_1;
                if (items) {
                    var item = items[i];
                    if (item.getAsEntry) {
                        entry = item.getAsEntry();
                    }
                    else if (item.webkitGetAsEntry) {
                        entry = item.webkitGetAsEntry();
                    }
                }
                if (!entry) {
                    files_1.push(fileToLoad);
                }
                else {
                    if (entry.isDirectory) {
                        folders.push(entry);
                    }
                    else {
                        files_1.push(fileToLoad);
                    }
                }
            }
            if (folders.length === 0) {
                this._processFiles(files_1);
                this._processReload();
            }
            else {
                var remaining = { count: folders.length };
                for (var _i = 0, folders_1 = folders; _i < folders_1.length; _i++) {
                    var folder = folders_1[_i];
                    this._traverseFolder(folder, files_1, remaining, function () {
                        _this._processFiles(files_1);
                        if (remaining.count === 0) {
                            _this._processReload();
                        }
                    });
                }
            }
        }
    };
    FilesInput.prototype._processReload = function () {
        if (this._onReloadCallback) {
            this._onReloadCallback(this._sceneFileToLoad);
        }
        else {
            this.reload();
        }
    };
    /**
     * Reload the current scene from the loaded files
     */
    FilesInput.prototype.reload = function () {
        var _this = this;
        // If a scene file has been provided
        if (this._sceneFileToLoad) {
            if (this._currentScene) {
                if (Logger.errorsCount > 0) {
                    Logger.ClearLogCache();
                }
                this._engine.stopRenderLoop();
            }
            SceneLoader.LoadAsync("file:", this._sceneFileToLoad, this._engine, function (progress) {
                if (_this._progressCallback) {
                    _this._progressCallback(progress);
                }
            }).then(function (scene) {
                if (_this._currentScene) {
                    _this._currentScene.dispose();
                }
                _this._currentScene = scene;
                if (_this._sceneLoadedCallback) {
                    _this._sceneLoadedCallback(_this._sceneFileToLoad, _this._currentScene);
                }
                // Wait for textures and shaders to be ready
                _this._currentScene.executeWhenReady(function () {
                    _this._engine.runRenderLoop(function () {
                        _this.renderFunction();
                    });
                });
            }).catch(function (error) {
                if (_this._errorCallback) {
                    _this._errorCallback(_this._sceneFileToLoad, _this._currentScene, error.message);
                }
            });
        }
        else {
            Logger.Error("Please provide a valid .babylon file.");
        }
    };
    return FilesInput;
}());

/**
 * Defines the root class used to create scene optimization to use with SceneOptimizer
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var SceneOptimization = /** @class */ (function () {
    /**
     * Creates the SceneOptimization object
     * @param priority defines the priority of this optimization (0 by default which means first in the list)
     * @param desc defines the description associated with the optimization
     */
    function SceneOptimization(
    /**
     * Defines the priority of this optimization (0 by default which means first in the list)
     */
    priority) {
        if (priority === void 0) { priority = 0; }
        this.priority = priority;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */
    SceneOptimization.prototype.getDescription = function () {
        return "";
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */
    SceneOptimization.prototype.apply = function (scene, optimizer) {
        return true;
    };
    return SceneOptimization;
}());
/**
 * Defines an optimization used to reduce the size of render target textures
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var TextureOptimization = /** @class */ (function (_super) {
    __extends(TextureOptimization, _super);
    /**
     * Creates the TextureOptimization object
     * @param priority defines the priority of this optimization (0 by default which means first in the list)
     * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
     * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
     */
    function TextureOptimization(
    /**
     * Defines the priority of this optimization (0 by default which means first in the list)
     */
    priority, 
    /**
     * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
     */
    maximumSize, 
    /**
     * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
     */
    step) {
        if (priority === void 0) { priority = 0; }
        if (maximumSize === void 0) { maximumSize = 1024; }
        if (step === void 0) { step = 0.5; }
        var _this = _super.call(this, priority) || this;
        _this.priority = priority;
        _this.maximumSize = maximumSize;
        _this.step = step;
        return _this;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */
    TextureOptimization.prototype.getDescription = function () {
        return "Reducing render target texture size to " + this.maximumSize;
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */
    TextureOptimization.prototype.apply = function (scene, optimizer) {
        var allDone = true;
        for (var index = 0; index < scene.textures.length; index++) {
            var texture = scene.textures[index];
            if (!texture.canRescale || texture.getContext) {
                continue;
            }
            var currentSize = texture.getSize();
            var maxDimension = Math.max(currentSize.width, currentSize.height);
            if (maxDimension > this.maximumSize) {
                texture.scale(this.step);
                allDone = false;
            }
        }
        return allDone;
    };
    return TextureOptimization;
}(SceneOptimization));
/**
 * Defines an optimization used to increase or decrease the rendering resolution
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var HardwareScalingOptimization = /** @class */ (function (_super) {
    __extends(HardwareScalingOptimization, _super);
    /**
     * Creates the HardwareScalingOptimization object
     * @param priority defines the priority of this optimization (0 by default which means first in the list)
     * @param maximumScale defines the maximum scale to use (2 by default)
     * @param step defines the step to use between two passes (0.5 by default)
     */
    function HardwareScalingOptimization(
    /**
     * Defines the priority of this optimization (0 by default which means first in the list)
     */
    priority, 
    /**
     * Defines the maximum scale to use (2 by default)
     */
    maximumScale, 
    /**
     * Defines the step to use between two passes (0.5 by default)
     */
    step) {
        if (priority === void 0) { priority = 0; }
        if (maximumScale === void 0) { maximumScale = 2; }
        if (step === void 0) { step = 0.25; }
        var _this = _super.call(this, priority) || this;
        _this.priority = priority;
        _this.maximumScale = maximumScale;
        _this.step = step;
        _this._currentScale = -1;
        _this._directionOffset = 1;
        return _this;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @return description string
     */
    HardwareScalingOptimization.prototype.getDescription = function () {
        return "Setting hardware scaling level to " + this._currentScale;
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */
    HardwareScalingOptimization.prototype.apply = function (scene, optimizer) {
        if (this._currentScale === -1) {
            this._currentScale = scene.getEngine().getHardwareScalingLevel();
            if (this._currentScale > this.maximumScale) {
                this._directionOffset = -1;
            }
        }
        this._currentScale += this._directionOffset * this.step;
        scene.getEngine().setHardwareScalingLevel(this._currentScale);
        return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;
    };
    return HardwareScalingOptimization;
}(SceneOptimization));
/**
 * Defines an optimization used to remove shadows
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var ShadowsOptimization = /** @class */ (function (_super) {
    __extends(ShadowsOptimization, _super);
    function ShadowsOptimization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @return description string
     */
    ShadowsOptimization.prototype.getDescription = function () {
        return "Turning shadows on/off";
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */
    ShadowsOptimization.prototype.apply = function (scene, optimizer) {
        scene.shadowsEnabled = optimizer.isInImprovementMode;
        return true;
    };
    return ShadowsOptimization;
}(SceneOptimization));
/**
 * Defines an optimization used to turn post-processes off
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var PostProcessesOptimization = /** @class */ (function (_super) {
    __extends(PostProcessesOptimization, _super);
    function PostProcessesOptimization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @return description string
     */
    PostProcessesOptimization.prototype.getDescription = function () {
        return "Turning post-processes on/off";
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */
    PostProcessesOptimization.prototype.apply = function (scene, optimizer) {
        scene.postProcessesEnabled = optimizer.isInImprovementMode;
        return true;
    };
    return PostProcessesOptimization;
}(SceneOptimization));
/**
 * Defines an optimization used to turn lens flares off
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var LensFlaresOptimization = /** @class */ (function (_super) {
    __extends(LensFlaresOptimization, _super);
    function LensFlaresOptimization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @return description string
     */
    LensFlaresOptimization.prototype.getDescription = function () {
        return "Turning lens flares on/off";
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */
    LensFlaresOptimization.prototype.apply = function (scene, optimizer) {
        scene.lensFlaresEnabled = optimizer.isInImprovementMode;
        return true;
    };
    return LensFlaresOptimization;
}(SceneOptimization));
/**
 * Defines an optimization based on user defined callback.
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var CustomOptimization = /** @class */ (function (_super) {
    __extends(CustomOptimization, _super);
    function CustomOptimization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */
    CustomOptimization.prototype.getDescription = function () {
        if (this.onGetDescription) {
            return this.onGetDescription();
        }
        return "Running user defined callback";
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */
    CustomOptimization.prototype.apply = function (scene, optimizer) {
        if (this.onApply) {
            return this.onApply(scene, optimizer);
        }
        return true;
    };
    return CustomOptimization;
}(SceneOptimization));
/**
 * Defines an optimization used to turn particles off
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var ParticlesOptimization = /** @class */ (function (_super) {
    __extends(ParticlesOptimization, _super);
    function ParticlesOptimization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @return description string
     */
    ParticlesOptimization.prototype.getDescription = function () {
        return "Turning particles on/off";
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */
    ParticlesOptimization.prototype.apply = function (scene, optimizer) {
        scene.particlesEnabled = optimizer.isInImprovementMode;
        return true;
    };
    return ParticlesOptimization;
}(SceneOptimization));
/**
 * Defines an optimization used to turn render targets off
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var RenderTargetsOptimization = /** @class */ (function (_super) {
    __extends(RenderTargetsOptimization, _super);
    function RenderTargetsOptimization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @return description string
     */
    RenderTargetsOptimization.prototype.getDescription = function () {
        return "Turning render targets off";
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */
    RenderTargetsOptimization.prototype.apply = function (scene, optimizer) {
        scene.renderTargetsEnabled = optimizer.isInImprovementMode;
        return true;
    };
    return RenderTargetsOptimization;
}(SceneOptimization));
/**
 * Defines an optimization used to merge meshes with compatible materials
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var MergeMeshesOptimization = /** @class */ (function (_super) {
    __extends(MergeMeshesOptimization, _super);
    function MergeMeshesOptimization() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._canBeMerged = function (abstractMesh) {
            if (!(abstractMesh instanceof Mesh)) {
                return false;
            }
            var mesh = abstractMesh;
            if (mesh.isDisposed()) {
                return false;
            }
            if (!mesh.isVisible || !mesh.isEnabled()) {
                return false;
            }
            if (mesh.instances.length > 0) {
                return false;
            }
            if (mesh.skeleton || mesh.hasLODLevels) {
                return false;
            }
            return true;
        };
        return _this;
    }
    Object.defineProperty(MergeMeshesOptimization, "UpdateSelectionTree", {
        /**
         * Gets or sets a boolean which defines if optimization octree has to be updated
         */
        get: function () {
            return MergeMeshesOptimization._UpdateSelectionTree;
        },
        /**
         * Gets or sets a boolean which defines if optimization octree has to be updated
         */
        set: function (value) {
            MergeMeshesOptimization._UpdateSelectionTree = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a string describing the action executed by the current optimization
     * @return description string
     */
    MergeMeshesOptimization.prototype.getDescription = function () {
        return "Merging similar meshes together";
    };
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @param updateSelectionTree defines that the selection octree has to be updated (false by default)
     * @returns true if everything that can be done was applied
     */
    MergeMeshesOptimization.prototype.apply = function (scene, optimizer, updateSelectionTree) {
        var globalPool = scene.meshes.slice(0);
        var globalLength = globalPool.length;
        for (var index = 0; index < globalLength; index++) {
            var currentPool = new Array();
            var current = globalPool[index];
            // Checks
            if (!this._canBeMerged(current)) {
                continue;
            }
            currentPool.push(current);
            // Find compatible meshes
            for (var subIndex = index + 1; subIndex < globalLength; subIndex++) {
                var otherMesh = globalPool[subIndex];
                if (!this._canBeMerged(otherMesh)) {
                    continue;
                }
                if (otherMesh.material !== current.material) {
                    continue;
                }
                if (otherMesh.checkCollisions !== current.checkCollisions) {
                    continue;
                }
                currentPool.push(otherMesh);
                globalLength--;
                globalPool.splice(subIndex, 1);
                subIndex--;
            }
            if (currentPool.length < 2) {
                continue;
            }
            // Merge meshes
            Mesh.MergeMeshes(currentPool, undefined, true);
        }
        // Call the octree system optimization if it is defined.
        var sceneAsAny = scene;
        if (sceneAsAny.createOrUpdateSelectionOctree) {
            if (updateSelectionTree != undefined) {
                if (updateSelectionTree) {
                    sceneAsAny.createOrUpdateSelectionOctree();
                }
            }
            else if (MergeMeshesOptimization.UpdateSelectionTree) {
                sceneAsAny.createOrUpdateSelectionOctree();
            }
        }
        return true;
    };
    MergeMeshesOptimization._UpdateSelectionTree = false;
    return MergeMeshesOptimization;
}(SceneOptimization));
/**
 * Defines a list of options used by SceneOptimizer
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var SceneOptimizerOptions = /** @class */ (function () {
    /**
     * Creates a new list of options used by SceneOptimizer
     * @param targetFrameRate defines the target frame rate to reach (60 by default)
     * @param trackerDuration defines the interval between two checkes (2000ms by default)
     */
    function SceneOptimizerOptions(
    /**
     * Defines the target frame rate to reach (60 by default)
     */
    targetFrameRate, 
    /**
     * Defines the interval between two checkes (2000ms by default)
     */
    trackerDuration) {
        if (targetFrameRate === void 0) { targetFrameRate = 60; }
        if (trackerDuration === void 0) { trackerDuration = 2000; }
        this.targetFrameRate = targetFrameRate;
        this.trackerDuration = trackerDuration;
        /**
         * Gets the list of optimizations to apply
         */
        this.optimizations = new Array();
    }
    /**
     * Add a new optimization
     * @param optimization defines the SceneOptimization to add to the list of active optimizations
     * @returns the current SceneOptimizerOptions
     */
    SceneOptimizerOptions.prototype.addOptimization = function (optimization) {
        this.optimizations.push(optimization);
        return this;
    };
    /**
     * Add a new custom optimization
     * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)
     * @param onGetDescription defines the callback called to get the description attached with the optimization.
     * @param priority defines the priority of this optimization (0 by default which means first in the list)
     * @returns the current SceneOptimizerOptions
     */
    SceneOptimizerOptions.prototype.addCustomOptimization = function (onApply, onGetDescription, priority) {
        if (priority === void 0) { priority = 0; }
        var optimization = new CustomOptimization(priority);
        optimization.onApply = onApply;
        optimization.onGetDescription = onGetDescription;
        this.optimizations.push(optimization);
        return this;
    };
    /**
     * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene
     * @param targetFrameRate defines the target frame rate (60 by default)
     * @returns a SceneOptimizerOptions object
     */
    SceneOptimizerOptions.LowDegradationAllowed = function (targetFrameRate) {
        var result = new SceneOptimizerOptions(targetFrameRate);
        var priority = 0;
        result.addOptimization(new MergeMeshesOptimization(priority));
        result.addOptimization(new ShadowsOptimization(priority));
        result.addOptimization(new LensFlaresOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new PostProcessesOptimization(priority));
        result.addOptimization(new ParticlesOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new TextureOptimization(priority, 1024));
        return result;
    };
    /**
     * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual
     * @param targetFrameRate defines the target frame rate (60 by default)
     * @returns a SceneOptimizerOptions object
     */
    SceneOptimizerOptions.ModerateDegradationAllowed = function (targetFrameRate) {
        var result = new SceneOptimizerOptions(targetFrameRate);
        var priority = 0;
        result.addOptimization(new MergeMeshesOptimization(priority));
        result.addOptimization(new ShadowsOptimization(priority));
        result.addOptimization(new LensFlaresOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new PostProcessesOptimization(priority));
        result.addOptimization(new ParticlesOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new TextureOptimization(priority, 512));
        // Next priority
        priority++;
        result.addOptimization(new RenderTargetsOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new HardwareScalingOptimization(priority, 2));
        return result;
    };
    /**
     * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual
     * @param targetFrameRate defines the target frame rate (60 by default)
     * @returns a SceneOptimizerOptions object
     */
    SceneOptimizerOptions.HighDegradationAllowed = function (targetFrameRate) {
        var result = new SceneOptimizerOptions(targetFrameRate);
        var priority = 0;
        result.addOptimization(new MergeMeshesOptimization(priority));
        result.addOptimization(new ShadowsOptimization(priority));
        result.addOptimization(new LensFlaresOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new PostProcessesOptimization(priority));
        result.addOptimization(new ParticlesOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new TextureOptimization(priority, 256));
        // Next priority
        priority++;
        result.addOptimization(new RenderTargetsOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new HardwareScalingOptimization(priority, 4));
        return result;
    };
    return SceneOptimizerOptions;
}());
/**
 * Class used to run optimizations in order to reach a target frame rate
 * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 */
var SceneOptimizer = /** @class */ (function () {
    /**
     * Creates a new SceneOptimizer
     * @param scene defines the scene to work on
     * @param options defines the options to use with the SceneOptimizer
     * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)
     * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)
     */
    function SceneOptimizer(scene, options, autoGeneratePriorities, improvementMode) {
        var _this = this;
        if (autoGeneratePriorities === void 0) { autoGeneratePriorities = true; }
        if (improvementMode === void 0) { improvementMode = false; }
        this._isRunning = false;
        this._currentPriorityLevel = 0;
        this._targetFrameRate = 60;
        this._trackerDuration = 2000;
        this._currentFrameRate = 0;
        this._improvementMode = false;
        /**
         * Defines an observable called when the optimizer reaches the target frame rate
         */
        this.onSuccessObservable = new Observable();
        /**
         * Defines an observable called when the optimizer enables an optimization
         */
        this.onNewOptimizationAppliedObservable = new Observable();
        /**
         * Defines an observable called when the optimizer is not able to reach the target frame rate
         */
        this.onFailureObservable = new Observable();
        if (!options) {
            this._options = new SceneOptimizerOptions();
        }
        else {
            this._options = options;
        }
        if (this._options.targetFrameRate) {
            this._targetFrameRate = this._options.targetFrameRate;
        }
        if (this._options.trackerDuration) {
            this._trackerDuration = this._options.trackerDuration;
        }
        if (autoGeneratePriorities) {
            var priority = 0;
            for (var _i = 0, _a = this._options.optimizations; _i < _a.length; _i++) {
                var optim = _a[_i];
                optim.priority = priority++;
            }
        }
        this._improvementMode = improvementMode;
        this._scene = scene || EngineStore.LastCreatedScene;
        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(function () {
            _this._sceneDisposeObserver = null;
            _this.dispose();
        });
    }
    Object.defineProperty(SceneOptimizer.prototype, "isInImprovementMode", {
        /**
         * Gets a boolean indicating if the optimizer is in improvement mode
         */
        get: function () {
            return this._improvementMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneOptimizer.prototype, "currentPriorityLevel", {
        /**
         * Gets the current priority level (0 at start)
         */
        get: function () {
            return this._currentPriorityLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneOptimizer.prototype, "currentFrameRate", {
        /**
         * Gets the current frame rate checked by the SceneOptimizer
         */
        get: function () {
            return this._currentFrameRate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneOptimizer.prototype, "targetFrameRate", {
        /**
         * Gets or sets the current target frame rate (60 by default)
         */
        get: function () {
            return this._targetFrameRate;
        },
        /**
         * Gets or sets the current target frame rate (60 by default)
         */
        set: function (value) {
            this._targetFrameRate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneOptimizer.prototype, "trackerDuration", {
        /**
         * Gets or sets the current interval between two checks (every 2000ms by default)
         */
        get: function () {
            return this._trackerDuration;
        },
        /**
         * Gets or sets the current interval between two checks (every 2000ms by default)
         */
        set: function (value) {
            this._trackerDuration = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneOptimizer.prototype, "optimizations", {
        /**
         * Gets the list of active optimizations
         */
        get: function () {
            return this._options.optimizations;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Stops the current optimizer
     */
    SceneOptimizer.prototype.stop = function () {
        this._isRunning = false;
    };
    /**
     * Reset the optimizer to initial step (current priority level = 0)
     */
    SceneOptimizer.prototype.reset = function () {
        this._currentPriorityLevel = 0;
    };
    /**
     * Start the optimizer. By default it will try to reach a specific framerate
     * but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate
     */
    SceneOptimizer.prototype.start = function () {
        var _this = this;
        if (this._isRunning) {
            return;
        }
        this._isRunning = true;
        // Let's wait for the scene to be ready before running our check
        this._scene.executeWhenReady(function () {
            setTimeout(function () {
                _this._checkCurrentState();
            }, _this._trackerDuration);
        });
    };
    SceneOptimizer.prototype._checkCurrentState = function () {
        var _this = this;
        if (!this._isRunning) {
            return;
        }
        var scene = this._scene;
        var options = this._options;
        this._currentFrameRate = Math.round(scene.getEngine().getFps());
        if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate ||
            !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {
            this._isRunning = false;
            this.onSuccessObservable.notifyObservers(this);
            return;
        }
        // Apply current level of optimizations
        var allDone = true;
        var noOptimizationApplied = true;
        for (var index = 0; index < options.optimizations.length; index++) {
            var optimization = options.optimizations[index];
            if (optimization.priority === this._currentPriorityLevel) {
                noOptimizationApplied = false;
                allDone = allDone && optimization.apply(scene, this);
                this.onNewOptimizationAppliedObservable.notifyObservers(optimization);
            }
        }
        // If no optimization was applied, this is a failure :(
        if (noOptimizationApplied) {
            this._isRunning = false;
            this.onFailureObservable.notifyObservers(this);
            return;
        }
        // If all optimizations were done, move to next level
        if (allDone) {
            this._currentPriorityLevel++;
        }
        // Let's the system running for a specific amount of time before checking FPS
        scene.executeWhenReady(function () {
            setTimeout(function () {
                _this._checkCurrentState();
            }, _this._trackerDuration);
        });
    };
    /**
     * Release all resources
     */
    SceneOptimizer.prototype.dispose = function () {
        this.stop();
        this.onSuccessObservable.clear();
        this.onFailureObservable.clear();
        this.onNewOptimizationAppliedObservable.clear();
        if (this._sceneDisposeObserver) {
            this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
        }
    };
    /**
     * Helper function to create a SceneOptimizer with one single line of code
     * @param scene defines the scene to work on
     * @param options defines the options to use with the SceneOptimizer
     * @param onSuccess defines a callback to call on success
     * @param onFailure defines a callback to call on failure
     * @returns the new SceneOptimizer object
     */
    SceneOptimizer.OptimizeAsync = function (scene, options, onSuccess, onFailure) {
        var optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);
        if (onSuccess) {
            optimizer.onSuccessObservable.add(function () {
                onSuccess();
            });
        }
        if (onFailure) {
            optimizer.onFailureObservable.add(function () {
                onFailure();
            });
        }
        optimizer.start();
        return optimizer;
    };
    return SceneOptimizer;
}());

var serializedGeometries = [];
var serializeGeometry = function (geometry, serializationGeometries) {
    if (serializedGeometries[geometry.id]) {
        return;
    }
    if (geometry.doNotSerialize) {
        return;
    }
    serializationGeometries.vertexData.push(geometry.serializeVerticeData());
    serializedGeometries[geometry.id] = true;
};
var serializeMesh = function (mesh, serializationScene) {
    var serializationObject = {};
    // Geometry
    var geometry = mesh._geometry;
    if (geometry) {
        if (!mesh.getScene().getGeometryByID(geometry.id)) {
            // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry
            serializeGeometry(geometry, serializationScene.geometries);
        }
    }
    // Custom
    if (mesh.serialize) {
        mesh.serialize(serializationObject);
    }
    return serializationObject;
};
var finalizeSingleMesh = function (mesh, serializationObject) {
    //only works if the mesh is already loaded
    if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {
        //serialize material
        if (mesh.material) {
            if (mesh.material instanceof MultiMaterial) {
                serializationObject.multiMaterials = serializationObject.multiMaterials || [];
                serializationObject.materials = serializationObject.materials || [];
                if (!serializationObject.multiMaterials.some(function (mat) { return (mat.id === mesh.material.id); })) {
                    serializationObject.multiMaterials.push(mesh.material.serialize());
                    var _loop_1 = function (submaterial) {
                        if (submaterial) {
                            if (!serializationObject.materials.some(function (mat) { return (mat.id === submaterial.id); })) {
                                serializationObject.materials.push(submaterial.serialize());
                            }
                        }
                    };
                    for (var _i = 0, _a = mesh.material.subMaterials; _i < _a.length; _i++) {
                        var submaterial = _a[_i];
                        _loop_1(submaterial);
                    }
                }
            }
            else {
                serializationObject.materials = serializationObject.materials || [];
                if (!serializationObject.materials.some(function (mat) { return (mat.id === mesh.material.id); })) {
                    serializationObject.materials.push(mesh.material.serialize());
                }
            }
        }
        //serialize geometry
        var geometry = mesh._geometry;
        if (geometry) {
            if (!serializationObject.geometries) {
                serializationObject.geometries = {};
                serializationObject.geometries.boxes = [];
                serializationObject.geometries.spheres = [];
                serializationObject.geometries.cylinders = [];
                serializationObject.geometries.toruses = [];
                serializationObject.geometries.grounds = [];
                serializationObject.geometries.planes = [];
                serializationObject.geometries.torusKnots = [];
                serializationObject.geometries.vertexData = [];
            }
            serializeGeometry(geometry, serializationObject.geometries);
        }
        // Skeletons
        if (mesh.skeleton) {
            serializationObject.skeletons = serializationObject.skeletons || [];
            serializationObject.skeletons.push(mesh.skeleton.serialize());
        }
        //serialize the actual mesh
        serializationObject.meshes = serializationObject.meshes || [];
        serializationObject.meshes.push(serializeMesh(mesh, serializationObject));
    }
};
/**
 * Class used to serialize a scene into a string
 */
var SceneSerializer = /** @class */ (function () {
    function SceneSerializer() {
    }
    /**
     * Clear cache used by a previous serialization
     */
    SceneSerializer.ClearCache = function () {
        serializedGeometries = [];
    };
    /**
     * Serialize a scene into a JSON compatible object
     * @param scene defines the scene to serialize
     * @returns a JSON compatible object
     */
    SceneSerializer.Serialize = function (scene) {
        var serializationObject = {};
        SceneSerializer.ClearCache();
        // Scene
        serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;
        serializationObject.autoClear = scene.autoClear;
        serializationObject.clearColor = scene.clearColor.asArray();
        serializationObject.ambientColor = scene.ambientColor.asArray();
        serializationObject.gravity = scene.gravity.asArray();
        serializationObject.collisionsEnabled = scene.collisionsEnabled;
        // Fog
        if (scene.fogMode && scene.fogMode !== 0) {
            serializationObject.fogMode = scene.fogMode;
            serializationObject.fogColor = scene.fogColor.asArray();
            serializationObject.fogStart = scene.fogStart;
            serializationObject.fogEnd = scene.fogEnd;
            serializationObject.fogDensity = scene.fogDensity;
        }
        //Physics
        if (scene.isPhysicsEnabled()) {
            var physicEngine = scene.getPhysicsEngine();
            if (physicEngine) {
                serializationObject.physicsEnabled = true;
                serializationObject.physicsGravity = physicEngine.gravity.asArray();
                serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();
            }
        }
        // Metadata
        if (scene.metadata) {
            serializationObject.metadata = scene.metadata;
        }
        // Morph targets
        serializationObject.morphTargetManagers = [];
        for (var _i = 0, _a = scene.meshes; _i < _a.length; _i++) {
            var abstractMesh = _a[_i];
            var manager = abstractMesh.morphTargetManager;
            if (manager) {
                serializationObject.morphTargetManagers.push(manager.serialize());
            }
        }
        // Lights
        serializationObject.lights = [];
        var index;
        var light;
        for (index = 0; index < scene.lights.length; index++) {
            light = scene.lights[index];
            if (!light.doNotSerialize) {
                serializationObject.lights.push(light.serialize());
            }
        }
        // Cameras
        serializationObject.cameras = [];
        for (index = 0; index < scene.cameras.length; index++) {
            var camera = scene.cameras[index];
            if (!camera.doNotSerialize) {
                serializationObject.cameras.push(camera.serialize());
            }
        }
        if (scene.activeCamera) {
            serializationObject.activeCameraID = scene.activeCamera.id;
        }
        // Animations
        SerializationHelper.AppendSerializedAnimations(scene, serializationObject);
        // Reflection probes
        if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {
            serializationObject.reflectionProbes = [];
            for (index = 0; index < scene.reflectionProbes.length; index++) {
                var reflectionProbe = scene.reflectionProbes[index];
                serializationObject.reflectionProbes.push(reflectionProbe.serialize());
            }
        }
        // Materials
        serializationObject.materials = [];
        serializationObject.multiMaterials = [];
        var material;
        for (index = 0; index < scene.materials.length; index++) {
            material = scene.materials[index];
            if (!material.doNotSerialize) {
                serializationObject.materials.push(material.serialize());
            }
        }
        // MultiMaterials
        serializationObject.multiMaterials = [];
        for (index = 0; index < scene.multiMaterials.length; index++) {
            var multiMaterial = scene.multiMaterials[index];
            serializationObject.multiMaterials.push(multiMaterial.serialize());
        }
        // Environment texture
        if (scene.environmentTexture) {
            serializationObject.environmentTexture = scene.environmentTexture.name;
        }
        // Skeletons
        serializationObject.skeletons = [];
        for (index = 0; index < scene.skeletons.length; index++) {
            var skeleton = scene.skeletons[index];
            if (!skeleton.doNotSerialize) {
                serializationObject.skeletons.push(skeleton.serialize());
            }
        }
        // Transform nodes
        serializationObject.transformNodes = [];
        for (index = 0; index < scene.transformNodes.length; index++) {
            serializationObject.transformNodes.push(scene.transformNodes[index].serialize());
        }
        // Geometries
        serializationObject.geometries = {};
        serializationObject.geometries.boxes = [];
        serializationObject.geometries.spheres = [];
        serializationObject.geometries.cylinders = [];
        serializationObject.geometries.toruses = [];
        serializationObject.geometries.grounds = [];
        serializationObject.geometries.planes = [];
        serializationObject.geometries.torusKnots = [];
        serializationObject.geometries.vertexData = [];
        serializedGeometries = [];
        var geometries = scene.getGeometries();
        for (index = 0; index < geometries.length; index++) {
            var geometry = geometries[index];
            if (geometry.isReady()) {
                serializeGeometry(geometry, serializationObject.geometries);
            }
        }
        // Meshes
        serializationObject.meshes = [];
        for (index = 0; index < scene.meshes.length; index++) {
            var abstractMesh = scene.meshes[index];
            if (abstractMesh instanceof Mesh) {
                var mesh = abstractMesh;
                if (!mesh.doNotSerialize) {
                    if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {
                        serializationObject.meshes.push(serializeMesh(mesh, serializationObject));
                    }
                }
            }
        }
        // Particles Systems
        serializationObject.particleSystems = [];
        for (index = 0; index < scene.particleSystems.length; index++) {
            serializationObject.particleSystems.push(scene.particleSystems[index].serialize());
        }
        // Action Manager
        if (scene.actionManager) {
            serializationObject.actions = scene.actionManager.serialize("scene");
        }
        // Components
        for (var _b = 0, _c = scene._serializableComponents; _b < _c.length; _b++) {
            var component = _c[_b];
            component.serialize(serializationObject);
        }
        return serializationObject;
    };
    /**
     * Serialize a mesh into a JSON compatible object
     * @param toSerialize defines the mesh to serialize
     * @param withParents defines if parents must be serialized as well
     * @param withChildren defines if children must be serialized as well
     * @returns a JSON compatible object
     */
    SceneSerializer.SerializeMesh = function (toSerialize /* Mesh || Mesh[] */, withParents, withChildren) {
        if (withParents === void 0) { withParents = false; }
        if (withChildren === void 0) { withChildren = false; }
        var serializationObject = {};
        SceneSerializer.ClearCache();
        toSerialize = (toSerialize instanceof Array) ? toSerialize : [toSerialize];
        if (withParents || withChildren) {
            //deliberate for loop! not for each, appended should be processed as well.
            for (var i = 0; i < toSerialize.length; ++i) {
                if (withChildren) {
                    toSerialize[i].getDescendants().forEach(function (node) {
                        if (node instanceof Mesh && (toSerialize.indexOf(node) < 0)) {
                            toSerialize.push(node);
                        }
                    });
                }
                //make sure the array doesn't contain the object already
                if (withParents && toSerialize[i].parent && (toSerialize.indexOf(toSerialize[i].parent) < 0)) {
                    toSerialize.push(toSerialize[i].parent);
                }
            }
        }
        toSerialize.forEach(function (mesh) {
            finalizeSingleMesh(mesh, serializationObject);
        });
        return serializationObject;
    };
    return SceneSerializer;
}());

/**
 * Class used to host texture specific utilities
 */
var TextureTools = /** @class */ (function () {
    function TextureTools() {
    }
    /**
     * Uses the GPU to create a copy texture rescaled at a given size
     * @param texture Texture to copy from
     * @param width defines the desired width
     * @param height defines the desired height
     * @param useBilinearMode defines if bilinear mode has to be used
     * @return the generated texture
     */
    TextureTools.CreateResizedCopy = function (texture, width, height, useBilinearMode) {
        if (useBilinearMode === void 0) { useBilinearMode = true; }
        var scene = texture.getScene();
        var engine = scene.getEngine();
        var rtt = new RenderTargetTexture('resized' + texture.name, { width: width, height: height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
        rtt.wrapU = texture.wrapU;
        rtt.wrapV = texture.wrapV;
        rtt.uOffset = texture.uOffset;
        rtt.vOffset = texture.vOffset;
        rtt.uScale = texture.uScale;
        rtt.vScale = texture.vScale;
        rtt.uAng = texture.uAng;
        rtt.vAng = texture.vAng;
        rtt.wAng = texture.wAng;
        rtt.coordinatesIndex = texture.coordinatesIndex;
        rtt.level = texture.level;
        rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
        rtt._texture.isReady = false;
        texture.wrapU = Texture.CLAMP_ADDRESSMODE;
        texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        var passPostProcess = new PassPostProcess("pass", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, Constants.TEXTURETYPE_UNSIGNED_INT);
        passPostProcess.getEffect().executeWhenCompiled(function () {
            passPostProcess.onApply = function (effect) {
                effect.setTexture("textureSampler", texture);
            };
            var internalTexture = rtt.getInternalTexture();
            if (internalTexture) {
                scene.postProcessManager.directRender([passPostProcess], internalTexture);
                engine.unBindFramebuffer(internalTexture);
                rtt.disposeFramebufferObjects();
                passPostProcess.dispose();
                internalTexture.isReady = true;
            }
        });
        return rtt;
    };
    return TextureTools;
}());

/**
 * This can helps recording videos from BabylonJS.
 * This is based on the available WebRTC functionalities of the browser.
 *
 * @see http://doc.babylonjs.com/how_to/render_scene_on_a_video
 */
var VideoRecorder = /** @class */ (function () {
    /**
     * Create a new VideoCapture object which can help converting what you see in Babylon to
     * a video file.
     * @param engine Defines the BabylonJS Engine you wish to record
     * @param options Defines options that can be used to customized the capture
     */
    function VideoRecorder(engine, options) {
        if (options === void 0) { options = null; }
        if (!VideoRecorder.IsSupported(engine)) {
            throw "Your browser does not support recording so far.";
        }
        var canvas = engine.getRenderingCanvas();
        if (!canvas) {
            throw "The babylon engine must have a canvas to be recorded";
        }
        this._canvas = canvas;
        this._canvas.isRecording = false;
        this._options = __assign({}, VideoRecorder._defaultOptions, options);
        var stream = this._canvas.captureStream(this._options.fps);
        if (this._options.audioTracks) {
            for (var _i = 0, _a = this._options.audioTracks; _i < _a.length; _i++) {
                var track = _a[_i];
                stream.addTrack(track);
            }
        }
        this._mediaRecorder = new MediaRecorder(stream, { mimeType: this._options.mimeType });
        this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);
        this._mediaRecorder.onerror = this._handleError.bind(this);
        this._mediaRecorder.onstop = this._handleStop.bind(this);
    }
    /**
     * Returns wehther or not the VideoRecorder is available in your browser.
     * @param engine Defines the Babylon Engine to check the support for
     * @returns true if supported otherwise false
     */
    VideoRecorder.IsSupported = function (engine) {
        var canvas = engine.getRenderingCanvas();
        return (!!canvas && typeof canvas.captureStream === "function");
    };
    Object.defineProperty(VideoRecorder.prototype, "isRecording", {
        /**
         * True wether a recording is already in progress.
         */
        get: function () {
            return !!this._canvas && this._canvas.isRecording;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Stops the current recording before the default capture timeout passed in the startRecording
     * functions.
     */
    VideoRecorder.prototype.stopRecording = function () {
        if (!this._canvas || !this._mediaRecorder) {
            return;
        }
        if (!this.isRecording) {
            return;
        }
        this._canvas.isRecording = false;
        this._mediaRecorder.stop();
    };
    /**
     * Starts recording the canvas for a max duration specified in parameters.
     * @param fileName Defines the name of the file to be downloaded when the recording stop. If null no automatic download will start and you can rely on the promise to get the data back.
     * @param maxDuration Defines the maximum recording time in seconds.
     * It default to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.
     * @return a promise callback at the end of the recording with the video data in Blob.
     */
    VideoRecorder.prototype.startRecording = function (fileName, maxDuration) {
        var _this = this;
        if (fileName === void 0) { fileName = "babylonjs.webm"; }
        if (maxDuration === void 0) { maxDuration = 7; }
        if (!this._canvas || !this._mediaRecorder) {
            throw "Recorder has already been disposed";
        }
        if (this.isRecording) {
            throw "Recording already in progress";
        }
        if (maxDuration > 0) {
            setTimeout(function () {
                _this.stopRecording();
            }, maxDuration * 1000);
        }
        this._fileName = fileName;
        this._recordedChunks = [];
        this._resolve = null;
        this._reject = null;
        this._canvas.isRecording = true;
        this._mediaRecorder.start(this._options.recordChunckSize);
        return new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    };
    /**
     * Releases internal resources used during the recording.
     */
    VideoRecorder.prototype.dispose = function () {
        this._canvas = null;
        this._mediaRecorder = null;
        this._recordedChunks = [];
        this._fileName = null;
        this._resolve = null;
        this._reject = null;
    };
    VideoRecorder.prototype._handleDataAvailable = function (event) {
        if (event.data.size > 0) {
            this._recordedChunks.push(event.data);
        }
    };
    VideoRecorder.prototype._handleError = function (event) {
        this.stopRecording();
        if (this._reject) {
            this._reject(event.error);
        }
        else {
            throw new event.error();
        }
    };
    VideoRecorder.prototype._handleStop = function () {
        this.stopRecording();
        var superBuffer = new Blob(this._recordedChunks);
        if (this._resolve) {
            this._resolve(superBuffer);
        }
        window.URL.createObjectURL(superBuffer);
        if (this._fileName) {
            Tools.Download(superBuffer, this._fileName);
        }
    };
    VideoRecorder._defaultOptions = {
        mimeType: "video/webm",
        fps: 25,
        recordChunckSize: 3000
    };
    return VideoRecorder;
}());

/**
 * Class containing a set of static utilities functions for screenshots
 */
var ScreenshotTools = /** @class */ (function () {
    function ScreenshotTools() {
    }
    /**
     * Captures a screenshot of the current rendering
     * @see http://doc.babylonjs.com/how_to/render_scene_on_a_png
     * @param engine defines the rendering engine
     * @param camera defines the source camera
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param successCallback defines the callback receives a single parameter which contains the
     * screenshot as a string of base64-encoded characters. This string can be assigned to the
     * src parameter of an <img> to display it
     * @param mimeType defines the MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     */
    ScreenshotTools.CreateScreenshot = function (engine, camera, size, successCallback, mimeType) {
        if (mimeType === void 0) { mimeType = "image/png"; }
        var width;
        var height;
        // If a precision value is specified
        if (size.precision) {
            width = Math.round(engine.getRenderWidth() * size.precision);
            height = Math.round(width / engine.getAspectRatio(camera));
        }
        else if (size.width && size.height) {
            width = size.width;
            height = size.height;
        }
        //If passing only width, computing height to keep display canvas ratio.
        else if (size.width && !size.height) {
            width = size.width;
            height = Math.round(width / engine.getAspectRatio(camera));
        }
        //If passing only height, computing width to keep display canvas ratio.
        else if (size.height && !size.width) {
            height = size.height;
            width = Math.round(height * engine.getAspectRatio(camera));
        }
        //Assuming here that "size" parameter is a number
        else if (!isNaN(size)) {
            height = size;
            width = size;
        }
        else {
            Logger.Error("Invalid 'size' parameter !");
            return;
        }
        if (!Tools._ScreenshotCanvas) {
            Tools._ScreenshotCanvas = document.createElement('canvas');
        }
        Tools._ScreenshotCanvas.width = width;
        Tools._ScreenshotCanvas.height = height;
        var renderContext = Tools._ScreenshotCanvas.getContext("2d");
        var ratio = engine.getRenderWidth() / engine.getRenderHeight();
        var newWidth = width;
        var newHeight = newWidth / ratio;
        if (newHeight > height) {
            newHeight = height;
            newWidth = newHeight * ratio;
        }
        var offsetX = Math.max(0, width - newWidth) / 2;
        var offsetY = Math.max(0, height - newHeight) / 2;
        var renderingCanvas = engine.getRenderingCanvas();
        if (renderContext && renderingCanvas) {
            renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);
        }
        Tools.EncodeScreenshotCanvasData(successCallback, mimeType);
    };
    /**
     * Generates an image screenshot from the specified camera.
     * @see http://doc.babylonjs.com/how_to/render_scene_on_a_png
     * @param engine The engine to use for rendering
     * @param camera The camera to use for rendering
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param successCallback The callback receives a single parameter which contains the
     * screenshot as a string of base64-encoded characters. This string can be assigned to the
     * src parameter of an <img> to display it
     * @param mimeType The MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param samples Texture samples (default: 1)
     * @param antialiasing Whether antialiasing should be turned on or not (default: false)
     * @param fileName A name for for the downloaded file.
     */
    ScreenshotTools.CreateScreenshotUsingRenderTarget = function (engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName) {
        if (mimeType === void 0) { mimeType = "image/png"; }
        if (samples === void 0) { samples = 1; }
        if (antialiasing === void 0) { antialiasing = false; }
        var width;
        var height;
        //If a precision value is specified
        if (size.precision) {
            width = Math.round(engine.getRenderWidth() * size.precision);
            height = Math.round(width / engine.getAspectRatio(camera));
            size = { width: width, height: height };
        }
        else if (size.width && size.height) {
            width = size.width;
            height = size.height;
        }
        //If passing only width, computing height to keep display canvas ratio.
        else if (size.width && !size.height) {
            width = size.width;
            height = Math.round(width / engine.getAspectRatio(camera));
            size = { width: width, height: height };
        }
        //If passing only height, computing width to keep display canvas ratio.
        else if (size.height && !size.width) {
            height = size.height;
            width = Math.round(height * engine.getAspectRatio(camera));
            size = { width: width, height: height };
        }
        //Assuming here that "size" parameter is a number
        else if (!isNaN(size)) {
            height = size;
            width = size;
        }
        else {
            Logger.Error("Invalid 'size' parameter !");
            return;
        }
        var scene = camera.getScene();
        var previousCamera = null;
        if (scene.activeCamera !== camera) {
            previousCamera = scene.activeCamera;
            scene.activeCamera = camera;
        }
        var renderCanvas = engine.getRenderingCanvas();
        if (!renderCanvas) {
            Logger.Error("No rendering canvas found !");
            return;
        }
        var originalSize = { width: renderCanvas.width, height: renderCanvas.height };
        engine.setSize(width, height);
        scene.render();
        // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)
        var texture = new RenderTargetTexture("screenShot", size, scene, false, false, Constants.TEXTURETYPE_UNSIGNED_INT, false, Texture.NEAREST_SAMPLINGMODE);
        texture.renderList = null;
        texture.samples = samples;
        if (antialiasing) {
            texture.addPostProcess(new FxaaPostProcess('antialiasing', 1.0, scene.activeCamera));
        }
        texture.onAfterRenderObservable.add(function () {
            Tools.DumpFramebuffer(width, height, engine, successCallback, mimeType, fileName);
        });
        scene.incrementRenderId();
        scene.resetCachedMaterial();
        texture.render(true);
        texture.dispose();
        if (previousCamera) {
            scene.activeCamera = previousCamera;
        }
        engine.setSize(originalSize.width, originalSize.height);
        camera.getProjectionMatrix(true); // Force cache refresh;
    };
    return ScreenshotTools;
}());
Tools.CreateScreenshot = ScreenshotTools.CreateScreenshot;
Tools.CreateScreenshotUsingRenderTarget = ScreenshotTools.CreateScreenshotUsingRenderTarget;

/**
 * Enum that determines the text-wrapping mode to use.
 */
var InspectableType;
(function (InspectableType) {
    /**
     * Checkbox for booleans
     */
    InspectableType[InspectableType["Checkbox"] = 0] = "Checkbox";
    /**
     * Sliders for numbers
     */
    InspectableType[InspectableType["Slider"] = 1] = "Slider";
    /**
     * Vector3
     */
    InspectableType[InspectableType["Vector3"] = 2] = "Vector3";
    /**
     * Quaternions
     */
    InspectableType[InspectableType["Quaternion"] = 3] = "Quaternion";
    /**
     * Color3
     */
    InspectableType[InspectableType["Color3"] = 4] = "Color3";
})(InspectableType || (InspectableType = {}));

export { AbstractAssetTask, Action, ActionManager, AmmoJSPlugin, AnaglyphArcRotateCamera, AnaglyphFreeCamera, AnaglyphGamepadCamera, AnaglyphPostProcess, AnaglyphUniversalCamera, Analyser, AnimationPropertiesOverride, ArcFollowCamera, ArcRotateCamera, ArcRotateCameraGamepadInput, ArcRotateCameraInputsManager, ArcRotateCameraKeyboardMoveInput, ArcRotateCameraMouseWheelInput, ArcRotateCameraPointersInput, ArcRotateCameraVRDeviceOrientationInput, AssetTaskState, AssetsManager, AssetsProgressEvent, AttachToBoxBehavior, AudioEngine, AudioSceneComponent, AutoRotationBehavior, AxesViewer, AxisDragGizmo, AxisScaleGizmo, BackEase, BackgroundMaterial, BaseParticleSystem, BezierCurveEase, BinaryFileAssetTask, BlackAndWhitePostProcess, BloomEffect, BloomMergePostProcess, BlurPostProcess, BoneAxesViewer, BoneIKController, BoneLookController, BounceEase, BouncingBehavior, BoundingBoxGizmo, BoundingBoxRenderer, BoxParticleEmitter, CSG, CannonJSPlugin, ChromaticAberrationPostProcess, CircleEase, CircleOfConfusionPostProcess, Collider, ColorCorrectionPostProcess, ColorGradingTexture, CombineAction, Condition, ConeParticleEmitter, ConvolutionPostProcess, CubeTextureAssetTask, CubicEase, CustomOptimization, CustomProceduralTexture, CylinderBuilder, CylinderDirectedParticleEmitter, CylinderParticleEmitter, DDSTools, Database, DaydreamController, DebugLayer, DecalBuilder, DefaultCollisionCoordinator, DefaultLoadingScreen, DefaultRenderingPipeline, DepthOfFieldBlurPostProcess, DepthOfFieldEffect, DepthOfFieldEffectBlurLevel, DepthOfFieldMergePostProcess, DepthOfFieldMergePostProcessOptions, DepthRenderer, DepthRendererSceneComponent, DepthSortedParticle, DeviceOrientationCamera, DiscBuilder, DisplayPassPostProcess, DistanceJoint, DoNothingAction, EasingFunction, EdgesRenderer, EffectLayer, EffectLayerSceneComponent, ElasticEase, EngineInstrumentation, EnvironmentHelper, EquiRectangularCubeTexture, EquiRectangularCubeTextureAssetTask, ExecuteCodeAction, ExponentialEase, ExtractHighlightsPostProcess, FilesInput, FilterPostProcess, FlyCamera, FlyCameraInputsManager, FlyCameraKeyboardInput, FlyCameraMouseInput, FollowCamera, FollowCameraKeyboardMoveInput, FollowCameraMouseWheelInput, FollowCameraPointersInput, FramingBehavior, FreeCameraDeviceOrientationInput, FreeCameraGamepadInput, FreeCameraVirtualJoystickInput, FresnelParameters, FxaaPostProcess, GPUParticleSystem, Gamepad, GamepadCamera, GamepadManager, GamepadSystemSceneComponent, GearVRController, GenericController, GenericPad, GeometryBufferRenderer, GeometryBufferRendererSceneComponent, Gizmo, GizmoManager, GlowLayer, GrainPostProcess, GroundBuilder, GroundMesh, HDRCubeTexture, HDRCubeTextureAssetTask, HDRTools, HardwareScalingOptimization, HemisphereBuilder, HemisphericParticleEmitter, HighlightLayer, HighlightsPostProcess, Hinge2Joint, HingeJoint, HtmlElementTexture, IcoSphereBuilder, ImageAssetTask, ImageProcessingPostProcess, IncrementValueAction, InspectableType, InstancedLinesMesh, InstancedMesh, InterpolateValueAction, JoystickAxis, KhronosTextureContainer, LatheBuilder, LensFlare, LensFlareSystem, LensFlareSystemSceneComponent, LensFlaresOptimization, LensRenderingPipeline, LightGizmo, LineEdgesRenderer, LinesBuilder, LinesMesh, MergeMeshesOptimization, MeshAssetTask, MeshBuilder, MeshExploder, MirrorTexture, ModelShape, MotionBlurPostProcess, MotorEnabledJoint, MultiPointerScaleBehavior, MultiRenderTarget, NoiseProceduralTexture, NullEngine, NullEngineOptions, Octree, OctreeBlock, OctreeSceneComponent, OculusTouchController, OimoJSPlugin, OnAfterEnteringVRObservableEvent, OutlineRenderer, PBRBaseSimpleMaterial, PBRMetallicRoughnessMaterial, PBRSpecularGlossinessMaterial, PanoramaToCubeMapTools, Particle, ParticleHelper, ParticleSystem, ParticleSystemSet, ParticlesOptimization, PassCubePostProcess, PassPostProcess, PhotoDome, PhysicsEngine, PhysicsEngineSceneComponent, PhysicsHelper, PhysicsImpostor, PhysicsJoint, PhysicsRadialExplosionEventOptions, PhysicsRadialImpulseFalloff, PhysicsUpdraftEventOptions, PhysicsUpdraftMode, PhysicsViewer, PhysicsVortexEventOptions, PivotTools, PlaneRotationGizmo, PlayAnimationAction, PlaySoundAction, PointParticleEmitter, PointerDragBehavior, PolygonBuilder, PolyhedronBuilder, PoseEnabledController, PoseEnabledControllerHelper, PoseEnabledControllerType, PositionGizmo, PostProcessRenderEffect, PostProcessRenderPipeline, PostProcessRenderPipelineManager, PostProcessRenderPipelineManagerSceneComponent, PostProcessesOptimization, PowerEase, PredicateCondition, QuadraticEase, QuarticEase, QuinticEase, RawTexture3D, Ray, RayHelper, ReflectionProbe, RefractionPostProcess, RefractionTexture, RenderTargetsOptimization, RibbonBuilder, RotationGizmo, SSAO2RenderingPipeline, SSAORenderingPipeline, ScaleGizmo, SceneInstrumentation, SceneOptimization, SceneOptimizer, SceneOptimizerOptions, SceneSerializer, ScreenshotTools, SetParentAction, SetStateAction, SetValueAction, ShadowGenerator, ShadowGeneratorSceneComponent, ShadowsOptimization, ShapeBuilder, SharpenPostProcess, SimplicationQueueSceneComponent, SimplificationQueue, SimplificationSettings, SimplificationType, SineEase, SixDofDragBehavior, SkeletonViewer, SolidParticle, SolidParticleSystem, SoundTrack, SphereBuilder, SphereDirectedParticleEmitter, SphereParticleEmitter, Sprite, SpriteManager, SpriteSceneComponent, StandardRenderingPipeline, StateCondition, StereoscopicArcRotateCamera, StereoscopicFreeCamera, StereoscopicGamepadCamera, StereoscopicInterlacePostProcess, StereoscopicUniversalCamera, StickValues, StopAnimationAction, StopSoundAction, SubEmitter, SubEmitterType, SwitchBooleanAction, TGATools, TextFileAssetTask, TextureAssetTask, TextureOptimization, TextureTools, TonemapPostProcess, TonemappingOperator, TorusBuilder, TorusKnotBuilder, TouchCamera, TrailMesh, TubeBuilder, UniversalCamera, VRCameraMetrics, VRDeviceOrientationArcRotateCamera, VRDeviceOrientationFreeCamera, VRDeviceOrientationGamepadCamera, VRDistortionCorrectionPostProcess, VRExperienceHelper, VRMultiviewToSingleviewPostProcess, ValueCondition, VideoDome, VideoRecorder, VideoTexture, VirtualJoystick, VirtualJoysticksCamera, ViveController, VolumetricLightScatteringPostProcess, WebVRController, WebVRFreeCamera, WebXRCamera, WebXRController, WebXREnterExitUI, WebXREnterExitUIButton, WebXREnterExitUIOptions, WebXRExperienceHelper, WebXRInput, WebXRManagedOutputCanvas, WebXRSessionManager, WebXRState, WindowsMotionController, Xbox360Button, Xbox360Dpad, Xbox360Pad, _BabylonLoaderRegistered, _DDSTextureLoader, _ENVTextureLoader, _IDoNeedToBeInTheBuild, _KTXTextureLoader, _OcclusionDataStorage, _TGATextureLoader, _TimeToken, _forceSceneHelpersToBundle, _forceTransformFeedbackToBundle };
